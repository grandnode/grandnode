<?xml version="1.0"?>
<doc>
    <assembly>
        <name>itextsharp</name>
    </assembly>
    <members>
        <member name="T:iTextSharp.text.Anchor">
            <summary>
            An Anchor can be a reference or a destination of a reference.
            </summary>
            <remarks>
            An Anchor is a special kind of <see cref="T:iTextSharp.text.Phrase"/>.
            It is constructed in the same way.
            </remarks>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Phrase"/>
        </member>
        <member name="T:iTextSharp.text.Phrase">
            <summary>
            A Phrase is a series of Chunks.
            </summary>
            <remarks>
            A Phrase has a main Font, but some chunks
            within the phrase can have a Font that differs from the
            main Font. All the Chunks in a Phrase
            have the same leading.
            </remarks>
            <example>
            <code>
            // When no parameters are passed, the default leading = 16
            <strong>Phrase phrase0 = new Phrase();
            Phrase phrase1 = new Phrase("this is a phrase");</strong>
            // In this example the leading is passed as a parameter
            <strong>Phrase phrase2 = new Phrase(16, "this is a phrase with leading 16");</strong>
            // When a Font is passed (explicitely or embedded in a chunk), the default leading = 1.5 * size of the font
            <strong>Phrase phrase3 = new Phrase("this is a phrase with a red, normal font Courier, size 12", FontFactory.GetFont(FontFactory.COURIER, 12, Font.NORMAL, new Color(255, 0, 0)));
            Phrase phrase4 = new Phrase(new Chunk("this is a phrase"));
            Phrase phrase5 = new Phrase(18, new Chunk("this is a phrase", FontFactory.GetFont(FontFactory.HELVETICA, 16, Font.BOLD, new Color(255, 0, 0)));</strong>
            </code>
            </example>
        </member>
        <member name="T:iTextSharp.text.ITextElementArray">
            <summary>
            Interface for a text element to which other objects can be added.
            </summary>
            <seealso cref="T:iTextSharp.text.Phrase"/>
            <seealso cref="T:iTextSharp.text.Paragraph"/>
            <seealso cref="T:iTextSharp.text.Section"/>
            <seealso cref="T:iTextSharp.text.ListItem"/>
            <seealso cref="T:iTextSharp.text.Chapter"/>
            <seealso cref="T:iTextSharp.text.Anchor"/>
            <seealso cref="T:iTextSharp.text.Cell"/>
        </member>
        <member name="T:iTextSharp.text.IElement">
            <summary>
            Interface for a text element.
            </summary>
            <seealso cref="T:iTextSharp.text.Anchor"/>
            <seealso cref="T:iTextSharp.text.Cell"/>
            <seealso cref="T:iTextSharp.text.Chapter"/>
            <seealso cref="T:iTextSharp.text.Chunk"/>
            <seealso cref="T:iTextSharp.text.Gif"/>
            <seealso cref="T:iTextSharp.text.Graphic"/>
            <seealso cref="T:iTextSharp.text.Header"/>
            <seealso cref="T:iTextSharp.text.Image"/>
            <seealso cref="T:iTextSharp.text.Jpeg"/>
            <seealso cref="T:iTextSharp.text.List"/>
            <seealso cref="T:iTextSharp.text.ListItem"/>
            <seealso cref="T:iTextSharp.text.Meta"/>
            <seealso cref="T:iTextSharp.text.Paragraph"/>
            <seealso cref="T:iTextSharp.text.Phrase"/>
            <seealso cref="T:iTextSharp.text.Rectangle"/>
            <seealso cref="T:iTextSharp.text.Row"/>
            <seealso cref="T:iTextSharp.text.Section"/>
            <seealso cref="T:iTextSharp.text.Table"/>
        </member>
        <member name="M:iTextSharp.text.IElement.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.IElement.IsContent">
            Checks if this element is a content object.
            If not, it's a metadata object.
            @since    iText 2.0.8
            @return   true if this is a 'content' element; false if this is a 'medadata' element
        </member>
        <member name="M:iTextSharp.text.IElement.IsNestable">
            Checks if this element is nestable.
            @since    iText 2.0.8
            @return   true if this element can be nested inside other elements.
        </member>
        <member name="M:iTextSharp.text.IElement.ToString">
            <summary>
            Gets the content of the text element.
            </summary>
            <returns>the content of the text element</returns>
        </member>
        <member name="P:iTextSharp.text.IElement.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.IElement.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="M:iTextSharp.text.ITextElementArray.Add(iTextSharp.text.IElement)">
            <summary>
            Adds an object to the TextElementArray.
            </summary>
            <param name="o">an object that has to be added</param>
            <returns>true if the addition succeeded; false otherwise</returns>
        </member>
        <member name="F:iTextSharp.text.Phrase.leading">
            <summary>This is the leading of this phrase.</summary>
        </member>
        <member name="F:iTextSharp.text.Phrase.multipliedLeading">
            The text leading that is multiplied by the biggest font size in the line. 
        </member>
        <member name="F:iTextSharp.text.Phrase.font">
            <summary> This is the font of this phrase. </summary>
        </member>
        <member name="F:iTextSharp.text.Phrase.hyphenation">
            Null, unless the Phrase has to be hyphenated.
            @since   2.1.2
        </member>
        <member name="F:iTextSharp.text.Phrase.tabSettings">
            Predefined tab position and properties(alignment, leader and etc.);
            @since	5.4.1
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor">
            <summary>
            Constructs a Phrase without specifying a leading.
            </summary>
            <overloads>
            Has nine overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(iTextSharp.text.Phrase)">
            Copy constructor for <CODE>Phrase</CODE>.
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(System.Single)">
            <summary>
            Constructs a Phrase with a certain leading.
            </summary>
            <param name="leading">the leading</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(iTextSharp.text.Chunk)">
            <summary>
            Constructs a Phrase with a certain Chunk.
            </summary>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(System.Single,iTextSharp.text.Chunk)">
            <summary>
            Constructs a Phrase with a certain Chunk and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(System.String)">
            <summary>
            Constructs a Phrase with a certain string.
            </summary>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(System.String,iTextSharp.text.Font)">
            <summary>
            Constructs a Phrase with a certain string and a certain Font.
            </summary>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.#ctor(System.Single,System.String)">
            <summary>
            Constructs a Phrase with a certain leading and a certain string.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            <see cref="T:iTextSharp.text.IElementListener"/>.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Phrase.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Phrase.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Phrase.Add(System.Int32,iTextSharp.text.IElement)">
            <summary>
            Adds a Chunk, an Anchor or another Phrase
            to this Phrase.
            </summary>
            <param name="index">index at which the specified element is to be inserted</param>
            <param name="o">an object of type Chunk, Anchor, or Phrase</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.Add(System.String)">
             Adds a <CODE>String</CODE> to this <CODE>Phrase</CODE>.
            
             @param   s       a string
             @return  a boolean
             @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.Phrase.Add(iTextSharp.text.IElement)">
            <summary>
            Adds a Chunk, Anchor or another Phrase
            to this Phrase.
            </summary>
            <param name="o">an object of type Chunk, Anchor or Phrase</param>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Phrase.AddAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Adds a collection of Chunks
            to this Phrase.
            </summary>
            <param name="collection">a collection of Chunks, Anchors and Phrases.</param>
            <returns>true if the action succeeded, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.Phrase.AddChunk(iTextSharp.text.Chunk)">
            <summary>
            Adds a Chunk.
            </summary>
            <remarks>
            This method is a hack to solve a problem I had with phrases that were split between chunks
            in the wrong place.
            </remarks>
            <param name="chunk">a Chunk</param>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Phrase.AddSpecial(iTextSharp.text.IElement)">
            <summary>
            Adds a Object to the Paragraph.
            </summary>
            <param name="obj">the object to add.</param>
        </member>
        <member name="M:iTextSharp.text.Phrase.IsEmpty">
            <summary>
            Checks is this Phrase contains no or 1 empty Chunk.
            </summary>
            <returns>
            false if the Phrase
            contains more than one or more non-emptyChunks.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.Phrase.SetLeading(System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.Phrase.#ctor(System.Boolean)">
            Constructs a Phrase that can be used in the static GetInstance() method.
            @param	dummy	a dummy parameter
        </member>
        <member name="M:iTextSharp.text.Phrase.GetInstance(System.String)">
            Gets a special kind of Phrase that changes some characters into corresponding symbols.
            @param string
            @return a newly constructed Phrase
        </member>
        <member name="M:iTextSharp.text.Phrase.GetInstance(System.Int32,System.String)">
            Gets a special kind of Phrase that changes some characters into corresponding symbols.
            @param leading
            @param string
            @return a newly constructed Phrase
        </member>
        <member name="M:iTextSharp.text.Phrase.GetInstance(System.Int32,System.String,iTextSharp.text.Font)">
            Gets a special kind of Phrase that changes some characters into corresponding symbols.
            @param leading
            @param string
            @param font
            @return a newly constructed Phrase
        </member>
        <member name="P:iTextSharp.text.Phrase.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Phrase.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.Phrase.MultipliedLeading" -->
        <member name="P:iTextSharp.text.Phrase.Leading">
            <summary>
            Gets/sets the leading of this phrase.
            </summary>
            <value>the linespacing</value>
        </member>
        <member name="P:iTextSharp.text.Phrase.TotalLeading">
            Gets the total leading.
            This method is based on the assumption that the
            font of the Paragraph is the font of all the elements
            that make part of the paragraph. This isn't necessarily
            true.
            @return the total leading (fixed and multiplied)
        </member>
        <member name="P:iTextSharp.text.Phrase.Font">
            <summary>
            Gets the font of the first Chunk that appears in this Phrase.
            </summary>
            <value>a Font</value>
        </member>
        <member name="P:iTextSharp.text.Phrase.Content">
            Returns the content as a String object.
            This method differs from toString because toString will return an ArrayList with the toString value of the Chunks in this Phrase.
        </member>
        <member name="P:iTextSharp.text.Phrase.Hyphenation">
            Setter/getter for the hyphenation.
            @param   hyphenation a HyphenationEvent instance
            @since   2.1.2
        </member>
        <member name="P:iTextSharp.text.Phrase.TabSettings">
            Setter/getter for the tabSettings.
            @param   tabSettings a TabSettings instance
            @since   5.4.1
        </member>
        <member name="F:iTextSharp.text.Anchor.name">
            <summary>
            This is the name of the Anchor.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Anchor.reference">
            <summary>
            This is the reference of the Anchor.
            </summary>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor">
            <summary>
            Constructs an Anchor without specifying a leading.
            </summary>
            <overloads>
            Has nine overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.Single)">
            <summary>
            Constructs an Anchor with a certain leading.
            </summary>
            <param name="leading">the leading</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(iTextSharp.text.Chunk)">
            <summary>
            Constructs an Anchor with a certain Chunk.
            </summary>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.String)">
            <summary>
            Constructs an Anchor with a certain string.
            </summary>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.String,iTextSharp.text.Font)">
            <summary>
            Constructs an Anchor with a certain string
            and a certain Font.
            </summary>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.Single,iTextSharp.text.Chunk)">
            <summary>
            Constructs an Anchor with a certain Chunk
            and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.Single,System.String)">
            <summary>
            Constructs an Anchor with a certain leading
            and a certain string.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(System.Single,System.String,iTextSharp.text.Font)">
            <summary>
            Constructs an Anchor with a certain leading,
            a certain string and a certain Font.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.Anchor.#ctor(iTextSharp.text.Phrase)">
             Constructs an <CODE>Anchor</CODE> with a certain <CODE>Phrase</CODE>.
            
             @param   phrase      a <CODE>Phrase</CODE>
        </member>
        <member name="M:iTextSharp.text.Anchor.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            <see cref="T:iTextSharp.text.IElementListener"/>
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Anchor.ApplyAnchor(iTextSharp.text.Chunk,System.Boolean,System.Boolean)">
            Applies the properties of the Anchor to a Chunk.
            @param chunk			the Chunk (part of the Anchor)
            @param notGotoOK		if true, this chunk will determine the local destination
            @param localDestination	true if the chunk is a local goto and the reference a local destination
            @return	the value of notGotoOK or false, if a previous Chunk was used to determine the local destination
        </member>
        <member name="P:iTextSharp.text.Anchor.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Anchor.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Anchor.Name">
            <summary>
            Name of this Anchor.
            </summary>
        </member>
        <member name="P:iTextSharp.text.Anchor.Reference">
            <summary>
            reference of this Anchor.
            </summary>
        </member>
        <member name="P:iTextSharp.text.Anchor.Url">
            <summary>
            reference of this Anchor.
            </summary>
            <value>an Uri</value>
        </member>
        <member name="T:iTextSharp.text.Annotation">
            <summary>
            An Annotation is a little note that can be added to a page
            on a document.
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Anchor"/>
        </member>
        <member name="F:iTextSharp.text.Annotation.TEXT">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.URL_NET">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.URL_AS_STRING">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.FILE_DEST">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.FILE_PAGE">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.NAMED_DEST">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.LAUNCH">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.SCREEN">
            <summary>This is a possible annotation type.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.TITLE">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.CONTENT">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.URL">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.FILE">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.DESTINATION">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.PAGE">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.NAMED">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.APPLICATION">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.PARAMETERS">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.OPERATION">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.DEFAULTDIR">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.LLX">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.LLY">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.URX">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.URY">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.MIMETYPE">
            <summary>This is a possible attribute.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.annotationtype">
            <summary>This is the type of annotation.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.annotationAttributes">
            <summary>This is the title of the Annotation.</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.llx">
            <summary>This is the lower left x-value</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.lly">
            <summary>This is the lower left y-value</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.urx">
            <summary>This is the upper right x-value</summary>
        </member>
        <member name="F:iTextSharp.text.Annotation.ury">
            <summary>This is the upper right y-value</summary>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs an Annotation with a certain title and some text.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.String,System.String)">
            <summary>
            Constructs an Annotation with a certain title and some text.
            </summary>
            <param name="title">the title of the annotation</param>
            <param name="text">the content of the annotation</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.String,System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs an Annotation with a certain title and some text.
            </summary>
            <param name="title">the title of the annotation</param>
            <param name="text">the content of the annotation</param>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.Uri)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="url">the external reference</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="url">the external reference</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.String)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="file">an external PDF file</param>
            <param name="dest">the destination in this file</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.String,System.Boolean)">
            <summary>
            Creates a Screen anotation to embed media clips
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="moviePath">path to the media clip file</param>
            <param name="mimeType">mime type of the media</param>
            <param name="showOnDisplay">if true play on display of the page</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.Int32)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="file">an external PDF file</param>
            <param name="page">a page number in this file</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="named">a named destination in this file</param>
            <overloads>
            Has nine overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Annotation.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.String,System.String,System.String)">
            <summary>
            Constructs an Annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
            <param name="application">an external application</param>
            <param name="parameters">parameters to pass to this application</param>
            <param name="operation">the operation to pass to this application</param>
            <param name="defaultdir">the default directory to run this application in</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was process successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.SetDimensions(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the dimensions of this annotation.
            </summary>
            <param name="llx">the lower left x-value</param>
            <param name="lly">the lower left y-value</param>
            <param name="urx">the upper right x-value</param>
            <param name="ury">the upper right y-value</param>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetLlx">
            <summary>
            Returns the lower left x-value.
            </summary>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetLly">
            <summary>
            Returns the lower left y-value.
            </summary>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetUrx">
            <summary>
            Returns the uppper right x-value.
            </summary>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetUry">
            <summary>
            Returns the uppper right y-value.
            </summary>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetLlx(System.Single)">
            <summary>
            Returns the lower left x-value.
            </summary>
            <param name="def">the default value</param>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetLly(System.Single)">
            <summary>
            Returns the lower left y-value.
            </summary>
            <param name="def">the default value</param>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetUrx(System.Single)">
            <summary>
            Returns the upper right x-value.
            </summary>
            <param name="def">the default value</param>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.GetUry(System.Single)">
            <summary>
            Returns the upper right y-value.
            </summary>
            <param name="def">the default value</param>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Annotation.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Annotation.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="P:iTextSharp.text.Annotation.Type">
            <summary>
            Gets the type of the text element
            </summary>
        </member>
        <member name="P:iTextSharp.text.Annotation.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Annotation.AnnotationType">
            <summary>
            Returns the type of this Annotation.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Annotation.Title">
            <summary>
            Returns the title of this Annotation.
            </summary>
            <value>a name</value>
        </member>
        <member name="P:iTextSharp.text.Annotation.Content">
            <summary>
            Gets the content of this Annotation.
            </summary>
            <value>a reference</value>
        </member>
        <member name="P:iTextSharp.text.Annotation.Attributes">
            <summary>
            Gets the content of this Annotation.
            </summary>
            <value>a reference</value>
        </member>
        <member name="T:iTextSharp.text.BadElementException">
            <summary>
            Signals an attempt to create an Element that hasn't got the right form.
            </summary>
            <seealso cref="T:iTextSharp.text.Cell"/>
            <seealso cref="T:iTextSharp.text.Table"/>
        </member>
        <member name="T:iTextSharp.text.DocumentException">
            <summary>
            Signals that an error has occurred in a Document.
            </summary>
            <seealso cref="T:iTextSharp.text.BadElementException"/>
            <seealso cref="T:iTextSharp.text.Document"/>
            <seealso cref="T:iTextSharp.text.DocWriter"/>
            <seealso cref="T:iTextSharp.text.IDocListener"/>
        </member>
        <member name="M:iTextSharp.text.DocumentException.#ctor">
            <summary>
            Constructs a new DocumentException
            </summary>
            <overloads>
            Has two overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.DocumentException.#ctor(System.String)">
            <summary>
            Construct a new DocumentException
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:iTextSharp.text.DocumentException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a DocumentException with a message and a Exception.
            </summary>
            <param name="message">a message describing the exception</param>
            <param name="ex">an exception that has to be turned into a DocumentException</param>
        </member>
        <member name="T:iTextSharp.text.BaseColor">
            <summary>
            Base class for Color, serves as wrapper class for <see cref="T:System.Drawing.Color"/>
            to allow extension.
            </summary>
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Construct a new BaseColor.
            @param red the value for the red gamma
            @param green the value for the green gamma
            @param blue the value for the blue gamma
            @param alpha the value for the alpha gamma
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Int32,System.Int32,System.Int32)">
            @param red
            @param green
            @param blue
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Single,System.Single,System.Single,System.Single)">
            Construct a BaseColor with float values.
            @param red
            @param green
            @param blue
            @param alpha
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Single,System.Single,System.Single)">
            Construct a BaseColor with float values.
            @param red
            @param green
            @param blue
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Int32)">
            Construct a BaseColor by setting the combined value.
            @param argb
        </member>
        <member name="M:iTextSharp.text.BaseColor.#ctor(System.Drawing.Color)">
            Construct a BaseColor by System.Drawing.Color.
            @param color
        </member>
        <member name="M:iTextSharp.text.BaseColor.Brighter">
            Make this BaseColor brighter. Factor used is 0.7.
            @return the new BaseColor
        </member>
        <member name="M:iTextSharp.text.BaseColor.Darker">
            Make this color darker. Factor used is 0.7
            @return the new BaseColor
        </member>
        <member name="P:iTextSharp.text.BaseColor.RGB">
            @return the combined color value
        </member>
        <member name="P:iTextSharp.text.BaseColor.R">
            
             @return the value for red
        </member>
        <member name="P:iTextSharp.text.BaseColor.G">
            
             @return the value for green
        </member>
        <member name="P:iTextSharp.text.BaseColor.B">
            
             @return the value for blue
        </member>
        <member name="P:iTextSharp.text.BaseColor.A">
            
             @return the value for the alpha channel
        </member>
        <member name="T:iTextSharp.text.Chapter">
            <summary>
            A Chapter is a special Section.
            </summary>
            <remarks>
            A chapter number has to be created using a Paragraph as title
            and an int as chapter number. The chapter number is shown be
            default. If you don't want to see the chapter number, you have to set the
            numberdepth to 0.
            </remarks>
            <example>
            <code>
            Paragraph title2 = new Paragraph("This is Chapter 2", FontFactory.GetFont(FontFactory.HELVETICA, 18, Font.BOLDITALIC, new BaseColor(0, 0, 255)));
            <strong>Chapter chapter2 = new Chapter(title2, 2);
            chapter2.SetNumberDepth(0);</strong>
            Paragraph someText = new Paragraph("This is some text");
            <strong>chapter2.Add(someText);</strong>
            Paragraph title21 = new Paragraph("This is Section 1 in Chapter 2", FontFactory.GetFont(FontFactory.HELVETICA, 16, Font.BOLD, new BaseColor(255, 0, 0)));
            Section section1 = <strong>chapter2.AddSection(title21);</strong>
            Paragraph someSectionText = new Paragraph("This is some silly paragraph in a chapter and/or section. It contains some text to test the functionality of Chapters and Section.");
            section1.Add(someSectionText);
            </code>
            </example>
        </member>
        <member name="T:iTextSharp.text.Section">
            <summary>
            A Section is a part of a Document containing
            other Sections, Paragraphs, List
            and/or Tables.
            </summary>
            <remarks>
            You can not construct a Section yourself.
            You will have to ask an instance of Section to the
            Chapter or Section to which you want to
            add the new Section.
            </remarks>
            <example>
            <code>
            Paragraph title2 = new Paragraph("This is Chapter 2", FontFactory.GetFont(FontFactory.HELVETICA, 18, Font.BOLDITALIC, new Color(0, 0, 255)));
            Chapter chapter2 = new Chapter(title2, 2);
            Paragraph someText = new Paragraph("This is some text");
            chapter2.Add(someText);
            Paragraph title21 = new Paragraph("This is Section 1 in Chapter 2", FontFactory.GetFont(FontFactory.HELVETICA, 16, Font.BOLD, new Color(255, 0, 0)));
            <strong>Section section1 = chapter2.AddSection(title21);</strong>
            Paragraph someSectionText = new Paragraph("This is some silly paragraph in a chapter and/or section. It contains some text to test the functionality of Chapters and Section.");
            <strong>section1.Add(someSectionText);</strong>
            Paragraph title211 = new Paragraph("This is SubSection 1 in Section 1 in Chapter 2", FontFactory.GetFont(FontFactory.HELVETICA, 14, Font.BOLD, new Color(255, 0, 0)));
            <strong>Section section11 = section1.AddSection(40, title211, 2);
            section11.Add(someSectionText);</strong>strong>
            </code>
            </example>
        </member>
        <member name="T:iTextSharp.text.ILargeElement">
            Interface implemented by Element objects that can potentially consume
            a lot of memory. Objects implementing the LargeElement interface can
            be added to a Document more than once. If you have invoked setCompleted(false),
            they will be added partially and the content that was added will be
            removed until you've invoked setCompleted(true);
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.ILargeElement.FlushContent">
            Flushes the content that has been added.
        </member>
        <member name="P:iTextSharp.text.ILargeElement.ElementComplete">
            If you invoke setCompleted(false), you indicate that the content
            of the object isn't complete yet; it can be added to the document
            partially, but more will follow. If you invoke setCompleted(true),
            you indicate that you won't add any more data to the object.
            @since   iText 2.0.8
            @param   complete    false if you'll be adding more data after
                                 adding the object to the document.
        </member>
        <member name="T:iTextSharp.text.api.IIndentable">
            Objects implementing Indentable allow to set indentation left and right.
        </member>
        <member name="P:iTextSharp.text.api.IIndentable.IndentationLeft">
             Sets the indentation on the left side.
            
             @param   indentation     the new indentation
        </member>
        <member name="P:iTextSharp.text.api.IIndentable.IndentationRight">
             Sets the indentation on the right side.
            
             @param   indentation     the new indentation
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IAccessibleElement.GetAccessibleAttribute(iTextSharp.text.pdf.PdfName)">
            Get the attribute of accessible element (everything in <code>A</code> dictionary + <code>Lang</code>, <code>Alt</code>, <code>ActualText</code>, <code>E</code>).
            @param key
            @return
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IAccessibleElement.SetAccessibleAttribute(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Set the attribute of accessible element (everything in <code>A</code> dictionary + <code>Lang</code>, <code>Alt</code>, <code>ActualText</code>, <code>E</code>).
            @param key
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IAccessibleElement.GetAccessibleAttributes">
            Gets all the properties of accessible element.
            @return
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IAccessibleElement.Role">
            Role propherty of the accessible element.
            Note that all child elements won't also be tagged.
            @return
        </member>
        <member name="F:iTextSharp.text.Section.NUMBERSTYLE_DOTTED">
            A possible number style. The default number style: "1.2.3."
            @since   iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT">
            A possible number style. For instance: "1.2.3"
            @since   iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.title">
            <summary> This is the title of this section. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.numberDepth">
            <summary> This is the number of sectionnumbers that has to be shown before the section title. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.numberStyle">
            The style for sectionnumbers.
            @since    iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.indentationLeft">
            <summary> The indentation of this section on the left side. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.indentationRight">
            <summary> The indentation of this section on the right side. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.indentation">
            <summary> The additional indentation of the content of this section. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.subsections">
            <summary> This is the number of subsections. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.numbers">
            <summary> This is the complete list of sectionnumbers of this section and the parents of this section. </summary>
        </member>
        <member name="F:iTextSharp.text.Section.complete">
            Indicates if the Section will be complete once added to the document.
            @since   iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.addedCompletely">
            Indicates if the Section was added completely to the document.
            @since   iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.notAddedYet">
            Indicates if this is the first time the section was added.
            @since   iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.Section.bookmarkOpen">
            <summary> false if the bookmark children are not visible </summary>
        </member>
        <member name="F:iTextSharp.text.Section.triggerNewPage">
            true if the section has to trigger a new page 
        </member>
        <member name="F:iTextSharp.text.Section.bookmarkTitle">
            The bookmark title if different from the content title 
        </member>
        <member name="M:iTextSharp.text.Section.#ctor">
            <summary>
            Constructs a new Section.
            </summary>
            <overloads>
            Has 2 overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Section.#ctor(iTextSharp.text.Paragraph,System.Int32)">
            <summary>
            Constructs a new Section.
            </summary>
            <param name="title">a Paragraph</param>
            <param name="numberDepth">the numberDepth</param>
        </member>
        <member name="M:iTextSharp.text.Section.SetNumbers(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Sets the number of this section.
            </summary>
            <param name="number">the number of this section</param>
            <param name="numbers">an ArrayList, containing the numbers of the Parent</param>
        </member>
        <member name="M:iTextSharp.text.Section.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">the IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Section.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Section.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Section.Add(System.Int32,iTextSharp.text.IElement)">
            <summary>
            Adds a Paragraph, List or Table
            to this Section.
            </summary>
            <param name="index">index at which the specified element is to be inserted</param>
            <param name="o">an object of type Paragraph, List or Table</param>
        </member>
        <member name="M:iTextSharp.text.Section.Add(iTextSharp.text.IElement)">
            <summary>
            Adds a Paragraph, List, Table or another Section
            to this Section.
            </summary>
            <param name="o">an object of type Paragraph, List, Table or another Section</param>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddAll``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Adds a collection of Elements
            to this Section.
            </summary>
            <param name="collection">a collection of Paragraphs, Lists and/or Tables</param>
            <returns>true if the action succeeded, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.Single,iTextSharp.text.Paragraph,System.Int32)">
            <summary>
            Creates a Section, adds it to this Section and returns it.
            </summary>
            <param name="indentation">the indentation of the new section</param>
            <param name="title">the title of the new section</param>
            <param name="numberDepth">the numberDepth of the section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.Single,iTextSharp.text.Paragraph)">
            <summary>
            Creates a Section, adds it to this Section and returns it.
            </summary>
            <param name="indentation">the indentation of the new section</param>
            <param name="title">the title of the new section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(iTextSharp.text.Paragraph,System.Int32)">
            <summary>
            Creates a Section, add it to this Section and returns it.
            </summary>
            <param name="title">the title of the new section</param>
            <param name="numberDepth">the numberDepth of the section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddMarkedSection">
            Adds a marked section. For use in class MarkedSection only!
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(iTextSharp.text.Paragraph)">
            <summary>
            Creates a Section, adds it to this Section and returns it.
            </summary>
            <param name="title">the title of the new section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.Single,System.String,System.Int32)">
             Adds a Section to this Section and returns it.
            
             @param    indentation    the indentation of the new section
             @param    title        the title of the new section
             @param    numberDepth    the numberDepth of the section
            <summary>
            Adds a Section to this Section and returns it.
            </summary>
            <param name="indentation">the indentation of the new section</param>
            <param name="title">the title of the new section</param>
            <param name="numberDepth">the numberDepth of the section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.String,System.Int32)">
             Adds a Section to this Section and returns it.
            
             @param    title        the title of the new section
             @param    numberDepth    the numberDepth of the section
            <summary>
            Adds a Section to this Section and returns it.
            </summary>
            <param name="title">the title of the new section</param>
            <param name="numberDepth">the numberDepth of the section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.Single,System.String)">
            <summary>
            Adds a Section to this Section and returns it.
            </summary>
            <param name="indentation">the indentation of the new section</param>
            <param name="title">the title of the new section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.AddSection(System.String)">
            <summary>
            Adds a Section to this Section and returns it.
            </summary>
            <param name="title">the title of the new section</param>
            <returns>the newly added Section</returns>
        </member>
        <member name="M:iTextSharp.text.Section.ConstructTitle(iTextSharp.text.Paragraph,System.Collections.Generic.List{System.Int32},System.Int32,System.Int32)">
            Constructs a Paragraph that will be used as title for a Section or Chapter.
            @param    title   the title of the section
            @param    numbers a list of sectionnumbers
            @param    numberDepth how many numbers have to be shown
            @param    numberStyle the numbering style
            @return   a Paragraph object
            @since    iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Section.IsChapter">
            <summary>
            Checks if this object is a Chapter.
            </summary>
            <returns>
            true if it is a Chapter,
            false if it is a Section
            </returns>
        </member>
        <member name="M:iTextSharp.text.Section.IsSection">
            <summary>
            Checks if this object is a Section.
            </summary>
            <returns>
            true if it is a Section,
            false if it is a Chapter.
            </returns>
        </member>
        <member name="M:iTextSharp.text.Section.GetBookmarkTitle">
            Gets the bookmark title.
            @return the bookmark title
        </member>
        <member name="M:iTextSharp.text.Section.SetChapterNumber(System.Int32)">
            Changes the Chapter number.
        </member>
        <member name="M:iTextSharp.text.Section.FlushContent">
            @since   iText 2.0.8
            @see com.lowagie.text.LargeElement#flushContent()
        </member>
        <member name="M:iTextSharp.text.Section.NewPage">
            Adds a new page to the section.
            @since   2.1.1
        </member>
        <member name="P:iTextSharp.text.Section.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Section.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Section.Title">
            <summary>
            Get/set the title of this section
            </summary>
            <value>a Paragraph</value>
        </member>
        <member name="P:iTextSharp.text.Section.NumberStyle">
            Sets the style for numbering sections.
            Possible values are NUMBERSTYLE_DOTTED: 1.2.3. (the default)
            or NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT: 1.2.3
            @since    iText 2.0.8
        </member>
        <member name="P:iTextSharp.text.Section.NumberDepth">
            <summary>
            Get/set the numberdepth of this Section.
            </summary>
            <value>a int</value>
        </member>
        <member name="P:iTextSharp.text.Section.IndentationLeft">
            <summary>
            Get/set the indentation of this Section on the left side.
            </summary>
            <value>the indentation</value>
        </member>
        <member name="P:iTextSharp.text.Section.IndentationRight">
            <summary>
            Get/set the indentation of this Section on the right side.
            </summary>
            <value>the indentation</value>
        </member>
        <member name="P:iTextSharp.text.Section.Indentation">
            <summary>
            Get/set the indentation of the content of this Section.
            </summary>
            <value>the indentation</value>
        </member>
        <member name="P:iTextSharp.text.Section.Depth">
            <summary>
            Returns the depth of this section.
            </summary>
            <value>the depth</value>
        </member>
        <member name="P:iTextSharp.text.Section.BookmarkOpen">
            <summary>
            Get/set the bookmark
            </summary>
            <value>a bool</value>
        </member>
        <member name="P:iTextSharp.text.Section.BookmarkTitle">
            Sets the bookmark title. The bookmark title is the same as the section title but
            can be changed with this method.
            @param bookmarkTitle the bookmark title
        </member>
        <member name="P:iTextSharp.text.Section.NotAddedYet">
            Indicates if this is the first time the section is added.
            @since   iText2.0.8
            @return  true if the section wasn't added yet
        </member>
        <member name="P:iTextSharp.text.Section.AddedCompletely">
            @see com.lowagie.text.LargeElement#isAddedCompletely()
            @since   iText 2.0.8
        </member>
        <member name="P:iTextSharp.text.Section.ElementComplete">
            @since   iText 2.0.8
            @see com.lowagie.text.LargeElement#isComplete()
        </member>
        <member name="M:iTextSharp.text.Chapter.#ctor(System.Int32)">
            Constructs a new <CODE>Chapter</CODE>.
            @param   number      the Chapter number
        </member>
        <member name="M:iTextSharp.text.Chapter.#ctor(iTextSharp.text.Paragraph,System.Int32)">
            <summary>
            Constructs a new Chapter.
            </summary>
            <param name="title">the Chapter title (as a Paragraph)</param>
            <param name="number">the Chapter number</param>
            <overoads>
            Has three overloads.
            </overoads>
        </member>
        <member name="M:iTextSharp.text.Chapter.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new Chapter.
            </summary>
            <param name="title">the Chapter title (as a string)</param>
            <param name="number">the Chapter number</param>
            <overoads>
            Has three overloads.
            </overoads>
        </member>
        <member name="M:iTextSharp.text.Chapter.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="P:iTextSharp.text.Chapter.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="T:iTextSharp.text.ChapterAutoNumber">
             Chapter with auto numbering.
            
             @author Michael Niedermair
        </member>
        <member name="F:iTextSharp.text.ChapterAutoNumber.numberSet">
            Is the chapter number already set?
            @since	2.1.4
        </member>
        <member name="M:iTextSharp.text.ChapterAutoNumber.#ctor(iTextSharp.text.Paragraph)">
             Create a new object.
            
             @param para     the Chapter title (as a <CODE>Paragraph</CODE>)
        </member>
        <member name="M:iTextSharp.text.ChapterAutoNumber.#ctor(System.String)">
            Create a new objet.
            
            @param title     the Chapter title (as a <CODE>String</CODE>)
        </member>
        <member name="M:iTextSharp.text.ChapterAutoNumber.AddSection(System.String)">
             Create a new section for this chapter and ad it.
            
             @param title  the Section title (as a <CODE>String</CODE>)
             @return Returns the new section.
        </member>
        <member name="M:iTextSharp.text.ChapterAutoNumber.AddSection(iTextSharp.text.Paragraph)">
             Create a new section for this chapter and add it.
            
             @param title  the Section title (as a <CODE>Paragraph</CODE>)
             @return Returns the new section.
        </member>
        <member name="M:iTextSharp.text.ChapterAutoNumber.SetAutomaticNumber(System.Int32)">
            Changes the Chapter number.
            @param	number	the new chapter number
            @since 2.1.4
        </member>
        <member name="T:iTextSharp.text.Chunk">
            <summary>
            This is the smallest significant part of text that can be added to a document.
            </summary>
            <remarks>
            Most elements can be divided in one or more Chunks.
            A chunk is a string with a certain Font.
            all other layoutparameters should be defined in the object to which
            this chunk of text is added.
            </remarks>
            <example>
            <code>
            <strong>Chunk chunk = new Chunk("Hello world", FontFactory.GetFont(FontFactory.COURIER, 20, Font.ITALIC, new BaseColor(255, 0, 0)));</strong>
            document.Add(chunk);
            </code>
            </example>
        </member>
        <member name="F:iTextSharp.text.Chunk.OBJECT_REPLACEMENT_CHARACTER">
            The character stand in for an image or a separator. 
        </member>
        <member name="F:iTextSharp.text.Chunk.SEPARATOR">
            Key for drawInterface of the Separator.
            @since   2.1.2
        </member>
        <member name="F:iTextSharp.text.Chunk.TAB">
            Key for drawInterface of the tab.
            @since   2.1.2
        </member>
        <member name="F:iTextSharp.text.Chunk.TABSETTINGS">
            Key for tab stops of the tab.
            @since	5.4.1
        </member>
        <member name="F:iTextSharp.text.Chunk.HSCALE">
            Key for text horizontal scaling. 
        </member>
        <member name="F:iTextSharp.text.Chunk.UNDERLINE">
            <summary> Key for underline. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.SUBSUPSCRIPT">
            <summary> Key for sub/basescript. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.SKEW">
            <summary> Key for text skewing. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.BACKGROUND">
            <summary> Key for background. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.TEXTRENDERMODE">
            <summary> Key for text rendering mode.</summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.SPLITCHARACTER">
            <summary> Key for split character. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.HYPHENATION">
            <summary> Key for hyphenation. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.REMOTEGOTO">
            <summary> Key for remote goto. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.LOCALGOTO">
            <summary> Key for local goto. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.LOCALDESTINATION">
            <summary> Key for local destination. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.GENERICTAG">
            <summary> Key for generic tag. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.LINEHEIGHT">
            Key for line-height (alternative for leading in Phrase). 
        </member>
        <member name="F:iTextSharp.text.Chunk.IMAGE">
            <summary> Key for image. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.ACTION">
            <summary> Key for Action. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.NEWPAGE">
            <summary> Key for newpage. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.PDFANNOTATION">
            <summary> Key for annotation. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.COLOR">
            <summary> Key for color. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.ENCODING">
            <summary> Key for encoding. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.CHAR_SPACING">
            Key for character spacing.
        </member>
        <member name="F:iTextSharp.text.Chunk.WORD_SPACING">
            Key for word spacing.
        </member>
        <member name="F:iTextSharp.text.Chunk.NEWLINE">
            <summary> This is a Chunk containing a newline. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.NEXTPAGE">
            This is a Chunk containing a newpage. 
        </member>
        <member name="F:iTextSharp.text.Chunk.content">
            <summary> This is the content of this chunk of text. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.font">
            <summary> This is the Font of this chunk of text. </summary>
        </member>
        <member name="F:iTextSharp.text.Chunk.attributes">
            <summary> Contains some of the attributes for this Chunk. </summary>
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor">
            <summary>
            Empty constructor.
            </summary>
            <overloads>
            Has six overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.Chunk)">
            A <CODE>Chunk</CODE> copy constructor.
            @param ck the <CODE>Chunk</CODE> to be copied
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(System.String,iTextSharp.text.Font)">
            <summary>
            Constructs a chunk of text with a certain content and a certain Font.
            </summary>
            <param name="content">the content</param>
            <param name="font">the font</param>
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(System.String)">
            <summary>
            Constructs a chunk of text with a certain content, without specifying a Font.
            </summary>
            <param name="content">the content</param>
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(System.Char,iTextSharp.text.Font)">
             Constructs a chunk of text with a char and a certain <CODE>Font</CODE>.
            
             @param    c        the content
             @param    font        the font
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(System.Char)">
             Constructs a chunk of text with a char, without specifying a <CODE>Font</CODE>.
            
             @param    c        the content
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.Image,System.Single,System.Single)">
            <summary>
            Constructs a chunk containing an Image.
            </summary>
            <param name="image">the image</param>
            <param name="offsetX">the image offset in the x direction</param>
            <param name="offsetY">the image offset in the y direction</param>
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.pdf.draw.IDrawInterface)">
            Creates a separator Chunk.
            Note that separator chunks can't be used in combination with tab chunks!
            @param   separator   the drawInterface to use to draw the separator.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.pdf.draw.IDrawInterface,System.Boolean)">
            Creates a separator Chunk.
            Note that separator chunks can't be used in combination with tab chunks!
            @param   separator   the drawInterface to use to draw the separator.
            @param   vertical    true if this is a vertical separator
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.pdf.draw.IDrawInterface,System.Single)">
            Creates a tab Chunk.
            Note that separator chunks can't be used in combination with tab chunks!
            @param   separator   the drawInterface to use to draw the tab.
            @param   tabPosition an X coordinate that will be used as start position for the next Chunk.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.pdf.draw.IDrawInterface,System.Single,System.Boolean)">
            Creates a tab Chunk.
            Note that separator chunks can't be used in combination with tab chunks!
            @param   separator   the drawInterface to use to draw the tab.
            @param   tabPosition an X coordinate that will be used as start position for the next Chunk.
            @param   newline     if true, a newline will be added if the tabPosition has already been reached.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(System.Single,System.Boolean)">
             Creates a tab Chunk.
            
             @param   tabInterval     an interval that will be used if tab stops are omitted.
             @param   isWhitespace    if true, the current tab is treated as white space.
             @since 5.4.1
        </member>
        <member name="M:iTextSharp.text.Chunk.#ctor(iTextSharp.text.Image,System.Single,System.Single,System.Boolean)">
            <summary>
            Constructs a chunk containing an Image.
            </summary>
            <param name="image">the image</param>
            <param name="offsetX">the image offset in the x direction</param>
            <param name="offsetY">the image offset in the y direction</param>
            <param name="changeLeading">true if the leading has to be adapted to the image</param>
        </member>
        <member name="M:iTextSharp.text.Chunk.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.Append(System.String)">
            <summary>
            appends some text to this Chunk.
            </summary>
            <param name="str">a string</param>
            <returns>a StringBuilder</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.IsEmpty">
            <summary>
            Checks is this Chunk is empty.
            </summary>
            <returns>false if the Chunk contains other characters than space.</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.GetWidthPoint">
            Gets the width of the Chunk in points.
            @return a width in points
        </member>
        <member name="M:iTextSharp.text.Chunk.HasAttributes">
            <summary>
            Checks the attributes of this Chunk.
            </summary>
            <returns>false if there aren't any.</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.HasAccessibleAttributes">
             Checks  the accessible attributes of this <CODE>Chunk</CODE>.
            
             @return false if there aren't any.
        </member>
        <member name="M:iTextSharp.text.Chunk.SetAttribute(System.String,System.Object)">
            <summary>
            Sets an arbitrary attribute.
            </summary>
            <param name="name">the key for the attribute</param>
            <param name="obj">the value of the attribute</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetHorizontalScaling(System.Single)">
            Sets the text horizontal scaling. A value of 1 is normal and a value of 0.5f
            shrinks the text to half it's width.
            @param scale the horizontal scaling factor
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetUnderline(System.Single,System.Single)">
            Sets an horizontal line that can be an underline or a strikethrough.
            Actually, the line can be anywhere vertically and has always the
            <CODE>Chunk</CODE> width. Multiple call to this method will
            produce multiple lines.
            @param thickness the absolute thickness of the line
            @param yPosition the absolute y position relative to the baseline
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetUnderline(iTextSharp.text.BaseColor,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Sets an horizontal line that can be an underline or a strikethrough.
            Actually, the line can be anywhere vertically and has always the
            <CODE>Chunk</CODE> width. Multiple call to this method will
            produce multiple lines.
            @param color the color of the line or <CODE>null</CODE> to follow
            the text color
            @param thickness the absolute thickness of the line
            @param thicknessMul the thickness multiplication factor with the font size
            @param yPosition the absolute y position relative to the baseline
            @param yPositionMul the position multiplication factor with the font size
            @param cap the end line cap. Allowed values are
            PdfContentByte.LINE_CAP_BUTT, PdfContentByte.LINE_CAP_ROUND and
            PdfContentByte.LINE_CAP_PROJECTING_SQUARE
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetTextRise(System.Single)">
            <summary>
            Sets the text displacement relative to the baseline. Positive values rise the text,
            negative values lower the text.
            </summary>
            <remarks>
            It can be used to implement sub/basescript.
            </remarks>
            <param name="rise">the displacement in points</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetSkew(System.Single,System.Single)">
            Skews the text to simulate italic and other effects.
            Try <CODE>alpha=0</CODE> and <CODE>beta=12</CODE>.
            @param alpha the first angle in degrees
            @param beta the second angle in degrees
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetBackground(iTextSharp.text.BaseColor)">
            <summary>
            Sets the color of the background Chunk.
            </summary>
            <param name="color">the color of the background</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetBackground(iTextSharp.text.BaseColor,System.Single,System.Single,System.Single,System.Single)">
            Sets the color and the size of the background <CODE>Chunk</CODE>.
            @param color the color of the background
            @param extraLeft increase the size of the rectangle in the left
            @param extraBottom increase the size of the rectangle in the bottom
            @param extraRight increase the size of the rectangle in the right
            @param extraTop increase the size of the rectangle in the top
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetTextRenderMode(System.Int32,System.Single,iTextSharp.text.BaseColor)">
            Sets the text rendering mode. It can outline text, simulate bold and make
            text invisible.
            @param mode the text rendering mode. It can be <CODE>PdfContentByte.TEXT_RENDER_MODE_FILL</CODE>,
            <CODE>PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE>, <CODE>PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE>
            and <CODE>PdfContentByte.TEXT_RENDER_MODE_INVISIBLE</CODE>.
            @param strokeWidth the stroke line width for the modes <CODE>PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE> and
            <CODE>PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE>.
            @param strokeColor the stroke color or <CODE>null</CODE> to follow the text color
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetSplitCharacter(iTextSharp.text.ISplitCharacter)">
            <summary>
            Sets the split characters.
            </summary>
            <param name="splitCharacter">the SplitCharacter interface</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetHyphenation(iTextSharp.text.pdf.IHyphenationEvent)">
            <summary>
            sets the hyphenation engine to this Chunk.
            </summary>
            <param name="hyphenation">the hyphenation engine</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetRemoteGoto(System.String,System.String)">
            <summary>
            Sets a goto for a remote destination for this Chunk.
            </summary>
            <param name="filename">the file name of the destination document</param>
            <param name="name">the name of the destination to go to</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetRemoteGoto(System.String,System.Int32)">
            <summary>
            Sets a goto for a remote destination for this Chunk.
            </summary>
            <param name="filename">the file name of the destination document</param>
            <param name="page">the page of the destination to go to. First page is 1</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetLocalGoto(System.String)">
            <summary>
            Sets a local goto for this Chunk.
            </summary>
            <remarks>
            There must be a local destination matching the name.
            </remarks>
            <param name="name">the name of the destination to go to</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetLocalDestination(System.String)">
            <summary>
            Sets a local destination for this Chunk.
            </summary>
            <param name="name">the name for this destination</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetGenericTag(System.String)">
            <summary>
            Sets the generic tag Chunk.
            </summary>
            <remarks>
            The text for this tag can be retrieved with PdfPageEvent.
            </remarks>
            <param name="text">the text for the tag</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.setLineHeight(System.Single)">
             Sets a line height tag.
            
             @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.GetImage">
            <summary>
            Returns the image.
            </summary>
            <value>an Image</value>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetAction(iTextSharp.text.pdf.PdfAction)">
            <summary>
            Sets an action for this Chunk.
            </summary>
            <param name="action">the action</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetAnchor(System.Uri)">
            <summary>
            Sets an anchor for this Chunk.
            </summary>
            <param name="url">the Uri to link to</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetAnchor(System.String)">
            <summary>
            Sets an anchor for this Chunk.
            </summary>
            <param name="url">the url to link to</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetNewPage">
            <summary>
            Sets a new page tag.
            </summary>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.SetAnnotation(iTextSharp.text.pdf.PdfAnnotation)">
            <summary>
            Sets a generic annotation to this Chunk.
            </summary>
            <param name="annotation">the annotation</param>
            <returns>this Chunk</returns>
        </member>
        <member name="M:iTextSharp.text.Chunk.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Chunk.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Chunk.GetHyphenation">
            Returns the hyphenation (if present).
            @param    hyphenation a HyphenationEvent instance
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Chunk.SetCharacterSpacing(System.Single)">
            Sets the character spacing.
            
            @param charSpace the character spacing value
            @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.GetCharacterSpacing">
            Gets the character spacing.
            
            @return a value in float
        </member>
        <member name="M:iTextSharp.text.Chunk.SetWordSpacing(System.Single)">
             Sets the word spacing.
            
             @param wordSpace the word spacing value
             @return this <CODE>Chunk</CODE>
        </member>
        <member name="M:iTextSharp.text.Chunk.GetWordSpacing">
             Gets the word spacing.
            
             @return a value in float
        </member>
        <member name="M:iTextSharp.text.Chunk.SetTextExpansion(System.String)">
            Sets the textual expansion of the abbreviation or acronym.
            It is highly recommend to set textuual expansion when generating PDF/UA documents.
            @param value
        </member>
        <member name="P:iTextSharp.text.Chunk.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Chunk.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Chunk.Font">
            <summary>
            Get/set the font of this Chunk.
            </summary>
            <value>a Font</value>
        </member>
        <member name="P:iTextSharp.text.Chunk.Content">
            <summary>
            Returns the content of this Chunk.
            </summary>
            <value>a string</value>
        </member>
        <member name="P:iTextSharp.text.Chunk.Attributes">
            <summary>
            Sets/Gets the attributes for this Chunk.
            </summary>
            <remarks>
            It may be null.
            </remarks>
            <value>a Hashtable</value>
        </member>
        <member name="P:iTextSharp.text.Chunk.HorizontalScaling">
            Gets the horizontal scaling.
            @return a percentage in float
        </member>
        <member name="T:iTextSharp.text.Document">
            <summary>
            A generic Document class.
            </summary>
            <remarks>
            All kinds of Text-elements can be added to a HTMLDocument.
            The Document signals all the listeners when an element
            has been added.<p/>
            <OL>
                <LI/>Once a document is created you can add some meta information.
                <LI/>You can also set the headers/footers.
                <LI/>You have to open the document before you can write content.
                <LI/>You can only write content (no more meta-formation!) once a document is opened.
                <LI/>When you change the header/footer on a certain page, this will be effective starting on the next page.
                <LI/>Ater closing the document, every listener (as well as its OutputStream) is closed too.
            </OL>
            </remarks>
            <example>
            <code>
            // creation of the document with a certain size and certain margins
            <strong>Document document = new Document(PageSize.A4, 50, 50, 50, 50);</strong>
            try {
                // creation of the different writers
                HtmlWriter.GetInstance(<strong>document</strong>, System.out);
                PdfWriter.GetInstance(<strong>document</strong>, new FileOutputStream("text.pdf"));
                // we add some meta information to the document
                <strong>document.AddAuthor("Bruno Lowagie");
                document.AddSubject("This is the result of a Test.");</strong>
                
                // we define a header and a footer
                HeaderFooter header = new HeaderFooter(new Phrase("This is a header."), false);
                HeaderFooter footer = new HeaderFooter(new Phrase("This is page "), new Phrase("."));
                footer.SetAlignment(Element.ALIGN_CENTER);
                <strong>document.SetHeader(header);
                document.SetFooter(footer);</strong>
                // we open the document for writing
                <strong>document.Open();
                document.Add(new Paragraph("Hello world"));</strong>
            }
            catch (DocumentException de) {
                Console.Error.WriteLine(de.Message);
            }
            <strong>document.Close();</strong>
            </code>
            </example>
        </member>
        <member name="T:iTextSharp.text.IDocListener">
            <summary>
            A class that implements DocListener will perform some
            actions when some actions are performed on a Document.
            </summary>
            <seealso cref="T:iTextSharp.text.IElementListener"/>
            <seealso cref="T:iTextSharp.text.Document"/>
            <seealso cref="T:iTextSharp.text.DocWriter"/>
        </member>
        <member name="T:iTextSharp.text.IElementListener">
            <summary>
            A class that implements ElementListener will perform some
            actions when an Element is added.
            </summary>
        </member>
        <member name="M:iTextSharp.text.IElementListener.Add(iTextSharp.text.IElement)">
            <summary>
            Signals that an Element was added to the Document.
            </summary>
            <param name="element">Element added</param>
            <returns>true if the element was added, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.IDocListener.Open">
            <summary>
            Signals that the Document has been opened and that
            Elements can be added.
            </summary>
        </member>
        <member name="M:iTextSharp.text.IDocListener.Close">
            <summary>
            Signals that the Document was closed and that no other
            Elements will be added.
            </summary>
            <remarks>
            The output stream of every writer implementing IDocListener will be closed.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.IDocListener.NewPage">
            <summary>
            Signals that an new page has to be started.
            </summary>
            <returns>true if the page was added, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.IDocListener.SetPageSize(iTextSharp.text.Rectangle)">
            <summary>
            Sets the pagesize.
            </summary>
            <param name="pageSize">the new pagesize</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.IDocListener.SetMargins(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the margins.
            </summary>
            <param name="marginLeft">the margin on the left</param>
            <param name="marginRight">the margin on the right</param>
            <param name="marginTop">the margin on the top</param>
            <param name="marginBottom">the margin on the bottom</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.IDocListener.SetMarginMirroring(System.Boolean)">
            Parameter that allows you to do margin mirroring (odd/even pages)
            @param marginMirroring
            @return true if succesfull
        </member>
        <member name="M:iTextSharp.text.IDocListener.SetMarginMirroringTopBottom(System.Boolean)">
            Parameter that allows you to do top/bottom margin mirroring (odd/even pages)
            @param marginMirroringTopBottom
            @return true if successful
            @since	2.1.6
        </member>
        <member name="M:iTextSharp.text.IDocListener.ResetPageCount">
            <summary>
            Sets the page number to 0.
            </summary>
        </member>
        <member name="P:iTextSharp.text.IDocListener.PageCount">
            <summary>
            Sets the page number.
            </summary>
            <value>the new page number</value>
        </member>
        <member name="F:iTextSharp.text.Document.Compress">
            <summary> Allows the pdf documents to be produced without compression for debugging purposes. </summary>
        </member>
        <member name="F:iTextSharp.text.Document.WmfFontCorrection">
            <summary> Scales the WMF font size. The default value is 0.86.  </summary>
        </member>
        <member name="F:iTextSharp.text.Document.listeners">
            <summary> The IDocListener. </summary>
        </member>
        <member name="F:iTextSharp.text.Document.open">
            <summary> Is the document open or not? </summary>
        </member>
        <member name="F:iTextSharp.text.Document.close">
            <summary> Has the document already been closed? </summary>
        </member>
        <member name="F:iTextSharp.text.Document.pageSize">
            <summary> The size of the page. </summary>
        </member>
        <member name="F:iTextSharp.text.Document.marginLeft">
            <summary> margin in x direction starting from the left </summary>
        </member>
        <member name="F:iTextSharp.text.Document.marginRight">
            <summary> margin in x direction starting from the right </summary>
        </member>
        <member name="F:iTextSharp.text.Document.marginTop">
            <summary> margin in y direction starting from the top </summary>
        </member>
        <member name="F:iTextSharp.text.Document.marginBottom">
            <summary> margin in y direction starting from the bottom </summary>
        </member>
        <member name="F:iTextSharp.text.Document.marginMirroringTopBottom">
            mirroring of the top/bottom margins
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.Document.javaScript_onLoad">
            <summary> Content of JavaScript onLoad function </summary>
        </member>
        <member name="F:iTextSharp.text.Document.javaScript_onUnLoad">
            <summary> Content of JavaScript onUnLoad function  </summary>
        </member>
        <member name="F:iTextSharp.text.Document.htmlStyleClass">
            <summary> Style class in HTML body tag </summary>
        </member>
        <member name="F:iTextSharp.text.Document.pageN">
            <summary> Current pagenumber </summary>
        </member>
        <member name="F:iTextSharp.text.Document.chapternumber">
            This is a chapter number in case ChapterAutoNumber is used. 
        </member>
        <member name="M:iTextSharp.text.Document.#ctor">
            <summary>
            Constructs a new Document-object.
            </summary>
            <overloads>
            Has three overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Document.#ctor(iTextSharp.text.Rectangle)">
            <summary>
            Constructs a new Document-object.
            </summary>
            <param name="pageSize">the pageSize</param>
        </member>
        <member name="M:iTextSharp.text.Document.#ctor(iTextSharp.text.Rectangle,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a new Document-object.
            </summary>
            <param name="pageSize">the pageSize</param>
            <param name="marginLeft">the margin on the left</param>
            <param name="marginRight">the margin on the right</param>
            <param name="marginTop">the margin on the top</param>
            <param name="marginBottom">the margin on the bottom</param>
        </member>
        <member name="M:iTextSharp.text.Document.AddDocListener(iTextSharp.text.IDocListener)">
            <summary>
            Adds a IDocListener to the Document.
            </summary>
            <param name="listener">the new IDocListener</param>
        </member>
        <member name="M:iTextSharp.text.Document.RemoveIDocListener(iTextSharp.text.IDocListener)">
            <summary>
            Removes a IDocListener from the Document.
            </summary>
            <param name="listener">the IDocListener that has to be removed.</param>
        </member>
        <member name="M:iTextSharp.text.Document.Add(iTextSharp.text.IElement)">
            <summary>
            Adds an Element to the Document.
            </summary>
            <param name="element">the Element to add</param>
            <returns>true if the element was added, false if not</returns>
        </member>
        <member name="M:iTextSharp.text.Document.Open">
            <summary>
            Opens the document.
            </summary>
            <remarks>
            Once the document is opened, you can't write any Header- or Meta-information
            anymore. You have to open the document before you can begin to add content
            to the body of the document.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.Document.OpenDocument">
            <summary>
            Opens the document.
            </summary>
            <remarks>
            Version for languages that are not case-dependant.
            Once the document is opened, you can't write any Header- or Meta-information
            anymore. You have to open the document before you can begin to add content
            to the body of the document.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.Document.SetPageSize(iTextSharp.text.Rectangle)">
            <summary>
            Sets the pagesize.
            </summary>
            <param name="pageSize">the new pagesize</param>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Document.SetMargins(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the margins.
            </summary>
            <param name="marginLeft">the margin on the left</param>
            <param name="marginRight">the margin on the right</param>
            <param name="marginTop">the margin on the top</param>
            <param name="marginBottom">the margin on the bottom</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Document.NewPage">
            <summary>
            Signals that an new page has to be started.
            </summary>
            <returns>true if the page was added, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.Document.ResetPageCount">
            <summary>
            Sets the page number to 0.
            </summary>
        </member>
        <member name="M:iTextSharp.text.Document.Close">
            <summary>
            Closes the document.
            </summary>
            <remarks>
            Once all the content has been written in the body, you have to close
            the body. After that nothing can be written to the body anymore.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.Document.CloseDocument">
            <summary>
            Closes the document.
            </summary>
            <remarks>
            Version for languages that are not case-dependant.
            Once all the content has been written in the body, you have to close
            the body. After that nothing can be written to the body anymore.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.Document.AddHeader(System.String,System.String)">
            <summary>
            Adds a user defined header to the document.
            </summary>
            <param name="name">the name of the header</param>
            <param name="content">the content of the header</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddTitle(System.String)">
            <summary>
            Adds the title to a Document.
            </summary>
            <param name="title">the title</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddSubject(System.String)">
            <summary>
            Adds the subject to a Document.
            </summary>
            <param name="subject">the subject</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddKeywords(System.String)">
            <summary>
            Adds the keywords to a Document.
            </summary>
            <param name="keywords">keywords to add</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddAuthor(System.String)">
            <summary>
            Adds the author to a Document.
            </summary>
            <param name="author">the name of the author</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddCreator(System.String)">
            <summary>
            Adds the creator to a Document.
            </summary>
            <param name="creator">the name of the creator</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddProducer">
            <summary>
            Adds the producer to a Document.
            </summary>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.AddLanguage(System.String)">
            Adds a language to th document. Required for PDF/UA compatible documents.
            @param language
            @return <code>true</code> if successfull, <code>false</code> otherwise
        </member>
        <member name="M:iTextSharp.text.Document.AddCreationDate">
            <summary>
            Adds the current date and time to a Document.
            </summary>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:iTextSharp.text.Document.GetLeft(System.Single)">
            <summary>
            Returns the lower left x-coordinate considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the lower left x-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Document.GetRight(System.Single)">
            <summary>
            Returns the upper right x-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the upper right x-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Document.GetTop(System.Single)">
            <summary>
            Returns the upper right y-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the upper right y-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Document.GetBottom(System.Single)">
            <summary>
            Returns the lower left y-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the lower left y-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Document.IsOpen">
            <summary>
            Checks if the document is open.
            </summary>
            <returns>true if the document is open</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.Document.SetMarginMirroring(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.Document.SetMarginMirroringTopBottom(System.Boolean)" -->
        <member name="M:iTextSharp.text.Document.IsMarginMirroring">
            Gets the margin mirroring flag.
            
            @return the margin mirroring flag
        </member>
        <member name="P:iTextSharp.text.Document.PageCount">
            <summary>
            Sets the page number.
            </summary>
            <value>an int</value>
        </member>
        <member name="P:iTextSharp.text.Document.PageNumber">
            <summary>
            Returns the current page number.
            </summary>
            <value>an int</value>
        </member>
        <member name="P:iTextSharp.text.Document.LeftMargin">
            <summary>
            Returns the left margin.
            </summary>
            <value>the left margin</value>
        </member>
        <member name="P:iTextSharp.text.Document.RightMargin">
            <summary>
            Return the right margin.
            </summary>
            <value>the right margin</value>
        </member>
        <member name="P:iTextSharp.text.Document.TopMargin">
            <summary>
            Returns the top margin.
            </summary>
            <value>the top margin</value>
        </member>
        <member name="P:iTextSharp.text.Document.BottomMargin">
            <summary>
            Returns the bottom margin.
            </summary>
            <value>the bottom margin</value>
        </member>
        <member name="P:iTextSharp.text.Document.Left">
            <summary>
            Returns the lower left x-coordinate.
            </summary>
            <value>the lower left x-coordinate</value>
        </member>
        <member name="P:iTextSharp.text.Document.Right">
            <summary>
            Returns the upper right x-coordinate.
            </summary>
            <value>the upper right x-coordinate.</value>
        </member>
        <member name="P:iTextSharp.text.Document.Top">
            <summary>
            Returns the upper right y-coordinate.
            </summary>
            <value>the upper right y-coordinate.</value>
        </member>
        <member name="P:iTextSharp.text.Document.Bottom">
            <summary>
            Returns the lower left y-coordinate.
            </summary>
            <value>the lower left y-coordinate.</value>
        </member>
        <member name="P:iTextSharp.text.Document.PageSize">
            <summary>
            Gets the pagesize.
            </summary>
            <value>the page size</value>
        </member>
        <member name="P:iTextSharp.text.Document.JavaScript_onLoad">
            <summary>
            Gets the JavaScript onLoad command.
            </summary>
            <value>the JavaScript onLoad command.</value>
        </member>
        <member name="P:iTextSharp.text.Document.JavaScript_onUnLoad">
            <summary>
            Gets the JavaScript onUnLoad command.
            </summary>
            <value>the JavaScript onUnLoad command</value>
        </member>
        <member name="P:iTextSharp.text.Document.HtmlStyleClass">
            <summary>
            Gets the style class of the HTML body tag
            </summary>
            <value>the style class of the HTML body tag</value>
        </member>
        <member name="T:iTextSharp.text.DocWriter">
            <summary>
            An abstract Writer class for documents.
            </summary>
            <remarks>
            DocWriter is the abstract class of several writers such
            as PdfWriter and HtmlWriter.
            A DocWriter can be added as a DocListener
            to a certain Document by getting an instance (see method
            GetInstance() in the specific writer-classes).
            Every Element added to the original Document
            will be written to the stream of the listening
            DocWriter.
            </remarks>
            <seealso cref="T:iTextSharp.text.Document"/>
            <seealso cref="T:iTextSharp.text.IDocListener"/>
        </member>
        <member name="F:iTextSharp.text.DocWriter.NEWLINE">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.TAB">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.LT">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.SPACE">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.EQUALS">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.QUOTE">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.GT">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.FORWARD">
            <summary> This is some byte that is often used. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.pageSize">
            <summary> The pageSize. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.document">
            <summary> This is the document that has to be written. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.os">
            <summary> The stream of this writer. </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.open">
            <summary> Is the writer open for writing? </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.pause">
            <summary> Do we have to pause all writing actions? </summary>
        </member>
        <member name="F:iTextSharp.text.DocWriter.closeStream">
            Closes the stream on document close 
        </member>
        <member name="M:iTextSharp.text.DocWriter.#ctor(iTextSharp.text.Document,System.IO.Stream)">
            <summary>
            Constructs a DocWriter.
            </summary>
            <param name="document">The Document that has to be written</param>
            <param name="os">The Stream the writer has to write to.</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Add(iTextSharp.text.IElement)">
            <summary>
            Signals that an Element was added to the Document.
            </summary>
            <remarks>
            This method should be overriden in the specific DocWriter classes
            derived from this abstract class.
            </remarks>
            <param name="element"></param>
            <returns>false</returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Open">
            <summary>
            Signals that the Document was opened.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.SetPageSize(iTextSharp.text.Rectangle)">
            <summary>
            Sets the pagesize.
            </summary>
            <param name="pageSize">the new pagesize</param>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.SetMargins(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the margins.
            </summary>
            <remarks>
            This does nothing. Has to be overridden if needed.
            </remarks>
            <param name="marginLeft">the margin on the left</param>
            <param name="marginRight">the margin on the right</param>
            <param name="marginTop">the margin on the top</param>
            <param name="marginBottom">the margin on the bottom</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.NewPage">
            <summary>
            Signals that an new page has to be started.
            </summary>
            <remarks>
            This does nothing. Has to be overridden if needed.
            </remarks>
            <returns>true if the page was added, false if not.</returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.ResetPageCount">
            <summary>
            Sets the page number to 0.
            </summary>
            <remarks>
            This method should be overriden in the specific DocWriter classes
            derived from this abstract class if they actually support the use of
            pagenumbers.
            </remarks>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Close">
            <summary>
            Signals that the Document was closed and that no other
            Elements will be added.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.GetISOBytes(System.String)">
            <summary>
            Converts a string into a Byte array
            according to the ISO-8859-1 codepage.
            </summary>
            <param name="text">the text to be converted</param>
            <returns>the conversion result</returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Pause">
            <summary>
            Let the writer know that all writing has to be paused.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.IsPaused">
             Checks if writing is paused.
            
             @return       <CODE>true</CODE> if writing temporarely has to be paused, <CODE>false</CODE> otherwise.
        </member>
        <member name="M:iTextSharp.text.DocWriter.Resume">
            <summary>
            Let the writer know that writing may be resumed.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Flush">
            <summary>
            Flushes the Stream.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Write(System.String)">
            <summary>
            Writes a string to the stream.
            </summary>
            <param name="str">the string to write</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.AddTabs(System.Int32)">
            <summary>
            Writes a number of tabs.
            </summary>
            <param name="indent">the number of tabs to add</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.Write(System.String,System.String)">
            <summary>
            Writes a key-value pair to the stream.
            </summary>
            <param name="key">the name of an attribute</param>
            <param name="value">the value of an attribute</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.WriteStart(System.String)">
            <summary>
            Writes a starttag to the stream.
            </summary>
            <param name="tag">the name of the tag</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.WriteEnd(System.String)">
            <summary>
            Writes an endtag to the stream.
            </summary>
            <param name="tag">the name of the tag</param>
        </member>
        <member name="M:iTextSharp.text.DocWriter.WriteEnd">
            <summary>
            Writes an endtag to the stream.
            </summary>
        </member>
        <member name="M:iTextSharp.text.DocWriter.WriteMarkupAttributes(System.util.Properties)">
            <summary>
            Writes the markup attributes of the specified MarkupAttributes
            object to the stream.
            </summary>
            <param name="mAtt">the MarkupAttributes to write.</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.DocWriter.SetMarginMirroringTopBottom(System.Boolean)">
            @see com.lowagie.text.DocListener#setMarginMirroring(boolean)
            @since	2.1.6
        </member>
        <member name="P:iTextSharp.text.DocWriter.PageCount">
            <summary>
            Sets the page number.
            </summary>
            <remarks>
            This method should be overriden in the specific DocWriter classes
            derived from this abstract class if they actually support the use of
            pagenumbers.
            </remarks>
        </member>
        <member name="T:iTextSharp.text.Element">
            <summary>
            Interface for a text element.
            </summary>
            <seealso cref="T:iTextSharp.text.Anchor"/>
            <seealso cref="T:iTextSharp.text.Cell"/>
            <seealso cref="T:iTextSharp.text.Chapter"/>
            <seealso cref="T:iTextSharp.text.Chunk"/>
            <seealso cref="T:iTextSharp.text.Gif"/>
            <seealso cref="T:iTextSharp.text.Graphic"/>
            <seealso cref="T:iTextSharp.text.Header"/>
            <seealso cref="T:iTextSharp.text.Image"/>
            <seealso cref="T:iTextSharp.text.Jpeg"/>
            <seealso cref="T:iTextSharp.text.List"/>
            <seealso cref="T:iTextSharp.text.ListItem"/>
            <seealso cref="T:iTextSharp.text.Meta"/>
            <seealso cref="T:iTextSharp.text.Paragraph"/>
            <seealso cref="T:iTextSharp.text.Phrase"/>
            <seealso cref="T:iTextSharp.text.Rectangle"/>
            <seealso cref="T:iTextSharp.text.Row"/>
            <seealso cref="T:iTextSharp.text.Section"/>
            <seealso cref="T:iTextSharp.text.Table"/>
        </member>
        <member name="F:iTextSharp.text.Element.HEADER">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.TITLE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.SUBJECT">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.KEYWORDS">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.AUTHOR">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.PRODUCER">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CREATIONDATE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CREATOR">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.LANGUAGE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CHUNK">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.PHRASE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.PARAGRAPH">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.SECTION">
            <summary> This is a possible type of Element </summary>
        </member>
        <member name="F:iTextSharp.text.Element.LIST">
            <summary> This is a possible type of Element </summary>
        </member>
        <member name="F:iTextSharp.text.Element.LISTITEM">
            <summary> This is a possible type of Element </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CHAPTER">
            <summary> This is a possible type of Element </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ANCHOR">
            <summary> This is a possible type of Element </summary>
        </member>
        <member name="F:iTextSharp.text.Element.PTABLE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ANNOTATION">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.RECTANGLE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.JPEG">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.JPEG2000">
            This is a possible type of <CODE>Element</CODE>. 
        </member>
        <member name="F:iTextSharp.text.Element.IMGRAW">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.IMGTEMPLATE">
            <summary> This is a possible type of Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Element.JBIG2">
            This is a possible type of <CODE>Element</CODE>.
            @since	2.1.5
        </member>
        <member name="F:iTextSharp.text.Element.DIV">
            This is a possible type of <CODE>Element</CODE>.
            @since	5.3.0
        </member>
        <member name="F:iTextSharp.text.Element.MARKED">
            This is a possible type of <CODE>Element</CODE>. 
        </member>
        <member name="F:iTextSharp.text.Element.YMARK">
            This is a possible type of <CODE>Element</CODE>.
            @since 2.1.2
        </member>
        <member name="F:iTextSharp.text.Element.WRITABLE_DIRECT">
            This is an element thats not an element.
            @see WritableDirectElement
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_UNDEFINED">
            <summary>
            A possible value for paragraph Element.  This
            specifies that the text is aligned to the left
            indent and extra whitespace should be placed on
            the right.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_LEFT">
            <summary>
            A possible value for paragraph Element.  This
            specifies that the text is aligned to the left
            indent and extra whitespace should be placed on
            the right.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_CENTER">
            <summary>
            A possible value for paragraph Element.  This
            specifies that the text is aligned to the center
            and extra whitespace should be placed equally on
            the left and right.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_RIGHT">
            <summary>
            A possible value for paragraph Element.  This
            specifies that the text is aligned to the right
            indent and extra whitespace should be placed on
            the left.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_JUSTIFIED">
            <summary>
            A possible value for paragraph Element.  This
            specifies that extra whitespace should be spread
            out through the rows of the paragraph with the
            text lined up with the left and right indent
            except on the last line which should be aligned
            to the left.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_TOP">
            <summary>
            A possible value for vertical Element.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_MIDDLE">
            <summary>
            A possible value for vertical Element.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_BOTTOM">
            <summary>
            A possible value for vertical Element.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_BASELINE">
            <summary>
            A possible value for vertical Element.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.ALIGN_JUSTIFIED_ALL">
            <summary>
            Does the same as ALIGN_JUSTIFIED but the last line is also spread out.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITTG4">
            <summary>
            Pure two-dimensional encoding (Group 4)
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITTG3_1D">
            <summary>
            Pure one-dimensional encoding (Group 3, 1-D)
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITTG3_2D">
            <summary>
            Mixed one- and two-dimensional encoding (Group 3, 2-D)
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITT_BLACKIS1">
            <summary>
            A flag indicating whether 1-bits are to be interpreted as black pixels
            and 0-bits as white pixels,
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITT_ENCODEDBYTEALIGN">
            <summary>
            A flag indicating whether the filter expects extra 0-bits before each
            encoded line so that the line begins on a byte boundary.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITT_ENDOFLINE">
            <summary>
            A flag indicating whether end-of-line bit patterns are required to be
             present in the encoding.
            </summary>
        </member>
        <member name="F:iTextSharp.text.Element.CCITT_ENDOFBLOCK">
            <summary>
            A flag indicating whether the filter expects the encoded data to be
            terminated by an end-of-block pattern, overriding the Rows
            parameter. The use of this flag will set the key /EndOfBlock to false.
            </summary>
        </member>
        <member name="T:iTextSharp.text.error_messages.MessageLocalization">
            Localizes error messages. The messages are located in the package
            com.lowagie.text.error_messages in the form language_country.lng.
            The internal file encoding is UTF-8 without any escape chars, it's not a
            normal property file. See en.lng for more information on the internal format.
            @author Paulo Soares (psoares@glintt.com)
        </member>
        <member name="M:iTextSharp.text.error_messages.MessageLocalization.GetMessage(System.String)">
            Get a message without parameters.
            @param key the key to the message
            @return the message
        </member>
        <member name="M:iTextSharp.text.error_messages.MessageLocalization.GetComposedMessage(System.String,System.Object[])">
            Get a message with parameters. The parameters will replace the strings
            "{1}", "{2}", ..., "{n}" found in the message.
            @param key the key to the message
            @param p the variable parameter
            @return the message
        </member>
        <member name="M:iTextSharp.text.error_messages.MessageLocalization.SetLanguage(System.String,System.String)">
            Sets the language to be used globally for the error messages. The language
            is a two letter lowercase country designation like "en" or "pt". The country
            is an optional two letter uppercase code like "US" or "PT".
            @param language the language
            @param country the country
            @return true if the language was found, false otherwise
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.error_messages.MessageLocalization.SetMessages(System.IO.TextReader)">
            Sets the error messages directly from a Reader.
            @param r the Reader
            @throws IOException on error
        </member>
        <member name="T:iTextSharp.text.exceptions.BadPasswordException">
            Typed exception used when opening an existing PDF document.
            Gets thrown when the document isn't a valid PDF document.
            @since 2.1.5 It was written for iText 2.0.8, but moved to another package
        </member>
        <member name="M:iTextSharp.text.exceptions.BadPasswordException.#ctor(System.String)">
            Creates an exception saying the user password was incorrect.
        </member>
        <member name="T:iTextSharp.text.exceptions.IllegalPdfSyntaxException">
            Typed exception used when creating PDF syntax that isn't valid.
            @since 2.1.6
        </member>
        <member name="M:iTextSharp.text.exceptions.IllegalPdfSyntaxException.#ctor(System.String)">
            Creates an exception saying the PDF syntax isn't correct.
            @param	message	some extra info about the exception
        </member>
        <member name="T:iTextSharp.text.exceptions.InvalidPdfException">
            Typed exception used when opening an existing PDF document.
            Gets thrown when the document isn't a valid PDF document.
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.exceptions.InvalidPdfException.#ctor(System.String)">
            Creates an instance of  with a message and no cause
            @param	message	the reason why the document isn't a PDF document according to iText.
        </member>
        <member name="M:iTextSharp.text.exceptions.InvalidPdfException.#ctor(System.String,System.Exception)">
            Creates an exception with a message and a cause
            @param message	the reason why the document isn't a PDF document according to iText. 
            @param cause the cause of the exception, if any
        </member>
        <member name="T:iTextSharp.text.exceptions.UnsupportedPdfException">
            Typed exception used when opening an existing PDF document.
            Gets thrown when the document isn't a valid PDF document according to iText,
            but it's different from the InvalidPdfException in the sense that it may
            be an iText limitation (most of the times it isn't but you might have
            bumped into something that has been added to the PDF specs, but that isn't
            supported in iText yet).
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.exceptions.UnsupportedPdfException.#ctor(System.String)">
            Creates an instance of an UnsupportedPdfException.
            @param	message	the reason why the document isn't a PDF document according to iText.
        </member>
        <member name="T:iTextSharp.text.factories.GreekAlphabetFactory">
            This class can produce String combinations representing a number built with
            Greek letters (from alpha to omega, then alpha alpha, alpha beta, alpha gamma).
            We are aware of the fact that the original Greek numbering is different;
            See http://www.cogsci.indiana.edu/farg/harry/lan/grknum.htm#ancient
            but this isn't implemented yet; the main reason being the fact that we
            need a font that has the obsolete Greek characters qoppa and sampi.
        </member>
        <member name="M:iTextSharp.text.factories.GreekAlphabetFactory.GetString(System.Int32)">
            Changes an int into a lower case Greek letter combination.
            @param index the original number
            @return the letter combination
        </member>
        <member name="M:iTextSharp.text.factories.GreekAlphabetFactory.GetLowerCaseString(System.Int32)">
            Changes an int into a lower case Greek letter combination.
            @param index the original number
            @return the letter combination
        </member>
        <member name="M:iTextSharp.text.factories.GreekAlphabetFactory.GetUpperCaseString(System.Int32)">
            Changes an int into a upper case Greek letter combination.
            @param index the original number
            @return the letter combination
        </member>
        <member name="M:iTextSharp.text.factories.GreekAlphabetFactory.GetString(System.Int32,System.Boolean)">
            Changes an int into a Greek letter combination.
            @param index the original number
            @return the letter combination
        </member>
        <member name="T:iTextSharp.text.factories.RomanAlphabetFactory">
            This class can produce String combinations representing a number.
            "a" to "z" represent 1 to 26, "AA" represents 27, "AB" represents 28,
            and so on; "ZZ" is followed by "AAA".
        </member>
        <member name="M:iTextSharp.text.factories.RomanAlphabetFactory.GetString(System.Int32)">
            Translates a positive integer (not equal to zero)
            into a String using the letters 'a' to 'z';
            1 = a, 2 = b, ..., 26 = z, 27 = aa, 28 = ab,...
        </member>
        <member name="M:iTextSharp.text.factories.RomanAlphabetFactory.GetLowerCaseString(System.Int32)">
            Translates a positive integer (not equal to zero)
            into a String using the letters 'a' to 'z';
            1 = a, 2 = b, ..., 26 = z, 27 = aa, 28 = ab,...
        </member>
        <member name="M:iTextSharp.text.factories.RomanAlphabetFactory.GetUpperCaseString(System.Int32)">
            Translates a positive integer (not equal to zero)
            into a String using the letters 'A' to 'Z';
            1 = A, 2 = B, ..., 26 = Z, 27 = AA, 28 = AB,...
        </member>
        <member name="M:iTextSharp.text.factories.RomanAlphabetFactory.GetString(System.Int32,System.Boolean)">
            Translates a positive integer (not equal to zero)
            into a String using the letters 'a' to 'z'
            (a = 1, b = 2, ..., z = 26, aa = 27, ab = 28,...).
        </member>
        <member name="T:iTextSharp.text.factories.RomanNumberFactory">
            This class can produce String combinations representing a roman number.
        </member>
        <member name="F:iTextSharp.text.factories.RomanNumberFactory.roman">
            Array with Roman digits.
        </member>
        <member name="M:iTextSharp.text.factories.RomanNumberFactory.GetString(System.Int32)">
            Changes an int into a lower case roman number.
            @param index the original number
            @return the roman number (lower case)
        </member>
        <member name="M:iTextSharp.text.factories.RomanNumberFactory.GetLowerCaseString(System.Int32)">
            Changes an int into a lower case roman number.
            @param index the original number
            @return the roman number (lower case)
        </member>
        <member name="M:iTextSharp.text.factories.RomanNumberFactory.GetUpperCaseString(System.Int32)">
            Changes an int into an upper case roman number.
            @param index the original number
            @return the roman number (lower case)
        </member>
        <member name="M:iTextSharp.text.factories.RomanNumberFactory.GetString(System.Int32,System.Boolean)">
            Changes an int into a roman number.
            @param index the original number
            @return the roman number (lower case)
        </member>
        <member name="T:iTextSharp.text.factories.RomanNumberFactory.RomanDigit">
            Helper class for Roman Digits
        </member>
        <member name="F:iTextSharp.text.factories.RomanNumberFactory.RomanDigit.digit">
            part of a roman number 
        </member>
        <member name="F:iTextSharp.text.factories.RomanNumberFactory.RomanDigit.value">
            value of the roman digit 
        </member>
        <member name="F:iTextSharp.text.factories.RomanNumberFactory.RomanDigit.pre">
            can the digit be used as a prefix 
        </member>
        <member name="M:iTextSharp.text.factories.RomanNumberFactory.RomanDigit.#ctor(System.Char,System.Int32,System.Boolean)">
            Constructs a roman digit
            @param digit the roman digit
            @param value the value
            @param pre can it be used as a prefix
        </member>
        <member name="T:iTextSharp.text.Font">
            <summary>
            Contains all the specifications of a font: fontfamily, size, style and color.
            </summary>
            <example>
            <code>
            Paragraph p = new Paragraph("This is a paragraph",
                          <strong>new Font(Font.HELVETICA, 18, Font.BOLDITALIC, new BaseColor(0, 0, 255))</strong>);
            </code>
            </example>
        </member>
        <member name="F:iTextSharp.text.Font.NORMAL">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.BOLD">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.ITALIC">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.UNDERLINE">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.STRIKETHRU">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.BOLDITALIC">
            <summary> this is a possible style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.UNDEFINED">
            <summary> the value of an undefined attribute. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.DEFAULTSIZE">
            <summary> the value of the default size. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.family">
            <summary> the value of the fontfamily. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.size">
            <summary> the value of the fontsize. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.style">
            <summary> the value of the style. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.color">
            <summary> the value of the color. </summary>
        </member>
        <member name="F:iTextSharp.text.Font.baseFont">
            <summary> the external font </summary>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.Font)">
            Copy constructor of a Font
            @param other the font that has to be copied
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.Font.FontFamily,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="family">the family to which this font belongs</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font.</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.pdf.BaseFont,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="bf">the external font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font.</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.pdf.BaseFont,System.Single,System.Int32)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="bf">the external font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.pdf.BaseFont,System.Single)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="bf">the external font</param>
            <param name="size">the size of this font</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.pdf.BaseFont)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="bf">the external font</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.Font.FontFamily,System.Single,System.Int32)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="family">the family to which this font belongs</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.Font.FontFamily,System.Single)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="family">the family to which this font belongs</param>
            <param name="size">the size of this font</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor(iTextSharp.text.Font.FontFamily)">
            <summary>
            Constructs a Font.
            </summary>
            <param name="family">the family to which this font belongs</param>
        </member>
        <member name="M:iTextSharp.text.Font.#ctor">
            <summary>
            Constructs a Font.
            </summary>
            <overloads>
            Has nine overloads.
            </overloads>
        </member>
        <member name="M:iTextSharp.text.Font.CompareTo(iTextSharp.text.Font)">
            <summary>
            Compares this Font with another
            </summary>
            <param name="obj">the other Font</param>
            <returns>a value</returns>
        </member>
        <member name="M:iTextSharp.text.Font.SetFamily(System.String)">
            <summary>
            Sets the family using a String ("Courier",
            "Helvetica", "Times New Roman", "Symbol" or "ZapfDingbats").
            </summary>
            <param name="family">A String representing a certain font-family.</param>
        </member>
        <member name="M:iTextSharp.text.Font.GetFamilyIndex(System.String)">
            <summary>
            Translates a string-value of a certain family
            into the index that is used for this family in this class.
            </summary>
            <param name="family">A string representing a certain font-family</param>
            <returns>the corresponding index</returns>
        </member>
        <member name="M:iTextSharp.text.Font.GetCalculatedLeading(System.Single)">
            Gets the leading that can be used with this font.
            
            @param multipliedLeading
                       a certain multipliedLeading
            @return the height of a line
        </member>
        <member name="M:iTextSharp.text.Font.IsBold">
            <summary>
            checks if this font is Bold.
            </summary>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.Font.IsItalic">
            <summary>
            checks if this font is Bold.
            </summary>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.Font.IsUnderlined">
            <summary>
            checks if this font is underlined.
            </summary>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.Font.IsStrikethru">
            <summary>
            checks if the style of this font is STRIKETHRU.
            </summary>
            <returns>a boolean</returns>
        </member>
        <member name="M:iTextSharp.text.Font.SetStyle(System.String)">
            <summary>
            Sets the style using a String containing one of
            more of the following values: normal, bold, italic, underline, strike.
            </summary>
            <param name="style">A String representing a certain style.</param>
        </member>
        <member name="M:iTextSharp.text.Font.SetStyle(System.Int32)">
            Sets the style.
            @param    style    the style.
        </member>
        <member name="M:iTextSharp.text.Font.GetStyleValue(System.String)">
            <summary>
            Translates a string-value of a certain style
            into the index value is used for this style in this class.
            </summary>
            <param name="style">a string</param>
            <returns>the corresponding value</returns>
        </member>
        <member name="M:iTextSharp.text.Font.SetColor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the color.
            </summary>
            <param name="red">the red-value of the new color</param>
            <param name="green">the green-value of the new color</param>
            <param name="blue">the blue-value of the new color</param>
        </member>
        <member name="M:iTextSharp.text.Font.GetCalculatedBaseFont(System.Boolean)">
            Gets the <CODE>BaseFont</CODE> this class represents.
            For the built-in fonts a <CODE>BaseFont</CODE> is calculated.
            @param specialEncoding <CODE>true</CODE> to use the special encoding for Symbol and ZapfDingbats,
            <CODE>false</CODE> to always use <CODE>Cp1252</CODE>
            @return the <CODE>BaseFont</CODE> this class represents
        </member>
        <member name="M:iTextSharp.text.Font.IsStandardFont">
            <summary>
            Checks if the properties of this font are undefined or null.
            <p/>
            If so, the standard should be used.
            </summary>
            <returns>a boolean</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.Font.Difference(iTextSharp.text.Font)" -->
        <member name="P:iTextSharp.text.Font.Family">
            <summary>
            Gets the family of this font.
            </summary>
            <value>the value of the family</value>
        </member>
        <member name="P:iTextSharp.text.Font.Familyname">
            <summary>
            Gets the familyname as a string.
            </summary>
            <value>the familyname</value>
        </member>
        <member name="P:iTextSharp.text.Font.Size">
            <summary>
            Get/set the size of this font.
            </summary>
            <value>the size of this font</value>
        </member>
        <member name="P:iTextSharp.text.Font.CalculatedSize">
            Gets the size that can be used with the calculated <CODE>BaseFont</CODE>.
            @return the size that can be used with the calculated <CODE>BaseFont</CODE>
        </member>
        <member name="P:iTextSharp.text.Font.Style">
            <summary>
            Gets the style of this font.
            </summary>
            <value>the style of this font</value>
        </member>
        <member name="P:iTextSharp.text.Font.CalculatedStyle">
            Gets the style that can be used with the calculated <CODE>BaseFont</CODE>.
            @return the style that can be used with the calculated <CODE>BaseFont</CODE>
        </member>
        <member name="P:iTextSharp.text.Font.Color">
            <summary>
            Get/set the color of this font.
            </summary>
            <value>the color of this font</value>
        </member>
        <member name="P:iTextSharp.text.Font.BaseFont">
            <summary>
            Gets the BaseFont inside this object.
            </summary>
            <value>the BaseFont</value>
        </member>
        <member name="T:iTextSharp.text.FontFactory">
            <summary>
            If you are using True Type fonts, you can declare the paths of the different ttf- and ttc-files
            to this static class first and then create fonts in your code using one of the static getFont-method
            without having to enter a path as parameter.
            </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.COURIER">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.COURIER_BOLD">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.COURIER_OBLIQUE">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.COURIER_BOLDOBLIQUE">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.HELVETICA">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.HELVETICA_BOLD">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.HELVETICA_OBLIQUE">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.HELVETICA_BOLDOBLIQUE">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.SYMBOL">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.TIMES">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.TIMES_ROMAN">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.TIMES_BOLD">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.TIMES_ITALIC">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.TIMES_BOLDITALIC">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.ZAPFDINGBATS">
            <summary> This is a possible value of a base 14 type 1 font </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.defaultEncoding">
            <summary> This is the default encoding to use. </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactory.defaultEmbedding">
            <summary> This is the default value of the <VAR>embedded</VAR> variable. </summary>
        </member>
        <member name="M:iTextSharp.text.FontFactory.#ctor">
            <summary> Creates new FontFactory </summary>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32,iTextSharp.text.BaseColor,System.Boolean)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <param name="cached">true if the font comes from the cache or is added to the cache if new, false if the font is always created new</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Boolean,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Boolean)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.String)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.Single,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.GetFont(System.String)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.RegisterFamily(System.String,System.String,System.String)">
            Register a font by giving explicitly the font family and name.
            @param familyName the font family
            @param fullName the font name
            @param path the font path
        </member>
        <member name="M:iTextSharp.text.FontFactory.Register(System.String)">
            <summary>
            Register a ttf- or a ttc-file.
            </summary>
            <param name="path">the path to a ttf- or ttc-file</param>
        </member>
        <member name="M:iTextSharp.text.FontFactory.Register(System.String,System.String)">
            <summary>
            Register a ttf- or a ttc-file and use an alias for the font contained in the ttf-file.
            </summary>
            <param name="path">the path to a ttf- or ttc-file</param>
            <param name="alias">the alias you want to use for the font</param>
        </member>
        <member name="M:iTextSharp.text.FontFactory.RegisterDirectory(System.String)">
            Register all the fonts in a directory.
            @param dir the directory
            @return the number of fonts registered
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.FontFactory.RegisterDirectory(System.String,System.Boolean)" -->
        <member name="M:iTextSharp.text.FontFactory.RegisterDirectories">
            Register fonts in some probable directories. It usually works in Windows,
            Linux and Solaris.
            @return the number of fonts registered
        </member>
        <member name="M:iTextSharp.text.FontFactory.Contains(System.String)">
            <summary>
            Checks whether the given font is contained within the object
            </summary>
            <param name="fontname">the name of the font</param>
            <returns>true if font is contained within the object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactory.IsRegistered(System.String)">
            <summary>
            Checks if a certain font is registered.
            </summary>
            <param name="fontname">the name of the font that has to be checked</param>
            <returns>true if the font is found</returns>
        </member>
        <member name="P:iTextSharp.text.FontFactory.RegisteredFonts">
            <summary>
            Gets a set of registered fontnames.
            </summary>
            <value>a set of registered fontnames</value>
        </member>
        <member name="P:iTextSharp.text.FontFactory.RegisteredFamilies">
            <summary>
            Gets a set of registered font families.
            </summary>
            <value>a set of registered font families</value>
        </member>
        <member name="T:iTextSharp.text.FontFactoryImp">
            <summary>
            If you are using True Type fonts, you can declare the paths of the different ttf- and ttc-files
            to this class first and then create fonts in your code using one of the getFont method
            without having to enter a path as parameter.
            </summary>
            
        </member>
        <member name="T:iTextSharp.text.IFontProvider">
            These two methods are used by FactoryProperties (for HTMLWorker).
            It's implemented by FontFactoryImp.
            @since   iText 5.0
        </member>
        <member name="M:iTextSharp.text.IFontProvider.IsRegistered(System.String)">
             Checks if a certain font is registered.
            
             @param   fontname    the name of the font that has to be checked.
             @return  true if the font is found
        </member>
        <member name="M:iTextSharp.text.IFontProvider.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32,iTextSharp.text.BaseColor)">
             Constructs a <CODE>Font</CODE>-object.
            
             @param   fontname    the name of the font
             @param   encoding    the encoding of the font
             @param       embedded    true if the font is to be embedded in the PDF
             @param   size        the size of this font
             @param   style       the style of this font
             @param   color       the <CODE>BaseColor</CODE> of this font.
             @return the Font constructed based on the parameters
        </member>
        <member name="F:iTextSharp.text.FontFactoryImp.trueTypeFonts">
            <summary> This is a map of postscriptfontnames of True Type fonts and the path of their ttf- or ttc-file. </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactoryImp.fontFamilies">
            <summary> This is a map of fontfamilies. </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactoryImp.defaultEncoding">
            <summary> This is the default encoding to use. </summary>
        </member>
        <member name="F:iTextSharp.text.FontFactoryImp.defaultEmbedding">
            <summary> This is the default value of the <VAR>embedded</VAR> variable. </summary>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.#ctor">
            <summary> Creates new FontFactory </summary>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32,iTextSharp.text.BaseColor,System.Boolean)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <param name="cached">true if the font comes from the cache or is added to the cache if new, false if the font is always created new</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Boolean,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Boolean,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <param name="size">the size of this font</param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Boolean)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="embedded">true if the font is to be embedded in the PDF</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <param name="size">the size of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.String)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="encoding">the encoding of the font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.Single,System.Int32,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.Single,iTextSharp.text.BaseColor)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="color">the BaseColor of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.Single,System.Int32)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <param name="style">the style of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String,System.Single)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <param name="size">the size of this font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.GetFont(System.String)">
            <summary>
            Constructs a Font-object.
            </summary>
            <param name="fontname">the name of the font</param>
            <returns>a Font object</returns>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.RegisterFamily(System.String,System.String,System.String)">
            Register a font by giving explicitly the font family and name.
            @param familyName the font family
            @param fullName the font name
            @param path the font path
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.Register(System.String)">
            <summary>
            Register a ttf- or a ttc-file.
            </summary>
            <param name="path">the path to a ttf- or ttc-file</param>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.Register(System.String,System.String)">
            <summary>
            Register a ttf- or a ttc-file and use an alias for the font contained in the ttf-file.
            </summary>
            <param name="path">the path to a ttf- or ttc-file</param>
            <param name="alias">the alias you want to use for the font</param>
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.RegisterDirectory(System.String)">
            Register all the fonts in a directory.
            @param dir the directory
            @return the number of fonts registered
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.FontFactoryImp.RegisterDirectory(System.String,System.Boolean)" -->
        <member name="M:iTextSharp.text.FontFactoryImp.RegisterDirectories">
            Register fonts in windows
            @return the number of fonts registered
        </member>
        <member name="M:iTextSharp.text.FontFactoryImp.IsRegistered(System.String)">
            <summary>
            Checks if a certain font is registered.
            </summary>
            <param name="fontname">the name of the font that has to be checked</param>
            <returns>true if the font is found</returns>
        </member>
        <member name="P:iTextSharp.text.FontFactoryImp.RegisteredFonts">
            <summary>
            Gets a set of registered fontnames.
            </summary>
            <value>a set of registered fontnames</value>
        </member>
        <member name="P:iTextSharp.text.FontFactoryImp.RegisteredFamilies">
            <summary>
            Gets a set of registered font families.
            </summary>
            <value>a set of registered font families</value>
        </member>
        <member name="T:iTextSharp.text.GreekList">
            
            A special-version of <CODE>LIST</CODE> whitch use greek-letters.
            
            @see com.lowagie.text.List
        </member>
        <member name="T:iTextSharp.text.List">
            <summary>
            A List contains several ListItems.
            </summary>
            <example>
            <B>Example 1:</B>
            <code>
            <strong>List list = new List(true, 20);
            list.Add(new ListItem("First line"));
            list.Add(new ListItem("The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?"));
            list.Add(new ListItem("Third line"));</strong>
            </code>
            
            The result of this code looks like this:
            <OL>
                <LI>
                    First line
                </LI>
                <LI>
                    The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?
                </LI>
                <LI>
                    Third line
                </LI>
            </OL>
            
            <B>Example 2:</B>
            <code>
            <strong>List overview = new List(false, 10);
            overview.Add(new ListItem("This is an item"));
            overview.Add("This is another item");</strong>
            </code>
            
            The result of this code looks like this:
            <UL>
                   <LI>
                       This is an item
                   </LI>
                   <LI>
                       This is another item
                   </LI>
               </UL>
            </example>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.ListItem"/>
        </member>
        <member name="F:iTextSharp.text.List.ORDERED">
            a possible value for the numbered parameter 
        </member>
        <member name="F:iTextSharp.text.List.UNORDERED">
            a possible value for the numbered parameter 
        </member>
        <member name="F:iTextSharp.text.List.NUMERICAL">
            a possible value for the lettered parameter 
        </member>
        <member name="F:iTextSharp.text.List.ALPHABETICAL">
            a possible value for the lettered parameter 
        </member>
        <member name="F:iTextSharp.text.List.UPPERCASE">
            a possible value for the lettered parameter 
        </member>
        <member name="F:iTextSharp.text.List.LOWERCASE">
            a possible value for the lettered parameter 
        </member>
        <member name="F:iTextSharp.text.List.list">
            <summary> This is the ArrayList containing the different ListItems. </summary>
        </member>
        <member name="F:iTextSharp.text.List.numbered">
            Indicates if the list has to be numbered. 
        </member>
        <member name="F:iTextSharp.text.List.lettered">
            Indicates if the listsymbols are numerical or alphabetical. 
        </member>
        <member name="F:iTextSharp.text.List.lowercase">
            Indicates if the listsymbols are lowercase or uppercase. 
        </member>
        <member name="F:iTextSharp.text.List.autoindent">
            Indicates if the indentation has to be set automatically. 
        </member>
        <member name="F:iTextSharp.text.List.alignindent">
            Indicates if the indentation of all the items has to be aligned. 
        </member>
        <member name="F:iTextSharp.text.List.first">
            <summary> This variable indicates the first number of a numbered list. </summary>
        </member>
        <member name="F:iTextSharp.text.List.symbol">
            <summary> This is the listsymbol of a list that is not numbered. </summary>
        </member>
        <member name="F:iTextSharp.text.List.preSymbol">
            In case you are using numbered/lettered lists, this String is added before the number/letter.
            @since   iText 2.1.1
        </member>
        <member name="F:iTextSharp.text.List.postSymbol">
            In case you are using numbered/lettered lists, this String is added after the number/letter. 
            @since   iText 2.1.1
        </member>
        <member name="F:iTextSharp.text.List.indentationLeft">
            <summary> The indentation of this list on the left side. </summary>
        </member>
        <member name="F:iTextSharp.text.List.indentationRight">
            <summary> The indentation of this list on the right side. </summary>
        </member>
        <member name="F:iTextSharp.text.List.symbolIndent">
            <summary> The indentation of the listitems. </summary>
        </member>
        <member name="M:iTextSharp.text.List.#ctor">
            Constructs a <CODE>List</CODE>.
        </member>
        <member name="M:iTextSharp.text.List.#ctor(System.Single)">
            Constructs a <CODE>List</CODE> with a specific symbol indentation.
            @param   symbolIndent    the symbol indentation
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.List.#ctor(System.Boolean)">
             Constructs a <CODE>List</CODE>.
            
             @param    numbered        a bool
        </member>
        <member name="M:iTextSharp.text.List.#ctor(System.Boolean,System.Boolean)">
             Constructs a <CODE>List</CODE>.
            
             @param    numbered        a bool
             @param lettered has the list to be 'numbered' with letters
        </member>
        <member name="M:iTextSharp.text.List.#ctor(System.Boolean,System.Single)">
            <summary>
            Constructs a List.
            </summary>
            <remarks>
            the parameter symbolIndent is important for instance when
            generating PDF-documents; it indicates the indentation of the listsymbol.
            </remarks>
            <param name="numbered">a bool</param>
            <param name="symbolIndent">the indentation that has to be used for the listsymbol</param>
        </member>
        <member name="M:iTextSharp.text.List.#ctor(System.Boolean,System.Boolean,System.Single)">
            <summary>
            Constructs a List.
            </summary>
            <param name="numbered">a bool</param>
            <param name="lettered">a bool</param>
            <param name="symbolIndent">the indentation that has to be used for the listsymbol</param>
        </member>
        <member name="M:iTextSharp.text.List.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.List.Add(iTextSharp.text.IElement)">
            <summary>
            Adds an Object to the List.
            </summary>
            <param name="o">the object to add</param>
            <returns>true is successful</returns>
        </member>
        <member name="M:iTextSharp.text.List.NormalizeIndentation">
            Makes sure all the items in the list have the same indentation. 
        </member>
        <member name="M:iTextSharp.text.List.SetListSymbol(System.String)">
            <summary>
            Sets the listsymbol.
            </summary>
            <remarks>
            This is a shortcut for SetListSymbol(Chunk symbol).
            </remarks>
            <param name="symbol">a string</param>
        </member>
        <member name="M:iTextSharp.text.List.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.List.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.List.IsEmpty">
            Returns <CODE>true</CODE> if the list is empty.
            
            @return <CODE>true</CODE> if the list is empty
        </member>
        <member name="M:iTextSharp.text.List.getPostSymbol">
            Returns the String that is after a number or letter in the list symbol.
            @return	the String that is after a number or letter in the list symbol
            @since	iText 2.1.1
        </member>
        <member name="P:iTextSharp.text.List.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.List.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.List.IsLowercase">
            <summary>
            Alias for VB.NET compatibility.
            </summary>
        </member>
        <member name="P:iTextSharp.text.List.First">
            <summary>
            Get/set the first number
            </summary>
            <value>an int</value>
        </member>
        <member name="P:iTextSharp.text.List.ListSymbol">
            <summary>
            Sets the symbol
            </summary>
            <value>a Chunk</value>
        </member>
        <member name="P:iTextSharp.text.List.IndentationLeft">
            <summary>
            Get/set the indentation of this paragraph on the left side.
            </summary>
            <value>the indentation</value>
        </member>
        <member name="P:iTextSharp.text.List.IndentationRight">
            <summary>
            Get/set the indentation of this paragraph on the right side.
            </summary>
            <value>the indentation</value>
        </member>
        <member name="P:iTextSharp.text.List.SymbolIndent">
            <summary>
            Gets the symbol indentation.
            </summary>
            <value>the symbol indentation</value>
        </member>
        <member name="P:iTextSharp.text.List.Items">
            <summary>
            Gets all the items in the list.
            </summary>
            <value>an ArrayList containing ListItems</value>
        </member>
        <member name="P:iTextSharp.text.List.Size">
            <summary>
            Gets the size of the list.
            </summary>
            <value>a size</value>
        </member>
        <member name="P:iTextSharp.text.List.TotalLeading">
            <summary>
            Gets the leading of the first listitem.
            </summary>
            <value>a leading</value>
        </member>
        <member name="P:iTextSharp.text.List.Symbol">
            <summary>
            Get/set the symbol indentation.
            </summary>
            <value>a Chunk</value>
        </member>
        <member name="P:iTextSharp.text.List.PostSymbol">
            Sets the String that has to be added after a number or letter in the list symbol.
            @since	iText 2.1.1
            @param	postSymbol the String that has to be added after a number or letter in the list symbol.
        </member>
        <member name="P:iTextSharp.text.List.PreSymbol">
            Sets the String that has to be added before a number or letter in the list symbol.
            @since	iText 2.1.1
            @param	preSymbol the String that has to be added before a number or letter in the list symbol.
        </member>
        <member name="M:iTextSharp.text.GreekList.#ctor">
            Initialization
            
            @param symbolIndent   indent
        </member>
        <member name="M:iTextSharp.text.GreekList.#ctor(System.Int32)">
            Initialisierung
            
            @param symbolIndent   indent
        </member>
        <member name="M:iTextSharp.text.GreekList.#ctor(System.Boolean,System.Int32)">
            Initialisierung 
            @param    greeklower      greek-char in lowercase   
            @param    symbolIndent    indent
        </member>
        <member name="M:iTextSharp.text.GreekList.SetGreekFont">
            change the font to SYMBOL
        </member>
        <member name="M:iTextSharp.text.GreekList.Add(iTextSharp.text.IElement)">
             Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
            
             @param    o   the object to add.
             @return true if adding the object succeeded
        </member>
        <member name="T:iTextSharp.text.Header">
            <summary>
            This is an Element that contains
            some userdefined meta information about the document.
            </summary>
            <example>
            <code>
            <strong>Header header = new Header("inspired by", "William Shakespeare");</strong>
            </code>
            </example>
        </member>
        <member name="T:iTextSharp.text.Meta">
            <summary>
            This is an Element that contains
            some meta information about the document.
            </summary>
            <remarks>
            An object of type Meta can not be constructed by the user.
            Userdefined meta information should be placed in a Header-object.
            Meta is reserved for: Subject, Keywords, Author, Title, Producer
            and Creationdate information.
            </remarks>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Header"/>
        </member>
        <member name="F:iTextSharp.text.Meta.UNKNOWN">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.PRODUCER">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.CREATIONDATE">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.AUTHOR">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.KEYWORDS">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.SUBJECT">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.TITLE">
            The possible value of an alignment attribute.
            @since 5.0.6 (moved from ElementTags)
        </member>
        <member name="F:iTextSharp.text.Meta.type">
            <summary> This is the type of Meta-information this object contains. </summary>
        </member>
        <member name="F:iTextSharp.text.Meta.content">
            <summary> This is the content of the Meta-information. </summary>
        </member>
        <member name="M:iTextSharp.text.Meta.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a Meta.
            </summary>
            <param name="type">the type of meta-information</param>
            <param name="content">the content</param>
        </member>
        <member name="M:iTextSharp.text.Meta.#ctor(System.String,System.String)">
            <summary>
            Constructs a Meta.
            </summary>
            <param name="tag">the tagname of the meta-information</param>
            <param name="content">the content</param>
        </member>
        <member name="M:iTextSharp.text.Meta.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to a
            IElementListener.
            </summary>
            <param name="listener">the IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Meta.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Meta.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Meta.Append(System.String)">
            <summary>
            appends some text to this Meta.
            </summary>
            <param name="str">a string</param>
            <returns>a StringBuilder</returns>
        </member>
        <member name="M:iTextSharp.text.Meta.GetType(System.String)">
            <summary>
            Returns the name of the meta information.
            </summary>
            <param name="tag">name to match</param>
            <returns>a string</returns>
        </member>
        <member name="P:iTextSharp.text.Meta.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Meta.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Meta.Content">
            <summary>
            Returns the content of the meta information.
            </summary>
            <value>a string</value>
        </member>
        <member name="P:iTextSharp.text.Meta.Name">
            <summary>
            Returns the name of the meta information.
            </summary>
            <value>a string</value>
        </member>
        <member name="F:iTextSharp.text.Header.name">
            <summary> This is the content of this chunk of text. </summary>
        </member>
        <member name="M:iTextSharp.text.Header.#ctor(System.String,System.String)">
            <summary>
            Constructs a Header.
            </summary>
            <param name="name">the name of the meta-information</param>
            <param name="content">the content</param>
        </member>
        <member name="P:iTextSharp.text.Header.Name">
            <summary>
            Returns the name of the meta information.
            </summary>
            <value>a string</value>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.html.HtmlEncoder" -->
        <member name="F:iTextSharp.text.html.HtmlEncoder.HTML_CODE">
            List with the HTML translation of all the characters. 
        </member>
        <member name="F:iTextSharp.text.html.HtmlEncoder.NEWLINETAGS">
            Set containing tags that trigger a new line.
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.HtmlEncoder.Encode(System.String)">
             Converts a <CODE>String</CODE> to the HTML-format of this <CODE>String</CODE>.
            
             @param   string  The <CODE>String</CODE> to convert
             @return  a <CODE>String</CODE>
        </member>
        <member name="M:iTextSharp.text.html.HtmlEncoder.Encode(iTextSharp.text.BaseColor)">
             Converts a <CODE>BaseColor</CODE> into a HTML representation of this <CODE>BaseColor</CODE>.
            
             @param   color   the <CODE>BaseColor</CODE> that has to be converted.
             @return  the HTML representation of this <COLOR>BaseColor</COLOR>
        </member>
        <member name="M:iTextSharp.text.html.HtmlEncoder.GetAlignment(System.Int32)">
             Translates the alignment value.
            
             @param   alignment   the alignment value
             @return  the translated value
        </member>
        <member name="M:iTextSharp.text.html.HtmlEncoder.IsNewLineTag(System.String)">
            Returns true if the tag causes a new line like p, br etc.
            @since iText 5.0.6
        </member>
        <member name="T:iTextSharp.text.html.HtmlTags">
            Static final values of supported HTML tags and attributes.
            @since 5.0.6
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.A">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.B">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BODY">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BLOCKQUOTE">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BR">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.DIV">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.EM">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FONT">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H1">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H2">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H3">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H4">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H5">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.H6">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.HR">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.I">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.IMG">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.LI">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.OL">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.P">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.PRE">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.S">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.SPAN">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.STRIKE">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.STRONG">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.SUB">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.SUP">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TABLE">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TD">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TH">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TR">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.U">
            name of a tag 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.UL">
            name of a tag.
            @since 5.0.6 (reorganized all constants)
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BGCOLOR">
            name of an attribute
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BORDER">
            name of an attribute
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.CELLPADDING">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.COLSPAN">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.EXTRAPARASPACE">
            name of an attribute
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ENCODING">
            name of an attribute
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FACE">
            name of an attribute
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.HEIGHT">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.HREF">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.HYPHENATION">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.IMAGEPATH">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.INDENT">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.LEADING">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ROWSPAN">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.SIZE">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.SRC">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.VALIGN">
            Name of an attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.WIDTH">
            name of an attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_LEFT">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_CENTER">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_RIGHT">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_JUSTIFY">
            The possible value of an alignment attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_JUSTIFIED_ALL">
            The possible value of an alignment attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_TOP">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_MIDDLE">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_BOTTOM">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ALIGN_BASELINE">
            the possible value of an alignment attribute 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.STYLE">
            This is used for inline css style information 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.CLASS">
            Attribute for specifying externally defined CSS class.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.COLOR">
            the CSS tag for text color 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FONTFAMILY">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FONTSIZE">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FONTSTYLE">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.FONTWEIGHT">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.LINEHEIGHT">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.PADDINGLEFT">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TEXTALIGN">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.TEXTDECORATION">
            The CSS tag for the font size.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.VERTICALALIGN">
            the CSS tag for text decorations 
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BOLD">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.ITALIC">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.LINETHROUGH">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.NORMAL">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.OBLIQUE">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.UNDERLINE">
            a CSS value for text decoration
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.AFTER">
            A possible attribute.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.HtmlTags.BEFORE">
            A possible attribute.
            @since 5.0.6
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.ChainedProperties">
            Stores the hierarchy of tags along with the attributes of each tag.
            @since 5.0.6 renamed from ChainedProperties
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.ChainedProperties.chain">
            A list of chained properties representing the tag hierarchy. 
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ChainedProperties.#ctor">
            Creates a new instance of ChainedProperties 
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ChainedProperties.HasProperty(System.String)">
            Walks through the hierarchy (bottom-up) looking for
            a property key. Returns true as soon as a match is
            found or false if the key can't be found.
            @param	key	the key of the property
            @return	true if the key is found
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ChainedProperties.AddToChain(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Adds a tag and its corresponding properties to the chain.
            @param tag	the tags that needs to be added to the chain
            @param props	the tag's attributes
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ChainedProperties.AdjustFontSize(System.Collections.Generic.IDictionary{System.String,System.String})">
            If the properties contain a font size, the size may need to
            be adjusted based on font sizes higher in the hierarchy.
            @param   attrs the attributes that may have to be updated
            @since 5.0.6 (renamed)
        </member>
        <member name="P:iTextSharp.text.html.simpleparser.ChainedProperties.Item(System.String)">
            Walks through the hierarchy (bottom-up) looking for
            a property key. Returns a value as soon as a match
            is found or null if the key can't be found.
            @param	key	the key of the property
            @return	the value of the property
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.ChainedProperties.TagAttributes">
            Class that stores the info about one tag in the chain.
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.ChainedProperties.TagAttributes.tag">
            A possible tag 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.ChainedProperties.TagAttributes.attrs">
            The styles corresponding with the tag 
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ChainedProperties.TagAttributes.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Constructs a chained property.
            @param   tag     an XML/HTML tag
            @param   attrs   the tag's attributes
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.HTMLWorker">
            Old iText class that allows you to convert HTML to PDF.
            We've completely rewritten HTML to PDF conversion and we made it a separate project named XML Worker.
            @deprecated since 5.5.2; please switch to XML Worker instead (this is a separate project)
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler">
            The handler for the events fired by <CODE>SimpleXMLParser</CODE>.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler.StartElement(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Called when a start tag is found.
            @param tag the tag name
            @param h the tag's attributes
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler.EndElement(System.String)">
            Called when an end tag is found.
            @param tag the tag name
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler.StartDocument">
            Called when the document starts to be parsed.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler.EndDocument">
            Called after the document is parsed.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler.Text(System.String)">
            Called when a text element is found.
            @param str the text element, probably a fragment.
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.IMG_PROVIDER">
            Key used to store the image provider in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.IMG_PROCESSOR">
            Key used to store the image processor in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.IMG_STORE">
            Key used to store the image store in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.IMG_BASEURL">
            Key used to store the image baseurl provider in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.FONT_PROVIDER">
            Key used to store the font provider in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.LINK_PROVIDER">
            Key used to store the link provider in the providers map.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.document">
            DocListener that will listen to the Elements
            produced by parsing the HTML.
            This can be a com.lowagie.text.Document adding
            the elements to a Document directly, or an
            HTMLWorker instance strong the objects in a List
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.tags">
            The map with all the supported tags.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.style">
            The object defining all the styles. 
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.#ctor(iTextSharp.text.IDocListener)">
            Creates a new instance of HTMLWorker
            @param document A class that implements <CODE>DocListener</CODE>
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.#ctor(iTextSharp.text.IDocListener,System.Collections.Generic.IDictionary{System.String,iTextSharp.text.html.simpleparser.IHTMLTagProcessor},iTextSharp.text.html.simpleparser.StyleSheet)">
            Creates a new instance of HTMLWorker
            @param document  A class that implements <CODE>DocListener</CODE>
            @param tags      A map containing the supported tags
            @param style     A StyleSheet
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetSupportedTags(System.Collections.Generic.IDictionary{System.String,iTextSharp.text.html.simpleparser.IHTMLTagProcessor})">
            Sets the map with supported tags.
            @param tags
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetStyleSheet(iTextSharp.text.html.simpleparser.StyleSheet)">
            Setter for the StyleSheet
            @param style the StyleSheet
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.Parse(System.IO.TextReader)">
            Parses content read from a java.io.Reader object.
            @param reader    the content
            @throws IOException
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.stack">
            Stack with the Elements that already have been processed.
            @since iText 5.0.6 (private => protected)
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.currentParagraph">
            Keeps the content of the current paragraph
            @since iText 5.0.6 (private => protected)
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.chain">
            The current hierarchy chain of tags.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.StartDocument">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#startDocument()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.StartElement(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#startElement(java.lang.String, java.util.Dictionary)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.Text(System.String)">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#text(java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.EndElement(System.String)">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#endElement(java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.EndDocument">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#endDocument()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.NewLine">
            Adds a new line to the currentParagraph.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CarriageReturn">
            Flushes the current paragraph, indicating that we're starting
            a new block.
            If the stack is empty, the paragraph is added to the document.
            Otherwise the Paragraph is added to the stack.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.FlushContent">
            Stacks the current paragraph, indicating that we're starting
            a new span.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.PushToStack(iTextSharp.text.IElement)">
            Pushes an element to the Stack.
            @param element
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.UpdateChain(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Updates the chain with a new tag and new attributes.
            @param tag   the new tag
            @param attrs the corresponding attributes
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.UpdateChain(System.String)">
            Updates the chain by removing a tag.
            @param tag   the new tag
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.providers">
            IDictionary containing providers such as a FontProvider or ImageProvider.
            @since 5.0.6 (renamed from interfaceProps)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetProviders(System.Collections.Generic.IDictionary{System.String,System.Object})">
            Setter for the providers.
            If a FontProvider is added, the ElementFactory is updated.
            @param providers a IDictionary with different providers
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.factory">
            Factory that is able to create iText Element objects.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateChunk(System.String)">
            Creates a Chunk using the factory.
            @param content   the content of the chunk
            @return  a Chunk with content
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateParagraph">
            Creates a Paragraph using the factory.
            @return  a Paragraph without any content
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateList(System.String)">
            Creates a List object.
            @param tag should be "ol" or "ul"
            @return  a List object
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateListItem">
            Creates a ListItem object.
            @return a ListItem object
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateLineSeparator(System.Collections.Generic.IDictionary{System.String,System.String})">
            Creates a LineSeparator object.
            @param attrs properties of the LineSeparator
            @return a LineSeparator object
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateImage(System.Collections.Generic.IDictionary{System.String,System.String})">
            Creates an Image object.
            @param attrs properties of the Image
            @return an Image object (or null if the Image couldn't be found)
            @throws DocumentException
            @throws IOException
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.CreateCell(System.String)">
            Creates a Cell.
            @param tag   the tag
            @return  a CellWrapper object
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessLink">
            Adds a link to the current paragraph.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessList">
            Fetches the List from the Stack and adds it to
            the TextElementArray on top of the Stack,
            or to the Document if the Stack is empty.
            @throws DocumentException
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessListItem">
            Looks for the List object on the Stack,
            and adds the ListItem to the List.
            @throws DocumentException
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessImage(iTextSharp.text.Image,System.Collections.Generic.IDictionary{System.String,System.String})">
            Processes an Image.
            @param img
            @param attrs
            @throws DocumentException
            @since   5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessTable">
            Processes the Table.
            @throws DocumentException
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ProcessRow">
            Gets the TableWrapper from the Stack and adds a new row.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.tableState">
            Stack to keep track of table tags. 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.pendingTR">
            Boolean to keep track of TR tags. 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.pendingTD">
            Boolean to keep track of TD and TH tags 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.pendingLI">
            Boolean to keep track of LI tags 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.insidePRE">
            Boolean to keep track of PRE tags
            @since 5.0.6 renamed from isPRE
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.skipText">
            Indicates if text needs to be skipped.
            @since iText 5.0.6 (private => protected)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.PushTableState">
            Pushes the values of pendingTR and pendingTD
            to a state stack.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.PopTableState">
            Pops the values of pendingTR and pendingTD
            from a state stack.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.IsPendingTR">
            @return the pendingTR
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetPendingTR(System.Boolean)">
            @param pendingTR the pendingTR to set
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.IsPendingTD">
            @return the pendingTD
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetPendingTD(System.Boolean)">
            @param pendingTD the pendingTD to set
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.IsPendingLI">
            @return the pendingLI
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetPendingLI(System.Boolean)">
            @param pendingLI the pendingLI to set
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.IsInsidePRE">
            @return the insidePRE
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetInsidePRE(System.Boolean)">
            @param insidePRE the insidePRE to set
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.IsSkipText">
            @return the skipText
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetSkipText(System.Boolean)">
            @param skipText the skipText to set
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLWorker.objectList">
            The resulting list of elements. 
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ParseToList(System.IO.TextReader,iTextSharp.text.html.simpleparser.StyleSheet)">
            Parses an HTML source to a List of Element objects
            @param reader    the HTML source
            @param style     a StyleSheet object
            @return a List of Element objects
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ParseToList(System.IO.TextReader,iTextSharp.text.html.simpleparser.StyleSheet,System.Collections.Generic.Dictionary{System.String,System.Object})">
            Parses an HTML source to a List of Element objects
            @param reader    the HTML source
            @param style     a StyleSheet object
            @param providers map containing classes with extra info
            @return a List of Element objects
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ParseToList(System.IO.TextReader,iTextSharp.text.html.simpleparser.StyleSheet,System.Collections.Generic.IDictionary{System.String,iTextSharp.text.html.simpleparser.IHTMLTagProcessor},System.Collections.Generic.Dictionary{System.String,System.Object})">
            Parses an HTML source to a List of Element objects
            @param reader    the HTML source
            @param style     a StyleSheet object
            @param tags      a map containing supported tags and their processors
            @param providers map containing classes with extra info
            @return a List of Element objects
            @throws IOException
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.Add(iTextSharp.text.IElement)">
            @see com.itextpdf.text.ElementListener#add(com.itextpdf.text.Element)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.Close">
            @see com.itextpdf.text.DocListener#close()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.NewPage">
            @see com.itextpdf.text.DocListener#newPage()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.Open">
            @see com.itextpdf.text.DocListener#open()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.ResetPageCount">
            @see com.itextpdf.text.DocListener#resetPageCount()
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetMarginMirroring(System.Boolean)">
            @see com.itextpdf.text.DocListener#setMarginMirroring(bool)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetMarginMirroringTopBottom(System.Boolean)">
            @see com.itextpdf.text.DocListener#setMarginMirroring(bool)
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetMargins(System.Single,System.Single,System.Single,System.Single)">
            @see com.itextpdf.text.DocListener#setMargins(float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetPageSize(iTextSharp.text.Rectangle)">
            @see com.itextpdf.text.DocListener#setPageSize(com.itextpdf.text.Rectangle)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.SetInterfaceProps(System.Collections.Generic.Dictionary{System.String,System.Object})">
            Sets the providers.
            @deprecated use SetProviders() instead
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLWorker.GetInterfaceProps">
            Gets the providers
            @deprecated use GetProviders() instead
        </member>
        <member name="P:iTextSharp.text.html.simpleparser.HTMLWorker.PageCount">
            @see com.itextpdf.text.DocListener#setPageCount(int)
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.IImageProvider">
            @deprecated since 5.5.2
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.StyleSheet">
            Old class to define styles for HTMLWorker.
            We've completely rewritten HTML to PDF functionality; see project XML Worker.
            XML Worker is able to parse CSS files and "style" attribute values.
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.StyleSheet.tagMap">
            IDictionary storing tags and their corresponding styles.
            @since 5.0.6 (changed Dictionary => IDictionary)
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.StyleSheet.classMap">
            IDictionary storing possible names of the "class" attribute
            and their corresponding styles.
            @since 5.0.6 (changed Dictionary => IDictionary)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.#ctor">
            Creates a new instance of StyleSheet
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.LoadTagStyle(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Associates a IDictionary containing styles with a tag.
            @param   tag     the name of the HTML/XML tag
            @param   attrs   a map containing styles
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.LoadTagStyle(System.String,System.String,System.String)">
            Adds an extra style key-value pair to the styles IDictionary
            of a specific tag
            @param   tag     the name of the HTML/XML tag
            @param   key     the key specifying a specific style
            @param   value   the value defining the style
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.LoadStyle(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            Associates a IDictionary containing styles with a class name.
            @param   className   the value of the class attribute
            @param   attrs       a map containing styles
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.LoadStyle(System.String,System.String,System.String)">
            Adds an extra style key-value pair to the styles IDictionary
            of a specific tag
            @param   className   the name of the HTML/XML tag
            @param   key         the key specifying a specific style
            @param   value       the value defining the style
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.ApplyStyle(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Resolves the styles based on the tag name and the value
            of the class attribute.
            @param   tag     the tag that needs to be resolved
            @param   attrs   existing style map that will be updated
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.StyleSheet.ResolveStyleAttribute(System.Collections.Generic.IDictionary{System.String,System.String},iTextSharp.text.html.simpleparser.ChainedProperties)">
            Method contributed by Lubos Strapko
            @param h
            @param chain
            @since 2.1.3
        </member>
        <member name="T:iTextSharp.text.html.WebColors">
            This class is a HashMap that contains the names of colors as a key and the
            corresponding Color as value. (Source: Wikipedia
            http://en.wikipedia.org/wiki/Web_colors )
            
            @author blowagie
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.html.WebColors.MissingHashColorFormat(System.String)">
            A web color string without the leading # will be 3 or 6 characters long
            and all those characters will be hex digits. NOTE: colStr must be all
            lower case or the current hex letter test will fail.
            
            @param colStr
                       A non-null, lower case string that might describe an RGB color
                       in hex.
            @return Is this a web color hex string without the leading #?
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.WebColors.GetRGBColor(System.String)">
             Gives you a BaseColor based on a name.
            
             @param name
                        a name such as black, violet, cornflowerblue or #RGB or
                        #RRGGBB or RGB or RRGGBB or rgb(R,G,B)
             @return the corresponding BaseColor object. Never returns null.
             @throws IllegalArgumentException
                         if the String isn't a know representation of a color.
        </member>
        <member name="T:iTextSharp.text.Image">
            <summary>
            An Image is the representation of a graphic element (JPEG, PNG or GIF)
            that has to be inserted into the document
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Rectangle"/>
        </member>
        <member name="T:iTextSharp.text.Rectangle">
            <summary>
            A Rectangle is the representation of a geometric figure.
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Table"/>
            <seealso cref="T:iTextSharp.text.Cell"/>
            <seealso cref="T:iTextSharp.text.HeaderFooter"/>
        </member>
        <member name="F:iTextSharp.text.Rectangle.UNDEFINED">
            <summary> This is the value that will be used as <VAR>undefined</VAR>. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.TOP_BORDER">
            <summary> This represents one side of the border of the Rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.BOTTOM_BORDER">
            <summary> This represents one side of the border of the Rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.LEFT_BORDER">
            <summary> This represents one side of the border of the Rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.RIGHT_BORDER">
            <summary> This represents one side of the border of the Rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.NO_BORDER">
            <summary> This represents a rectangle without borders. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.BOX">
            <summary> This represents a type of border. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.llx">
            <summary> the lower left x-coordinate. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.lly">
            <summary> the lower left y-coordinate. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.urx">
            <summary> the upper right x-coordinate. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.ury">
            <summary> the upper right y-coordinate. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.border">
            <summary> This represents the status of the 4 sides of the rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderWidth">
            <summary> This is the width of the border around this rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderColor">
            <summary> This is the color of the border of this rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderColorLeft">
            The color of the left border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderColorRight">
            The color of the right border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderColorTop">
            The color of the top border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderColorBottom">
            The color of the bottom border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderWidthLeft">
            The width of the left border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderWidthRight">
            The width of the right border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderWidthTop">
            The width of the top border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.borderWidthBottom">
            The width of the bottom border of this rectangle. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.useVariableBorders">
            Whether variable width borders are used. 
        </member>
        <member name="F:iTextSharp.text.Rectangle.backgroundColor">
            <summary> This is the color of the background of this rectangle. </summary>
        </member>
        <member name="F:iTextSharp.text.Rectangle.rotation">
            <summary> This is the rotation value of this rectangle. </summary>
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a Rectangle-object.
            </summary>
            <param name="llx">lower left x</param>
            <param name="lly">lower left y</param>
            <param name="urx">upper right x</param>
            <param name="ury">upper right y</param>
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32)">
             Constructs a <CODE>Rectangle</CODE>-object.
            
             @param llx   lower left x
             @param lly   lower left y
             @param urx   upper right x
             @param ury   upper right y
             @param rotation the rotation (0, 90, 180, or 270)
             @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(System.Single,System.Single)">
            <summary>
            Constructs a Rectangle-object starting from the origin (0, 0).
            </summary>
            <param name="urx">upper right x</param>
            <param name="ury">upper right y</param>
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(System.Single,System.Single,System.Int32)">
             Constructs a <CODE>Rectangle</CODE>-object starting from the origin
             (0, 0) and with a specific rotation (valid values are 0, 90, 180, 270).
            
             @param urx   upper right x
             @param ury   upper right y
             @param rotation the rotation of the rectangle
             @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(iTextSharp.text.Rectangle)">
            <summary>
            Constructs a Rectangle-object.
            </summary>
            <param name="rect">another Rectangle</param>
        </member>
        <member name="M:iTextSharp.text.Rectangle.#ctor(System.util.RectangleJ)">
            Constructs a <CODE>Rectangle</CODE>-object based on a <CODE>com.itextpdf.awt.geom.Rectangle</CODE> object
            @param rect com.itextpdf.awt.geom.Rectangle
        </member>
        <member name="M:iTextSharp.text.Rectangle.CloneNonPositionParameters(iTextSharp.text.Rectangle)">
            Copies all of the parameters from a <CODE>Rectangle</CODE> object
            except the position.
            
            @param rect
                       <CODE>Rectangle</CODE> to copy from
        </member>
        <member name="M:iTextSharp.text.Rectangle.SoftCloneNonPositionParameters(iTextSharp.text.Rectangle)">
            Copies all of the parameters from a <CODE>Rectangle</CODE> object
            except the position.
            
            @param rect
                       <CODE>Rectangle</CODE> to copy from
        </member>
        <member name="M:iTextSharp.text.Rectangle.Process(iTextSharp.text.IElementListener)">
            <summary>
            Processes the element by adding it (or the different parts) to an
            IElementListener.
            </summary>
            <param name="listener">an IElementListener</param>
            <returns>true if the element was processed successfully</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Rectangle.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Rectangle.Normalize">
            Switches lowerleft with upperright
        </member>
        <member name="M:iTextSharp.text.Rectangle.GetRectangle(System.Single,System.Single)">
            <summary>
            Gets a Rectangle that is altered to fit on the page.
            </summary>
            <param name="top">the top position</param>
            <param name="bottom">the bottom position</param>
            <returns>a Rectangle</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.Rotate">
            <summary>
            Swaps the values of urx and ury and of lly and llx in order to rotate the rectangle.
            </summary>
            <returns>a Rectangle</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.EnableBorderSide(System.Int32)">
            Enables the border on the specified side.
            
            @param side
                       the side to enable. One of <CODE>LEFT, RIGHT, TOP, BOTTOM
                       </CODE>
        </member>
        <member name="M:iTextSharp.text.Rectangle.DisableBorderSide(System.Int32)">
            Disables the border on the specified side.
            
            @param side
                       the side to disable. One of <CODE>LEFT, RIGHT, TOP, BOTTOM
                       </CODE>
        </member>
        <member name="M:iTextSharp.text.Rectangle.GetLeft(System.Single)">
            <summary>
            Returns the lower left x-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the lower left x-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.GetRight(System.Single)">
            <summary>
            Returns the upper right x-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the upper right x-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.GetTop(System.Single)">
            <summary>
            Returns the upper right y-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the upper right y-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.GetBottom(System.Single)">
            <summary>
            Returns the lower left y-coordinate, considering a given margin.
            </summary>
            <param name="margin">a margin</param>
            <returns>the lower left y-coordinate</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.HasBorders">
            <summary>
            Indicates if the table has borders.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.HasBorder(System.Int32)">
            <summary>
            Indicates if the table has a some type of border.
            </summary>
            <param name="type">the type of border</param>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Rectangle.UpdateBorderBasedOnWidth(System.Single,System.Int32)">
            Updates the border flag for a side based on the specified width. A width
            of 0 will disable the border on that side. Any other width enables it.
            
            @param width
                       width of border
            @param side
                       border side constant
        </member>
        <member name="P:iTextSharp.text.Rectangle.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Chunks">
            <summary>
            Gets all the chunks in this element.
            </summary>
            <value>an ArrayList</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Top">
            <summary>
            Get/set the upper right y-coordinate. 
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Border">
            <summary>
            Get/set the border
            </summary>
            <value>a int</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.GrayFill">
            <summary>
            Get/set the grayscale of the rectangle.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Left">
            <summary>
            Get/set the lower left x-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Right">
            <summary>
            Get/set the upper right x-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Bottom">
            <summary>
            Get/set the lower left y-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Width">
            <summary>
            Returns the width of the rectangle.
            </summary>
            <value>a width</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Height">
            <summary>
            Returns the height of the rectangle.
            </summary>
            <value>a height</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.BorderWidth">
            <summary>
            Get/set the borderwidth.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.BorderColor">
             Gets the color of the border.
            
             @return    a value
            <summary>
            Get/set the color of the border.
            </summary>
            <value>a BaseColor</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.BackgroundColor">
             Gets the backgroundcolor.
            
             @return    a value
            <summary>
            Get/set the backgroundcolor.
            </summary>
            <value>a BaseColor</value>
        </member>
        <member name="P:iTextSharp.text.Rectangle.Rotation">
            <summary>
            Set/gets the rotation
            </summary>
            <value>a int</value>    
        </member>
        <member name="P:iTextSharp.text.Rectangle.UseVariableBorders">
            Sets a parameter indicating if the rectangle has variable borders
            
            @param useVariableBorders
                       indication if the rectangle has variable borders
        </member>
        <member name="T:iTextSharp.text.api.ISpaceable">
            Objects implementing Spaceable allow setting spacing before and after.
        </member>
        <member name="P:iTextSharp.text.api.ISpaceable.SpacingBefore">
             Sets the spacing before.
            
             @param   spacing     the new spacing
        </member>
        <member name="P:iTextSharp.text.api.ISpaceable.SpacingAfter">
             Sets the spacing after.
            
             @param   spacing     the new spacing
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IAlternateDescription">
            Interface providing alternate description for accessible elements.
        </member>
        <member name="F:iTextSharp.text.Image.DEFAULT">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.RIGHT_ALIGN">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.LEFT_ALIGN">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.MIDDLE_ALIGN">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.TEXTWRAP">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.UNDERLYING">
            <summary> this is a kind of image Element. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.AX">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.AY">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.BX">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.BY">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.CX">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.CY">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.DX">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.DY">
            <summary> This represents a coordinate in the transformation matrix. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_NONE">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_JPEG">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_PNG">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_GIF">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_BMP">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_TIFF">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_WMF">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_JPEG2000">
            type of image 
        </member>
        <member name="F:iTextSharp.text.Image.ORIGINAL_JBIG2">
            type of image
            @since	2.1.5
        </member>
        <member name="F:iTextSharp.text.Image.invert">
            Image color inversion 
        </member>
        <member name="F:iTextSharp.text.Image.type">
            <summary> The imagetype. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.url">
            <summary> The URL of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.rawData">
            <summary> The raw data of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.template">
            <summary> The template to be treated as an image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.alignment">
            <summary> The alignment of the Image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.alt">
            <summary> Text that can be shown instead of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.absoluteX">
            <summary> This is the absolute X-position of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.absoluteY">
            <summary> This is the absolute Y-position of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.plainWidth">
            <summary> This is the width of the image without rotation. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.plainHeight">
            <summary> This is the width of the image without rotation. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.scaledWidth">
            <summary> This is the scaled width of the image taking rotation into account. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.scaledHeight">
            <summary> This is the original height of the image taking rotation into account. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.compressionLevel">
            The compression level of the content streams.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.Image.rotationRadians">
            <summary> This is the rotation of the image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.colorspace">
            <summary> this is the colorspace of a jpeg-image. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.bpc">
            <summary> this is the bits per component of the raw image. It also flags a CCITT image.</summary>
        </member>
        <member name="F:iTextSharp.text.Image.transparency">
            <summary> this is the transparency information of the raw image</summary>
        </member>
        <member name="F:iTextSharp.text.Image.indentationLeft">
            the indentation to the left. 
        </member>
        <member name="F:iTextSharp.text.Image.indentationRight">
            the indentation to the right. 
        </member>
        <member name="F:iTextSharp.text.Image.dpiX">
            <summary> Holds value of property dpiX. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.dpiY">
            <summary> Holds value of property dpiY. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.interpolation">
            <summary> Holds value of property interpolation. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.annotation">
            <summary> if the annotation is not null the image will be clickable. </summary>
        </member>
        <member name="F:iTextSharp.text.Image.profile">
            <summary> ICC Profile attached </summary>
        </member>
        <member name="F:iTextSharp.text.Image.deflated">
            Holds value of property deflated. 
        </member>
        <member name="F:iTextSharp.text.Image.smask">
            Holds value of property smask. 
        </member>
        <member name="F:iTextSharp.text.Image.xyRatio">
            Holds value of property XYRatio. 
        </member>
        <member name="F:iTextSharp.text.Image.originalType">
            Holds value of property originalType. 
        </member>
        <member name="F:iTextSharp.text.Image.originalData">
            Holds value of property originalData. 
        </member>
        <member name="F:iTextSharp.text.Image.spacingBefore">
            The spacing before the image. 
        </member>
        <member name="F:iTextSharp.text.Image.spacingAfter">
            The spacing after the image. 
        </member>
        <member name="F:iTextSharp.text.Image.widthPercentage">
            Holds value of property widthPercentage.
        </member>
        <member name="F:iTextSharp.text.Image.initialRotation">
            Holds value of property initialRotation.
        </member>
        <member name="M:iTextSharp.text.Image.#ctor(System.Uri)">
            <summary>
            Constructs an Image-object, using an url.
            </summary>
            <param name="url">the URL where the image can be found.</param>
        </member>
        <member name="M:iTextSharp.text.Image.#ctor(iTextSharp.text.Image)">
            <summary>
            Constructs an Image object duplicate.
            </summary>
            <param name="image">another Image object.</param>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(iTextSharp.text.Image)">
            <summary>
            Gets an instance of an Image.
            </summary>
            <param name="image">an Image</param>
            <returns>an object of type Gif, Jpeg or Png</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Uri)">
            <summary>
            Gets an instance of an Image.
            </summary>
            <param name="url">an URL</param>
            <returns>an object of type Gif, Jpeg or Png</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Uri,System.Boolean)">
            <summary>
            Gets an instance of an Image.
            </summary>
            <param name="url">an URL</param>
            <returns>an object of type Gif, Jpeg or Png</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Byte[],System.Boolean)">
            <summary>
            Gets an instance of an Image.
            </summary>
            <param name="img">a byte array</param>
            <returns>an object of type Gif, Jpeg or Png</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Drawing.Image,iTextSharp.text.BaseColor,System.Boolean)">
            <summary>
            Gets an instance of an Image from a System.Drwaing.Image.
            </summary>
            <param name="image">the System.Drawing.Image to convert</param>
            <param name="color">
            if different from null the transparency
            pixels are replaced by this color
            </param>
            <param name="forceBW">if true the image is treated as black and white</param>
            <returns>an object of type ImgRaw</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Drawing.Image,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Converts a .NET image to a Native(PNG, JPG, GIF, WMF) image
            </summary>
            <param name="image"></param>
            <param name="?"></param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Drawing.Image,iTextSharp.text.BaseColor)">
            <summary>
            Gets an instance of an Image from a System.Drawing.Image.
            </summary>
            <param name="image">the System.Drawing.Image to convert</param>
            <param name="color">
            if different from null the transparency
            pixels are replaced by this color
            </param>
            <returns>an object of type ImgRaw</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.String)">
            <summary>
            Gets an instance of an Image.
            </summary>
            <param name="filename">a filename</param>
            <returns>an object of type Gif, Jpeg or Png</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Gets an instance of an Image in raw mode.
            </summary>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <param name="components">1,3 or 4 for GrayScale, RGB and CMYK</param>
            <param name="bpc">bits per component</param>
            <param name="data">the image data</param>
            <returns>an object of type ImgRaw</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Int32,System.Int32,System.Byte[],System.Byte[])">
            Creates a JBIG2 Image.
            @param   width   the width of the image
            @param   height  the height of the image
            @param   data    the raw image data
            @param   globals JBIG2 globals
            @since   2.1.5
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(iTextSharp.text.pdf.PRIndirectReference)">
            Reuses an existing image.
            @param ref the reference to the image dictionary
            @throws BadElementException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(iTextSharp.text.pdf.PdfTemplate)">
            <summary>
            Gets an instance of an Image in raw mode.
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Gets an instance of an Image in raw mode.
            </summary>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <param name="reverseBits"></param>
            <param name="typeCCITT"></param>
            <param name="parameters"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Byte[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="reverseBits"></param>
            <param name="typeCCITT"></param>
            <param name="parameters"></param>
            <param name="data"></param>
            <param name="transparency"></param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetInstance(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32[])">
            <summary>
            Gets an instance of an Image in raw mode.
            </summary>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <param name="components">1,3 or 4 for GrayScale, RGB and CMYK</param>
            <param name="bpc">bits per component</param>
            <param name="data">the image data</param>
            <param name="transparency">
            transparency information in the Mask format of the
            image dictionary
            </param>
            <returns>an object of type ImgRaw</returns>
        </member>
        <member name="M:iTextSharp.text.Image.SetAbsolutePosition(System.Single,System.Single)">
            <summary>
            Sets the absolute position of the Image.
            </summary>
            <param name="absoluteX"></param>
            <param name="absoluteY"></param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleAbsolute(iTextSharp.text.Rectangle)">
            <summary>
            Scale the image to the dimensions of the rectangle
            </summary>
            <param name="rectangle">dimensions to scale the Image</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleAbsolute(System.Single,System.Single)">
            <summary>
            Scale the image to an absolute width and an absolute height.
            </summary>
            <param name="newWidth">the new width</param>
            <param name="newHeight">the new height</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleAbsoluteWidth(System.Single)">
            <summary>
            Scale the image to an absolute width.
            </summary>
            <param name="newWidth">the new width</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleAbsoluteHeight(System.Single)">
            <summary>
            Scale the image to an absolute height.
            </summary>
            <param name="newHeight">the new height</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScalePercent(System.Single)">
            <summary>
            Scale the image to a certain percentage.
            </summary>
            <param name="percent">the scaling percentage</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScalePercent(System.Single,System.Single)">
            <summary>
            Scale the width and height of an image to a certain percentage.
            </summary>
            <param name="percentX">the scaling percentage of the width</param>
            <param name="percentY">the scaling percentage of the height</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleToFit(iTextSharp.text.Rectangle)">
            <summary>
            Scales the images to the dimensions of the rectangle.
            </summary>
            <param name="rectangle">the dimensions to fit</param>
        </member>
        <member name="M:iTextSharp.text.Image.ScaleToFit(System.Single,System.Single)">
            <summary>
            Scales the image so that it fits a certain width and height.
            </summary>
            <param name="fitWidth">the width to fit</param>
            <param name="fitHeight">the height to fit</param>
        </member>
        <member name="M:iTextSharp.text.Image.GetImageRotation">
            Gets the current image rotation in radians.
            @return the current image rotation in radians
        </member>
        <member name="M:iTextSharp.text.Image.HasAbsolutePosition">
            <summary>
            Checks if the Images has to be added at an absolute position.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Image.HasAbsoluteX">
            <summary>
            Checks if the Images has to be added at an absolute X position.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Image.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.Image.IsJpeg">
            <summary>
            Returns true if the image is a Jpeg-object.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Image.IsImgRaw">
            <summary>
            Returns true if the image is a ImgRaw-object.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Image.IsImgTemplate">
            <summary>
            Returns true if the image is an ImgTemplate-object.
            </summary>
            <returns>a bool</returns>
        </member>
        <member name="M:iTextSharp.text.Image.GetMatrix">
            <summary>
            Returns the transformation matrix of the image.
            </summary>
            <value>an array [AX, AY, BX, BY, CX, CY, DX, DY]</value>
        </member>
        <member name="M:iTextSharp.text.Image.GetMatrix(System.Single)">
             Returns the transformation matrix of the image.
            
             @return an array [AX, AY, BX, BY, CX, CY, DX, DY]
        </member>
        <member name="M:iTextSharp.text.Image.GetSerialId">
            <summary>
            generates new serial id
            </summary>
        </member>
        <member name="M:iTextSharp.text.Image.SetDpi(System.Int32,System.Int32)">
            Sets the dots per inch value
            
            @param dpiX
                       dpi for x coordinates
            @param dpiY
                       dpi for y coordinates
        </member>
        <member name="M:iTextSharp.text.Image.IsMaskCandidate">
            <summary>
            Returns true if this Image has the
            requisites to be a mask.
            </summary>
            <returns>true if this Image can be a mask</returns>
        </member>
        <member name="M:iTextSharp.text.Image.MakeMask">
            <summary>
            Make this Image a mask.
            </summary>
        </member>
        <member name="M:iTextSharp.text.Image.IsMask">
            <summary>
            Returns true if this Image is a mask.
            </summary>
            <returns>true if this Image is a mask</returns>
        </member>
        <member name="M:iTextSharp.text.Image.HasICCProfile">
            Checks is the image has an ICC profile.
            @return the ICC profile or null
        </member>
        <member name="F:iTextSharp.text.Image.scaleToFitLineWhenOverflow">
            Indicates if the image should be scaled to fit the line
            when the image exceeds the available width.
            @since iText 5.0.6
        </member>
        <member name="F:iTextSharp.text.Image.scaleToFitHeight">
            Indicates if the image should be scaled to fit
            when the image exceeds the available height.
            @since iText 5.4.2
        </member>
        <member name="M:iTextSharp.text.Image.SimplifyColorspace">
            Replaces CalRGB and CalGray colorspaces with DeviceRGB and DeviceGray.
        </member>
        <member name="P:iTextSharp.text.Image.Rotation">
            <summary>
            Sets the rotation of the image in radians.
            </summary>
            <param name="r">rotation in radians</param>
        </member>
        <member name="P:iTextSharp.text.Image.RotationDegrees">
            <summary>
            Sets the rotation of the image in degrees.
            </summary>
            <param name="deg">rotation in degrees</param>
        </member>
        <member name="P:iTextSharp.text.Image.Annotation">
            <summary>
            Get/set the annotation.
            </summary>
            <value>the Annotation</value>
        </member>
        <member name="P:iTextSharp.text.Image.Bpc">
            <summary>
            Gets the bpc for the image.
            </summary>
            <remarks>
            this only makes sense for Images of the type RawImage.
            </remarks>
            <value>a bpc value</value>
        </member>
        <member name="P:iTextSharp.text.Image.RawData">
            <summary>
            Gets the raw data for the image.
            </summary>
            <remarks>
            this only makes sense for Images of the type RawImage.
            </remarks>
            <value>the raw data</value>
        </member>
        <member name="P:iTextSharp.text.Image.TemplateData">
            <summary>
            Get/set the template to be used as an image.
            </summary>
            <remarks>
            this only makes sense for Images of the type ImgTemplate.
            </remarks>
            <value>the template</value>
        </member>
        <member name="P:iTextSharp.text.Image.AbsoluteX">
            <summary>
            Returns the absolute X position.
            </summary>
            <value>a position</value>
        </member>
        <member name="P:iTextSharp.text.Image.AbsoluteY">
            <summary>
            Returns the absolute Y position.
            </summary>
            <value>a position</value>
        </member>
        <member name="P:iTextSharp.text.Image.Type">
            <summary>
            Returns the type.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Image.Url">
            <summary>
            Gets the string-representation of the reference to the image.
            </summary>
            <value>a string</value>
        </member>
        <member name="P:iTextSharp.text.Image.Alignment">
            <summary>
            Get/set the alignment for the image.
            </summary>
            <value>a value</value>
        </member>
        <member name="P:iTextSharp.text.Image.Alt">
            <summary>
            Get/set the alternative text for the image.
            </summary>
            <value>a string</value>
        </member>
        <member name="P:iTextSharp.text.Image.ScaledWidth">
            <summary>
            Gets the scaled width of the image.
            </summary>
            <value>a value</value>
        </member>
        <member name="P:iTextSharp.text.Image.ScaledHeight">
            <summary>
            Gets the scaled height of the image.
            </summary>
            <value>a value</value>
        </member>
        <member name="P:iTextSharp.text.Image.Colorspace">
            <summary>
            Gets the colorspace for the image.
            </summary>
            <remarks>
            this only makes sense for Images of the type Jpeg.
            </remarks>
            <value>a colorspace value</value>
        </member>
        <member name="P:iTextSharp.text.Image.Transparency">
            <summary>
            Returns the transparency.
            </summary>
            <value>the transparency</value>
        </member>
        <member name="P:iTextSharp.text.Image.PlainWidth">
            <summary>
            Gets the plain width of the image.
            </summary>
            <value>a value</value>
        </member>
        <member name="P:iTextSharp.text.Image.PlainHeight">
            <summary>
            Gets the plain height of the image.
            </summary>
            <value>a value</value>
        </member>
        <member name="P:iTextSharp.text.Image.MySerialId">
            <summary>
            returns serial id for this object
            </summary>
        </member>
        <member name="P:iTextSharp.text.Image.DpiX">
            <summary>
            Gets the dots-per-inch in the X direction. Returns 0 if not available.
            </summary>
            <value>the dots-per-inch in the X direction</value>
        </member>
        <member name="P:iTextSharp.text.Image.DpiY">
            <summary>
            Gets the dots-per-inch in the Y direction. Returns 0 if not available.
            </summary>
            <value>the dots-per-inch in the Y direction</value>
        </member>
        <member name="P:iTextSharp.text.Image.ImageMask">
            <summary>
            Get/set the explicit masking.
            </summary>
            <value>the explicit masking</value>
        </member>
        <member name="P:iTextSharp.text.Image.Inverted">
            <summary>
            Inverts the meaning of the bits of a mask.
            </summary>
            <value>true to invert the meaning of the bits of a mask</value>
        </member>
        <member name="P:iTextSharp.text.Image.Interpolation">
            <summary>
            Sets the image interpolation. Image interpolation attempts to
            produce a smooth transition between adjacent sample values.
            </summary>
            <value>New value of property interpolation.</value>
        </member>
        <member name="P:iTextSharp.text.Image.TagICC">
            Tags this image with an ICC profile.
            @param profile the profile
        </member>
        <member name="P:iTextSharp.text.Image.ScaleToFitHeight">
            Gets and sets the value of scaleToFitHeight.
            @return true if the image size has to scale to the available height
            @since iText 5.4.2
        </member>
        <member name="P:iTextSharp.text.Image.InitialRotation">
            Some image formats, like TIFF may present the images rotated that have
            to be compensated.
        </member>
        <member name="P:iTextSharp.text.Image.CompressionLevel">
            Sets the compression level to be used if the image is written as a compressed stream.
            @param compressionLevel a value between 0 (best speed) and 9 (best compression)
            @since   2.1.3
        </member>
        <member name="T:iTextSharp.text.ImgCCITT">
             CCITT Image data that has to be inserted into the document
            
             @see        Element
             @see        Image
            
             @author  Paulo Soares
            <summary>
            CCITT Image data that has to be inserted into the document
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Image"/>
        </member>
        <member name="M:iTextSharp.text.ImgCCITT.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Creats an Image in CCITT mode.
            </summary>
            <param name="width">the exact width of the image</param>
            <param name="height">the exact height of the image</param>
            <param name="reverseBits">
            reverses the bits in data.
            Bit 0 is swapped with bit 7 and so on
            </param>
            <param name="typeCCITT">
            the type of compression in data. It can be
            CCITTG4, CCITTG31D, CCITTG32D
            </param>
            <param name="parameters">
            parameters associated with this stream. Possible values are
            CCITT_BLACKIS1, CCITT_ENCODEDBYTEALIGN, CCITT_ENDOFLINE and CCITT_ENDOFBLOCK or a
            combination of them
            </param>
            <param name="data">the image data</param>
        </member>
        <member name="T:iTextSharp.text.ImgJBIG2">
            Support for JBIG2 images.
            @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.ImgJBIG2.global">
            JBIG2 globals 
        </member>
        <member name="F:iTextSharp.text.ImgJBIG2.globalHash">
            A unique hash 
        </member>
        <member name="M:iTextSharp.text.ImgJBIG2.#ctor(iTextSharp.text.Image)">
            Copy contstructor.
            @param    image another Image
        </member>
        <member name="M:iTextSharp.text.ImgJBIG2.#ctor">
            Empty constructor.
        </member>
        <member name="M:iTextSharp.text.ImgJBIG2.#ctor(System.Int32,System.Int32,System.Byte[],System.Byte[])">
            Actual constructor for ImgJBIG2 images.
            @param    width   the width of the image
            @param    height  the height of the image
            @param    data    the raw image data
            @param    globals JBIG2 globals
        </member>
        <member name="P:iTextSharp.text.ImgJBIG2.GlobalBytes">
            Getter for the JBIG2 global data.
            @return   an array of bytes
        </member>
        <member name="P:iTextSharp.text.ImgJBIG2.GlobalHash">
            Getter for the unique hash.
            @return   an array of bytes
        </member>
        <member name="T:iTextSharp.text.ImgRaw">
            <summary>
            Raw Image data that has to be inserted into the document
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Image"/>
        </member>
        <member name="M:iTextSharp.text.ImgRaw.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Creats an Image in raw mode.
            </summary>
            <param name="width">the exact width of the image</param>
            <param name="height">the exact height of the image</param>
            <param name="components">1,3 or 4 for GrayScale, RGB and CMYK</param>
            <param name="bpc">bits per component. Must be 1,2,4 or 8</param>
            <param name="data">data the image data</param>
        </member>
        <member name="T:iTextSharp.text.ImgTemplate">
            <summary>
            PdfTemplate that has to be inserted into the document
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Image"/>
        </member>
        <member name="M:iTextSharp.text.ImgTemplate.#ctor(iTextSharp.text.Image)">
            <summary>
            Creats an Image from a PdfTemplate.
            </summary>
            <param name="image">the Image</param>
        </member>
        <member name="M:iTextSharp.text.ImgTemplate.#ctor(iTextSharp.text.pdf.PdfTemplate)">
            <summary>
            Creats an Image from a PdfTemplate.
            </summary>
            <param name="template">the PdfTemplate</param>
        </member>
        <member name="T:iTextSharp.text.ImgWMF">
             An ImgWMF is the representation of a windows metafile
             that has to be inserted into the document
            
             @see        Element
             @see        Image
             @see        Gif
             @see        Png
            <summary>
            An ImgWMF is the representation of a windows metafile
            that has to be inserted into the document
            </summary>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.#ctor(iTextSharp.text.Image)">
            <summary>
            Constructs an ImgWMF-object
            </summary>
            <param name="image">a Image</param>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.#ctor(System.Uri)">
            <summary>
            Constructs an ImgWMF-object, using an url.
            </summary>
            <param name="url">the URL where the image can be found</param>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.#ctor(System.String)">
            <summary>
            Constructs an ImgWMF-object, using a filename.
            </summary>
            <param name="filename">a string-representation of the file that contains the image.</param>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.#ctor(System.Byte[])">
            <summary>
            Constructs an ImgWMF-object from memory.
            </summary>
            <param name="img">the memory image</param>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.ProcessParameters">
            <summary>
            This method checks if the image is a valid WMF and processes some parameters.
            </summary>
        </member>
        <member name="M:iTextSharp.text.ImgWMF.ReadWMF(iTextSharp.text.pdf.PdfTemplate)">
            <summary>
            Reads the WMF into a template.
            </summary>
            <param name="template">the template to read to</param>
        </member>
        <member name="T:iTextSharp.text.IRtfElementInterface">
            The RTF jar depends on the iText jar, but the iText jar may not
            depend on the RTF jar. This interface offers a temporary solution
            until we find a more elegant way to solve this.
        </member>
        <member name="T:iTextSharp.text.ISplitCharacter">
            <summary>
            Interface for customizing the split character.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.ISplitCharacter.IsSplitCharacter(System.Int32,System.Int32,System.Int32,System.Char[],iTextSharp.text.pdf.PdfChunk[])" -->
        <member name="T:iTextSharp.text.Jpeg">
            <summary>
            An Jpeg is the representation of a graphic element (JPEG)
            that has to be inserted into the document
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Image"/>
            <seealso cref="T:iTextSharp.text.Gif"/>
            <seealso cref="T:iTextSharp.text.Png"/>
        </member>
        <member name="F:iTextSharp.text.Jpeg.NOT_A_MARKER">
            <summary> This is a type of marker. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.VALID_MARKER">
            <summary> This is a type of marker. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.UNSUPPORTED_MARKER">
            <summary> This is a type of marker. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.NOPARAM_MARKER">
            <summary> This is a type of marker. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.M_APPD">
            Marker value for Photoshop IRB 
        </member>
        <member name="F:iTextSharp.text.Jpeg.VALID_MARKERS">
            <summary> Acceptable Jpeg markers. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.UNSUPPORTED_MARKERS">
            <summary> Unsupported Jpeg markers. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.NOPARAM_MARKERS">
            <summary> Jpeg markers without additional parameters. </summary>
        </member>
        <member name="F:iTextSharp.text.Jpeg.PS_8BIM_RESO">
            sequence preceding Photoshop resolution data 
        </member>
        <member name="M:iTextSharp.text.Jpeg.#ctor(iTextSharp.text.Image)">
            <summary>
            Construct a Jpeg-object, using a Image
            </summary>
            <param name="image">a Image</param>
        </member>
        <member name="M:iTextSharp.text.Jpeg.#ctor(System.Uri)">
            <summary>
            Constructs a Jpeg-object, using an Uri.
            </summary>
            <remarks>
            Deprecated, use Image.GetInstance(...) to create an Image
            </remarks>
            <param name="Uri">the Uri where the image can be found</param>
        </member>
        <member name="M:iTextSharp.text.Jpeg.#ctor(System.Byte[])">
            <summary>
            Constructs a Jpeg-object from memory.
            </summary>
            <param name="img">the memory image</param>
        </member>
        <member name="M:iTextSharp.text.Jpeg.#ctor(System.Byte[],System.Single,System.Single)">
            <summary>
            Constructs a Jpeg-object from memory.
            </summary>
            <param name="img">the memory image.</param>
            <param name="width">the width you want the image to have</param>
            <param name="height">the height you want the image to have</param>
        </member>
        <member name="M:iTextSharp.text.Jpeg.GetShort(System.IO.Stream)">
            <summary>
            Reads a short from the Stream.
            </summary>
            <param name="istr">the Stream</param>
            <returns>an int</returns>
        </member>
        <member name="M:iTextSharp.text.Jpeg.GetShortInverted(System.IO.Stream)">
            <summary>
            Reads an inverted short from the Stream.
            </summary>
            <param name="istr">the Stream</param>
            <returns>an int</returns>
        </member>
        <member name="M:iTextSharp.text.Jpeg.MarkerType(System.Int32)">
            <summary>
            Returns a type of marker.
            </summary>
            <param name="marker">an int</param>
            <returns>a type: VALID_MARKER, UNSUPPORTED_MARKER or NOPARAM_MARKER</returns>
        </member>
        <member name="M:iTextSharp.text.Jpeg.ProcessParameters">
            <summary>
            This method checks if the image is a valid JPEG and processes some parameters.
            </summary>
        </member>
        <member name="T:iTextSharp.text.Jpeg2000">
             An <CODE>Jpeg2000</CODE> is the representation of a graphic element (JPEG)
             that has to be inserted into the document
            
             @see		Element
             @see		Image
        </member>
        <member name="M:iTextSharp.text.Jpeg2000.#ctor(System.Uri)">
             Constructs a <CODE>Jpeg2000</CODE>-object, using an <VAR>url</VAR>.
            
             @param		url			the <CODE>URL</CODE> where the image can be found
             @throws BadElementException
             @throws IOException
        </member>
        <member name="M:iTextSharp.text.Jpeg2000.#ctor(System.Byte[])">
             Constructs a <CODE>Jpeg2000</CODE>-object from memory.
            
             @param		img		the memory image
             @throws BadElementException
             @throws IOException
        </member>
        <member name="M:iTextSharp.text.Jpeg2000.#ctor(System.Byte[],System.Single,System.Single)">
             Constructs a <CODE>Jpeg2000</CODE>-object from memory.
            
             @param		img			the memory image.
             @param		width		the width you want the image to have
             @param		height		the height you want the image to have
             @throws BadElementException
             @throws IOException
        </member>
        <member name="M:iTextSharp.text.Jpeg2000.ProcessParameters">
            This method checks if the image is a valid JPEG and processes some parameters.
            @throws BadElementException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.Jpeg2000.IsJp2">
            @return <code>true</code> if the image is JP2, <code>false</code> if a codestream.
        </member>
        <member name="T:iTextSharp.text.ListItem">
            <summary>
            A ListItem is a Paragraph
            that can be added to a List.
            </summary>
            <example>
            <B>Example 1:</B>
            <code>
            List list = new List(true, 20);
            list.Add(<strong>new ListItem("First line")</strong>);
            list.Add(<strong>new ListItem("The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?")</strong>);
            list.Add(<strong>new ListItem("Third line")</strong>);
            </code>
            
            The result of this code looks like this:
            <OL>
                   <LI>
                       First line
                   </LI>
                   <LI>
                       The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?
                   </LI>
                   <LI>
                       Third line
                   </LI>
               </OL>
               
            <B>Example 2:</B>
            <code>
            List overview = new List(false, 10);
            overview.Add(<strong>new ListItem("This is an item")</strong>);
            overview.Add("This is another item");
            </code>
            
            The result of this code looks like this:
            <UL>
                   <LI>
                       This is an item
                   </LI>
                   <LI>
                       This is another item
                   </LI>
               </UL>
            </example>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.List"/>
            <seealso cref="T:iTextSharp.text.Paragraph"/>
        </member>
        <member name="T:iTextSharp.text.Paragraph">
            <summary>
            A Paragraph is a series of Chunks and/or Phrases.
            </summary>
            <remarks>
            A Paragraph has the same qualities of a Phrase, but also
            some additional layout-parameters:
            <UL>
            <LI/>the indentation
            <LI/>the alignment of the text
            </UL>
            </remarks>
            <example>
            <code>
            <strong>Paragraph p = new Paragraph("This is a paragraph",
                           FontFactory.GetFont(FontFactory.HELVETICA, 18, Font.BOLDITALIC, new BaseColor(0, 0, 255)));</strong>
               </code>
            </example>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Phrase"/>
            <seealso cref="T:iTextSharp.text.ListItem"/>
        </member>
        <member name="F:iTextSharp.text.Paragraph.alignment">
            <summary> The alignment of the text. </summary>
        </member>
        <member name="F:iTextSharp.text.Paragraph.indentationLeft">
            <summary> The indentation of this paragraph on the left side. </summary>
        </member>
        <member name="F:iTextSharp.text.Paragraph.indentationRight">
            <summary> The indentation of this paragraph on the right side. </summary>
        </member>
        <member name="F:iTextSharp.text.Paragraph.firstLineIndent">
            Holds value of property firstLineIndent.
        </member>
        <member name="F:iTextSharp.text.Paragraph.spacingBefore">
            The spacing before the paragraph. 
        </member>
        <member name="F:iTextSharp.text.Paragraph.spacingAfter">
            The spacing after the paragraph. 
        </member>
        <member name="F:iTextSharp.text.Paragraph.extraParagraphSpace">
            Holds value of property extraParagraphSpace.
        </member>
        <member name="F:iTextSharp.text.Paragraph.keeptogether">
            <summary> Does the paragraph has to be kept together on 1 page. </summary>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor">
            <summary>
            Constructs a Paragraph.
            </summary>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.Single)">
            <summary>
            Constructs a Paragraph with a certain leading.
            </summary>
            <param name="leading">the leading</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(iTextSharp.text.Chunk)">
            <summary>
            Constructs a Paragraph with a certain Chunk.
            </summary>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.Single,iTextSharp.text.Chunk)">
            <summary>
            Constructs a Paragraph with a certain Chunk
            and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.String)">
            <summary>
            Constructs a Paragraph with a certain string.
            </summary>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.String,iTextSharp.text.Font)">
            <summary>
            Constructs a Paragraph with a certain string
            and a certain Font.
            </summary>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.Single,System.String)">
            <summary>
            Constructs a Paragraph with a certain string
            and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(System.Single,System.String,iTextSharp.text.Font)">
            <summary>
            Constructs a Paragraph with a certain leading, string
            and Font.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.#ctor(iTextSharp.text.Phrase)">
            <summary>
            Constructs a Paragraph with a certain Phrase.
            </summary>
            <param name="phrase">a Phrase</param>
        </member>
        <member name="M:iTextSharp.text.Paragraph.CloneShallow(System.Boolean)">
            Creates a shallow clone of the Paragraph.
            @return
        </member>
        <member name="M:iTextSharp.text.Paragraph.cloneShallow(System.Boolean)">
            Creates a shallow clone of the Paragraph.
            @return
        </member>
        <member name="M:iTextSharp.text.Paragraph.BreakUp">
            Breaks this Paragraph up in different parts, separating paragraphs, lists and tables from each other.
            @return
        </member>
        <member name="M:iTextSharp.text.Paragraph.breakUp">
            Breaks this Paragraph up in different parts, separating paragraphs, lists and tables from each other.
            @return
        </member>
        <member name="M:iTextSharp.text.Paragraph.Add(iTextSharp.text.IElement)">
            <summary>
            Adds an Object to the Paragraph.
            </summary>
            <param name="o">the object to add</param>
            <returns>a bool</returns>
        </member>
        <member name="P:iTextSharp.text.Paragraph.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.Paragraph.Alignment">
            <summary>
            Get/set the alignment of this paragraph.
            </summary>
            <value>a integer</value>
        </member>
        <member name="P:iTextSharp.text.Paragraph.IndentationLeft">
            <summary>
            Get/set the indentation of this paragraph on the left side.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Paragraph.IndentationRight">
            <summary>
            Get/set the indentation of this paragraph on the right side.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.Paragraph.KeepTogether">
            <summary>
            Set/get if this paragraph has to be kept together on one page.
            </summary>
            <value>a bool</value>
        </member>
        <member name="F:iTextSharp.text.ListItem.symbol">
            <summary> this is the symbol that wil proceed the listitem. </summary>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor">
            <summary>
            Constructs a ListItem.
            </summary>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.Single)">
            <summary>
               Constructs a ListItem with a certain leading.
            </summary>
            <param name="leading">the leading</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(iTextSharp.text.Chunk)">
            <summary>
            Constructs a ListItem with a certain Chunk.
            </summary>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.String)">
            <summary>
            Constructs a ListItem with a certain string.
            </summary>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.String,iTextSharp.text.Font)">
            <summary>
            Constructs a ListItem with a certain string
            and a certain Font.
            </summary>
            <param name="str">a string</param>
            <param name="font">a string</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.Single,iTextSharp.text.Chunk)">
            <summary>
            Constructs a ListItem with a certain Chunk
            and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="chunk">a Chunk</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.Single,System.String)">
            <summary>
            Constructs a ListItem with a certain string
            and a certain leading.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(System.Single,System.String,iTextSharp.text.Font)">
             Constructs a ListItem with a certain leading, string
             and Font.
            
             @param    leading        the leading
             @param    string        a string
             @param    font        a Font
            <summary>
            Constructs a ListItem with a certain leading, string
            and Font.
            </summary>
            <param name="leading">the leading</param>
            <param name="str">a string</param>
            <param name="font">a Font</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.#ctor(iTextSharp.text.Phrase)">
            <summary>
            Constructs a ListItem with a certain Phrase.
            </summary>
            <param name="phrase">a Phrase</param>
        </member>
        <member name="M:iTextSharp.text.ListItem.SetIndentationLeft(System.Single,System.Boolean)">
             Sets the indentation of this paragraph on the left side.
            
             @param	indentation		the new indentation
        </member>
        <member name="M:iTextSharp.text.ListItem.AdjustListSymbolFont">
            Changes the font of the list symbol to the font of the first chunk
            in the list item.
            @since 5.0.6
        </member>
        <member name="P:iTextSharp.text.ListItem.Type">
            <summary>
            Gets the type of the text element.
            </summary>
            <value>a type</value>
        </member>
        <member name="P:iTextSharp.text.ListItem.ListSymbol">
            <summary>
            Get/set the listsymbol.
            </summary>
            <value>a Chunk</value>
        </member>
        <member name="T:iTextSharp.text.MarkedObject">
             Wrapper that allows to add properties to 'basic building block' objects.
             Before iText 1.5 every 'basic building block' implemented the MarkupAttributes interface.
             By setting attributes, you could add markup to the corresponding XML and/or HTML tag.
             This functionality was hardly used by anyone, so it was removed, and replaced by
             the MarkedObject functionality.
            
             @deprecated since 5.5.9. This class is no longer used.
        </member>
        <member name="F:iTextSharp.text.MarkedObject.element">
            The element that is wrapped in a MarkedObject. 
        </member>
        <member name="F:iTextSharp.text.MarkedObject.markupAttributes">
            Contains extra markupAttributes 
        </member>
        <member name="M:iTextSharp.text.MarkedObject.#ctor">
            This constructor is for internal use only.
        </member>
        <member name="M:iTextSharp.text.MarkedObject.#ctor(iTextSharp.text.IElement)">
            Creates a MarkedObject.
        </member>
        <member name="M:iTextSharp.text.MarkedObject.Process(iTextSharp.text.IElementListener)">
             Processes the element by adding it (or the different parts) to an
             <CODE>ElementListener</CODE>.
            
             @param       listener        an <CODE>ElementListener</CODE>
             @return <CODE>true</CODE> if the element was processed successfully
        </member>
        <member name="M:iTextSharp.text.MarkedObject.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.MarkedObject.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="P:iTextSharp.text.MarkedObject.Chunks">
             Gets all the chunks in this element.
            
             @return  an <CODE>ArrayList</CODE>
        </member>
        <member name="P:iTextSharp.text.MarkedObject.Type">
             Gets the type of the text element.
            
             @return  a type
        </member>
        <member name="P:iTextSharp.text.MarkedObject.MarkupAttributes">
            @return the markupAttributes
        </member>
        <member name="T:iTextSharp.text.MarkedSection">
             Wrapper that allows to add properties to a Chapter/Section object.
             Before iText 1.5 every 'basic building block' implemented the MarkupAttributes interface.
             By setting attributes, you could add markup to the corresponding XML and/or HTML tag.
             This functionality was hardly used by anyone, so it was removed, and replaced by
             the MarkedObject functionality.
            
             @deprecated since 5.5.9. This class is no longer used.
        </member>
        <member name="F:iTextSharp.text.MarkedSection.title">
            This is the title of this section. 
        </member>
        <member name="M:iTextSharp.text.MarkedSection.#ctor(iTextSharp.text.Section)">
            Creates a MarkedObject with a Section or Chapter object.
            @param section   the marked section
        </member>
        <member name="M:iTextSharp.text.MarkedSection.Add(System.Int32,iTextSharp.text.IElement)">
             Adds a <CODE>Paragraph</CODE>, <CODE>List</CODE> or <CODE>Table</CODE>
             to this <CODE>Section</CODE>.
            
             @param   index   index at which the specified element is to be inserted
             @param   o       an object of type <CODE>Paragraph</CODE>, <CODE>List</CODE> or <CODE>Table</CODE>=
             @throws  ClassCastException if the object is not a <CODE>Paragraph</CODE>, <CODE>List</CODE> or <CODE>Table</CODE>
        </member>
        <member name="M:iTextSharp.text.MarkedSection.Add(iTextSharp.text.IElement)">
             Adds a <CODE>Paragraph</CODE>, <CODE>List</CODE>, <CODE>Table</CODE> or another <CODE>Section</CODE>
             to this <CODE>Section</CODE>.
            
             @param   o       an object of type <CODE>Paragraph</CODE>, <CODE>List</CODE>, <CODE>Table</CODE> or another <CODE>Section</CODE>
             @return  a bool
             @throws  ClassCastException if the object is not a <CODE>Paragraph</CODE>, <CODE>List</CODE>, <CODE>Table</CODE> or <CODE>Section</CODE>
        </member>
        <member name="M:iTextSharp.text.MarkedSection.Process(iTextSharp.text.IElementListener)">
             Processes the element by adding it (or the different parts) to an
             <CODE>ElementListener</CODE>.
            
             @param       listener        an <CODE>ElementListener</CODE>
             @return <CODE>true</CODE> if the element was processed successfully
        </member>
        <member name="M:iTextSharp.text.MarkedSection.AddAll``1(System.Collections.Generic.ICollection{``0})">
             Adds a collection of <CODE>Element</CODE>s
             to this <CODE>Section</CODE>.
            
             @param   collection  a collection of <CODE>Paragraph</CODE>s, <CODE>List</CODE>s and/or <CODE>Table</CODE>s
             @return  <CODE>true</CODE> if the action succeeded, <CODE>false</CODE> if not.
             @throws  ClassCastException if one of the objects isn't a <CODE>Paragraph</CODE>, <CODE>List</CODE>, <CODE>Table</CODE>
        </member>
        <member name="M:iTextSharp.text.MarkedSection.AddSection(System.Single,System.Int32)">
             Creates a <CODE>Section</CODE>, adds it to this <CODE>Section</CODE> and returns it.
            
             @param   indentation the indentation of the new section
             @param   numberDepth the numberDepth of the section
             @return  a new Section object
        </member>
        <member name="M:iTextSharp.text.MarkedSection.AddSection(System.Single)">
             Creates a <CODE>Section</CODE>, adds it to this <CODE>Section</CODE> and returns it.
            
             @param   indentation the indentation of the new section
             @return  a new Section object
        </member>
        <member name="M:iTextSharp.text.MarkedSection.AddSection(System.Int32)">
             Creates a <CODE>Section</CODE>, add it to this <CODE>Section</CODE> and returns it.
            
             @param   numberDepth the numberDepth of the section
             @return  a new Section object
        </member>
        <member name="M:iTextSharp.text.MarkedSection.AddSection">
             Creates a <CODE>Section</CODE>, adds it to this <CODE>Section</CODE> and returns it.
            
             @return  a new Section object
        </member>
        <member name="M:iTextSharp.text.MarkedSection.NewPage">
            Adds a new page to the section.
            @since    2.1.1
        </member>
        <member name="P:iTextSharp.text.MarkedSection.Title">
             Sets the title of this section.
            
             @param   title   the new title
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.MarkedSection.NumberDepth" -->
        <member name="P:iTextSharp.text.MarkedSection.IndentationLeft">
             Sets the indentation of this <CODE>Section</CODE> on the left side.
            
             @param   indentation     the indentation
        </member>
        <member name="P:iTextSharp.text.MarkedSection.IndentationRight">
             Sets the indentation of this <CODE>Section</CODE> on the right side.
            
             @param   indentation     the indentation
        </member>
        <member name="P:iTextSharp.text.MarkedSection.Indentation">
             Sets the indentation of the content of this <CODE>Section</CODE>.
            
             @param   indentation     the indentation
        </member>
        <member name="P:iTextSharp.text.MarkedSection.BookmarkOpen">
            Setter for property bookmarkOpen.
            @param bookmarkOpen false if the bookmark children are not
            visible.
        </member>
        <member name="P:iTextSharp.text.MarkedSection.TriggerNewPage">
            Setter for property triggerNewPage.
            @param triggerNewPage true if a new page has to be triggered.
        </member>
        <member name="P:iTextSharp.text.MarkedSection.BookmarkTitle">
            Sets the bookmark title. The bookmark title is the same as the section title but
            can be changed with this method.
            @param bookmarkTitle the bookmark title
        </member>
        <member name="T:iTextSharp.text.PageSize">
            <summary>
            The PageSize-object contains a number of read only rectangles representing the most common paper sizes.
            </summary>
            <seealso cref="T:iTextSharp.text.RectangleReadOnly"/>
        </member>
        <member name="F:iTextSharp.text.PageSize.LETTER">
            This is the letter format 
        </member>
        <member name="F:iTextSharp.text.PageSize.NOTE">
            This is the note format 
        </member>
        <member name="F:iTextSharp.text.PageSize.LEGAL">
            This is the legal format 
        </member>
        <member name="F:iTextSharp.text.PageSize.TABLOID">
            This is the tabloid format 
        </member>
        <member name="F:iTextSharp.text.PageSize.EXECUTIVE">
            This is the executive format 
        </member>
        <member name="F:iTextSharp.text.PageSize.POSTCARD">
            This is the postcard format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A0">
            This is the a0 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A1">
            This is the a1 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A2">
            This is the a2 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A3">
            This is the a3 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A4">
            This is the a4 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A5">
            This is the a5 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A6">
            This is the a6 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A7">
            This is the a7 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A8">
            This is the a8 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A9">
            This is the a9 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.A10">
            This is the a10 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B0">
            This is the b0 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B1">
            This is the b1 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B2">
            This is the b2 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B3">
            This is the b3 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B4">
            This is the b4 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B5">
            This is the b5 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B6">
            This is the b6 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B7">
            This is the b7 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B8">
            This is the b8 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B9">
            This is the b9 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.B10">
            This is the b10 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ARCH_E">
            This is the archE format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ARCH_D">
            This is the archD format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ARCH_C">
            This is the archC format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ARCH_B">
            This is the archB format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ARCH_A">
            This is the archA format 
        </member>
        <member name="F:iTextSharp.text.PageSize.FLSA">
            This is the American Foolscap format 
        </member>
        <member name="F:iTextSharp.text.PageSize.FLSE">
            This is the European Foolscap format 
        </member>
        <member name="F:iTextSharp.text.PageSize.HALFLETTER">
            This is the halfletter format 
        </member>
        <member name="F:iTextSharp.text.PageSize._11X17">
            This is the 11x17 format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ID_1">
            This is the ISO 7810 ID-1 format (85.60 x 53.98 mm or 3.370 x 2.125 inch) 
        </member>
        <member name="F:iTextSharp.text.PageSize.ID_2">
            This is the ISO 7810 ID-2 format (A7 rotated) 
        </member>
        <member name="F:iTextSharp.text.PageSize.ID_3">
            This is the ISO 7810 ID-3 format (B7 rotated) 
        </member>
        <member name="F:iTextSharp.text.PageSize.LEDGER">
            This is the ledger format 
        </member>
        <member name="F:iTextSharp.text.PageSize.CROWN_QUARTO">
            This is the Crown Quarto format 
        </member>
        <member name="F:iTextSharp.text.PageSize.LARGE_CROWN_QUARTO">
            This is the Large Crown Quarto format 
        </member>
        <member name="F:iTextSharp.text.PageSize.DEMY_QUARTO">
            This is the Demy Quarto format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.ROYAL_QUARTO">
            This is the Royal Quarto format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.CROWN_OCTAVO">
            This is the Crown Octavo format 
        </member>
        <member name="F:iTextSharp.text.PageSize.LARGE_CROWN_OCTAVO">
            This is the Large Crown Octavo format 
        </member>
        <member name="F:iTextSharp.text.PageSize.DEMY_OCTAVO">
            This is the Demy Octavo format 
        </member>
        <member name="F:iTextSharp.text.PageSize.ROYAL_OCTAVO">
            This is the Royal Octavo format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.SMALL_PAPERBACK">
            This is the small paperback format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.PENGUIN_SMALL_PAPERBACK">
            This is the Pengiun small paperback format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.PENGUIN_LARGE_PAPERBACK">
            This is the Penguin large paparback format. 
        </member>
        <member name="F:iTextSharp.text.PageSize.LETTER_LANDSCAPE">
            This is the letter format
            @since iText 5.0.6
        </member>
        <member name="F:iTextSharp.text.PageSize.LEGAL_LANDSCAPE">
            This is the legal format
            @since iText 5.0.6
        </member>
        <member name="F:iTextSharp.text.PageSize.A4_LANDSCAPE">
            This is the a4 format
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.PageSize.GetRectangle(System.String)">
            This method returns a Rectangle based on a String.
            Possible values are the the names of a constant in this class
            (for instance "A4", "LETTER",...) or a value like "595 842"
        </member>
        <member name="T:iTextSharp.text.pdf.AcroFields">
            Query and change fields in existing documents either by method
            calls or by FDF merging.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_NONE">
            A field type invalid or not found.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_PUSHBUTTON">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_CHECKBOX">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_RADIOBUTTON">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_TEXT">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_LIST">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_COMBO">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.FIELD_TYPE_SIGNATURE">
            A field type.
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.generateAppearances">
            Holds value of property generateAppearances. 
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetAppearanceStates(System.String)">
            Gets the list of appearance names. Use it to get the names allowed
             with radio and checkbox fields. If the /Opt key exists the values will
             also be included. The name 'Off' may also be valid
             even if not returned in the list.
              
             For Comboboxes it will return an array of display values. To extract the
             export values of a Combobox, please refer to {@link AcroFields#getListOptionExport(String)}
            
             @param fieldName the fully qualified field name
             @return the list of names or <CODE>null</CODE> if the field does not exist
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetListOptionExport(System.String)">
            Gets the list of export option values from fields of type list or combo.
            If the field doesn't exist or the field type is not list or combo it will return
            <CODE>null</CODE>.
            @param fieldName the field name
            @return the list of export option values from fields of type list or combo
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetListOptionDisplay(System.String)">
            Gets the list of display option values from fields of type list or combo.
            If the field doesn't exist or the field type is not list or combo it will return
            <CODE>null</CODE>.
            @param fieldName the field name
            @return the list of export option values from fields of type list or combo
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.AcroFields.SetListOption(System.String,System.String[],System.String[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.AcroFields.GetFieldType(System.String)" -->
        <member name="M:iTextSharp.text.pdf.AcroFields.ExportAsFdf(iTextSharp.text.pdf.FdfWriter)">
            Export the fields as a FDF.
            @param writer the FDF writer
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RenameField(System.String,System.String)">
            Renames a field. Only the last part of the name can be renamed. For example,
            if the original field is "ab.cd.ef" only the "ef" part can be renamed.
            @param oldName the old field name
            @param newName the new field name
            @return <CODE>true</CODE> if the renaming was successful, <CODE>false</CODE>
            otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetFieldRichValue(System.String)">
            Retrieve the rich value for the given field
            @param name
            @return The rich value if present, or null.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetField(System.String)">
            Gets the field value.
            @param name the fully qualified field name
            @return the field value
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetListSelection(System.String)">
            Gets the field values of a Choice field.
            @param name the fully qualified field name
            @return the field value
            @since 2.1.3
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.AcroFields.SetFieldProperty(System.String,System.String,System.Object,System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.AcroFields.SetFieldProperty(System.String,System.String,System.Int32,System.Int32[])" -->
        <member name="M:iTextSharp.text.pdf.AcroFields.MergeXfaData(System.Xml.XmlNode)">
            Merges an XML data structure into this form.
            @param n the top node of the data structure
            @throws java.io.IOException on error
            @throws com.lowagie.text.DocumentException o error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetFields(iTextSharp.text.pdf.FdfReader)">
            Sets the fields by FDF merging.
            @param fdf the FDF form
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetFields(iTextSharp.text.pdf.XfdfReader)">
            Sets the fields by XFDF merging.
            @param xfdf the XFDF form
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RegenerateField(System.String)">
            Regenerates the field appearance.
            This is usefull when you change a field property, but not its value,
            for instance form.SetFieldProperty("f", "bgcolor", BaseColor.BLUE, null);
            This won't have any effect, unless you use RegenerateField("f") after changing
            the property.
            
            @param name the fully qualified field name or the partial name in the case of XFA forms
            @throws IOException on error
            @throws DocumentException on error
            @return <CODE>true</CODE> if the field was found and changed,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetField(System.String,System.String)">
            Sets the field value.
            @param name the fully qualified field name or the partial name in the case of XFA forms
            @param value the field value
            @throws IOException on error
            @throws DocumentException on error
            @return <CODE>true</CODE> if the field was found and changed,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetField(System.String,System.String,System.Boolean)">
            Sets the field value.
            @param name the fully qualified field name or the partial name in the case of XFA forms
            @param value the field value
            @param saveAppearance save the current appearance of the field or not
            @throws IOException on error
            @throws DocumentException on error
            @return <CODE>true</CODE> if the field was found and changed,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetFieldRichValue(System.String,System.String)">
            Sets the rich value for the given field.  See <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/pdf/pdfs/PDF32000_2008.pdf">PDF Reference</a> chapter 
            12.7.3.4 (Rich Text) and 12.7.4.3 (Text Fields) for further details. Note that iText doesn't create an appearance for Rich Text fields.
            So you either need to use XML Worker to create an appearance (/N entry in the /AP dictionary), or you need to use setGenerateAppearances(false) to tell the viewer
            that iText didn't create any appearances.
            @param name  Field name
            @param richValue html markup 
            @return success/failure (will fail if the field isn't found, isn't a text field, or doesn't support rich text)
            @throws DocumentException
            @throws IOException 
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetField(System.String,System.String,System.String)">
            Sets the field value and the display string. The display string
            is used to build the appearance in the cases where the value
            is modified by Acrobat with JavaScript and the algorithm is
            known.
            @param name the fully qualified field name or the partial name in the case of XFA forms
            @param value the field value
            @param display the string that is used for the appearance. If <CODE>null</CODE>
            the <CODE>value</CODE> parameter will be used
            @return <CODE>true</CODE> if the field was found and changed,
            <CODE>false</CODE> otherwise
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetField(System.String,System.String,System.String,System.Boolean)">
            Sets the field value and the display string. The display string
            is used to build the appearance in the cases where the value
            is modified by Acrobat with JavaScript and the algorithm is
            known.
            @param name the fully qualified field name or the partial name in the case of XFA forms
            @param value the field value
            @param display the string that is used for the appearance. If <CODE>null</CODE>
            the <CODE>value</CODE> parameter will be used
            @param saveAppearance save the current appearance of the field or not
            @return <CODE>true</CODE> if the field was found and changed,
            <CODE>false</CODE> otherwise
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetListSelection(System.String,System.String[])">
            Sets different values in a list selection.
            No appearance is generated yet; nor does the code check if multiple select is allowed.
            
            @param    name    the name of the field
            @param    value   an array with values that need to be selected
            @return   true only if the field value was changed
            @since 2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetFieldItem(System.String)">
            Gets the field structure.
            @param name the name of the field
            @return the field structure or <CODE>null</CODE> if the field
            does not exist
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetTranslatedFieldName(System.String)">
            Gets the long XFA translated name.
            @param name the name of the field
            @return the long field name
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetFieldPositions(System.String)">
            Gets the field box positions in the document. The return is an array of <CODE>float</CODE>
            multiple of 5. For each of this groups the values are: [page, llx, lly, urx,
            ury]. The coordinates have the page rotation in consideration.
            @param name the field name
            @return the positions or <CODE>null</CODE> if field does not exist
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RemoveFieldsFromPage(System.Int32)">
            Removes all the fields from <CODE>page</CODE>.
            @param page the page to remove the fields from
            @return <CODE>true</CODE> if any field was removed, <CODE>false otherwise</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RemoveField(System.String,System.Int32)">
            Removes a field from the document. If page equals -1 all the fields with this
            <CODE>name</CODE> are removed from the document otherwise only the fields in
            that particular page are removed.
            @param name the field name
            @param page the page to remove the field from or -1 to remove it from all the pages
            @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RemoveField(System.String)">
            Removes a field from the document.
            @param name the field name
            @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.ClearSignatureField(System.String)">
            Clears a signed field.
            @param name the field name
            @return true if the field was signed, false if the field was not signed or not found
            @since 5.0.5
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetSignatureNames">
            Gets the field names that have signatures and are signed.
            @return the field names that have signatures and are signed
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetBlankSignatureNames">
            Gets the field names that have blank signatures.
            @return the field names that have blank signatures
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetSignatureDictionary(System.String)">
            Gets the signature dictionary, the one keyed by /V.
            @param name the field name
            @return the signature dictionary keyed by /V or <CODE>null</CODE> if the field is not
            a signature
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetNormalAppearance(System.String)">
             Gets a reference to the normal appearance of a field.
            
             @param name the field name
             @return a reference to the /N entry of the /AP dictionary or <CODE>null</CODE> if the field is not found
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SignatureCoversWholeDocument(System.String)">
            Checks is the signature covers the entire document or just part of it.
            @param name the signature field name
            @return <CODE>true</CODE> if the signature covers the entire document,
            <CODE>false</CODE> otherwise
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.AcroFields.VerifySignature(System.String)" -->
        <member name="M:iTextSharp.text.pdf.AcroFields.GetRevision(System.String)">
            Gets this <CODE>field</CODE> revision.
            @param field the signature field name
            @return the revision or zero if it's not a signature field
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.ExtractRevision(System.String)">
            Extracts a revision from the document.
            @param field the signature field name
            @return an <CODE>Stream</CODE> covering the revision. Returns <CODE>null</CODE> if
            it's not a signature field
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.SetExtraMargin(System.Single,System.Single)">
            Sets extra margins in text fields to better mimic the Acrobat layout.
            @param extraMarginLeft the extra marging left
            @param extraMarginTop the extra margin top
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.AddSubstitutionFont(iTextSharp.text.pdf.BaseFont)">
            Adds a substitution font to the list. The fonts in this list will be used if the original
            font doesn't contain the needed glyphs.
            @param font the font
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.fieldCache">
            Holds value of property fieldCache.
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.RemoveXfa">
            Removes the XFA stream from the document.
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetNewPushbuttonFromField(System.String)">
            Creates a new pushbutton from an existing field. If there are several pushbuttons with the same name
            only the first one is used. This pushbutton can be changed and be used to replace 
            an existing one, with the same name or other name, as long is it is in the same document. To replace an existing pushbutton
            call {@link #replacePushbuttonField(String,PdfFormField)}.
            @param field the field name that should be a pushbutton
            @return a new pushbutton or <CODE>null</CODE> if the field is not a pushbutton
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.GetNewPushbuttonFromField(System.String,System.Int32)">
            Creates a new pushbutton from an existing field. This pushbutton can be changed and be used to replace 
            an existing one, with the same name or other name, as long is it is in the same document. To replace an existing pushbutton
            call {@link #replacePushbuttonField(String,PdfFormField,int)}.
            @param field the field name that should be a pushbutton
            @param order the field order in fields with same name
            @return a new pushbutton or <CODE>null</CODE> if the field is not a pushbutton
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.ReplacePushbuttonField(System.String,iTextSharp.text.pdf.PdfFormField)">
            Replaces the first field with a new pushbutton. The pushbutton can be created with
            {@link #getNewPushbuttonFromField(String)} from the same document or it can be a
            generic PdfFormField of the type pushbutton.
            @param field the field name
            @param button the <CODE>PdfFormField</CODE> representing the pushbutton
            @return <CODE>true</CODE> if the field was replaced, <CODE>false</CODE> if the field
            was not a pushbutton
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.ReplacePushbuttonField(System.String,iTextSharp.text.pdf.PdfFormField,System.Int32)">
            Replaces the designated field with a new pushbutton. The pushbutton can be created with
            {@link #getNewPushbuttonFromField(String,int)} from the same document or it can be a
            generic PdfFormField of the type pushbutton.
            @param field the field name
            @param button the <CODE>PdfFormField</CODE> representing the pushbutton
            @param order the field order in fields with same name
            @return <CODE>true</CODE> if the field was replaced, <CODE>false</CODE> if the field
            was not a pushbutton
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.DoesSignatureFieldExist(System.String)">
            Checks whether a name exists as a signature field or not. It checks both signed fields and blank signatures.
            @param name String
            @return boolean does the signature field exist
            @since 5.5.1
        </member>
        <member name="P:iTextSharp.text.pdf.AcroFields.Fields">
            Gets all the fields. The fields are keyed by the fully qualified field name and
            the value is an instance of <CODE>AcroFields.Item</CODE>.
            @return all the fields
        </member>
        <member name="P:iTextSharp.text.pdf.AcroFields.GenerateAppearances">
            Sets the option to generate appearances. Not generating apperances
            will speed-up form filling but the results can be
            unexpected in Acrobat. Don't use it unless your environment is well
            controlled. The default is <CODE>true</CODE>.
            @param generateAppearances the option to generate appearances
        </member>
        <member name="P:iTextSharp.text.pdf.AcroFields.TotalRevisions">
            Gets the total number of revisions this document has.
            @return the total number of revisions
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.AcroFields.FieldCache" -->
        <member name="P:iTextSharp.text.pdf.AcroFields.SubstitutionFonts">
            Sets a list of substitution fonts. The list is composed of <CODE>BaseFont</CODE> and can also be <CODE>null</CODE>. The fonts in this list will be used if the original
            font doesn't contain the needed glyphs.
            @param substitutionFonts the list
        </member>
        <member name="P:iTextSharp.text.pdf.AcroFields.Xfa">
            Gets the XFA form processor.
            @return the XFA form processor
        </member>
        <member name="T:iTextSharp.text.pdf.AcroFields.Item">
            The field representations for retrieval and modification. 
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.WRITE_MERGED">
            <CODE>writeToAll</CODE> constant.
            
             @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.WRITE_WIDGET">
            <CODE>writeToAll</CODE> and <CODE>markUsed</CODE> constant.
            
             @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.WRITE_VALUE">
            <CODE>writeToAll</CODE> and <CODE>markUsed</CODE> constant.
            
             @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.WriteToAll(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject,System.Int32)">
             This function writes the given key/value pair to all the instances
             of merged, widget, and/or value, depending on the <code>writeFlags</code> setting
            
             @since 2.1.5
            
             @param key        you'll never guess what this is for.
             @param value      if value is null, the key will be removed
             @param writeFlags ORed together WRITE_* flags
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.MarkUsed(iTextSharp.text.pdf.AcroFields,System.Int32)">
            Mark all the item dictionaries used matching the given flags
            
            @since 2.1.5
            @param writeFlags WRITE_MERGED is ignored
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.values">
            An array of <CODE>PdfDictionary</CODE> where the value tag /V
            is present.
            
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.widgets">
            An array of <CODE>PdfDictionary</CODE> with the widgets.
            
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.widget_refs">
            An array of <CODE>PdfDictionary</CODE> with the widget references.
            
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.merged">
            An array of <CODE>PdfDictionary</CODE> with all the field
            and widget tags merged.
            
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.page">
            An array of <CODE>Integer</CODE> with the page numbers where
            the widgets are displayed.
            
        </member>
        <member name="F:iTextSharp.text.pdf.AcroFields.Item.tabOrder">
            An array of <CODE>Integer</CODE> with the tab order of the field in the page.
            
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.Remove(System.Int32)">
            Remove the given instance from this item.  It is possible to
            remove all instances using this function.
            
            @since 2.1.5
            @param killIdx
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetValue(System.Int32)">
            Retrieve the value dictionary of the given instance
            
            @since 2.1.5
            @param idx instance index
            @return dictionary storing this instance's value.  It may be shared across instances.
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddValue(iTextSharp.text.pdf.PdfDictionary)">
            Add a value dict to this Item
            
            @since 2.1.5
            @param value new value dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetWidget(System.Int32)">
            Retrieve the widget dictionary of the given instance
            
            @since 2.1.5
            @param idx instance index
            @return The dictionary found in the appropriate page's Annot array.
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddWidget(iTextSharp.text.pdf.PdfDictionary)">
            Add a widget dict to this Item
            
            @since 2.1.5
            @param widget
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetWidgetRef(System.Int32)">
            Retrieve the reference to the given instance
            
            @since 2.1.5
            @param idx instance index
            @return reference to the given field instance
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddWidgetRef(iTextSharp.text.pdf.PdfIndirectReference)">
            Add a widget ref to this Item
            
            @since 2.1.5
            @param widgRef
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetMerged(System.Int32)">
            Retrieve the merged dictionary for the given instance.  The merged
            dictionary contains all the keys present in parent fields, though they
            may have been overwritten (or modified?) by children.
            Example: a merged radio field dict will contain /V
            
            @since 2.1.5
            @param idx  instance index
            @return the merged dictionary for the given instance
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddMerged(iTextSharp.text.pdf.PdfDictionary)">
            Adds a merged dictionary to this Item.
            
            @since 2.1.5
            @param mergeDict
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetPage(System.Int32)">
            Retrieve the page number of the given instance
            
            @since 2.1.5
            @param idx
            @return remember, pages are "1-indexed", not "0-indexed" like field instances.
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddPage(System.Int32)">
            Adds a page to the current Item.
            
            @since 2.1.5
            @param pg
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.ForcePage(System.Int32,System.Int32)">
            forces a page value into the Item.
            
            @since 2.1.5
            @param idx
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.GetTabOrder(System.Int32)">
            Gets the tabOrder.
            
            @since 2.1.5
            @param idx
            @return tab index of the given field instance
        </member>
        <member name="M:iTextSharp.text.pdf.AcroFields.Item.AddTabOrder(System.Int32)">
            Adds a tab order value to this Item.
            
            @since 2.1.5
            @param order
        </member>
        <member name="P:iTextSharp.text.pdf.AcroFields.Item.Size">
            Preferred method of determining the number of instances
            of a given field.
            
            @since 2.1.5
            @return number of instances
        </member>
        <member name="T:iTextSharp.text.pdf.AcroFields.FieldPosition">
            A class representing a field position
            @since 5.0.2
        </member>
        <member name="T:iTextSharp.text.pdf.BadPdfFormatException">
             Signals that a bad PDF format has been used to construct a <CODE>PdfObject</CODE>.
            
             @see        PdfException
             @see        PdfBoolean
             @see        PdfNumber
             @see        PdfString
             @see        PdfName
             @see        PdfDictionary
             @see        PdfFont
        </member>
        <member name="T:iTextSharp.text.pdf.Barcode">
            Base class containing properties and methods commom to all
             barcode types.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.EAN13">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.EAN8">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.UPCA">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.UPCE">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.SUPP2">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.SUPP5">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.POSTNET">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.PLANET">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.CODE128">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.CODE128_UCC">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.CODE128_RAW">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.CODABAR">
            A type of barcode 
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.x">
            The minimum bar width.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.n">
            The bar multiplier for wide bars or the distance between
            bars for Postnet and Planet.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.font">
            The text font. <CODE>null</CODE> if no text.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.size">
            The size of the text or the height of the shorter bar
            in Postnet.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.baseline">
            If positive, the text distance under the bars. If zero or negative,
            the text distance above the bars.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.barHeight">
            The height of the bars.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.textAlignment">
            The text Element. Can be <CODE>Element.ALIGN_LEFT</CODE>,
            <CODE>Element.ALIGN_CENTER</CODE> or <CODE>Element.ALIGN_RIGHT</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.generateChecksum">
            The optional checksum generation.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.checksumText">
            Shows the generated checksum in the the text.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.startStopText">
            Show the start and stop character '*' in the text for
            the barcode 39 or 'ABCD' for codabar.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.extended">
            Generates extended barcode 39.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.code">
            The code to generate.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.guardBars">
            Show the guard bars for barcode EAN.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.codeType">
            The code type.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.inkSpreading">
            The ink spreading. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.Barcode.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="M:iTextSharp.text.pdf.Barcode.CreateTemplateWithBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)">
            Creates a template with the barcode.
            @param cb the <CODE>PdfContentByte</CODE> to create the template. It
            serves no other use
            @param barColor the color of the bars. It can be <CODE>null</CODE>
            @param textColor the color of the text. It can be <CODE>null</CODE>
            @return the template
            @see #placeBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor)
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode.CreateImageWithBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)">
            Creates an <CODE>Image</CODE> with the barcode.
            @param cb the <CODE>PdfContentByte</CODE> to create the <CODE>Image</CODE>. It
            serves no other use
            @param barColor the color of the bars. It can be <CODE>null</CODE>
            @param textColor the color of the text. It can be <CODE>null</CODE>
            @return the <CODE>Image</CODE>
            @see #placeBarcode(PdfContentByte cb, BaseColor barColor, BaseColor textColor)
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode.altText">
            The alternate text to be used, if present.
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.X">
            Gets the minimum bar width.
            @return the minimum bar width
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.N">
            Gets the bar multiplier for wide bars.
            @return the bar multiplier for wide bars
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.Font">
            Gets the text font. <CODE>null</CODE> if no text.
            @return the text font. <CODE>null</CODE> if no text
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.Size">
            Gets the size of the text.
            @return the size of the text
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.Baseline">
            Gets the text baseline.
            If positive, the text distance under the bars. If zero or negative,
            the text distance above the bars.
            @return the baseline.
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.BarHeight">
            Gets the height of the bars.
            @return the height of the bars
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.TextAlignment">
            Gets the text Element. Can be <CODE>Element.ALIGN_LEFT</CODE>,
            <CODE>Element.ALIGN_CENTER</CODE> or <CODE>Element.ALIGN_RIGHT</CODE>.
            @return the text alignment
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.GenerateChecksum">
            The property for the optional checksum generation.
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.ChecksumText">
            Sets the property to show the generated checksum in the the text.
            @param checksumText new value of property checksumText
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.StartStopText">
            Gets the property to show the start and stop character '*' in the text for
            the barcode 39.
            @param startStopText new value of property startStopText
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.Extended">
            Sets the property to generate extended barcode 39.
            @param extended new value of property extended
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.Code">
            Gets the code to generate.
            @return the code to generate
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.GuardBars">
            Sets the property to show the guard bars for barcode EAN.
            @param guardBars new value of property guardBars
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.CodeType">
            Gets the code type.
            @return the code type
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="P:iTextSharp.text.pdf.Barcode.AltText">
            Sets the alternate text. If present, this text will be used instead of the
            text derived from the supplied code.
            @param altText the alternate text
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.Barcode128" -->
        <member name="F:iTextSharp.text.pdf.Barcode128.CODE_AB_TO_C">
            The charset code change.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.CODE_AC_TO_B">
            The charset code change.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.CODE_BC_TO_A">
            The charset code change.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.FNC1_INDEX">
            The code for UCC/EAN-128.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.START_A">
            The start code.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.START_B">
            The start code.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.START_C">
            The start code.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.BARS">
            The bars to generate the code.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode128.BARS_STOP">
            The stop bars.
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.#ctor">
            Creates new Barcode128 
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.RemoveFNC1(System.String)">
            Removes the FNC1 codes in the text.
            @param code the text to clean
            @return the cleaned text
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.GetHumanReadableUCCEAN(System.String)">
            Gets the human readable text of a sequence of AI.
            @param code the text
            @return the human readable text
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.IsNextDigits(System.String,System.Int32,System.Int32)">
            Returns <CODE>true</CODE> if the next <CODE>numDigits</CODE>
            starting from index <CODE>textIndex</CODE> are numeric skipping any FNC1.
            @param text the text to check
            @param textIndex where to check from
            @param numDigits the number of digits to check
            @return the check result
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.GetPackedRawDigits(System.String,System.Int32,System.Int32)">
            Packs the digits for charset C also considering FNC1. It assumes that all the parameters
            are valid.
            @param text the text to pack
            @param textIndex where to pack from
            @param numDigits the number of digits to pack. It is always an even number
            @return the packed digits, two digits per character
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.GetRawText(System.String,System.Boolean,iTextSharp.text.pdf.Barcode128.Barcode128CodeSet)">
            Converts the human readable text to the characters needed to
            create a barcode using the specified code set.
            @param text the text to convert
            @param ucc <CODE>true</CODE> if it is an UCC/EAN-128. In this case
            the character FNC1 is added
            @param codeSet forced code set, or AUTO for optimized barcode.
            @return the code ready to be fed to getBarsCode128Raw()
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.GetRawText(System.String,System.Boolean)">
            Converts the human readable text to the characters needed to
            create a barcode. Some optimization is done to get the shortest code.
            @param text the text to convert
            @param ucc <CODE>true</CODE> if it is an UCC/EAN-128. In this case
            the character FNC1 is added
            @return the code ready to be fed to getBarsCode128Raw()
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode128.GetBarsCode128Raw(System.String)">
            Generates the bars. The input has the actual barcodes, not
            the human readable text.
            @param text the barcode
            @return the bars
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.Barcode128.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.Barcode128.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.Barcode128.Code" -->
        <member name="T:iTextSharp.text.pdf.Barcode39">
            Implements the code 39 and code 39 extended. The default parameters are:
             <pre>
            x = 0.8f;
            n = 2;
            font = BaseFont.CreateFont("Helvetica", "winansi", false);
            size = 8;
            baseline = size;
            barHeight = size * 3;
            textint= Element.ALIGN_CENTER;
            generateChecksum = false;
            checksumText = false;
            startStopText = true;
            extended = false;
             </pre>
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode39.CHARS">
            The index chars to <CODE>BARS</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode39.EXTENDED">
            The character combinations to make the code 39 extended.
        </member>
        <member name="F:iTextSharp.text.pdf.Barcode39.BARS">
            The bars to generate the code.
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode39.#ctor">
            Creates a new Barcode39.
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode39.GetBarsCode39(System.String)">
            Creates the bars.
            @param text the text to create the bars. This text does not include the start and
            stop characters
            @return the bars
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode39.GetCode39Ex(System.String)">
            Converts the extended text into a normal, escaped text,
            ready to generate bars.
            @param text the extended text
            @return the escaped text
        </member>
        <member name="M:iTextSharp.text.pdf.Barcode39.GetChecksum(System.String)">
            Calculates the checksum.
            @param text the text
            @return the checksum
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.Barcode39.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.Barcode39.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="T:iTextSharp.text.pdf.BarcodeCodabar">
            Implements the code codabar. The default parameters are:
             <pre>
            x = 0.8f;
            n = 2;
            font = BaseFont.CreateFont("Helvetica", "winansi", false);
            size = 8;
            baseline = size;
            barHeight = size * 3;
            textAlignment = Element.ALIGN_CENTER;
            generateChecksum = false;
            checksumText = false;
            startStopText = false;
             </pre>
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeCodabar.CHARS">
            The index chars to <CODE>BARS</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeCodabar.BARS">
            The bars to generate the code.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeCodabar.#ctor">
            Creates a new BarcodeCodabar.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeCodabar.GetBarsCodabar(System.String)">
            Creates the bars.
            @param text the text to create the bars
            @return the bars
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeCodabar.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.BarcodeCodabar.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_NO_ERROR">
            No error.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_ERROR_TEXT_TOO_BIG">
            The text is too big for the symbology capabilities.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_ERROR_INVALID_SQUARE">
            The dimensions given for the symbol are illegal.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_ERROR_EXTENSION">
            An error while parsing an extension.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_AUTO">
            The best encodation will be used.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_ASCII">
            ASCII encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_C40">
            C40 encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_TEXT">
            TEXT encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_B256">
            Binary encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_X21">
            X21 encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_EDIFACT">
            EDIFACT encodation.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_RAW">
            No encodation needed. The bytes provided are already encoded.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_EXTENSION">
            Allows extensions to be embedded at the start of the text.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeDatamatrix.DM_TEST">
            Doesn't generate the image but returns all the other information.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeDatamatrix.#ctor">
            Creates an instance of this class.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeDatamatrix.Generate(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeDatamatrix.Generate(System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.BarcodeDatamatrix.CreateImage">
            Gets an <CODE>Image</CODE> with the barcode. A successful call to the method <CODE>generate()</CODE>
            before calling this method is required.
            @return the barcode <CODE>Image</CODE>
            @throws BadElementException on error
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeDatamatrix.CreateDrawingImage(System.Drawing.Color,System.Drawing.Color)">
            Creates a <CODE>java.awt.Image</CODE>. A successful call to the method <CODE>generate()</CODE>
            before calling this method is required.
            @param foreground the color of the bars
            @param background the color of the background
            @return the image
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodeDatamatrix.BitImage">
            Gets the generated image. The image is represented as a stream of bytes, each byte representing
            8 pixels, 0 for white and 1 for black, with the high-order bit of each byte first. Each row
            is aligned at byte boundaries. The dimensions of the image are defined by height and width
            plus 2 * ws.
            @return the generated image
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BarcodeDatamatrix.Height" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BarcodeDatamatrix.Width" -->
        <member name="P:iTextSharp.text.pdf.BarcodeDatamatrix.Ws">
            Gets/sets the whitespace border around the barcode.
            @param ws the whitespace border around the barcode
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BarcodeDatamatrix.Options" -->
        <member name="T:iTextSharp.text.pdf.BarcodeEAN">
            Generates barcodes in several formats: EAN13, EAN8, UPCA, UPCE,
             supplemental 2 and 5. The default parameters are:
             <pre>
            x = 0.8f;
            font = BaseFont.CreateFont("Helvetica", "winansi", false);
            size = 8;
            baseline = size;
            barHeight = size * 3;
            guardBars = true;
            codeType = EAN13;
            code = "";
             </pre>
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TOTALBARS_EAN13">
            The total number of bars for EAN13.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TOTALBARS_EAN8">
            The total number of bars for EAN8.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TOTALBARS_UPCE">
            The total number of bars for UPCE.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TOTALBARS_SUPP2">
            The total number of bars for supplemental 2.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TOTALBARS_SUPP5">
            The total number of bars for supplemental 5.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.ODD">
            Marker for odd parity.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.EVEN">
            Marker for even parity.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.GUARD_EMPTY">
            The bar positions that are guard bars.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.GUARD_UPCA">
            The bar positions that are guard bars.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.GUARD_EAN13">
            The bar positions that are guard bars.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.GUARD_EAN8">
            The bar positions that are guard bars.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.GUARD_UPCE">
            The bar positions that are guard bars.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TEXTPOS_EAN13">
            The x coordinates to place the text.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.TEXTPOS_EAN8">
            The x coordinates to place the text.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.BARS">
            The basic bar widths.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.PARITY13">
            Sequence of parities to be used with EAN13.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.PARITY2">
            Sequence of parities to be used with supplemental 2.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.PARITY5">
            Sequence of parities to be used with supplemental 2.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEAN.PARITYE">
            Sequence of parities to be used with UPCE.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.#ctor">
            Creates new BarcodeEAN 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.CalculateEANParity(System.String)">
            Calculates the EAN parity character.
            @param code the code
            @return the parity character
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.ConvertUPCAtoUPCE(System.String)">
            Converts an UPCA code into an UPCE code. If the code can not
            be converted a <CODE>null</CODE> is returned.
            @param text the code to convert. It must have 12 numeric characters
            @return the 8 converted digits or <CODE>null</CODE> if the
            code could not be converted
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.GetBarsEAN13(System.String)">
            Creates the bars for the barcode EAN13 and UPCA.
            @param _code the text with 13 digits
            @return the barcode
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.GetBarsEAN8(System.String)">
            Creates the bars for the barcode EAN8.
            @param _code the text with 8 digits
            @return the barcode
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.GetBarsUPCE(System.String)">
            Creates the bars for the barcode UPCE.
            @param _code the text with 8 digits
            @return the barcode
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.GetBarsSupplemental2(System.String)">
            Creates the bars for the barcode supplemental 2.
            @param _code the text with 2 digits
            @return the barcode
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEAN.GetBarsSupplemental5(System.String)">
            Creates the bars for the barcode supplemental 5.
            @param _code the text with 5 digits
            @return the barcode
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeEAN.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.BarcodeEAN.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.BarcodeEANSUPP" -->
        <member name="F:iTextSharp.text.pdf.BarcodeEANSUPP.ean">
            The barcode with the EAN/UPC.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeEANSUPP.supp">
            The barcode with the supplemental.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeEANSUPP.#ctor(iTextSharp.text.pdf.Barcode,iTextSharp.text.pdf.Barcode)">
            Creates new combined barcode.
            @param ean the EAN/UPC barcode
            @param supp the supplemental barcode
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeEANSUPP.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.BarcodeEANSUPP.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="T:iTextSharp.text.pdf.BarcodeInter25">
            Implements the code interleaved 2 of 5. The text can include
             non numeric characters that are printed but do not generate bars.
             The default parameters are:
             <pre>
            x = 0.8f;
            n = 2;
            font = BaseFont.CreateFont("Helvetica", "winansi", false);
            size = 8;
            baseline = size;
            barHeight = size * 3;
            textint= Element.ALIGN_CENTER;
            generateChecksum = false;
            checksumText = false;
             </pre>
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodeInter25.BARS">
            The bars to generate the code.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeInter25.#ctor">
            Creates new BarcodeInter25 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeInter25.KeepNumbers(System.String)">
            Deletes all the non numeric characters from <CODE>text</CODE>.
            @param text the text
            @return a <CODE>string</CODE> with only numeric characters
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeInter25.GetChecksum(System.String)">
            Calculates the checksum.
            @param text the numeric text
            @return the checksum
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeInter25.GetBarsInter25(System.String)">
            Creates the bars for the barcode.
            @param text the text. It can contain non numeric characters
            @return the barcode
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodeInter25.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.BarcodeInter25.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="T:iTextSharp.text.pdf.BarcodePDF417">
            Generates the 2D barcode PDF417. Supports dimensioning auto-sizing, fixed
            and variable sizes, automatic and manual error levels, raw codeword input,
            codeword size optimization and bitmap inversion. The output can
            be a CCITT G4 <CODE>Image</CODE> or a raw bitmap.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_USE_ASPECT_RATIO">
            Auto-size is made based on <CODE>aspectRatio</CODE> and <CODE>yHeight</CODE>. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_FIXED_RECTANGLE">
            The size of the barcode will be at least <CODE>codeColumns*codeRows</CODE>. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_FIXED_COLUMNS">
            The size will be at least <CODE>codeColumns</CODE>
            with a variable number of <CODE>codeRows</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_FIXED_ROWS">
            The size will be at least <CODE>codeRows</CODE>
            with a variable number of <CODE>codeColumns</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_AUTO_ERROR_LEVEL">
            The error level correction is set automatically according
            to ISO 15438 recomendations.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_USE_ERROR_LEVEL">
            The error level correction is set by the user. It can be 0 to 8. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_FORCE_BINARY">
            One single binary segment is used
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_USE_RAW_CODEWORDS">
            No <CODE>text</CODE> interpretation is done and the content of <CODE>codewords</CODE>
            is used directly.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_INVERT_BITMAP">
            Inverts the output bits of the raw bitmap that is normally
            bit one for black. It has only effect for the raw bitmap.
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.PDF417_USE_MACRO">
            Use Macro PDF417 Encoding
            @see #setMacroFileId(String)
            @see #setMacroSegmentId(int)
            @see #setMacroSegmentCount(int)
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.#ctor">
            Creates a new <CODE>BarcodePDF417</CODE> with the default settings. 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.SetDefaultParameters">
            Set the default settings that correspond to <CODE>PDF417_USE_ASPECT_RATIO</CODE>
            and <CODE>PDF417_AUTO_ERROR_LEVEL</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.PaintCode">
            Paints the barcode. If no exception was thrown a valid barcode is available. 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.GetImage">
            Gets an <CODE>Image</CODE> with the barcode. The image will have to be
            scaled in the Y direction by <CODE>yHeight</CODE>for the barcode
            to have the right printing aspect.
            @return the barcode <CODE>Image</CODE>
            @throws BadElementException on error
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.SetText(System.String)">
            Sets the text that will form the barcode. This text is converted
            to bytes using the encoding Cp437.
            @param s the text that will form the barcode
            @throws UnsupportedEncodingException if the encoding Cp437 is not supported
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.outBits">
            Holds value of property outBits. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.bitColumns">
            Holds value of property bitColumns. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.codeRows">
            Holds value of property codeRows. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.codeColumns">
            Holds value of property codeColumns. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.codewords">
            Holds value of property codewords. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.lenCodewords">
            Holds value of property lenCodewords. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.errorLevel">
            Holds value of property errorLevel. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.text">
            Holds value of property text. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.options">
            Holds value of property options. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.aspectRatio">
            Holds value of property aspectRatio. 
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePDF417.yHeight">
            Holds value of property yHeight. 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePDF417.GetBarcodeSize">
            Gets the size of the barcode grid. 
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.MacroSegmentId">
            Sets the segment id for macro PDF417 encoding
            @param id the id (starting at 0)
            @see #setMacroSegmentCount(int)
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.MacroSegmentCount">
            Sets the segment count for macro PDF417 encoding
            @param cnt the number of macro segments
            @see #setMacroSegmentId(int)
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.MacroFileId">
            Sets the File ID for macro PDF417 encoding 
            @param id the file id
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.OutBits">
            Gets the raw image bits of the barcode. The image will have to
            be scaled in the Y direction by <CODE>yHeight</CODE>.
            @return The raw barcode image
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.BitColumns">
            Gets the number of X pixels of <CODE>outBits</CODE>.
            @return the number of X pixels of <CODE>outBits</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.CodeRows">
            Gets the number of Y pixels of <CODE>outBits</CODE>.
            It is also the number of rows in the barcode.
            @return the number of Y pixels of <CODE>outBits</CODE>
            Sets the number of barcode rows. This number may be changed
            to keep the barcode valid.
            @param codeRows the number of barcode rows
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.CodeColumns">
            Sets the number of barcode data columns.
            This number may be changed to keep the barcode valid.
            @param codeColumns the number of barcode data columns
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.Codewords">
            Gets the codeword array. This array is always 928 elements long.
            It can be writen to if the option <CODE>PDF417_USE_RAW_CODEWORDS</CODE>
            is set.
            @return the codeword array
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.LenCodewords">
            Sets the length of the codewords.
            @param lenCodewords the length of the codewords
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.ErrorLevel">
            Gets the error level correction used for the barcode. It may different
            from the previously set value.
            @return the error level correction used for the barcode
            Sets the error level correction for the barcode.
            @param errorLevel the error level correction for the barcode
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.Text">
            Sets the bytes that form the barcode. This bytes should
            be interpreted in the codepage Cp437.
            @param text the bytes that form the barcode
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.Options">
            Sets the options to generate the barcode. This can be all
            the <CODE>PDF417_*</CODE> constants.
            @param options the options to generate the barcode
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.AspectRatio">
            Sets the barcode aspect ratio. A ratio or 0.5 will make the
            barcode width twice as large as the height.
            @param aspectRatio the barcode aspect ratio
        </member>
        <member name="P:iTextSharp.text.pdf.BarcodePDF417.YHeight">
            Sets the Y pixel height relative to X. It is usually 3.
            @param yHeight the Y pixel height relative to X
        </member>
        <member name="T:iTextSharp.text.pdf.BarcodePostnet">
            Implements the Postnet and Planet barcodes. The default parameters are:
             <pre>
            n = 72f / 22f; // distance between bars
            x = 0.02f * 72f; // bar width
            barHeight = 0.125f * 72f; // height of the tall bars
            size = 0.05f * 72f; // height of the short bars
            codeType = POSTNET; // type of code
             </pre>
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.BarcodePostnet.BARS">
            The bars for each character.
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePostnet.#ctor">
            Creates new BarcodePostnet 
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodePostnet.GetBarsPostnet(System.String)">
            Creates the bars for Postnet.
            @param text the code to be created without checksum
            @return the bars
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BarcodePostnet.PlaceBarcode(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.BaseColor,iTextSharp.text.BaseColor)" -->
        <member name="P:iTextSharp.text.pdf.BarcodePostnet.BarcodeSize">
            Gets the maximum area that the barcode and the text, if
            any, will occupy. The lower left corner is always (0, 0).
            @return the size the barcode occupies.
        </member>
        <member name="T:iTextSharp.text.pdf.BarcodeQRCode">
            A QRCode implementation based on the zxing code.
            @author Paulo Soares
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeQRCode.#ctor(System.String,System.Int32,System.Int32,System.Collections.Generic.IDictionary{iTextSharp.text.pdf.qrcode.EncodeHintType,System.Object})">
            Creates the QR barcode. The barcode is always created with the smallest possible size and is then stretched
            to the width and height given. Set the width and height to 1 to get an unscaled barcode.
            @param content the text to be encoded
            @param width the barcode width
            @param height the barcode height
            @param hints modifiers to change the way the barcode is create. They can be EncodeHintType.ERROR_CORRECTION
            and EncodeHintType.CHARACTER_SET. For EncodeHintType.ERROR_CORRECTION the values can be ErrorCorrectionLevel.L, M, Q, H.
            For EncodeHintType.CHARACTER_SET the values are strings and can be Cp437, Shift_JIS and ISO-8859-1 to ISO-8859-16.
            You can also use UTF-8, but correct behaviour is not guaranteed as Unicode is not supported in QRCodes.
            The default value is ISO-8859-1.
            @throws WriterException
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeQRCode.GetImage">
            Gets an <CODE>Image</CODE> with the barcode.
            @return the barcode <CODE>Image</CODE>
            @throws BadElementException on error
        </member>
        <member name="M:iTextSharp.text.pdf.BarcodeQRCode.GetBarcodeSize">
            Gets the size of the barcode grid. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.BORDER_WIDTH_THIN">
            A thin border with 1 point width. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.BORDER_WIDTH_MEDIUM">
            A medium border with 2 point width. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.BORDER_WIDTH_THICK">
            A thick border with 3 point width. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.VISIBLE">
            The field is visible. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.HIDDEN">
            The field is hidden. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.VISIBLE_BUT_DOES_NOT_PRINT">
            The field is visible but does not print. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.HIDDEN_BUT_PRINTABLE">
            The field is hidden but is printable. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.READ_ONLY">
            The user may not change the value of the field. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.REQUIRED">
            The field must have a value at the time it is exported by a submit-form
            action.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.MULTILINE">
            The field may contain multiple lines of text.
            This flag is only meaningful with text fields.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.DO_NOT_SCROLL">
            The field will not scroll (horizontally for single-line
            fields, vertically for multiple-line fields) to accommodate more text
            than will fit within its annotation rectangle. Once the field is full, no
            further text will be accepted.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.PASSWORD">
            The field is intended for entering a secure password that should
            not be echoed visibly to the screen.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.FILE_SELECTION">
            The text entered in the field represents the pathname of
            a file whose contents are to be submitted as the value of the field.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.DO_NOT_SPELL_CHECK">
            The text entered in the field will not be spell-checked.
            This flag is meaningful only in text fields and in combo
            fields with the <CODE>EDIT</CODE> flag set.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.EDIT">
            If set the combo box includes an editable text box as well as a drop list; if
            clear, it includes only a drop list.
            This flag is only meaningful with combo fields.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.MULTISELECT">
            whether or not a list may have multiple selections.  Only applies to /CH LIST
            fields, not combo boxes.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.COMB">
            combo box flag.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.rotation">
            Holds value of property rotation. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.visibility">
            Holds value of property visibility. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.fieldName">
            Holds value of property fieldName. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.options">
            Holds value of property options. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseField.maxCharacterLength">
            Holds value of property maxCharacterLength. 
        </member>
        <member name="M:iTextSharp.text.pdf.BaseField.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String)">
            Creates a new <CODE>TextField</CODE>.
            @param writer the document <CODE>PdfWriter</CODE>
            @param box the field location and dimensions
            @param fieldName the field name. If <CODE>null</CODE> only the widget keys
            will be included in the field allowing it to be used as a kid field.
        </member>
        <member name="M:iTextSharp.text.pdf.BaseField.SetRotationFromPage(iTextSharp.text.Rectangle)">
            Convenience method to set the field rotation the same as the
            page rotation.
            @param page the page
        </member>
        <member name="M:iTextSharp.text.pdf.BaseField.MoveFields(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary)">
            Moves the field keys from <CODE>from</CODE> to <CODE>to</CODE>. The moved keys
            are removed from <CODE>from</CODE>.
            @param from the source
            @param to the destination. It may be <CODE>null</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.BorderWidth">
            Sets the border width in points. To eliminate the border
            set the border color to <CODE>null</CODE>.
            @param borderWidth the border width in points
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.BorderStyle">
            Sets the border style. The styles are found in <CODE>PdfBorderDictionary</CODE>
            and can be <CODE>STYLE_SOLID</CODE>, <CODE>STYLE_DASHED</CODE>,
            <CODE>STYLE_BEVELED</CODE>, <CODE>STYLE_INSET</CODE> and
            <CODE>STYLE_UNDERLINE</CODE>.
            @param borderStyle the border style
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.BorderColor">
            Sets the border color. Set to <CODE>null</CODE> to remove
            the border.
            @param borderColor the border color
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.BackgroundColor">
            Sets the background color. Set to <CODE>null</CODE> for
            transparent background.
            @param backgroundColor the background color
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.TextColor">
            Sets the text color. If <CODE>null</CODE> the color used
            will be black.
            @param textColor the text color
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Font">
            Sets the text font. If <CODE>null</CODE> then Helvetica
            will be used.
            @param font the text font
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.FontSize">
            Sets the font size. If 0 then auto-sizing will be used but
            only for text fields.
            @param fontSize the font size
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Alignment">
            Sets the text horizontal alignment. It can be <CODE>Element.ALIGN_LEFT</CODE>,
            <CODE>Element.ALIGN_CENTER</CODE> and <CODE>Element.ALIGN_RIGHT</CODE>.
            @param alignment the text horizontal alignment
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Text">
            Sets the text for text fields.
            @param text the text
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Box">
            Sets the field dimension and position.
            @param box the field dimension and position
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Rotation">
            Sets the field rotation. This value should be the same as
            the page rotation where the field will be shown.
            @param rotation the field rotation
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Visibility">
            Sets the field visibility flag. This flags can be one of
            <CODE>VISIBLE</CODE>, <CODE>HIDDEN</CODE>, <CODE>VISIBLE_BUT_DOES_NOT_PRINT</CODE>
            and <CODE>HIDDEN_BUT_PRINTABLE</CODE>.
            @param visibility field visibility flag
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.FieldName">
            Sets the field name.
            @param fieldName the field name. If <CODE>null</CODE> only the widget keys
            will be included in the field allowing it to be used as a kid field.
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.Options">
            Sets the option flags. The option flags can be a combination by oring of
            <CODE>READ_ONLY</CODE>, <CODE>REQUIRED</CODE>,
            <CODE>MULTILINE</CODE>, <CODE>DO_NOT_SCROLL</CODE>,
            <CODE>PASSWORD</CODE>, <CODE>FILE_SELECTION</CODE>,
            <CODE>DO_NOT_SPELL_CHECK</CODE> and <CODE>EDIT</CODE>.
            @param options the option flags
        </member>
        <member name="P:iTextSharp.text.pdf.BaseField.MaxCharacterLength">
            Sets the maximum length of the field�s text, in characters.
            It is only meaningful for text fields.
            @param maxCharacterLength the maximum length of the field�s text, in characters
        </member>
        <member name="T:iTextSharp.text.pdf.BaseFont">
            <summary>
            Summary description for BaseFont.
            </summary>
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.COURIER">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.COURIER_BOLD">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.COURIER_OBLIQUE">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.COURIER_BOLDOBLIQUE">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.HELVETICA">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.HELVETICA_BOLD">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.HELVETICA_OBLIQUE">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.HELVETICA_BOLDOBLIQUE">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.SYMBOL">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.TIMES_ROMAN">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.TIMES_BOLD">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.TIMES_ITALIC">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.TIMES_BOLDITALIC">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.ZAPFDINGBATS">
            This is a possible value of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.ASCENT">
            The maximum height above the baseline reached by glyphs in this
            font, excluding the height of glyphs for accented characters.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CAPHEIGHT">
            The y coordinate of the top of flat capital letters, measured from
            the baseline.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.DESCENT">
            The maximum depth below the baseline reached by glyphs in this
            font. The value is a negative number.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.ITALICANGLE">
            The angle, expressed in degrees counterclockwise from the vertical,
            of the dominant vertical strokes of the font. The value is
            negative for fonts that slope to the right, as almost all italic fonts do.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.BBOXLLX">
            The lower left x glyph coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.BBOXLLY">
            The lower left y glyph coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.BBOXURX">
            The upper right x glyph coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.BBOXURY">
            The upper right y glyph coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.AWT_ASCENT">
            java.awt.Font property 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.AWT_DESCENT">
            java.awt.Font property 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.AWT_LEADING">
            java.awt.Font property 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.AWT_MAXADVANCE">
            java.awt.Font property 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.UNDERLINE_POSITION">
            The underline position. Usually a negative value.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.UNDERLINE_THICKNESS">
            The underline thickness.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.STRIKETHROUGH_POSITION">
            The strikethrough position.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.STRIKETHROUGH_THICKNESS">
            The strikethrough thickness.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.SUBSCRIPT_SIZE">
            The recommended vertical size for subscripts for this font.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.SUBSCRIPT_OFFSET">
            The recommended vertical offset from the baseline for subscripts for this font. Usually a negative value.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.SUPERSCRIPT_SIZE">
            The recommended vertical size for superscripts for this font.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.SUPERSCRIPT_OFFSET">
            The recommended vertical offset from the baseline for superscripts for this font.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.WEIGHT_CLASS">
            The weight class of the font, as defined by the font author
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.WIDTH_CLASS">
            The width class of the font, as defined by the font author
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_WEIGHT">
            The entry of PDF FontDescriptor dictionary.
            (Optional; PDF 1.5; strongly recommended for Type 3 fonts in Tagged PDF documents)
            The weight (thickness) component of the fully-qualified font name or font specifier.
            A value larger than 500 indicates bold font-weight.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_T1">
            The font is Type 1.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_TT">
            The font is True Type with a standard encoding.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_CJK">
            The font is CJK.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_TTUNI">
            The font is True Type with a Unicode encoding.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_DOCUMENT">
            A font already inside the document.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.FONT_TYPE_T3">
            A Type3 font.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.IDENTITY_H">
            The Unicode encoding with horizontal writing.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.IDENTITY_V">
            The Unicode encoding with vertical writing.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CP1250">
            A possible encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CP1252">
            A possible encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CP1257">
            A possible encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.WINANSI">
            A possible encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.MACROMAN">
            A possible encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.EMBEDDED">
            if the font has to be embedded 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.NOT_EMBEDDED">
            if the font doesn't have to be embedded 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CACHED">
            if the font has to be cached 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.NOT_CACHED">
            if the font doesn't have to be cached 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.RESOURCE_PATH">
            The path to the font resources. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.CID_NEWLINE">
            The fake CID code that represents a newline. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.PARAGRAPH_SEPARATOR">
                     * Unicode Character 'PARAGRAPH SEPARATOR' (U+2029)
            	     * Treated as a line feed character in XFA rich and plain text.
                     * @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.notdef">
            a not defined character in a custom PDF encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.DEFAULT_FONT_MATRIX">
            default array of six numbers specifying the font matrix, mapping glyph space to text space 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.fontType">
            The font type.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.widths">
            table of characters widths for this encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.differences">
            encoding names 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.unicodeDifferences">
            same as differences but with the unicode codes 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.encoding">
            encoding used with this font 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.embedded">
            true if the font is to be embedded in the PDF 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.compressionLevel">
            The compression level for the font stream.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.fontSpecific">
            true if the font must use its built in encoding. In that case the
            <CODE>encoding</CODE> is only used to map a char to the position inside
            the font, not to the expected char name.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.fontCache">
            cache for the fonts already used. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.BuiltinFonts14">
            list of the 14 built in fonts. 
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.forceWidthsOutput">
            Forces the output of the width array. Only matters for the 14
            built-in fonts.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.directTextToByte">
            Converts <CODE>char</CODE> directly to <CODE>byte</CODE>
            by casting.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.subset">
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document.
        </member>
        <member name="F:iTextSharp.text.pdf.BaseFont.specialMap">
            Custom encodings use this map to key the Unicode character
            to the single byte code.
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.#ctor">
            Creates new BaseFont
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.CreateFont">
            Creates a new font. This will always be the default Helvetica font (not embedded).
            This method is introduced because Helvetica is used in many examples.
            @return  a BaseFont object (Helvetica, Winansi, not embedded)
            @throws  IOException         This shouldn't occur ever
            @throws  DocumentException   This shouldn't occur ever
            @since   2.1.1 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.CreateFont(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.CreateFont(System.String,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.CreateFont(System.String,System.String,System.Boolean,System.Boolean,System.Byte[],System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.CreateFont(System.String,System.String,System.Boolean,System.Boolean,System.Byte[],System.Byte[],System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.CreateFont(System.String,System.String,System.Boolean,System.Boolean,System.Byte[],System.Byte[],System.Boolean,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.BaseFont.CreateFont(iTextSharp.text.pdf.PRIndirectReference)">
            Creates a font based on an existing document font. The created font font may not
            behave as expected, depending on the encoding or subset.
            @param fontRef the reference to the document font
            @return the font
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.IsVertical">
            Indicates whether the font is used for verticl writing or not.
            @return <code>true</code> if the writing mode is vertical for the given font, <code>false</code> otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetBaseName(System.String)">
            Gets the name without the modifiers Bold, Italic or BoldItalic.
            @param name the full name of the font
            @return the name without the modifiers Bold, Italic or BoldItalic
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.NormalizeEncoding(System.String)">
            Normalize the encoding names. "winansi" is changed to "Cp1252" and
            "macroman" is changed to "MacRoman".
            @param enc the encoding to be normalized
            @return the normalized encoding
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.CreateEncoding">
            Creates the <CODE>widths</CODE> and the <CODE>differences</CODE> arrays
            @throws UnsupportedEncodingException the encoding is not supported
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetRawWidth(System.Int32,System.String)">
            Gets the width from the font according to the Unicode char <CODE>c</CODE>
            or the <CODE>name</CODE>. If the <CODE>name</CODE> is null it's a symbolic font.
            @param c the unicode char
            @param name the glyph name
            @return the width of the char
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetKerning(System.Int32,System.Int32)">
            Gets the kerning between two Unicode chars.
            @param char1 the first char
            @param char2 the second char
            @return the kerning to be applied
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.SetKerning(System.Int32,System.Int32,System.Int32)">
            Sets the kerning between two Unicode chars.
            @param char1 the first char
            @param char2 the second char
            @param kern the kerning to apply in normalized 1000 units
            @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetWidth(System.Int32)">
            Gets the width of a <CODE>char</CODE> in normalized 1000 units.
            @param char1 the unicode <CODE>char</CODE> to get the width of
            @return the width in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetWidth(System.String)">
            Gets the width of a <CODE>string</CODE> in normalized 1000 units.
            @param text the <CODE>string</CODE> to get the witdth of
            @return the width in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetDescent(System.String)">
            Gets the descent of a <CODE>String</CODE> in normalized 1000 units. The descent will always be
            less than or equal to zero even if all the characters have an higher descent.
            @param text the <CODE>String</CODE> to get the descent of
            @return the dexcent in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetAscent(System.String)">
            Gets the ascent of a <CODE>String</CODE> in normalized 1000 units. The ascent will always be
            greater than or equal to zero even if all the characters have a lower ascent.
            @param text the <CODE>String</CODE> to get the ascent of
            @return the ascent in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetDescentPoint(System.String,System.Single)">
            Gets the descent of a <CODE>String</CODE> in points. The descent will always be
            less than or equal to zero even if all the characters have an higher descent.
            @param text the <CODE>String</CODE> to get the descent of
            @param fontSize the size of the font
            @return the dexcent in points
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetAscentPoint(System.String,System.Single)">
            Gets the ascent of a <CODE>String</CODE> in points. The ascent will always be
            greater than or equal to zero even if all the characters have a lower ascent.
            @param text the <CODE>String</CODE> to get the ascent of
            @param fontSize the size of the font
            @return the ascent in points
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetWidthPointKerned(System.String,System.Single)">
            Gets the width of a <CODE>String</CODE> in points taking kerning
            into account.
            @param text the <CODE>String</CODE> to get the witdth of
            @param fontSize the font size
            @return the width in points
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetWidthPoint(System.String,System.Single)">
            Gets the width of a <CODE>string</CODE> in points.
            @param text the <CODE>string</CODE> to get the witdth of
            @param fontSize the font size
            @return the width in points
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetWidthPoint(System.Int32,System.Single)">
            Gets the width of a <CODE>char</CODE> in points.
            @param char1 the <CODE>char</CODE> to get the witdth of
            @param fontSize the font size
            @return the width in points
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.ConvertToBytes(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.ConvertToBytes(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.BaseFont.WriteFont(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfIndirectReference,System.Object[])">
            Outputs to the writer the font dictionaries and streams.
            @param writer the writer for this document
            @param ref the font indirect reference
            @param params several parameters that depend on the font type
            @throws IOException on error
            @throws DocumentException error in generating the object
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetFullFontStream">
            Returns a PdfStream object with the full font program (if possible).
            This method will return null for some types of fonts (CJKFont, Type3Font)
            or if there is no font program available (standard Type 1 fonts).
            @return  a PdfStream with the font program
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetFontDescriptor(System.Int32,System.Single)">
            Gets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>,
            <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
            and <CODE>BBOXURY</CODE>.
            @param key the parameter to be extracted
            @param fontSize the font size in points
            @return the parameter in points
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.SetFontDescriptor(System.Int32,System.Single)">
            Sets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>,
            <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
            and <CODE>BBOXURY</CODE>.
            @param key the parameter to be updated
            @param value the parameter value
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.IsEmbedded">
            Gets the embedded flag.
            @return <CODE>true</CODE> if the font is embedded.
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.IsFontSpecific">
            Gets the symbolic flag of the font.
            @return <CODE>true</CODE> if the font is symbolic
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.CreateSubsetPrefix">
            Creates a unique subset prefix to be added to the font name when the font is embedded and subset.
            @return the subset prefix
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetUnicodeDifferences(System.Int32)">
            Gets the Unicode character corresponding to the byte output to the pdf stream.
            @param index the byte index
            @return the Unicode character
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.GetFullFontName(System.String,System.String,System.Byte[])" -->
        <member name="M:iTextSharp.text.pdf.BaseFont.GetAllFontNames(System.String,System.String,System.Byte[])">
            Gets all the names from the font. Only the required tables are read.
            @param name the name of the font
            @param encoding the encoding of the font
            @param ttfAfm the true type font or the afm in a byte array
            @throws DocumentException on error
            @throws IOException on error
            @return an array of Object[] built with {getPostscriptFontName(), GetFamilyFontName(), GetFullFontName()}
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetAllNameEntries(System.String,System.String,System.Byte[])">
            Gets all the entries of the namestable from the font. Only the required tables are read.
            @param name the name of the font
            @param encoding the encoding of the font
            @param ttfAfm the true type font or the afm in a byte array
            @throws DocumentException on error
            @throws IOException on error
            @return an array of Object[] built with {getPostscriptFontName(), getFamilyFontName(), getFullFontName()}
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.EnumerateTTCNames(System.String)">
            Enumerates the postscript font names present inside a
            True Type Collection.
            @param ttcFile the file name of the font
            @throws DocumentException on error
            @throws IOException on error
            @return the postscript font names
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.EnumerateTTCNames(System.Byte[])">
            Enumerates the postscript font names present inside a
            True Type Collection.
            @param ttcArray the font as a <CODE>byte</CODE> array
            @throws DocumentException on error
            @throws IOException on error
            @return the postscript font names
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BaseFont.GetUnicodeEquivalent(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.BaseFont.GetCidCode(System.Int32)">
            Gets the CID code given an Unicode.
            It has only meaning with CJK fonts.
            @param c the Unicode
            @return the CID equivalent
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.HasKernPairs">
            Checks if the font has any kerning pairs.
            @return <CODE>true</CODE> if the font has any kerning pairs
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.CharExists(System.Int32)">
            Checks if a character exists in this font.
            @param c the character to check
            @return <CODE>true</CODE> if the character has a glyph,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.SetCharAdvance(System.Int32,System.Int32)">
            Sets the character advance.
            @param c the character
            @param advance the character advance normalized to 1000 units
            @return <CODE>true</CODE> if the advance was set,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetDocumentFonts(iTextSharp.text.pdf.PdfReader)">
            Gets a list of all document fonts. Each element of the <CODE>ArrayList</CODE>
            contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
            and the indirect reference to it.
            @param reader the document where the fonts are to be listed from
            @return the list of fonts and references
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetDocumentFonts(iTextSharp.text.pdf.PdfReader,System.Int32)">
            Gets a list of the document fonts in a particular page. Each element of the <CODE>ArrayList</CODE>
            contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
            and the indirect reference to it.
            @param reader the document where the fonts are to be listed from
            @param page the page to list the fonts from
            @return the list of fonts and references
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetCharBBox(System.Int32)">
            Gets the smallest box enclosing the character contours. It will return
            <CODE>null</CODE> if the font has not the information or the character has no
            contours, as in the case of the space, for example. Characters with no contours may
            also return [0,0,0,0].
            @param c the character to get the contour bounding box from
            @return an array of four floats with the bounding box in the format [llx,lly,urx,ury] or
            <code>null</code>
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.GetFontMatrix">
             Gets default array of six numbers specifying the font matrix, mapping glyph space to text space
            @return an array of six values
            <code>null</code>
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.CorrectArabicAdvance">
            iText expects Arabic Diactrics (tashkeel) to have zero advance but some fonts,
            most notably those that come with Windows, like times.ttf, have non-zero
            advance for those characters. This method makes those character to have zero
            width advance and work correctly in the iText Arabic shaping and reordering
            context.
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.AddSubsetRange(System.Int32[])">
            Adds a character range when subsetting. The range is an <CODE>int</CODE> array
            where the first element is the start range inclusive and the second element is the
            end range inclusive. Several ranges are allowed in the same array.
            @param range the character range
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.Encoding">
            Gets the encoding used to convert <CODE>string</CODE> into <CODE>byte[]</CODE>.
            @return the encoding name
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.FontType">
            Gets the font type. The font types can be: FONT_TYPE_T1,
            FONT_TYPE_TT, FONT_TYPE_CJK and FONT_TYPE_TTUNI.
            @return the font type
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.PostscriptFontName">
            Gets the postscript font name.
            @return the postscript font name
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BaseFont.FullFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BaseFont.AllNameEntries" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.BaseFont.FamilyFontName" -->
        <member name="P:iTextSharp.text.pdf.BaseFont.CodePagesSupported">
            Gets the code pages supported by the font. This has only meaning
            with True Type fonts.
            @return the code pages supported by the font
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.Widths">
            Gets the font width array.
            @return the font width array
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.Differences">
            Gets the array with the names of the characters.
            @return the array with the names of the characters
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.UnicodeDifferences">
            Gets the array with the unicode characters.
            @return the array with the unicode characters
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.ForceWidthsOutput">
            Set to <CODE>true</CODE> to force the generation of the
            widths array.
            @param forceWidthsOutput <CODE>true</CODE> to force the generation of the
            widths array
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.DirectTextToByte">
            Sets the conversion of <CODE>char</CODE> directly to <CODE>byte</CODE>
            by casting. This is a low level feature to put the bytes directly in
            the content stream without passing through string.GetBytes().
            @param directTextToByte New value of property directTextToByte.
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.Subset">
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document. When set to <CODE>true</CODE>
            only the glyphs used will be included in the font. When set to <CODE>false</CODE>
            and {@link #addSubsetRange(int[])} was not called the full font will be included
            otherwise just the characters ranges will be included.
            @param subset new value of property subset
        </member>
        <member name="P:iTextSharp.text.pdf.BaseFont.CompressionLevel">
            Sets the compression level to be used for the font streams.
            @param compressionLevel a value between 0 (best speed) and 9 (best compression)
            @since 2.1.3
        </member>
        <member name="T:iTextSharp.text.pdf.BaseFont.StreamFont">
            Generates the PDF stream with the Type1 and Truetype fonts returning
            a PdfStream.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfStream" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfDictionary" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfObject" -->
        <member name="F:iTextSharp.text.pdf.PdfObject.BOOLEAN">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.NUMBER">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.STRING">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.NAME">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.ARRAY">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.DICTIONARY">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.STREAM">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.NULL">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.INDIRECT">
            a possible type of <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.NOTHING">
            This is an empty string used for the <CODE>PdfNull</CODE>-object and for an empty <CODE>PdfString</CODE>-object. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.TEXT_PDFDOCENCODING">
            This is the default encoding to be used for converting strings into bytes and vice versa.
            The default encoding is PdfDocEcoding.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.TEXT_UNICODE">
            This is the encoding to be used to output text in Unicode. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.bytes">
            the content of this <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.type">
            the type of this <CODE>PdfObject</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.indRef">
            Holds value of property indRef.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.hashCode">
            Hash code of the PdfObject instance. 
            Unfortunately, default C# behavior does not generate unique hash code.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.objCounter">
            Used for generating hash code.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfObject.locker">
            Making hash code generation thread safe.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.#ctor(System.Int32)">
             Constructs a <CODE>PdfObject</CODE> of a certain <VAR>type</VAR> without any <VAR>content</VAR>.
            
             @param        type            type of the new <CODE>PdfObject</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.#ctor(System.Int32,System.String)">
             Constructs a <CODE>PdfObject</CODE> of a certain <VAR>type</VAR> with a certain <VAR>content</VAR>.
            
             @param        type            type of the new <CODE>PdfObject</CODE>
             @param        content            content of the new <CODE>PdfObject</CODE> as a <CODE>String</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.#ctor(System.Int32,System.Byte[])">
             Constructs a <CODE>PdfObject</CODE> of a certain <VAR>type</VAR> with a certain <VAR>content</VAR>.
            
             @param        type            type of the new <CODE>PdfObject</CODE>
             @param        bytes            content of the new <CODE>PdfObject</CODE> as an array of <CODE>byte</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
            Writes the PDF representation of this <CODE>PdfObject</CODE> as an array of <CODE>byte</CODE>s to the writer.
            @param writer for backwards compatibility
            @param os the outputstream to write the bytes to.
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.GetBytes">
            Gets the presentation of this object in a byte array
            @return a byte array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.CanBeInObjStm">
            Can this object be in an object stream?
            @return true if this object can be in an object stream.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.ToString">
             Returns the <CODE>String</CODE>-representation of this <CODE>PdfObject</CODE>.
            
             @return        a <CODE>String</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsNull">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfNull</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsBoolean">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfBoolean</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsNumber">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfNumber</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsString">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfString</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsName">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfName</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsArray">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfArray</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsDictionary">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfDictionary</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsStream">
             Checks if this <CODE>PdfObject</CODE> is of the type <CODE>PdfStream</CODE>.
            
             @return        <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfObject.IsIndirect">
            Checks if this is an indirect object.
            @return true if this is an indirect object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfObject.Length">
             Returns the length of the actual content of the <CODE>PdfObject</CODE>.
             <P>
             In some cases, namely for <CODE>PdfString</CODE> and <CODE>PdfStream</CODE>,
             this method differs from the method <CODE>pdfLength</CODE> because <CODE>pdfLength</CODE>
             returns the length of the PDF representation of the object, not of the actual content
             as does the method <CODE>length</CODE>.</P>
             <P>
             Remark: the actual content of an object is in some cases identical to its representation.
             The following statement is always true: Length() &gt;= PdfLength().</P>
            
             @return        a length
        </member>
        <member name="P:iTextSharp.text.pdf.PdfObject.Content">
             Changes the content of this <CODE>PdfObject</CODE>.
            
             @param        content            the new content of this <CODE>PdfObject</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfObject.Type">
             Returns the type of this <CODE>PdfObject</CODE>.
            
             @return        a type
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.FONT">
            This is a possible type of dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.OUTLINES">
            This is a possible type of dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.PAGE">
            This is a possible type of dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.PAGES">
            This is a possible type of dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.CATALOG">
            This is a possible type of dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.dictionaryType">
            This is the type of this dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDictionary.hashMap">
            This is the hashmap that contains all the values and keys of the dictionary 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.#ctor">
            Constructs an empty <CODE>PdfDictionary</CODE>-object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.#ctor(iTextSharp.text.pdf.PdfName)">
             Constructs a <CODE>PdfDictionary</CODE>-object of a certain type.
            
             @param        type    a <CODE>PdfName</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
             Returns the PDF representation of this <CODE>PdfDictionary</CODE>.
            
             @return        an array of <CODE>byte</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.Put(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
             Adds a <CODE>PdfObject</CODE> and its key to the <CODE>PdfDictionary</CODE>.
             If the value is <CODE>null</CODE> or <CODE>PdfNull</CODE> the key is deleted.
            
             @param        key        key of the entry (a <CODE>PdfName</CODE>)
             @param        value    value of the entry (a <CODE>PdfObject</CODE>)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.PutEx(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
             Adds a <CODE>PdfObject</CODE> and its key to the <CODE>PdfDictionary</CODE>.
             If the value is null it does nothing.
            
             @param        key        key of the entry (a <CODE>PdfName</CODE>)
             @param        value    value of the entry (a <CODE>PdfObject</CODE>)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.PutAll(iTextSharp.text.pdf.PdfDictionary)">
             Copies all of the mappings from the specified <CODE>PdfDictionary</CODE>
             to this <CODE>PdfDictionary</CODE>.
            
             These mappings will replace any mappings previously contained in this
             <CODE>PdfDictionary</CODE>.
            
             @param dic The <CODE>PdfDictionary</CODE> with the mappings to be
               copied over
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.Remove(iTextSharp.text.pdf.PdfName)">
             Removes a <CODE>PdfObject</CODE> and its key from the <CODE>PdfDictionary</CODE>.
            
             @param        key        key of the entry (a <CODE>PdfName</CODE>)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.Clear">
            Removes all the <CODE>PdfObject</CODE>s and its <VAR>key</VAR>s from the
            <CODE>PdfDictionary</CODE>.
            @since 5.0.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDictionary.Get(iTextSharp.text.pdf.PdfName)" -->
        <member name="M:iTextSharp.text.pdf.PdfDictionary.IsFont">
              Checks if a <CODE>Dictionary</CODE> is of the type FONT.
            
             @return        <CODE>true</CODE> if it is, <CODE>false</CODE> if it isn't.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.IsPage">
              Checks if a <CODE>Dictionary</CODE> is of the type PAGE.
            
             @return        <CODE>true</CODE> if it is, <CODE>false</CODE> if it isn't.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.IsPages">
              Checks if a <CODE>Dictionary</CODE> is of the type PAGES.
            
             @return        <CODE>true</CODE> if it is, <CODE>false</CODE> if it isn't.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.IsCatalog">
              Checks if a <CODE>Dictionary</CODE> is of the type CATALOG.
            
             @return        <CODE>true</CODE> if it is, <CODE>false</CODE> if it isn't.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.IsOutlineTree">
              Checks if a <CODE>Dictionary</CODE> is of the type OUTLINES.
            
             @return        <CODE>true</CODE> if it is, <CODE>false</CODE> if it isn't.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.CheckType(iTextSharp.text.pdf.PdfName)">
            Checks the type of the dictionary.
            @param type the type you're looking for
            @return true if the type of the dictionary corresponds with the type you're looking for
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.GetDirectObject(iTextSharp.text.pdf.PdfName)">
            This function behaves the same as 'get', but will never return an indirect reference,
            it will always look such references up and return the actual object.
            @param key 
            @return null, or a non-indirect object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDictionary.GetAsDict(iTextSharp.text.pdf.PdfName)">
            All the getAs functions will return either null, or the specified object type
            This function will automatically look up indirect references. There's one obvious
            exception, the one that will only return an indirect reference.  All direct objects
            come back as a null.
            Mark A Storer (2/17/06)
            @param key
            @return the appropriate object in its final type, or null
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.DEFAULT_COMPRESSION">
            A possible compression level.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.NO_COMPRESSION">
            A possible compression level.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.BEST_SPEED">
            A possible compression level.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.BEST_COMPRESSION">
            A possible compression level.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.compressed">
            is the stream compressed? 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStream.compressionLevel">
            The level of compression.
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.#ctor(System.Byte[])">
             Constructs a <CODE>PdfStream</CODE>-object.
            
             @param        bytes            content of the new <CODE>PdfObject</CODE> as an array of <CODE>byte</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.#ctor(System.IO.Stream,iTextSharp.text.pdf.PdfWriter)">
            Creates an efficient stream. No temporary array is ever created. The <CODE>InputStream</CODE>
            is totally consumed but is not closed. The general usage is:
            <pre>
            InputStream in = ...;
            PdfStream stream = new PdfStream(in, writer);
            stream.FlateCompress();
            writer.AddToBody(stream);
            stream.WriteLength();
            in.Close();
            </pre>
            @param inputStream the data to write to this stream
            @param writer the <CODE>PdfWriter</CODE> for this stream
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.#ctor">
            Constructs a <CODE>PdfStream</CODE>-object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.WriteLength">
            Writes the stream length to the <CODE>PdfWriter</CODE>.
            <p>
            This method must be called and can only be called if the contructor {@link #PdfStream(InputStream,PdfWriter)}
            is used to create the stream.
            </p>
            @throws IOException on error
            @see #PdfStream(InputStream,PdfWriter)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.FlateCompress">
            Compresses the stream.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.FlateCompress(System.Int32)">
            Compresses the stream.
            @param compressionLevel the compression level (0 = best speed, 9 = best compression, -1 is default)
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.WriteContent(System.IO.Stream)">
            Writes the data content to an <CODE>Stream</CODE>.
            @param os the destination to write to
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStream.ToString">
            @see com.lowagie.text.pdf.PdfObject#toString()
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.StreamFont.#ctor(System.Byte[],System.Int32[],System.Int32)">
            Generates the PDF stream with the Type1 and Truetype fonts returning
            a PdfStream.
            @param contents the content of the stream
            @param lengths an array of int that describes the several lengths of each part of the font
            @param compressionLevel  the compression level of the Stream
            @throws DocumentException error in the stream compression
            @since   2.1.3 (replaces the constructor without param compressionLevel)
        </member>
        <member name="M:iTextSharp.text.pdf.BaseFont.StreamFont.#ctor(System.Byte[],System.String,System.Int32)">
            Generates the PDF stream for a font.
            @param contents the content of a stream
            @param subType the subtype of the font.
            @param compressionLevel  the compression level of the Stream
            @throws DocumentException error in the stream compression
            @since   2.1.3 (replaces the constructor without param compressionLevel)
        </member>
        <member name="T:iTextSharp.text.pdf.BidiLine">
            Does all the line bidirectional processing with PdfChunk assembly.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.BidiLine.#ctor">
            Creates new BidiLine 
        </member>
        <member name="M:iTextSharp.text.pdf.BidiLine.IsWordSplit">
            Call this after processLine() to know if any word was split into several lines.
            @return
        </member>
        <member name="M:iTextSharp.text.pdf.BidiLine.GetWidth(System.Int32,System.Int32)">
            Gets the width of a range of characters.
            @param startIdx the first index to calculate
            @param lastIdx the last inclusive index to calculate
            @return the sum of all widths
        </member>
        <member name="M:iTextSharp.text.pdf.BidiLine.GetWidth(System.Int32,System.Int32,System.Single)">
            Gets the width of a range of characters.
            @param startIdx the first index to calculate
            @param lastIdx the last inclusive index to calculate
            @param originalWidth the full width of the line. It is used in case of RTL and tab stops
            @return the sum of all widths
        </member>
        <member name="M:iTextSharp.text.pdf.BidiLine.ProcessLTR(System.String,System.Int32,System.Int32)">
            Method that changes a String with Arabic characters into a String in which the ligatures are made.
            @param s	the original String
            @param runDirection
            @param arabicOptions
            @return the String with the ligaturesc
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.L">
            Left-to-right
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.LRE">
            Left-to-Right Embedding 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.LRO">
            Left-to-Right Override 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.R">
            Right-to-Left 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.AL">
            Right-to-Left Arabic 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.RLE">
            Right-to-Left Embedding 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.RLO">
            Right-to-Left Override 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.PDF">
            Pop Directional Format 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.EN">
            European Number 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.ES">
            European Number Separator 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.ET">
            European Number Terminator 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.AN">
            Arabic Number 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.CS">
            Common Number Separator 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.NSM">
            Non-Spacing Mark 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.BN">
            Boundary Neutral 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.B">
            Paragraph Separator 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.S">
            Segment Separator 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.WS">
            Whitespace 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.ON">
            Other Neutrals 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.TYPE_MIN">
            Minimum bidi type value. 
        </member>
        <member name="F:iTextSharp.text.pdf.BidiOrder.TYPE_MAX">
            Maximum bidi type value. 
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.#ctor(System.SByte[])">
             Initialize using an array of direction types.  Types range from TYPE_MIN to TYPE_MAX inclusive
             and represent the direction codes of the characters in the text.
            
             @param types the types array
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.#ctor(System.SByte[],System.SByte)">
             Initialize using an array of direction types and an externally supplied paragraph embedding level.
             The embedding level may be -1, 0, or 1.  -1 means to apply the default algorithm (rules P2 and P3),
             0 is for LTR paragraphs, and 1 is for RTL paragraphs.
            
             @param types the types array
             @param paragraphEmbeddingLevel the externally supplied paragraph embedding level.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.RunAlgorithm">
            The algorithm.
            Does not include line-based processing (Rules L1, L2).
            These are applied later in the line-based phase of the algorithm.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BidiOrder.DetermineParagraphEmbeddingLevel" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BidiOrder.DetermineExplicitEmbeddingLevels" -->
        <member name="M:iTextSharp.text.pdf.BidiOrder.RemoveExplicitCodes">
            Rules X9.
            Remove explicit codes so that they may be ignored during the remainder
            of the main portion of the algorithm.  The length of the resulting text
            is returned.
            @return the length of the data excluding explicit codes and BN.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ReinsertExplicitCodes(System.Int32)">
            Reinsert levels information for explicit codes.
            This is for ease of relating the level information
            to the original input data.  Note that the levels
            assigned to these codes are arbitrary, they're
            chosen so as to avoid breaking level runs.
            @param textLength the length of the data after compression
            @return the length of the data (original length of
            types array supplied to constructor)
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ProcessEmbeddings(System.SByte[],System.SByte)">
             2) determining explicit levels
             Rules X1 - X8
            
             The interaction of these rules makes handling them a bit complex.
             This examines resultTypes but does not modify it.  It returns embedding and
             override information in the result array.  The low 7 bits are the level, the high
             bit is set if the level is an override, and clear if it is an embedding.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ResolveWeakTypes(System.Int32,System.Int32,System.SByte,System.SByte,System.SByte)">
             3) resolving weak types
             Rules W1-W7.
            
             Note that some weak types (EN, AN) remain after this processing is complete.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ResolveNeutralTypes(System.Int32,System.Int32,System.SByte,System.SByte,System.SByte)">
            6) resolving neutral types
            Rules N1-N2.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ResolveImplicitLevels(System.Int32,System.Int32,System.SByte,System.SByte,System.SByte)">
            7) resolving implicit embedding levels
            Rules I1, I2.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.BidiOrder.GetLevels(System.Int32[])" -->
        <member name="M:iTextSharp.text.pdf.BidiOrder.ComputeMultilineReordering(System.SByte[],System.Int32[])">
            Return multiline reordering array for a given level array.
            Reordering does not occur across a line break.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ComputeReordering(System.SByte[])">
            Return reordering array for a given level array.  This reorders a single line.
            The reordering is a visual to logical map.  For example,
            the leftmost char is string.CharAt(order[0]).
            Rule L2.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.GetBaseLevel">
            Return the base level of the paragraph.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.IsWhitespace(System.SByte)">
            Return true if the type is considered a whitespace type for the line break rules.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.TypeForLevel(System.Int32)">
            Return the strong type (L or R) corresponding to the level.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.FindRunLimit(System.Int32,System.Int32,System.SByte[])">
            Return the limit of the run starting at index that includes only resultTypes in validSet.
            This checks the value at index, and will return index if that value is not in validSet.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.FindRunStart(System.Int32,System.SByte[])">
            Return the start of the run including index that includes only resultTypes in validSet.
            This assumes the value at index is valid, and does not check it.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.SetTypes(System.Int32,System.Int32,System.SByte)">
            Set resultTypes from start up to (but not including) limit to newType.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.SetLevels(System.Int32,System.Int32,System.SByte)">
            Set resultLevels from start up to (but not including) limit to newLevel.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ValidateTypes(System.SByte[])">
            Throw exception if type array is invalid.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ValidateParagraphEmbeddingLevel(System.SByte)">
            Throw exception if paragraph embedding level is invalid. Special allowance for -1 so that
            default processing can still be performed when using this API.
        </member>
        <member name="M:iTextSharp.text.pdf.BidiOrder.ValidateLineBreaks(System.Int32[],System.Int32)">
            Throw exception if line breaks array is invalid.
        </member>
        <member name="T:iTextSharp.text.pdf.ByteBuffer">
            Acts like a <CODE>StringBuilder</CODE> but works with <CODE>byte</CODE> arrays.
            floating point is converted to a format suitable to the PDF.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.ByteBuffer.count">
            The count of bytes in the buffer. 
        </member>
        <member name="F:iTextSharp.text.pdf.ByteBuffer.buf">
            The buffer where the bytes are stored. 
        </member>
        <member name="F:iTextSharp.text.pdf.ByteBuffer.HIGH_PRECISION">
            If <CODE>true</CODE> always output floating point numbers with 6 decimal digits.
            If <CODE>false</CODE> uses the faster, although less precise, representation.
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.#ctor">
            Creates new ByteBuffer with capacity 128 
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.#ctor(System.Int32)">
            Creates a byte buffer with a certain capacity.
            @param size the initial capacity
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.ByteBuffer.SetCacheSize(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.ByteBuffer.FillCache(System.Int32)">
             You can fill the cache in advance if you want to.
            
             @param   decimals
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.ConvertToBytes(System.Int32)">
             Converts an double (multiplied by 100 and cast to an int) into an array of bytes.
            
             @param   i   the int
             @return  a bytearray
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append_i(System.Int32)">
            Appends an <CODE>int</CODE>. The size of the array will grow by one.
            @param b the int to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Byte[],System.Int32,System.Int32)">
            Appends the subarray of the <CODE>byte</CODE> array. The buffer will grow by
            <CODE>len</CODE> bytes.
            @param b the array to be appended
            @param off the offset to the start of the array
            @param len the length of bytes to Append
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Byte[])">
            Appends an array of bytes.
            @param b the array to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.String)">
            Appends a <CODE>string</CODE> to the buffer. The <CODE>string</CODE> is
            converted according to the encoding ISO-8859-1.
            @param str the <CODE>string</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Char)">
            Appends a <CODE>char</CODE> to the buffer. The <CODE>char</CODE> is
            converted according to the encoding ISO-8859-1.
            @param c the <CODE>char</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(iTextSharp.text.pdf.ByteBuffer)">
            Appends another <CODE>ByteBuffer</CODE> to this buffer.
            @param buf the <CODE>ByteBuffer</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Int32)">
            Appends the string representation of an <CODE>int</CODE>.
            @param i the <CODE>int</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Int64)">
            Appends the string representation of a <CODE>long</CODE>.
            @param i the <CODE>long</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Single)">
            Appends a string representation of a <CODE>float</CODE> according
            to the Pdf conventions.
            @param i the <CODE>float</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Append(System.Double)">
            Appends a string representation of a <CODE>double</CODE> according
            to the Pdf conventions.
            @param d the <CODE>double</CODE> to be appended
            @return a reference to this <CODE>ByteBuffer</CODE> object
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.FormatDouble(System.Double)">
            Outputs a <CODE>double</CODE> into a format suitable for the PDF.
            @param d a double
            @return the <CODE>string</CODE> representation of the <CODE>double</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.FormatDouble(System.Double,iTextSharp.text.pdf.ByteBuffer)">
            Outputs a <CODE>double</CODE> into a format suitable for the PDF.
            @param d a double
            @param buf a ByteBuffer
            @return the <CODE>String</CODE> representation of the <CODE>double</CODE> if
            <CODE>buf</CODE> is <CODE>null</CODE>. If <CODE>buf</CODE> is <B>not</B> <CODE>null</CODE>,
            then the double is appended directly to the buffer and this methods returns <CODE>null</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.Reset">
            Sets the size to zero.
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.ToByteArray">
             Creates a newly allocated byte array. Its size is the current
             size of this output stream and the valid contents of the buffer
             have been copied into it.
            
             @return  the current contents of this output stream, as a byte array.
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.ToString">
             Converts the buffer's contents into a string, translating bytes into
             characters according to the platform's default character encoding.
            
             @return string translated from the buffer's contents.
        </member>
        <member name="M:iTextSharp.text.pdf.ByteBuffer.WriteTo(System.IO.Stream)">
             Writes the complete contents of this byte buffer output to
             the specified output stream argument, as if by calling the output
             stream's write method using <code>out.Write(buf, 0, count)</code>.
            
             @param      out   the output stream to which to write the data.
             @exception  IOException  if an I/O error occurs.
        </member>
        <member name="P:iTextSharp.text.pdf.ByteBuffer.Size">
             Returns the current size of the buffer.
            
             @return the value of the <code>count</code> field, which is the number of valid bytes in this byte buffer.
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.GetEntireIndexRange(System.Int32)">
            a utility that creates a range item for an entire index
            
             @param indexOffset where the index is
             @return a range item representing the entire index
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.GetCID(System.String)">
            get a single CID font. The PDF architecture (1.4)
            supports 16-bit strings only with CID CFF fonts, not
            in Type-1 CFF fonts, so we convert the font to CID if
            it is in the Type-1 format.
            Two other tasks that we need to do are to select
            only a single font from the CFF package (this again is
            a PDF restriction) and to subset the CharStrings glyph
            description.
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFont.buf">
            A random Access File or an array
            (contributed by orly manor)
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.Item">
            List items for the linked list that builds the new CID font.
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.Item.Increment(System.Int32[])">
            remember the current offset and increment by item's size in bytes. 
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.Item.Emit(System.Byte[])">
            Emit the byte stream for this item. 
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.Item.Xref">
            Fix up cross references to this item (applies only to markers). 
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFont.OffsetItem.Set(System.Int32)">
            set the value of an offset item that was initially unknown.
            It will be fixed up latex by a call to xref on some marker.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.RangeItem">
            A range item.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.IndexOffsetItem">
            An index-offset item for the list.
            The size denotes the required size in the CFF. A positive
            value means that we need a specific size in bytes (for offset arrays)
            and a negative value means that this is a dict item that uses a
            variable-size representation.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.SubrMarkerItem">
             
             @author orly manor
            
             TODO To change the template for this generated type comment go to
             Window - Preferences - Java - Code Generation - Code and Comments
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.DictOffsetItem">
            an unknown offset in a dictionary for the list.
            We will fix up the offset later; for now, assume it's large.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.UInt24Item">
            Card24 item.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.UInt32Item">
            Card32 item.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.UInt16Item">
            A SID or Card16 item.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.UInt8Item">
            A Card8 item.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.DictNumberItem">
            A dictionary number on the list.
            This implementation is inefficient: it doesn't use the variable-length
            representation.
        </member>
        <member name="T:iTextSharp.text.pdf.CFFFont.MarkerItem">
            An offset-marker item for the list.
            It is used to mark an offset and to set the offset list item.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.CFFFont.Font" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.CFFFontSubset" -->
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.ENDCHAR_OP">
            Operator codes for unused  CharStrings and unused local and global Subrs
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.SubrsFunctions">
            The Strings in this array represent Type1/Type2 operator names
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.SubrsEscapeFuncs">
            The Strings in this array represent Type1/Type2 escape operator names
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.GlyphsUsed">
            A HashMap containing the glyphs used in the text after being converted
            to glyph number by the CMap 
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.glyphsInList">
            The GlyphsUsed keys as an ArrayList
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.FDArrayUsed">
            A HashMap for keeping the FDArrays being used by the font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.hSubrsUsed">
            A HashMaps array for keeping the subroutines used in each FontDict
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.lSubrsUsed">
            The SubroutinesUsed HashMaps as ArrayLists
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.hGSubrsUsed">
            A HashMap for keeping the Global subroutines used in the font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.lGSubrsUsed">
            The Global SubroutinesUsed HashMaps as ArrayLists
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.hSubrsUsedNonCID">
            A HashMap for keeping the subroutines used in a non-cid font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.lSubrsUsedNonCID">
            The SubroutinesUsed HashMap as ArrayList
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.NewLSubrsIndex">
            An array of the new Indexs for the local Subr. One index for each FontDict
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.NewSubrsIndexNonCID">
            The new subroutines index for a non-cid font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.NewGSubrsIndex">
            The new global subroutines index of the font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.NewCharStringsIndex">
            The new CharString of the font
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.GBias">
            The bias for the global subroutines
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.OutputList">
            The linked list for generating the new font stream
        </member>
        <member name="F:iTextSharp.text.pdf.CFFFontSubset.NumOfHints">
            Number of arguments to the stem operators in a subroutine calculated recursivly
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Collections.Generic.Dictionary{System.Int32,System.Int32[]})">
            C'tor for CFFFontSubset
            @param rf - The font file
            @param GlyphsUsed - a HashMap that contains the glyph used in the subset 
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CountCharset(System.Int32,System.Int32)">
            Calculates the length of the charset according to its format
            @param Offset The Charset Offset
            @param NumofGlyphs Number of glyphs in the font
            @return the length of the Charset
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CountRange(System.Int32,System.Int32)">
            Function calculates the number of ranges in the Charset
            @param NumofGlyphs The number of glyphs in the font
            @param Type The format of the Charset
            @return The number of ranges in the Charset data structure
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReadFDSelect(System.Int32)">
            Read the FDSelect of the font and compute the array and its length
            @param Font The index of the font being processed
            @return The Processed FDSelect of the font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildFDArrayUsed(System.Int32)">
            Function reads the FDSelect and builds the FDArrayUsed HashMap According to the glyphs used
            @param Font the Number of font being processed
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReadFDArray(System.Int32)">
            Read the FDArray count, offsize and Offset array
            @param Font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.Process(System.String)">
            The Process function extracts one font out of the CFF file and returns a
            subset version of the original.
            @param fontName - The name of the font to be taken out of the CFF
            @return The new font stream
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CalcBias(System.Int32,System.Int32)">
            Function calcs bias according to the CharString type and the count
            of the subrs
            @param Offset The offset to the relevent subrs index
            @param Font the font
            @return The calculated Bias
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildNewCharString(System.Int32)">
            Function uses BuildNewIndex to create the new index of the subset charstrings
             @param FontIndex the font
             @throws IOException
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.CFFFontSubset.BuildNewLGSubrs(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildFDSubrsOffsets(System.Int32,System.Int32)">
            The function finds for the FD array processed the local subr offset and its 
            offset array.  
            @param Font the font
            @param FD The FDARRAY processed
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.CFFFontSubset.BuildSubrUsed(System.Int32,System.Int32,System.Int32,System.Int32[],System.Collections.Generic.Dictionary{System.Int32,System.Int32[]},System.Collections.Generic.List{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.CFFFontSubset.BuildGSubrsUsed(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReadASubr(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Int32[]},System.Collections.Generic.List{System.Int32},System.Int32[])">
            The function reads a subrs (glyph info) between begin and end.
            Adds calls to a Lsubr to the hSubr and lSubrs.
            Adds calls to a Gsubr to the hGSubr and lGSubrs.
            @param begin the start point of the subr
            @param end the end point of the subr
            @param GBias the bias of the Global Subrs
            @param LBias the bias of the Local Subrs
            @param hSubr the HashMap for the lSubrs
            @param lSubr the ArrayList for the lSubrs
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.HandelStack">
            Function Checks how the current operator effects the run time stack after being run 
            An operator may increase or decrease the stack size
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.StackOpp">
            Function checks the key and return the change to the stack after the operator
            @return The change in the stack. 2-> flush the stack
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.EmptyStack">
             Empty the Type2 Stack
            
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.PopStack">
             Pop one element from the stack 
            
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.PushStack">
             Add an item to the stack
            
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReadCommand">
            The function reads the next command after the file pointer is set
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CalcHints(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            The function reads the subroutine and returns the number of the hint in it.
            If a call to another subroutine is found the function calls recursively.
            @param begin the start point of the subr
            @param end the end point of the subr
            @param LBias the bias of the Local Subrs
            @param GBias the bias of the Global Subrs
            @param LSubrsOffsets The Offsets array of the subroutines
            @return The number of hints in the subroutine read.
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildNewIndex(System.Int32[],System.Collections.Generic.Dictionary{System.Int32,System.Int32[]},System.Byte)">
            Function builds the new offset array, object array and assembles the index.
            used for creating the glyph and subrs subsetted index 
            @param Offsets the offset array of the original index  
            @param Used the hashmap of the used objects
            @param OperatorForUnusedEntries the operator inserted into the data stream for unused entries
            @return the new index subset version 
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.AssembleIndex(System.Int32[],System.Byte[])">
            Function creates the new index, inserting the count,offsetsize,offset array
            and object array.
            @param NewOffsets the subsetted offset array
            @param NewObjects the subsetted object array
            @return the new index created
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildNewFile(System.Int32)">
            The function builds the new output stream according to the subset process
            @param Font the font
            @return the subseted font stream
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CopyHeader">
            Function Copies the header from the original fileto the output list
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.BuildIndexHeader(System.Int32,System.Int32,System.Int32)">
            Function Build the header of an index
            @param Count the count field of the index
            @param Offsize the offsize field of the index
            @param First the first offset of the index
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateKeys(iTextSharp.text.pdf.CFFFont.OffsetItem,iTextSharp.text.pdf.CFFFont.OffsetItem,iTextSharp.text.pdf.CFFFont.OffsetItem,iTextSharp.text.pdf.CFFFont.OffsetItem)">
            Function adds the keys into the TopDict
            @param fdarrayRef OffsetItem for the FDArray
            @param fdselectRef OffsetItem for the FDSelect
            @param charsetRef OffsetItem for the CharSet
            @param charstringsRef OffsetItem for the CharString
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateNewStringIndex(System.Int32)">
            Function takes the original string item and adds the new strings
            to accomodate the CID rules
            @param Font the font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateFDSelect(iTextSharp.text.pdf.CFFFont.OffsetItem,System.Int32)">
            Function creates new FDSelect for non-CID fonts.
            The FDSelect built uses a single range for all glyphs
            @param fdselectRef OffsetItem for the FDSelect
            @param nglyphs the number of glyphs in the font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateCharset(iTextSharp.text.pdf.CFFFont.OffsetItem,System.Int32)">
            Function creates new CharSet for non-CID fonts.
            The CharSet built uses a single range for all glyphs
            @param charsetRef OffsetItem for the CharSet
            @param nglyphs the number of glyphs in the font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateFDArray(iTextSharp.text.pdf.CFFFont.OffsetItem,iTextSharp.text.pdf.CFFFont.OffsetItem,System.Int32)">
            Function creates new FDArray for non-CID fonts.
            The FDArray built has only the "Private" operator that points to the font's
            original private dict 
            @param fdarrayRef OffsetItem for the FDArray
            @param privateRef OffsetItem for the Private Dict
            @param Font the font
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.Reconstruct(System.Int32)">
            Function reconstructs the FDArray, PrivateDict and LSubr for CID fonts
            @param Font the font
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReconstructFDArray(System.Int32,iTextSharp.text.pdf.CFFFont.OffsetItem[])">
            Function subsets the FDArray and builds the new one with new offsets
            @param Font The font
            @param fdPrivate OffsetItem Array (one for each FDArray)
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReconstructPrivateDict(System.Int32,iTextSharp.text.pdf.CFFFont.OffsetItem[],iTextSharp.text.pdf.CFFFont.IndexBaseItem[],iTextSharp.text.pdf.CFFFont.OffsetItem[])">
            Function Adds the new private dicts (only for the FDs used) to the list
            @param Font the font
            @param fdPrivate OffsetItem array one element for each private
            @param fdPrivateBase IndexBaseItem array one element for each private
            @param fdSubrs OffsetItem array one element for each private
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.ReconstructPrivateSubrs(System.Int32,iTextSharp.text.pdf.CFFFont.IndexBaseItem[],iTextSharp.text.pdf.CFFFont.OffsetItem[])">
            Function Adds the new LSubrs dicts (only for the FDs used) to the list
            @param Font  The index of the font
            @param fdPrivateBase The IndexBaseItem array for the linked list
            @param fdSubrs OffsetItem array for the linked list
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CalcSubrOffsetSize(System.Int32,System.Int32)">
            Calculates how many byte it took to write the offset for the subrs in a specific
            private dict.
            @param Offset The Offset for the private dict
            @param Size The size of the private dict
            @return The size of the offset of the subrs in the private dict
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CountEntireIndexRange(System.Int32)">
            Function computes the size of an index
            @param indexOffset The offset for the computed index
            @return The size of the index
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateNonCIDPrivate(System.Int32,iTextSharp.text.pdf.CFFFont.OffsetItem)">
            The function creates a private dict for a font that was not CID
            All the keys are copied as is except for the subrs key 
            @param Font the font
            @param Subr The OffsetItem for the subrs of the private 
        </member>
        <member name="M:iTextSharp.text.pdf.CFFFontSubset.CreateNonCIDSubrs(System.Int32,iTextSharp.text.pdf.CFFFont.IndexBaseItem,iTextSharp.text.pdf.CFFFont.OffsetItem)">
            the function marks the beginning of the subrs index and adds the subsetted subrs
            index to the output list. 
            @param Font the font
            @param PrivateBase IndexBaseItem for the private that's referencing to the subrs
            @param Subrs OffsetItem for the subrs
            @throws IOException
        </member>
        <member name="T:iTextSharp.text.pdf.CJKFont">
             Creates a CJK font compatible with the fonts in the Adobe Asian font Pack.
            
             @author  Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.CJKFont.CJK_ENCODING">
            The encoding used in the PDF document for CJK fonts
        </member>
        <member name="F:iTextSharp.text.pdf.CJKFont.RESOURCE_PATH_CMAP">
            The path to the font resources. 
        </member>
        <member name="F:iTextSharp.text.pdf.CJKFont.fontName">
            The font name 
        </member>
        <member name="F:iTextSharp.text.pdf.CJKFont.style">
            The style modifier 
        </member>
        <member name="F:iTextSharp.text.pdf.CJKFont.CMap">
            The CMap name associated with this font 
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.#ctor(System.String,System.String,System.Boolean)">
            Creates a CJK font.
            @param fontName the name of the font
            @param enc the encoding of the font
            @param emb always <CODE>false</CODE>. CJK font and not embedded
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.GetCompatibleFont(System.String)">
            Returns a font compatible with a CJK encoding or null if not found.
            @param enc
            @return 
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.IsCJKFont(System.String,System.String)">
            Checks if its a valid CJK font.
            @param fontName the font name
            @param enc the encoding
            @return <CODE>true</CODE> if it is CJK font
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.GetWidth(System.Int32)">
            Gets the width of a <CODE>char</CODE> in normalized 1000 units.
            @param char1 the unicode <CODE>char</CODE> to get the width of
            @return the width in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.GetFullFontStream">
            You can't get the FontStream of a CJK font (CJK fonts are never embedded),
            so this method always returns null.
            @return  null
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.CJKFont.GetFontDescriptor(System.Int32,System.Single)">
            Gets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>
            and <CODE>ITALICANGLE</CODE>.
            @param key the parameter to be extracted
            @param fontSize the font size in points
            @return the parameter in points
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.CJKFont.ConvertToBytes(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.CJKFont.ConvertToBytes(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.CJKFont.FullFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.CJKFont.AllNameEntries" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.CJKFont.FamilyFontName" -->
        <member name="T:iTextSharp.text.pdf.CMapAwareDocumentFont">
            Implementation of DocumentFont used while parsing PDF streams.
            @since 2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.#ctor(iTextSharp.text.pdf.PdfDictionary)">
            Creates a new instance of DocumentFont 
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.#ctor(iTextSharp.text.pdf.PRIndirectReference)">
            Creates a new instance of DocumentFont 
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.#ctor(iTextSharp.text.pdf.PRIndirectReference,iTextSharp.text.pdf.PdfDictionary)">
            Creates a new instance of DocumentFont 
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.GetFontDescriptor(System.Int32,System.Single)">
            Gets the font parameter identified by <CODE>key</CODE>. Valid values
             for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>,
             <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
             and <CODE>BBOXURY</CODE>.
             @param key the parameter to be extracted
             @param fontSize the font size in points
             @return the parameter in points
            
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.GetKerning(System.Int32,System.Int32)">
            Gets the kerning between two Unicode chars.
             @param char1 the first char
             @param char2 the second char
             @return the kerning to be applied
            
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.GetRawWidth(System.Int32,System.String)">
            Gets the width from the font according to the Unicode char <CODE>c</CODE>
             or the <CODE>name</CODE>. If the <CODE>name</CODE> is null it's a symbolic font.
             @param c the unicode char
             @param name the glyph name
             @return the width of the char
            
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.HasKernPairs">
            Checks if the font has any kerning pairs.
             @return <CODE>true</CODE> if the font has any kerning pairs
            
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.WriteFont(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfIndirectReference,System.Object[])">
            Outputs to the writer the font dictionaries and streams.
             @param writer the writer for this document
             @param ref the font indirect reference
             @param params several parameters that depend on the font type
             @throws IOException on error
             @throws DocumentException error in generating the object
            
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.GetFullFontStream">
            Always returns null.
            @return  null
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.DocumentFont.GetWidth(System.Int32)">
            Gets the width of a <CODE>char</CODE> in normalized 1000 units.
            @param char1 the unicode <CODE>char</CODE> to get the width of
            @return the width in normalized 1000 units
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.DocumentFont.FamilyFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.DocumentFont.FullFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.DocumentFont.AllNameEntries" -->
        <member name="P:iTextSharp.text.pdf.DocumentFont.PostscriptFontName">
            Gets the postscript font name.
             @return the postscript font name
            
        </member>
        <member name="P:iTextSharp.text.pdf.DocumentFont.Uni2Byte">
            Exposes the unicode - > CID map that is constructed from the font's encoding
            @return the unicode to CID map
            @since 2.1.7
        </member>
        <member name="P:iTextSharp.text.pdf.DocumentFont.Byte2Uni">
            Exposes the CID - > unicode map that is constructed from the font's encoding
            @return the CID to unicode map
            @since 5.4.0
        </member>
        <member name="P:iTextSharp.text.pdf.DocumentFont.Diffmap">
            Gets the difference map
            @return the difference map
            @since 5.0.5
        </member>
        <member name="F:iTextSharp.text.pdf.CMapAwareDocumentFont.fontDic">
            The font dictionary. 
        </member>
        <member name="F:iTextSharp.text.pdf.CMapAwareDocumentFont.spaceWidth">
            the width of a space for this font, in normalized 1000 point units 
        </member>
        <member name="F:iTextSharp.text.pdf.CMapAwareDocumentFont.toUnicodeCmap">
            The CMap constructed from the ToUnicode map from the font's dictionary, if present.
            This CMap transforms CID values into unicode equivalent
        </member>
        <member name="F:iTextSharp.text.pdf.CMapAwareDocumentFont.cidbyte2uni">
            Mapping between CID code (single byte only for now) and unicode equivalent
            as derived by the font's encoding.  Only needed if the ToUnicode CMap is not provided.
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.#ctor(iTextSharp.text.pdf.PRIndirectReference)">
            Creates an instance of a CMapAwareFont based on an indirect reference to a font.
            @param refFont   the indirect reference to a font
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.ProcessToUnicode">
            Parses the ToUnicode entry, if present, and constructs a CMap for it
            @since 2.1.7
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.ProcessUni2Byte">
            Inverts DocumentFont's uni2byte mapping to obtain a cid-to-unicode mapping based
            on the font's encoding
            @since 2.1.7
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.ComputeAverageWidth">
            For all widths of all glyphs, compute the average width in normalized 1000 point units.
            This is used to give some meaningful width in cases where we need an average font width 
            (such as if the width of a space isn't specified by a given font)
            @return the average width of all non-zero width glyphs in the font
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.GetWidth(System.Int32)">
            @since 2.1.5
            Override to allow special handling for fonts that don't specify width of space character
            @see com.itextpdf.text.pdf.DocumentFont#getWidth(int)
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.DecodeSingleCID(System.Byte[],System.Int32,System.Int32)">
            Decodes a single CID (represented by one or two bytes) to a unicode String.
            @param bytes     the bytes making up the character code to convert
            @param offset    an offset
            @param len       a length
            @return  a String containing the encoded form of the input bytes using the font's encoding.
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.Decode(System.Byte[],System.Int32,System.Int32)">
            Decodes a string of bytes (encoded in the font's encoding) into a unicode string
            This will use the ToUnicode map of the font, if available, otherwise it uses
            the font's encoding
            @param cidbytes    the bytes that need to be decoded
            @return  the unicode String that results from decoding
            @since 2.1.7
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.DecodeSingleCharacter(System.Byte[],System.Int32,System.Int32)">
            ! .NET SPECIFIC; this method is used to avoid unecessary using of StringBuilder because it is slow in .NET !
            Decodes a single character string of bytes (encoded in the font's encoding) into a unicode string
            This will use the ToUnicode map of the font, if available, otherwise it uses
            the font's encoding
            @param cidbytes    the bytes that need to be decoded
            @return  the unicode String that results from decoding
        </member>
        <member name="M:iTextSharp.text.pdf.CMapAwareDocumentFont.Encode(System.Byte[],System.Int32,System.Int32)">
            Encodes bytes to a String.
            @param bytes     the bytes from a stream
            @param offset    an offset
            @param len       a length
            @return  a String encoded taking into account if the bytes are in unicode or not.
            @deprecated method name is not indicative of what it does.  Use <code>decode</code> instead.
        </member>
        <member name="T:iTextSharp.text.pdf.CMYKColor">
            
             @author  Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.ExtendedColor">
            
             @author  Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.ExtendedColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructs an extended color of a certain type and a certain color.
            @param type
            @param red
            @param green
            @param blue
            @param alpha
        </member>
        <member name="T:iTextSharp.text.pdf.codec.BitFile">
             Came from GIFEncoder initially.
             Modified - to allow for output compressed data without the block counts
             which breakup the compressed data stream for GIF.
            
        </member>
        <member name="F:iTextSharp.text.pdf.codec.BitFile.blocks_">
            note this also indicates gif format BITFile. *
        </member>
        <member name="M:iTextSharp.text.pdf.codec.BitFile.#ctor(System.IO.Stream,System.Boolean)">
             @param output destination for output data
             @param blocks GIF LZW requires block counts for output data
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.codec.BmpImage" -->
        <member name="M:iTextSharp.text.pdf.codec.BmpImage.GetImage(System.Uri)">
            Reads a BMP from an url.
            @param url the url
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.BmpImage.GetImage(System.IO.Stream)">
            Reads a BMP from a stream. The stream is not closed.
            @param is the stream
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.BmpImage.GetImage(System.IO.Stream,System.Boolean,System.Int32)">
            Reads a BMP from a stream. The stream is not closed.
            The BMP may not have a header and be considered as a plain DIB.
            @param is the stream
            @param noHeader true to process a plain DIB
            @param size the size of the DIB. Not used for a BMP
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.BmpImage.GetImage(System.String)">
            Reads a BMP from a file.
            @param file the file
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.BmpImage.GetImage(System.Byte[])">
            Reads a BMP from a byte array.
            @param data the byte array
            @throws IOException on error
            @return the image
        </member>
        <member name="T:iTextSharp.text.pdf.codec.CCITTG4Encoder">
            Encodes data in the CCITT G4 FAX format.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.CCITTG4Encoder.#ctor(System.Int32)">
            Creates a new encoder.
            @param width the line width
        </member>
        <member name="M:iTextSharp.text.pdf.codec.CCITTG4Encoder.Fax4Encode(System.Byte[],System.Int32,System.Int32)">
            Encodes a number of lines.
            @param data the data to be encoded
            @param offset the offset into the data
            @param size the size of the data to be encoded
        </member>
        <member name="M:iTextSharp.text.pdf.codec.CCITTG4Encoder.Compress(System.Byte[],System.Int32,System.Int32)">
            Encodes a full image.
            @param data the data to encode
            @param width the image width
            @param height the image height
            @return the encoded image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.CCITTG4Encoder.Fax4Encode(System.Byte[],System.Int32)">
            Encodes a number of lines.
            @param data the data to be encoded
            @param height the number of lines to encode
        </member>
        <member name="M:iTextSharp.text.pdf.codec.CCITTG4Encoder.Close">
            Closes the encoder and returns the encoded data.
            @return the encoded data
        </member>
        <member name="T:iTextSharp.text.pdf.codec.GifImage">
            Reads gif images of all types. All the images in a gif are read in the constructors
            and can be retrieved with other methods.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.#ctor(System.Uri)">
            Reads gif images from an URL.
            @param url the URL
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.#ctor(System.String)">
            Reads gif images from a file.
            @param file the file
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.#ctor(System.Byte[])">
            Reads gif images from a byte array.
            @param data the byte array
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.#ctor(System.IO.Stream)">
            Reads gif images from a stream. The stream isp not closed.
            @param isp the stream
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.GetFrameCount">
            Gets the number of frames the gif has.
            @return the number of frames the gif has
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.GetImage(System.Int32)">
            Gets the image from a frame. The first frame isp 1.
            @param frame the frame to get the image from
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.GetFramePosition(System.Int32)">
            Gets the [x,y] position of the frame in reference to the
            logical screen.
            @param frame the frame
            @return the [x,y] position of the frame
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.GetLogicalScreen">
            Gets the logical screen. The images may be smaller and placed
            in some position in this screen to playback some animation.
            No image will be be bigger that this.
            @return the logical screen dimensions as [x,y]
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadHeader">
            Reads GIF file header information.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadLSD">
            Reads Logical Screen Descriptor
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadShort">
            Reads next 16-bit value, LSB first
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadBlock">
             Reads next variable length block from input.
            
             @return number of bytes stored in "buffer"
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadImage">
            Reads next frame image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ResetFrame">
            Resets frame state for reading next image.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.ReadGraphicControlExt">
            Reads Graphics Control Extension values
        </member>
        <member name="M:iTextSharp.text.pdf.codec.GifImage.Skip">
            Skips variable length blocks up to and including
            next zero length block.
        </member>
        <member name="T:iTextSharp.text.pdf.codec.JBIG2Image">
            Support for JBIG2 Images.
            This class assumes that we are always embedding into a pdf.
            
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.codec.JBIG2Image.GetGlobalSegment(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Gets a byte array that can be used as a /JBIG2Globals,
            or null if not applicable to the given jbig2.
            @param   ra  an random access file or array
            @return  a byte array
        </member>
        <member name="M:iTextSharp.text.pdf.codec.JBIG2Image.GetJbig2Image(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Int32)">
            returns an Image representing the given page.
            @param ra    the file or array containing the image
            @param page  the page number of the image
            @return  an Image object
        </member>
        <member name="T:iTextSharp.text.pdf.codec.JBIG2SegmentReader">
            Class to read a JBIG2 file at a basic level: understand all the segments, 
            understand what segments belong to which pages, how many pages there are,
            what the width and height of each page is, and global segments if there
            are any.  Or: the minimum required to be able to take a normal sequential
            or random-access organized file, and be able to embed JBIG2 pages as images 
            in a PDF.
            
            TODO: the indeterminate-segment-size value of dataLength, else?
            
            @since 2.1.5
        </member>
        <member name="T:iTextSharp.text.pdf.codec.JBIG2SegmentReader.JBIG2Segment">
            Inner class that holds information about a JBIG2 segment.
            @since   2.1.5
        </member>
        <member name="T:iTextSharp.text.pdf.codec.JBIG2SegmentReader.JBIG2Page">
            Inner class that holds information about a JBIG2 page.
            @since   2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.codec.JBIG2SegmentReader.JBIG2Page.GetData(System.Boolean)">
            return as a single byte array the header-data for each segment in segment number
            order, EMBEDDED organization, but i am putting the needed segments in SEQUENTIAL organization.
            if for_embedding, skip the segment types that are known to be not for acrobat. 
            @param for_embedding
            @return  a byte array
            @throws IOException
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.codec.PngImage" -->
        <member name="F:iTextSharp.text.pdf.codec.PngImage.IHDR">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.PLTE">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.IDAT">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.IEND">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.tRNS">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.pHYs">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.gAMA">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.cHRM">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.sRGB">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.iCCP">
            A PNG marker. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.PngImage.PNGID">
            Some PNG specific values. 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.#ctor(System.IO.Stream)">
            Creates a new instance of PngImage 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetImage(System.Uri)">
            Reads a PNG from an url.
            @param url the url
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetImage(System.IO.Stream)">
            Reads a PNG from a stream.
            @param is the stream
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetImage(System.String)">
            Reads a PNG from a file.
            @param file the file
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetImage(System.Byte[])">
            Reads a PNG from a byte array.
            @param data the byte array
            @throws IOException on error
            @return the image
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetInt(System.IO.Stream)">
             Gets an <CODE>int</CODE> from an <CODE>Stream</CODE>.
            
             @param		is      an <CODE>Stream</CODE>
             @return		the value of an <CODE>int</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetWord(System.IO.Stream)">
             Gets a <CODE>word</CODE> from an <CODE>Stream</CODE>.
            
             @param		is      an <CODE>Stream</CODE>
             @return		the value of an <CODE>int</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.codec.PngImage.GetString(System.IO.Stream)">
             Gets a <CODE>String</CODE> from an <CODE>Stream</CODE>.
            
             @param		is      an <CODE>Stream</CODE>
             @return		the value of an <CODE>int</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.codec.TIFFConstants">
            A list of constants used in class TIFFImage.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.codec.TIFFDirectory" -->
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.isBigEndian">
            A bool storing the endianness of the stream. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.numEntries">
            The number of entries in the IFD. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.fields">
            An array of TIFFFields. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.fieldIndex">
            A Hashtable indexing the fields by tag number. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.IFDOffset">
            The offset of this IFD. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFDirectory.nextIFDOffset">
            The offset of the next IFD. 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.#ctor">
            The default constructor. 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Int32)">
             Constructs a TIFFDirectory from a SeekableStream.
             The directory parameter specifies which directory to read from
             the linked list present in the stream; directory 0 is normally
             read but it is possible to store multiple images in a single
             TIFF file by maintaing multiple directories.
            
             @param stream a SeekableStream to read from.
             @param directory the index of the directory to read.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Int64,System.Int32)">
             Constructs a TIFFDirectory by reading a SeekableStream.
             The ifd_offset parameter specifies the stream offset from which
             to begin reading; this mechanism is sometimes used to store
             private IFDs within a TIFF file that are not part of the normal
             sequence of IFDs.
            
             @param stream a SeekableStream to read from.
             @param ifd_offset the long byte offset of the directory.
             @param directory the index of the directory to read beyond the
                    one at the current stream offset; zero indicates the IFD
                    at the current offset.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetNumEntries">
            Returns the number of directory entries. 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetField(System.Int32)">
            Returns the value of a given tag as a TIFFField,
            or null if the tag is not present.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.IsTagPresent(System.Int32)">
            Returns true if a tag appears in the directory.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetTags">
            Returns an ordered array of ints indicating the tag
            values.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFields">
            Returns an array of TIFFFields containing all the fields
            in this directory.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsByte(System.Int32,System.Int32)">
            Returns the value of a particular index of a given tag as a
            byte.  The caller is responsible for ensuring that the tag is
            present and has type TIFFField.TIFF_SBYTE, TIFF_BYTE, or
            TIFF_UNDEFINED.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsByte(System.Int32)">
            Returns the value of index 0 of a given tag as a
            byte.  The caller is responsible for ensuring that the tag is
            present and has  type TIFFField.TIFF_SBYTE, TIFF_BYTE, or
            TIFF_UNDEFINED.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsLong(System.Int32,System.Int32)">
            Returns the value of a particular index of a given tag as a
            long.  The caller is responsible for ensuring that the tag is
            present and has type TIFF_BYTE, TIFF_SBYTE, TIFF_UNDEFINED,
            TIFF_SHORT, TIFF_SSHORT, TIFF_SLONG or TIFF_LONG.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsLong(System.Int32)">
            Returns the value of index 0 of a given tag as a
            long.  The caller is responsible for ensuring that the tag is
            present and has type TIFF_BYTE, TIFF_SBYTE, TIFF_UNDEFINED,
            TIFF_SHORT, TIFF_SSHORT, TIFF_SLONG or TIFF_LONG.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsFloat(System.Int32,System.Int32)">
            Returns the value of a particular index of a given tag as a
            float.  The caller is responsible for ensuring that the tag is
            present and has numeric type (all but TIFF_UNDEFINED and
            TIFF_ASCII).
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsFloat(System.Int32)">
            Returns the value of index 0 of a given tag as a float.  The
            caller is responsible for ensuring that the tag is present and
            has numeric type (all but TIFF_UNDEFINED and TIFF_ASCII).
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsDouble(System.Int32,System.Int32)">
            Returns the value of a particular index of a given tag as a
            double.  The caller is responsible for ensuring that the tag is
            present and has numeric type (all but TIFF_UNDEFINED and
            TIFF_ASCII).
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetFieldAsDouble(System.Int32)">
            Returns the value of index 0 of a given tag as a double.  The
            caller is responsible for ensuring that the tag is present and
            has numeric type (all but TIFF_UNDEFINED and TIFF_ASCII).
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetNumDirectories(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Returns the number of image directories (subimages) stored in a
            given TIFF file, represented by a <code>SeekableStream</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.IsBigEndian">
            Returns a bool indicating whether the byte order used in the
            the TIFF file is big-endian (i.e. whether the byte order is from
            the most significant to the least significant)
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetIFDOffset">
            Returns the offset of the IFD corresponding to this
            <code>TIFFDirectory</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFDirectory.GetNextIFDOffset">
            Returns the offset of the next IFD after the IFD corresponding to this
            <code>TIFFDirectory</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFFaxDecoder.#ctor(System.Int64,System.Int32,System.Int32)">
            @param fillOrder   The fill order of the compressed data bytes.
            @param w
            @param h
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFFaxDecompressor.fillOrder">
            The logical order of bits within a byte.
            <pre>
            1 = MSB-to-LSB
            2 = LSB-to-MSB (flipped)
            </pre>
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFFaxDecompressor.uncompressedMode">
            Uncompressed mode flag: 1 if uncompressed, 0 if not.
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFFaxDecompressor.fillBits">
            EOL padding flag: 1 if fill bits have been added before an EOL such
            that the EOL ends on a byte boundary, 0 otherwise.
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFFaxDecompressor.oneD">
            Coding dimensionality: 1 for 2-dimensional, 0 for 1-dimensional.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFFaxDecompressor.SetOptions(System.Int32,System.Int32,System.Int32,System.Int32)">
            Invokes the superclass method and then sets instance variables on
            the basis of the metadata set on this decompressor.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.codec.TIFFField" -->
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_BYTE">
            Flag for 8 bit unsigned integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_ASCII">
            Flag for null-terminated ASCII strings. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_SHORT">
            Flag for 16 bit unsigned integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_LONG">
            Flag for 32 bit unsigned integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_RATIONAL">
            Flag for pairs of 32 bit unsigned integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_SBYTE">
            Flag for 8 bit signed integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_UNDEFINED">
            Flag for 8 bit uninterpreted bytes. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_SSHORT">
            Flag for 16 bit signed integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_SLONG">
            Flag for 32 bit signed integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_SRATIONAL">
            Flag for pairs of 32 bit signed integers. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_FLOAT">
            Flag for 32 bit IEEE floats. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.TIFF_DOUBLE">
            Flag for 64 bit IEEE doubles. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.tag">
            The tag number. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.type">
            The tag type. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.count">
            The number of data items present in the field. 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.TIFFField.data">
            The field data. 
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFField.#ctor">
            The default constructor. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.#ctor(System.Int32,System.Int32,System.Int32,System.Object)" -->
        <member name="M:iTextSharp.text.pdf.codec.TIFFField.GetTag">
            Returns the tag number, between 0 and 65535.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFField.GetType">
             Returns the type of the data stored in the IFD.
             For a TIFF6.0 file, the value will equal one of the
             TIFF_ constants defined in this class.  For future
             revisions of TIFF, higher values are possible.
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFField.GetCount">
            Returns the number of elements in the IFD.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsBytes" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsChars" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsShorts" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsInts" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsLongs" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsFloats" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsDoubles" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsSRationals" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsRationals" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsInt(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsLong(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsFloat(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsDouble(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsString(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsSRational(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.GetAsRational(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.codec.TIFFField.CompareTo(iTextSharp.text.pdf.codec.TIFFField)" -->
        <member name="T:iTextSharp.text.pdf.codec.TiffImage">
            Reads TIFF images
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TiffImage.GetNumberOfPages(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Gets the number of pages the TIFF document has.
            @param s the file source
            @return the number of pages
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TiffImage.GetTiffImage(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Boolean,System.Int32,System.Boolean)">
            Reads a page from a TIFF image.
            @param s the file source
            @param page the page to get. The first page is 1
            @param direct for single strip, CCITT images, generate the image
            by direct byte copying. It's faster but may not work
            every time
            @return the <CODE>Image</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TiffImage.GetTiffImage(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Int32)">
            Reads a page from a TIFF image. Direct mode is not used.
            @param s the file source
            @param page the page to get. The first page is 1
            @return the <CODE>Image</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TiffImage.GetTiffImage(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Int32,System.Boolean)">
            Reads a page from a TIFF image.
            @param s the file source
            @param page the page to get. The first page is 1
            @param direct for single strip, CCITT images, generate the image
            by direct byte copying. It's faster but may not work
            every time
            @return the <CODE>Image</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.codec.TIFFLZWDecoder">
             A class for performing LZW decoding.
            
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.Decode(System.Byte[],System.Byte[],System.Int32)">
             Method to decode LZW compressed data.
            
             @param data            The compressed data.
             @param uncompData      Array to return the uncompressed data in.
             @param h               The number of rows the compressed data contains.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.InitializeStringTable">
            Initialize the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.WriteString(System.Byte[])">
            Write out the string just uncompressed.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.AddStringToTable(System.Byte[],System.Byte)">
            Add a new string to the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.AddStringToTable(System.Byte[])">
            Add a new string to the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.codec.TIFFLZWDecoder.ComposeString(System.Byte[],System.Byte)">
            Append <code>newString</code> to the end of <code>oldString</code>.
        </member>
        <member name="T:iTextSharp.text.pdf.codec.TiffWriter">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.codec.wmf.InputMeta">
            <summary>
            Summary description for InputMeta.
            </summary>
        </member>
        <member name="T:iTextSharp.text.pdf.codec.wmf.MetaDo">
            <summary>
            Summary description for MetaDo.
            </summary>
        </member>
        <member name="M:iTextSharp.text.pdf.codec.wmf.MetaState.#ctor">
            Creates new MetaState 
        </member>
        <member name="P:iTextSharp.text.pdf.codec.wmf.MetaState.CurrentBackgroundColor">
            Getter for property currentBackgroundColor.
            @return Value of property currentBackgroundColor.
        </member>
        <member name="P:iTextSharp.text.pdf.codec.wmf.MetaState.CurrentTextColor">
            Getter for property currentTextColor.
            @return Value of property currentTextColor.
        </member>
        <member name="P:iTextSharp.text.pdf.codec.wmf.MetaState.BackgroundMode">
            Getter for property backgroundMode.
            @return Value of property backgroundMode.
        </member>
        <member name="P:iTextSharp.text.pdf.codec.wmf.MetaState.TextAlign">
            Getter for property textAlign.
            @return Value of property textAlign.
        </member>
        <member name="P:iTextSharp.text.pdf.codec.wmf.MetaState.PolyFillMode">
            Getter for property polyFillMode.
            @return Value of property polyFillMode.
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollection.DETAILS">
            A type of PDF Collection 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollection.TILE">
            A type of PDF Collection 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollection.HIDDEN">
            A type of PDF Collection 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollection.CUSTOM">
            A type of PDF Collection 
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollection.#ctor(System.Int32)">
            Constructs a PDF Collection.
            @param   type    the type of PDF collection.
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollection.InitialDocument">
            Identifies the document that will be initially presented
            in the user interface.
            @param description   the description that was used when attaching the file to the document
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollection.Schema">
            Sets the Collection schema dictionary.
            @param schema    an overview of the collection fields
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollection.Sort">
            Sets the Collection sort dictionary.
            @param sort  a collection sort dictionary
        </member>
        <member name="T:iTextSharp.text.pdf.collection.PdfCollectionField">
             @author blowagie
            
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.TEXT">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.DATE">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.NUMBER">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.FILENAME">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.DESC">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.MODDATE">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.CREATIONDATE">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.SIZE">
            A possible type of collection field. 
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionField.fieldType">
            The type of the PDF collection field. 
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionField.#ctor(System.String,System.Int32)">
            Creates a PdfCollectionField.
            @param name      the field name
            @param type      the field type
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionField.IsCollectionItem">
            Checks if the type of the field is suitable for a Collection Item.
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionField.GetValue(System.String)">
            Returns a PdfObject that can be used as the value of a Collection Item.
            @param String    value   the value that has to be changed into a PdfObject (PdfString, PdfDate or PdfNumber) 
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollectionField.Order">
            The relative order of the field name. Fields are sorted in ascending order.
            @param i a number indicating the order of the field
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollectionField.Visible">
            Sets the initial visibility of the field.
            @param visible   the default is true (visible)
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfCollectionField.Editable">
            Indication if the field value should be editable in the viewer.
            @param editable  the default is false (not editable)
        </member>
        <member name="F:iTextSharp.text.pdf.collection.PdfCollectionItem.schema">
            The PdfCollectionSchema with the names and types of the items. 
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.#ctor(iTextSharp.text.pdf.collection.PdfCollectionSchema)">
            Constructs a Collection Item that can be added to a PdfFileSpecification.
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,System.String)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,iTextSharp.text.pdf.PdfString)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,iTextSharp.text.pdf.PdfDate)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,iTextSharp.text.pdf.PdfNumber)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,System.DateTime)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,System.Int32)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,System.Single)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.AddItem(System.String,System.Double)">
            Sets the value of the collection item.
            @param value
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionItem.SetPrefix(System.String,System.String)">
            Adds a prefix for the Collection item.
            You can only use this method after you have set the value of the item.
            @param prefix    a prefix
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSchema.#ctor">
            Creates a Collection Schema dictionary.
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSchema.AddField(System.String,iTextSharp.text.pdf.collection.PdfCollectionField)">
            Adds a Collection field to the Schema.
            @param name  the name of the collection field
            @param field a Collection Field
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSort.#ctor(System.String)">
            Constructs a PDF Collection Sort Dictionary.
            @param key   the key of the field that will be used to sort entries
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSort.#ctor(System.String[])">
            Constructs a PDF Collection Sort Dictionary.
            @param keys  the keys of the fields that will be used to sort entries
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSort.SetSortOrder(System.Boolean)">
            Defines the sort order of the field (ascending or descending).
            @param ascending true is the default, use false for descending order
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfCollectionSort.SetSortOrder(System.Boolean[])">
            Defines the sort order of the field (ascending or descending).
            @param ascending an array with every element corresponding with a name of a field.
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfTargetDictionary.#ctor(iTextSharp.text.pdf.collection.PdfTargetDictionary)">
            Creates dictionary referring to a target document that is the parent of the current document.
            @param nested    null if this is the actual target, another target if this is only an intermediate target.
        </member>
        <member name="M:iTextSharp.text.pdf.collection.PdfTargetDictionary.#ctor(System.Boolean)">
            Creates a dictionary referring to a target document.
            @param child if false, this refers to the parent document; if true, this refers to a child document, and you'll have to specify where to find the child using the other methods of this class
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.EmbeddedFileName">
            If this dictionary refers to a child that is a document level attachment,
            you need to specify the name that was used to attach the document.
            @param   name    the name in the EmbeddedFiles name tree
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.FileAttachmentPagename">
            If this dictionary refers to a child that is a file attachment added to a page,
            you need to specify the name of the page (or use setFileAttachmentPage to specify the page number).
            Once you have specified the page, you still need to specify the attachment using another method.
            @param name  the named destination referring to the page with the file attachment.
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.FileAttachmentPage">
            If this dictionary refers to a child that is a file attachment added to a page,
            you need to specify the page number (or use setFileAttachmentPagename to specify a named destination).
            Once you have specified the page, you still need to specify the attachment using another method.
            @param page  the page number of the page with the file attachment.
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.FileAttachmentName">
            If this dictionary refers to a child that is a file attachment added to a page,
            you need to specify the page with setFileAttachmentPage or setFileAttachmentPageName,
            and then specify the name of the attachment added to this page (or use setFileAttachmentIndex).
            @param name      the name of the attachment
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.FileAttachmentIndex">
            If this dictionary refers to a child that is a file attachment added to a page,
            you need to specify the page with setFileAttachmentPage or setFileAttachmentPageName,
            and then specify the index of the attachment added to this page (or use setFileAttachmentName).
            @param name      the name of the attachment
        </member>
        <member name="P:iTextSharp.text.pdf.collection.PdfTargetDictionary.AdditionalPath">
            If this dictionary refers to an intermediate target, you can
            add the next target in the sequence.
            @param nested    the next target in the sequence
        </member>
        <member name="T:iTextSharp.text.pdf.ColorDetails">
            Each colorSpace in the document will have an instance of this class
            
             @author Phillip Pan (phillip@formstar.com)
        </member>
        <member name="F:iTextSharp.text.pdf.ColorDetails.indirectReference">
            The indirect reference to this color
        </member>
        <member name="F:iTextSharp.text.pdf.ColorDetails.colorSpaceName">
            The color name that appears in the document body stream
        </member>
        <member name="F:iTextSharp.text.pdf.ColorDetails.colorSpace">
            The color
        </member>
        <member name="M:iTextSharp.text.pdf.ColorDetails.#ctor(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.ICachedColorSpace)">
            Each spot color used in a document has an instance of this class.
            @param colorName the color name
            @param indirectReference the indirect reference to the font
            @param scolor the <CODE>PDfSpotColor</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.ColorDetails.GetPdfObject(iTextSharp.text.pdf.PdfWriter)">
            Gets the <CODE>SpotColor</CODE> object.
            @return the <CODE>PdfSpotColor</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.ColorDetails.IndirectReference">
            Gets the indirect reference to this color.
            @return the indirect reference to this color
        </member>
        <member name="P:iTextSharp.text.pdf.ColorDetails.ColorSpaceName">
            Gets the color name as it appears in the document body.
            @return the color name
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.ColumnText" -->
        <member name="F:iTextSharp.text.pdf.ColumnText.AR_COMPOSEDTASHKEEL">
            Compose the tashkeel in the ligatures. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.AR_LIG">
            Do some extra double ligatures. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGITS_EN2AN">
            Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGITS_AN2EN">
            Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGITS_EN2AN_INIT_LR">
            Digit shaping option:
            Replace European digits (U+0030...U+0039) by Arabic-Indic digits
            if the most recent strongly directional character
            is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
            The initial state at the start of the text is assumed to be not an Arabic,
            letter, so European digits at the start of the text will not change.
            Compare to DIGITS_ALEN2AN_INIT_AL.
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGITS_EN2AN_INIT_AL">
            Digit shaping option:
            Replace European digits (U+0030...U+0039) by Arabic-Indic digits
            if the most recent strongly directional character
            is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
            The initial state at the start of the text is assumed to be an Arabic,
            letter, so European digits at the start of the text will change.
            Compare to DIGITS_ALEN2AN_INT_LR.
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGIT_TYPE_AN">
            Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.DIGIT_TYPE_AN_EXTENDED">
            Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.NO_MORE_TEXT">
            Signals that there is no more text available. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.NO_MORE_COLUMN">
            Signals that there is no more column. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.LINE_STATUS_OK">
            The column is valid. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.LINE_STATUS_OFFLIMITS">
            The line is out the column limits. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.LINE_STATUS_NOLINE">
            The line cannot fit this column position. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.AR_NOVOWEL">
            Eliminate the arabic vowels 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.maxY">
            Upper bound of the column. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.minY">
            Lower bound of the column. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.alignment">
            The column Element. Default is left Element. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.leftWall">
            The left column bound. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.rightWall">
            The right column bound. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.bidiLine">
            The chunks that form the text. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.yLine">
            The current y line location. Text will be written at this line minus the leading. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.lastX">
            The X position after the last line that has been written.
            @since 5.0.3
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.currentLeading">
            The leading for the current line. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.fixedLeading">
            The fixed text leading. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.multipliedLeading">
            The text leading that is multiplied by the biggest font size in the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.canvas">
            The <CODE>PdfContent</CODE> where the text will be written to. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.lineStatus">
            The line status when trying to fit a line to a column. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.indent">
            The first paragraph line indent. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.followingIndent">
            The following paragraph lines indent. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.rightIndent">
            The right paragraph lines indent. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.extraParagraphSpace">
            The extra space between paragraphs. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.rectangularWidth">
            The width of the line when the column is defined as a simple rectangle. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.spaceCharRatio">
            Holds value of property spaceCharRatio. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.linesWritten">
            Holds value of property linesWritten. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.arabicOptions">
            Holds value of property arabicOptions. 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.rowIdx">
            Pointer for the row in a table that is being dealt with
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.splittedRow">
            The index of the last row that needed to be splitted.
            @since 5.0.1 changed a boolean into an int
            -2 value mean it is the first attempt to split the first row.
            -1 means that we try to avoid splitting current row.
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.useAscender">
            if true, first line height is adjusted so that the max ascender touches the top 
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.inheritGraphicState">
            @since 5.4.2
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.#ctor(iTextSharp.text.pdf.PdfContentByte)">
            Creates a <CODE>ColumnText</CODE>.
            @param text the place where the text will be written to. Can
            be a template.
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.Duplicate(iTextSharp.text.pdf.ColumnText)">
            Creates an independent duplicated of the instance <CODE>org</CODE>.
            @param org the original <CODE>ColumnText</CODE>
            @return the duplicated
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetACopy(iTextSharp.text.pdf.ColumnText)">
            Makes this instance an independent copy of <CODE>org</CODE>.
            @param org the original <CODE>ColumnText</CODE>
            @return itself
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.AddText(iTextSharp.text.Phrase)">
            Adds a <CODE>Phrase</CODE> to the current text array.
            @param phrase the text
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetText(iTextSharp.text.Phrase)">
            Replaces the current text array with this <CODE>Phrase</CODE>.
            Anything added previously with AddElement() is lost.
            @param phrase the text
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.AddText(iTextSharp.text.Chunk)">
            Adds a <CODE>Chunk</CODE> to the current text array.
            Will not have any effect if AddElement() was called before.
            @param chunk the text
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.ColumnText.AddElement(iTextSharp.text.IElement)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.ColumnText.ConvertColumn(System.Single[])" -->
        <member name="M:iTextSharp.text.pdf.ColumnText.FindLimitsPoint(System.Collections.Generic.List{System.Single[]})">
            Finds the intersection between the <CODE>yLine</CODE> and the column. It will
            set the <CODE>lineStatus</CODE> apropriatly.
            @param wall the column to intersect
            @return the x coordinate of the intersection
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.FindLimitsOneLine">
            Finds the intersection between the <CODE>yLine</CODE> and the two
            column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
            @return a <CODE>float[2]</CODE>with the x coordinates of the intersection
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.FindLimitsTwoLines">
            Finds the intersection between the <CODE>yLine</CODE>,
            the <CODE>yLine-leading</CODE>and the two
            column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
            @return a <CODE>float[4]</CODE>with the x coordinates of the intersection
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetColumns(System.Single[],System.Single[])">
            Sets the columns bounds. Each column bound is described by a
            <CODE>float[]</CODE> with the line points [x1,y1,x2,y2,...].
            The array must have at least 4 elements.
            @param leftLine the left column bound
            @param rightLine the right column bound
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetSimpleColumn(iTextSharp.text.Phrase,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Simplified method for rectangular columns.
            @param phrase a <CODE>Phrase</CODE>
            @param llx the lower left x corner
            @param lly the lower left y corner
            @param urx the upper right x corner
            @param ury the upper right y corner
            @param leading the leading
            @param alignment the column alignment
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetSimpleColumn(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Simplified method for rectangular columns.
            @param llx the lower left x corner
            @param lly the lower left y corner
            @param urx the upper right x corner
            @param ury the upper right y corner
            @param leading the leading
            @param alignment the column alignment
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetSimpleColumn(System.Single,System.Single,System.Single,System.Single)">
            Simplified method for rectangular columns.
            @param llx
            @param lly
            @param urx
            @param ury
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetSimpleColumn(iTextSharp.text.Rectangle)">
            Simplified method for rectangular columns.
            @param rect  the rectangle for the column
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetLeading(System.Single,System.Single)">
            Sets the leading fixed and variable. The resultant leading will be
            fixedLeading+multipliedLeading*maxFontSize where maxFontSize is the
            size of the bigest font in the line.
            @param fixedLeading the fixed leading
            @param multipliedLeading the variable leading
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.SetIndent(System.Single,System.Boolean)">
             Sets the first paragraph line indent.
            
             @param indent the indent
             @param	repeatFirstLineIndent	do we need to repeat the indentation of the first line after a newline?
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.Go">
            Outputs the lines to the document. It is equivalent to <CODE>go(false)</CODE>.
            @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
            and/or <CODE>NO_MORE_COLUMN</CODE>
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.Go(System.Boolean)">
            Outputs the lines to the document. The output can be simulated.
            @param simulate <CODE>true</CODE> to simulate the writting to the document
            @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
            and/or <CODE>NO_MORE_COLUMN</CODE>
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.IsWordSplit">
            Call this after go() to know if any word was split into several lines.
            @return
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.ClearChunks">
            Clears the chunk array. A call to <CODE>go()</CODE> will always return
            NO_MORE_TEXT.
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.GetWidth(iTextSharp.text.Phrase,System.Int32,System.Int32)">
            Gets the width that the line will occupy after writing.
            Only the width of the first line is returned.
            @param phrase the <CODE>Phrase</CODE> containing the line
            @param runDirection the run direction
            @param arabicOptions the options for the arabic shaping
            @return the width of the line
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.GetWidth(iTextSharp.text.Phrase)">
            Gets the width that the line will occupy after writing.
            Only the width of the first line is returned.
            @param phrase the <CODE>Phrase</CODE> containing the line
            @return the width of the line
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.ShowTextAligned(iTextSharp.text.pdf.PdfContentByte,System.Int32,iTextSharp.text.Phrase,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            Shows a line of text. Only the first line is written.
            @param canvas where the text is to be written to
            @param alignment the alignment. It is not influenced by the run direction
            @param phrase the <CODE>Phrase</CODE> with the text
            @param x the x reference position
            @param y the y reference position
            @param rotation the rotation to be applied in degrees counterclockwise
            @param runDirection the run direction
            @param arabicOptions the options for the arabic shaping
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.ShowTextAligned(iTextSharp.text.pdf.PdfContentByte,System.Int32,iTextSharp.text.Phrase,System.Single,System.Single,System.Single)">
            Shows a line of text. Only the first line is written.
            @param canvas where the text is to be written to
            @param alignment the alignment
            @param phrase the <CODE>Phrase</CODE> with the text
            @param x the x reference position
            @param y the y reference position
            @param rotation the rotation to be applied in degrees counterclockwise
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.FitText(iTextSharp.text.Font,System.String,iTextSharp.text.Rectangle,System.Single,System.Int32)">
            Fits the text to some rectangle adjusting the font size as needed.
            @param font the font to use
            @param text the text
            @param rect the rectangle where the text must fit
            @param maxFontSize the maximum font size
            @param runDirection the run direction
            @return the calculated font size that makes the text fit
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.ZeroHeightElement">
            Checks if the element has a height of 0.
            @return true or false
            @since 2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.HasMoreText(System.Int32)">
            Checks the status variable and looks if there's still some text.
        </member>
        <member name="F:iTextSharp.text.pdf.ColumnText.filledWidth">
            Holds value of property filledWidth.
        </member>
        <member name="M:iTextSharp.text.pdf.ColumnText.UpdateFilledWidth(System.Single)">
            Replaces the <CODE>filledWidth</CODE> if greater than the existing one.
            @param w the new <CODE>filledWidth</CODE> if greater than the existing one
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Leading">
            Gets the fixed leading
            @return the leading
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.MultipliedLeading">
            Gets the variable leading
            @return the leading
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.YLine">
            Gets the yLine.
            @return the yLine
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.RowsDrawn">
            Gets the number of rows that were drawn when a table is involved.
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Alignment">
            Gets the Element.
            @return the alignment
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Indent">
            Gets the first paragraph line indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.FollowingIndent">
            Gets the following paragraph lines indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.RightIndent">
            Gets the right paragraph lines indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.CurrentLeading">
             Gets the currentLeading.
            
             @return the currentLeading
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.ExtraParagraphSpace">
            Sets the extra space between paragraphs.
            @return the extra space between paragraphs
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.SpaceCharRatio">
            Gets the space/character extra spacing ratio for
            fully justified text.
            @return the space/character extra spacing ratio
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.RunDirection">
            Gets the run direction.
            @return the run direction
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.LinesWritten">
            Gets the number of lines written.
            @return the number of lines written
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.LastX">
            Gets the X position of the end of the last line that has been written
            (will not work in simulation mode!).
            @since 5.0.3
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.ArabicOptions">
            Sets the arabic shaping options. The option can be AR_NOVOWEL,
            AR_COMPOSEDTASHKEEL and AR_LIG.
            @param arabicOptions the arabic shaping options
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Descender">
            Gets the biggest descender value of the last line written.
            @return the biggest descender value of the last line written
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Canvas">
            Sets the canvas.
            @param canvas
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.Canvases">
            Sets the canvases.
            @param canvas
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.UseAscender">
            Enables/Disables adjustment of first line height based on max ascender.
            @param use enable adjustment if true
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.FilledWidth">
            Sets the real width used by the largest line. Only used to set it
            to zero to start another measurement.
            @param filledWidth the real width used by the largest line
        </member>
        <member name="P:iTextSharp.text.pdf.ColumnText.AdjustFirstLine">
            Sets the first line adjustment. Some objects have properties, like spacing before, that
            behave differently if the object is the first to be written after go() or not. The first line adjustment is 
            <CODE>true</CODE> by default but can be changed if several objects are to be placed one
            after the other in the same column calling go() several times.
            @param adjustFirstLine <CODE>true</CODE> to adjust the first line, <CODE>false</CODE> otherwise
        </member>
        <member name="T:iTextSharp.text.pdf.crypto.AESCipherCBCnoPad">
            Creates an AES Cipher with CBC and no padding.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.AESCipherCBCnoPad.#ctor(System.Boolean,System.Byte[])">
            Creates a new instance of AESCipher 
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.ARCFOUREncryption.#ctor">
            Creates a new instance of ARCFOUREncryption 
        </member>
        <member name="T:iTextSharp.text.pdf.crypto.IVGenerator">
            An initialization vector generator for a CBC block encryption. It's a random generator based on RC4.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.IVGenerator.#ctor">
            Creates a new instance of IVGenerator 
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.IVGenerator.GetIV">
            Gets a 16 byte random initialization vector.
            @return a 16 byte random initialization vector
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.IVGenerator.GetIV(System.Int32)">
            Gets a random initialization vector.
            @param len the length of the initialization vector
            @return a random initialization vector
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.DefaultSplitCharacter" -->
        <member name="F:iTextSharp.text.pdf.DefaultSplitCharacter.DEFAULT">
            An instance of the default SplitCharacter.
        </member>
        <member name="M:iTextSharp.text.pdf.DefaultSplitCharacter.#ctor">
            Default constructor, has no custom characters to check.
        </member>
        <member name="M:iTextSharp.text.pdf.DefaultSplitCharacter.#ctor(System.Char)">
             Constructor with one splittable character.
            
             @param character char
        </member>
        <member name="M:iTextSharp.text.pdf.DefaultSplitCharacter.#ctor(System.Char[])">
             Constructor with an array of splittable characters
            
             @param characters char[]
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.DefaultSplitCharacter.IsSplitCharacter(System.Int32,System.Int32,System.Int32,System.Char[],iTextSharp.text.pdf.PdfChunk[])" -->
        <member name="M:iTextSharp.text.pdf.DefaultSplitCharacter.GetCurrentCharacter(System.Int32,System.Char[],iTextSharp.text.pdf.PdfChunk[])">
             Returns the current character
            
             @param current current position in the array
             @param ck      chunk array
             @param cc      the character array that has to be checked
             @return the current character
        </member>
        <member name="T:iTextSharp.text.pdf.draw.DottedLineSeparator">
            Element that draws a dotted line from left to right.
            Can be added directly to a document or column.
            Can also be used to create a separator chunk.
            @since   2.1.2 
        </member>
        <member name="T:iTextSharp.text.pdf.draw.LineSeparator">
            Element that draws a solid line from left to right.
            Can be added directly to a document or column.
            Can also be used to create a separator chunk.
            @author   Paulo Soares
            @since    2.1.2
        </member>
        <member name="T:iTextSharp.text.pdf.draw.VerticalPositionMark">
            Helper class implementing the DrawInterface. Can be used to add
            horizontal or vertical separators. Won't draw anything unless
            you implement the draw method.
            @since   2.1.2
        </member>
        <member name="T:iTextSharp.text.pdf.draw.IDrawInterface">
            Interface for an Element that allows you to draw something at the current
            vertical position. Trivial implementations are LineSeparator and VerticalPositionMark.
            It is also used to define what has to be drawn by a separator chunk.
            @since 2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.draw.IDrawInterface.Draw(iTextSharp.text.pdf.PdfContentByte,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Implement this method if you want to draw something at the current Y position
            (for instance a line).
            @param   canvas  the canvas on which you can draw
            @param   llx     the x coordinate of the left page margin
            @param   lly     the y coordinate of the bottom page margin
            @param   urx     the x coordinate of the right page margin
            @param   ury     the y coordinate of the top page margin
            @param   y       the current y position on the page
        </member>
        <member name="F:iTextSharp.text.pdf.draw.VerticalPositionMark.drawInterface">
            Another implementation of the DrawInterface; its draw method will overrule LineSeparator.Draw(). 
        </member>
        <member name="F:iTextSharp.text.pdf.draw.VerticalPositionMark.offset">
            The offset for the line. 
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.#ctor">
            Creates a vertical position mark that won't draw anything unless
            you define a DrawInterface.
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.#ctor(iTextSharp.text.pdf.draw.IDrawInterface,System.Single)">
            Creates a vertical position mark that won't draw anything unless
            you define a DrawInterface.
            @param   drawInterface   the drawInterface for this vertical position mark.
            @param   offset          the offset for this vertical position mark.
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.Draw(iTextSharp.text.pdf.PdfContentByte,System.Single,System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.draw.DrawInterface#draw(com.lowagie.text.pdf.PdfContentByte, float, float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.Process(iTextSharp.text.IElementListener)">
            @see com.lowagie.text.Element#process(com.lowagie.text.ElementListener)
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.IsContent">
            @see com.lowagie.text.Element#isContent()
        </member>
        <member name="M:iTextSharp.text.pdf.draw.VerticalPositionMark.IsNestable">
            @see com.lowagie.text.Element#isNestable()
        </member>
        <member name="P:iTextSharp.text.pdf.draw.VerticalPositionMark.Type">
            @see com.lowagie.text.Element#type()
        </member>
        <member name="P:iTextSharp.text.pdf.draw.VerticalPositionMark.Chunks">
            @see com.lowagie.text.Element#getChunks()
        </member>
        <member name="P:iTextSharp.text.pdf.draw.VerticalPositionMark.DrawInterface">
            Setter for the interface with the overruling Draw() method.
            @param drawInterface a DrawInterface implementation
        </member>
        <member name="P:iTextSharp.text.pdf.draw.VerticalPositionMark.Offset">
            Setter for the offset. The offset is relative to the current
            Y position. If you want to underline something, you have to
            choose a negative offset.
            @param offset    an offset
        </member>
        <member name="F:iTextSharp.text.pdf.draw.LineSeparator.lineWidth">
            The thickness of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.draw.LineSeparator.percentage">
            The width of the line as a percentage of the available page width. 
        </member>
        <member name="F:iTextSharp.text.pdf.draw.LineSeparator.lineColor">
            The color of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.draw.LineSeparator.alignment">
            The alignment of the line. 
        </member>
        <member name="M:iTextSharp.text.pdf.draw.LineSeparator.#ctor(System.Single,System.Single,iTextSharp.text.BaseColor,System.Int32,System.Single)">
            Creates a new instance of the LineSeparator class.
            @param lineWidth      the thickness of the line
            @param percentage the width of the line as a percentage of the available page width
            @param color          the color of the line
            @param align          the alignment
            @param offset     the offset of the line relative to the current baseline (negative = under the baseline)
        </member>
        <member name="M:iTextSharp.text.pdf.draw.LineSeparator.#ctor(iTextSharp.text.Font)">
            Creates a new instance of the LineSeparator class.
            @param font			the font
        </member>
        <member name="M:iTextSharp.text.pdf.draw.LineSeparator.#ctor">
            Creates a new instance of the LineSeparator class with
            default values: lineWidth 1 user unit, width 100%, centered with offset 0.
        </member>
        <member name="M:iTextSharp.text.pdf.draw.LineSeparator.Draw(iTextSharp.text.pdf.PdfContentByte,System.Single,System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.draw.DrawInterface#draw(com.lowagie.text.pdf.PdfContentByte, float, float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.draw.LineSeparator.DrawLine(iTextSharp.text.pdf.PdfContentByte,System.Single,System.Single,System.Single)">
            Draws a horizontal line.
            @param canvas the canvas to draw on
            @param leftX      the left x coordinate
            @param rightX the right x coordindate
            @param y          the y coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.draw.LineSeparator.LineWidth">
            Setter for the line width.
            @param lineWidth  the thickness of the line that will be drawn.
        </member>
        <member name="P:iTextSharp.text.pdf.draw.LineSeparator.Percentage">
            Setter for the width as a percentage of the available width.
            @return   a width percentage
        </member>
        <member name="P:iTextSharp.text.pdf.draw.LineSeparator.LineColor">
            Setter for the color of the line that will be drawn.
            @param color  a color
        </member>
        <member name="P:iTextSharp.text.pdf.draw.LineSeparator.Alignment">
            Setter for the alignment of the line.
            @param align  an alignment value
        </member>
        <member name="F:iTextSharp.text.pdf.draw.DottedLineSeparator.gap">
            the gap between the dots. 
        </member>
        <member name="M:iTextSharp.text.pdf.draw.DottedLineSeparator.Draw(iTextSharp.text.pdf.PdfContentByte,System.Single,System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.draw.DrawInterface#draw(com.lowagie.text.pdf.PdfContentByte, float, float, float, float, float)
        </member>
        <member name="P:iTextSharp.text.pdf.draw.DottedLineSeparator.Gap">
            Setter for the gap between the center of the dots of the dotted line.
            @param   gap the gap between the center of the dots
        </member>
        <member name="T:iTextSharp.text.pdf.EnumerateTTC">
            Enumerates all the fonts inside a True Type Collection.
            
             @author  Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.TrueTypeFont">
            Reads a Truetype font
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.codePages">
            The code pages possible for a True Type font.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.tables">
            Contains the location of the several tables. The key is the name of
            the table and the value is an <CODE>int[2]</CODE> where position 0
            is the offset from the start of the file and position 1 is the length
            of the table.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.rf">
            The file in use.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.fileName">
            The file name.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.directoryOffset">
            The offset from the start of the file to the table directory.
            It is 0 for TTF and may vary for TTC depending on the chosen font.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.ttcIndex">
            The index for the TTC font. It is an empty <CODE>string</CODE> for a
            TTF file.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.style">
            The style modifier 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.head">
            The content of table 'head'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.hhea">
            The content of table 'hhea'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.os_2">
            The content of table 'OS/2'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.glyphWidthsByIndex">
            The width of the glyphs. This is essentially the content of table
            'hmtx' normalized to 1000 units.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.cmap10">
            The map containing the code information for the table 'cmap', encoding 1.0.
            The key is the code and the value is an <CODE>int[2]</CODE> where position 0
            is the glyph number and position 1 is the glyph width normalized to 1000
            units.
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.pdf.TrueTypeFont.cmap31" -->
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.cmapExt">
            <summary>
            By James for unicode Ext.B
            </summary>
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.kerning">
            The map containing the kerning information. It represents the content of
            table 'kern'. The key is an <CODE>Integer</CODE> where the top 16 bits
            are the glyph number for the first character and the lower 16 bits are the
            glyph number for the second character. The value is the amount of kerning in
            normalized 1000 units as an <CODE>Integer</CODE>. This value is usually negative.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.fontName">
            The font name.
            This name is usually extracted from the table 'name' with
            the 'Name ID' 6.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.subFamily">
            The font subfamily
            This subFamily name is usually extracted from the table 'name' with
            the 'Name ID' 2 or 'Name ID' 17.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.fullName">
            The full name of the font 'Name ID' 1 or 'Name ID' 16 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.allNameEntries">
            All the names auf the Names-Table
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.familyName">
            The family name of the font
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.pdf.TrueTypeFont.italicAngle" -->
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.isFixedPitch">
            <CODE>true</CODE> if all the glyphs have the same width.
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.#ctor">
            This constructor is present to allow extending the class.
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.#ctor(System.String,System.String,System.Boolean,System.Byte[],System.Boolean,System.Boolean)">
            Creates a new TrueType font.
            @param ttFile the location of the font on file. The file must end in '.ttf' or
            '.ttc' but can have modifiers after the name
            @param enc the encoding to be applied to this font
            @param emb true if the font is to be embedded in the PDF
            @param ttfAfm the font as a <CODE>byte</CODE> array
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetTTCName(System.String)">
            Gets the name from a composed TTC file name.
            If I have for input "myfont.ttc,2" the return will
            be "myfont.ttc".
            @param name the full name
            @return the simple file name
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.FillTables">
            Reads the tables 'head', 'hhea', 'OS/2', 'post' and 'maxp' filling several variables.
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetNames(System.Int32)">
            Extracts the names of the font in all the languages available.
            @param id the name id to retrieve
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetAllNames">
            Extracts all the names of the names-Table
            @param id the name id to retrieve
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.Process(System.Byte[],System.Boolean)">
            Reads the font data.
            @param ttfAfm the font as a <CODE>byte</CODE> array, possibly <CODE>null</CODE>
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadStandardString(System.Int32)">
            Reads a <CODE>string</CODE> from the font file as bytes using the Cp1252
             encoding.
            @param length the length of bytes to read
            @return the <CODE>string</CODE> read
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadUnicodeString(System.Int32)">
            Reads a Unicode <CODE>string</CODE> from the font file. Each character is
             represented by two bytes.
            @param length the length of bytes to read. The <CODE>string</CODE> will have <CODE>length</CODE>/2
            characters
            @return the <CODE>string</CODE> read
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadGlyphWidths">
            Reads the glyphs widths. The widths are extracted from the table 'hmtx'.
             The glyphs are normalized to 1000 units.
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetGlyphWidth(System.Int32)">
            Gets a glyph width.
            @param glyph the glyph to get the width of
            @return the width of the glyph in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadCMaps">
            Reads the several maps from the table 'cmap'. The maps of interest are 1.0 for symbolic
             fonts and 3.1 for all others. A symbolic font is defined as having the map 3.0.
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadFormat0">
            The information in the maps of the table 'cmap' is coded in several formats.
             Format 0 is the Apple standard character to glyph index mapping table.
            @return a <CODE>Hashtable</CODE> representing this map
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadFormat4">
            The information in the maps of the table 'cmap' is coded in several formats.
             Format 4 is the Microsoft standard character to glyph index mapping table.
            @return a <CODE>Hashtable</CODE> representing this map
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadFormat6">
            The information in the maps of the table 'cmap' is coded in several formats.
             Format 6 is a trimmed table mapping. It is similar to format 0 but can have
             less than 256 entries.
            @return a <CODE>Hashtable</CODE> representing this map
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadKerning">
            Reads the kerning information from the 'kern' table.
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetKerning(System.Int32,System.Int32)">
            Gets the kerning between two Unicode chars.
            @param char1 the first char
            @param char2 the second char
            @return the kerning to be applied
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetRawWidth(System.Int32,System.String)">
            Gets the width from the font according to the unicode char <CODE>c</CODE>.
            If the <CODE>name</CODE> is null it's a symbolic font.
            @param c the unicode char
            @param name the glyph name
            @return the width of the char
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetFontDescriptor(iTextSharp.text.pdf.PdfIndirectReference,System.String,iTextSharp.text.pdf.PdfIndirectReference)">
            Generates the font descriptor for this font.
            @return the PdfDictionary containing the font descriptor or <CODE>null</CODE>
            @param subsetPrefix the subset prefix
            @param fontStream the indirect reference to a PdfStream containing the font or <CODE>null</CODE>
            @throws DocumentException if there is an error
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetFontBaseType(iTextSharp.text.pdf.PdfIndirectReference,System.String,System.Int32,System.Int32,System.Byte[])">
            Generates the font dictionary for this font.
            @return the PdfDictionary containing the font dictionary
            @param subsetPrefix the subset prefx
            @param firstChar the first valid character
            @param lastChar the last valid character
            @param shortTag a 256 bytes long <CODE>byte</CODE> array where each unused byte is represented by 0
            @param fontDescriptor the indirect reference to a PdfDictionary containing the font descriptor or <CODE>null</CODE>
            @throws DocumentException if there is an error
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.WriteFont(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfIndirectReference,System.Object[])">
            Outputs to the writer the font dictionaries and streams.
            @param writer the writer for this document
            @param ref the font indirect reference
            @param params several parameters that depend on the font type
            @throws IOException on error
            @throws DocumentException error in generating the object
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.ReadCffFont">
            If this font file is using the Compact Font File Format, then this method
            will return the raw bytes needed for the font stream. If this method is
            ever made public: make sure to add a test if (cff == true).
            @return  a byte array
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetFullFontStream">
            Returns a PdfStream object with the full font program.
            @return  a PdfStream with the font program
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetFontDescriptor(System.Int32,System.Single)">
            Gets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>
            and <CODE>ITALICANGLE</CODE>.
            @param key the parameter to be extracted
            @param fontSize the font size in points
            @return the parameter in points
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.GetMetricsTT(System.Int32)">
            Gets the glyph index and metrics for a character.
            @param c the character
            @return an <CODE>int</CODE> array with {glyph index, width}
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.HasKernPairs">
            Checks if the font has any kerning pairs.
            @return <CODE>true</CODE> if the font has any kerning pairs
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFont.SetKerning(System.Int32,System.Int32,System.Int32)">
            Sets the kerning between two Unicode chars.
            @param char1 the first char
            @param char2 the second char
            @param kern the kerning to apply in normalized 1000 units
            @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
        </member>
        <member name="P:iTextSharp.text.pdf.TrueTypeFont.BaseFont">
            Gets the Postscript font name.
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
            @return the Postscript font name
        </member>
        <member name="P:iTextSharp.text.pdf.TrueTypeFont.PostscriptFontName">
            Gets the postscript font name.
            @return the postscript font name
        </member>
        <member name="P:iTextSharp.text.pdf.TrueTypeFont.CodePagesSupported">
            Gets the code pages supported by the font.
            @return the code pages supported by the font
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.TrueTypeFont.FullFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.TrueTypeFont.Subfamily" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.TrueTypeFont.AllNameEntries" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.TrueTypeFont.FamilyFontName" -->
        <member name="T:iTextSharp.text.pdf.TrueTypeFont.FontHeader">
            The components of table 'head'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.flags">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.unitsPerEm">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.xMin">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.yMin">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.xMax">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.yMax">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.FontHeader.macStyle">
            A variable. 
        </member>
        <member name="T:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader">
            The components of table 'hhea'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.Ascender">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.Descender">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.LineGap">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.advanceWidthMax">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.minLeftSideBearing">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.minRightSideBearing">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.xMaxExtent">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.caretSlopeRise">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.caretSlopeRun">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.HorizontalHeader.numberOfHMetrics">
            A variable. 
        </member>
        <member name="T:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics">
            The components of table 'OS/2'.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.xAvgCharWidth">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usWeightClass">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usWidthClass">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.fsType">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySubscriptXSize">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySubscriptYSize">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySubscriptXOffset">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySubscriptYOffset">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySuperscriptXSize">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySuperscriptYSize">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySuperscriptXOffset">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ySuperscriptYOffset">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.yStrikeoutSize">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.yStrikeoutPosition">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.sFamilyClass">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.panose">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.achVendID">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.fsSelection">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usFirstCharIndex">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usLastCharIndex">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.sTypoAscender">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.sTypoDescender">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.sTypoLineGap">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usWinAscent">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.usWinDescent">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ulCodePageRange1">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.ulCodePageRange2">
            A variable. 
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFont.WindowsMetrics.sCapHeight">
            A variable. 
        </member>
        <member name="T:iTextSharp.text.pdf.events.FieldPositioningEvents">
            Class for an index.
            
            @author Michael Niedermair
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPageEventHelper">
             Helps the use of <CODE>PdfPageEvent</CODE> by implementing all the interface methods.
             A class can extend <CODE>PdfPageEventHelper</CODE> and only implement the
             needed methods.
            
             @author Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.IPdfPageEvent">
             Allows a class to catch several document events.
            
             @author  Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.IPdfPageEvent.OnOpenDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
             Called when the document is opened.
            
             @param writer the <CODE>PdfWriter</CODE> for this document
             @param document the document
        </member>
        <member name="M:iTextSharp.text.pdf.IPdfPageEvent.OnStartPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
             Called when a page is initialized.
             <P>
             Note that if even if a page is not written this method is still
             called. It is preferable to use <CODE>onEndPage</CODE> to avoid
             infinite loops.
             </P>
             <P>
             Note that this method isn't called for the first page. You should apply modifications for the first
             page either before opening the document or by using the onOpenDocument() method.
             </P>
            
             @param writer the <CODE>PdfWriter</CODE> for this document
             @param document the document
        </member>
        <member name="M:iTextSharp.text.pdf.IPdfPageEvent.OnEndPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
             Called when a page is finished, just before being written to the document.
            
             @param writer the <CODE>PdfWriter</CODE> for this document
             @param document the document
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnCloseDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnParagraph(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnParagraphEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnChapter(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnChapterEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnSection(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,System.Int32,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnSectionEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPageEvent.OnGenericTag(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,iTextSharp.text.Rectangle,System.String)" -->
        <member name="M:iTextSharp.text.pdf.PdfPageEventHelper.OnOpenDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
             Called when the document is opened.
            
             @param writer the <CODE>PdfWriter</CODE> for this document
             @param document the document
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnStartPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)" -->
        <member name="M:iTextSharp.text.pdf.PdfPageEventHelper.OnEndPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
             Called when a page is finished, just before being written to the document.
            
             @param writer the <CODE>PdfWriter</CODE> for this document
             @param document the document
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnCloseDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnParagraph(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnParagraphEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnChapter(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnChapterEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnSection(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,System.Int32,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnSectionEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPageEventHelper.OnGenericTag(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,iTextSharp.text.Rectangle,System.String)" -->
        <member name="T:iTextSharp.text.pdf.IPdfPCellEvent">
            <summary>
            Summary description for IPdfPCellEvent.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPCellEvent.CellLayout(iTextSharp.text.pdf.PdfPCell,iTextSharp.text.Rectangle,iTextSharp.text.pdf.PdfContentByte[])" -->
        <member name="F:iTextSharp.text.pdf.events.FieldPositioningEvents.genericChunkFields">
            Keeps a map with fields that are to be positioned in inGenericTag.
        </member>
        <member name="F:iTextSharp.text.pdf.events.FieldPositioningEvents.cellField">
            Keeps the form field that is to be positioned in a cellLayout event.
        </member>
        <member name="F:iTextSharp.text.pdf.events.FieldPositioningEvents.fieldWriter">
            The PdfWriter to use when a field has to added in a cell event. 
        </member>
        <member name="F:iTextSharp.text.pdf.events.FieldPositioningEvents.parent">
            The PdfFormField that is the parent of the field added in a cell event. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.#ctor">
            Creates a new event. This constructor will be used if you need to position fields with Chunk objects. 
        </member>
        <member name="F:iTextSharp.text.pdf.events.FieldPositioningEvents.padding">
            Some extra padding that will be taken into account when defining the widget. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.AddField(System.String,iTextSharp.text.pdf.PdfFormField)">
            Add a PdfFormField that has to be tied to a generic Chunk.
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfFormField)">
            Creates a new event. This constructor will be used if you need to position fields with a Cell Event. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.#ctor(iTextSharp.text.pdf.PdfFormField,iTextSharp.text.pdf.PdfFormField)">
            Creates a new event. This constructor will be used if you need to position fields with a Cell Event. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.#ctor(iTextSharp.text.pdf.PdfWriter,System.String)">
            Creates a new event. This constructor will be used if you need to position fields with a Cell Event. 
            @throws DocumentException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfFormField,System.String)">
            Creates a new event. This constructor will be used if you need to position fields with a Cell Event. 
            @throws DocumentException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.OnGenericTag(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,iTextSharp.text.Rectangle,System.String)">
            @see com.lowagie.text.pdf.PdfPageEvent#onGenericTag(com.lowagie.text.pdf.PdfWriter, com.lowagie.text.Document, com.lowagie.text.Rectangle, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.pdf.events.FieldPositioningEvents.CellLayout(iTextSharp.text.pdf.PdfPCell,iTextSharp.text.Rectangle,iTextSharp.text.pdf.PdfContentByte[])">
            @see com.lowagie.text.pdf.PdfPCellEvent#cellLayout(com.lowagie.text.pdf.PdfPCell, com.lowagie.text.Rectangle, com.lowagie.text.pdf.PdfContentByte[])
        </member>
        <member name="P:iTextSharp.text.pdf.events.FieldPositioningEvents.Padding">
            @param padding The padding to set.
        </member>
        <member name="P:iTextSharp.text.pdf.events.FieldPositioningEvents.Parent">
            @param parent The parent to set.
        </member>
        <member name="T:iTextSharp.text.pdf.events.IndexEvents">
            Class for an index.
            
            @author Michael Niedermair
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.indextag">
            keeps the indextag with the pagenumber
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.OnGenericTag(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,iTextSharp.text.Rectangle,System.String)">
            All the text that is passed to this event, gets registered in the indexentry.
            
            @see com.lowagie.text.pdf.PdfPageEventHelper#onGenericTag(
                 com.lowagie.text.pdf.PdfWriter, com.lowagie.text.Document,
                 com.lowagie.text.Rectangle, java.lang.String)
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.indexcounter">
            indexcounter
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.indexentry">
            the list for the index entry
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(System.String,System.String,System.String,System.String)">
             Create an index entry.
            
             @param text  The text for the Chunk.
             @param in1   The first level.
             @param in2   The second level.
             @param in3   The third level.
             @return Returns the Chunk.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(System.String,System.String)">
             Create an index entry.
            
             @param text  The text for the Chunk.
             @param in1   The first level.
             @return Returns the Chunk.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(System.String,System.String,System.String)">
             Create an index entry.
            
             @param text  The text for the Chunk.
             @param in1   The first level.
             @param in2   The second level.
             @return Returns the Chunk.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(iTextSharp.text.Chunk,System.String,System.String,System.String)">
             Create an index entry.
            
             @param text  The text.
             @param in1   The first level.
             @param in2   The second level.
             @param in3   The third level.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(iTextSharp.text.Chunk,System.String)">
             Create an index entry.
            
             @param text  The text.
             @param in1   The first level.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Create(iTextSharp.text.Chunk,System.String,System.String)">
             Create an index entry.
            
             @param text  The text.
             @param in1   The first level.
             @param in2   The second level.
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.comparator">
            Comparator for sorting the index
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.SetComparator(System.Collections.Generic.IComparer{iTextSharp.text.pdf.events.IndexEvents.Entry})">
            Set the comparator.
            @param aComparator The comparator to set.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.GetSortedEntries">
            Returns the sorted list with the entries and the collected page numbers.
            @return Returns the sorted list with the entries and teh collected page numbers.
        </member>
        <member name="T:iTextSharp.text.pdf.events.IndexEvents.Entry">
            Class for an index entry.
            <p>
            In the first step, only in1, in2,in3 and tag are used.
            After the collections of the index entries, pagenumbers are used.
            </p>
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.in1">
            first level
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.in2">
            second level
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.in3">
            third level
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.tag">
            the tag
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.pagenumbers">
            the lsit of all page numbers.
        </member>
        <member name="F:iTextSharp.text.pdf.events.IndexEvents.Entry.tags">
            the lsit of all tags.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.#ctor(System.String,System.String,System.String,System.String,iTextSharp.text.pdf.events.IndexEvents)">
            Create a new object.
            @param aIn1   The first level.
            @param aIn2   The second level.
            @param aIn3   The third level.
            @param aTag   The tag.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetIn1">
            Returns the in1.
            @return Returns the in1.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetIn2">
            Returns the in2.
            @return Returns the in2.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetIn3">
            Returns the in3.
            @return Returns the in3.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetTag">
            Returns the tag.
            @return Returns the tag.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetPageNumber">
            Returns the pagenumer for this entry.
            @return Returns the pagenumer for this entry.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.AddPageNumberAndTag(System.Int32,System.String)">
            Add a pagenumber.
            @param number    The page number.
            @param tag
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetKey">
            Returns the key for the map-entry.
            @return Returns the key for the map-entry.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetPagenumbers">
            Returns the pagenumbers.
            @return Returns the pagenumbers.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.GetTags">
            Returns the tags.
            @return Returns the tags.
        </member>
        <member name="M:iTextSharp.text.pdf.events.IndexEvents.Entry.ToString">
            print the entry (only for test)
            @return the toString implementation of the entry
        </member>
        <member name="T:iTextSharp.text.pdf.events.PdfPageEventForwarder">
            If you want to add more than one page eventa to a PdfWriter,
            you have to construct a PdfPageEventForwarder, add the
            different events to this object and add the forwarder to
            the PdfWriter.
        </member>
        <member name="F:iTextSharp.text.pdf.events.PdfPageEventForwarder.events">
            ArrayList containing all the PageEvents that have to be executed. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPageEventForwarder.AddPageEvent(iTextSharp.text.pdf.IPdfPageEvent)">
            Add a page eventa to the forwarder.
            @param eventa an eventa that has to be added to the forwarder.
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnOpenDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
            Called when the document is opened.
            
            @param writer
                       the <CODE>PdfWriter</CODE> for this document
            @param document
                       the document
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnStartPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)" -->
        <member name="M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnEndPage(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
            Called when a page is finished, just before being written to the
            document.
            
            @param writer
                       the <CODE>PdfWriter</CODE> for this document
            @param document
                       the document
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnCloseDocument(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnParagraph(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnParagraphEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnChapter(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnChapterEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnSection(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single,System.Int32,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnSectionEnd(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.events.PdfPageEventForwarder.OnGenericTag(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document,iTextSharp.text.Rectangle,System.String)" -->
        <member name="T:iTextSharp.text.pdf.events.PdfPCellEventForwarder">
            If you want to add more than one event to a cell,
            you have to construct a PdfPCellEventForwarder, add the
            different events to this object and add the forwarder to
            the PdfPCell.
        </member>
        <member name="F:iTextSharp.text.pdf.events.PdfPCellEventForwarder.events">
            ArrayList containing all the PageEvents that have to be executed. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPCellEventForwarder.AddCellEvent(iTextSharp.text.pdf.IPdfPCellEvent)">
            Add a page event to the forwarder.
            @param event an event that has to be added to the forwarder.
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPCellEventForwarder.CellLayout(iTextSharp.text.pdf.PdfPCell,iTextSharp.text.Rectangle,iTextSharp.text.pdf.PdfContentByte[])">
            @see com.lowagie.text.pdf.PdfPCellEvent#cellLayout(com.lowagie.text.pdf.PdfPCell, com.lowagie.text.Rectangle, com.lowagie.text.pdf.PdfContentByte[])
        </member>
        <member name="T:iTextSharp.text.pdf.events.PdfPTableEventForwarder">
            If you want to add more than one page event to a PdfPTable,
            you have to construct a PdfPTableEventForwarder, add the
            different events to this object and add the forwarder to
            the PdfWriter.
        </member>
        <member name="T:iTextSharp.text.pdf.IPdfPTableEventSplit">
            Signals that a table will continue in the next page.
            
            @since 5.0.6
        </member>
        <member name="T:iTextSharp.text.pdf.IPdfPTableEvent">
            An interface that can be used to retrieve the position of cells in <CODE>PdfPTable</CODE>.
            
             @author Paulo Soares
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPTableEvent.TableLayout(iTextSharp.text.pdf.PdfPTable,System.Single[][],System.Single[],System.Int32,System.Int32,iTextSharp.text.pdf.PdfContentByte[])" -->
        <member name="M:iTextSharp.text.pdf.IPdfPTableEventSplit.SplitTable(iTextSharp.text.pdf.PdfPTable)">
             This method is called to indicate that table is being split. It's called
             before the <CODE>tableLayout</CODE> method and before the table is drawn.
            
             @param table the <CODE>PdfPTable</CODE> in use
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.IPdfPTableEventAfterSplit.AfterSplitTable(iTextSharp.text.pdf.PdfPTable,iTextSharp.text.pdf.PdfPRow,System.Int32)" -->
        <member name="F:iTextSharp.text.pdf.events.PdfPTableEventForwarder.events">
            ArrayList containing all the PageEvents that have to be executed. 
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPTableEventForwarder.AddTableEvent(iTextSharp.text.pdf.IPdfPTableEvent)">
            Add a page event to the forwarder.
            @param event an event that has to be added to the forwarder.
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPTableEventForwarder.TableLayout(iTextSharp.text.pdf.PdfPTable,System.Single[][],System.Single[],System.Int32,System.Int32,iTextSharp.text.pdf.PdfContentByte[])">
            @see com.lowagie.text.pdf.PdfPTableEvent#tableLayout(com.lowagie.text.pdf.PdfPTable, float[][], float[], int, int, com.lowagie.text.pdf.PdfContentByte[])
        </member>
        <member name="M:iTextSharp.text.pdf.events.PdfPTableEventForwarder.AfterSplitTable(iTextSharp.text.pdf.PdfPTable,iTextSharp.text.pdf.PdfPRow,System.Int32)">
            @see com.itextpdf.text.pdf.PdfPTableEventAfterSplit#afterSplitTable(com.itextpdf.text.pdf.PdfPTable, com.itextpdf.text.pdf.PdfPRow, int)
            @since iText 5.4.3
        </member>
        <member name="T:iTextSharp.text.pdf.FdfReader">
            Reads an FDF form and makes the fields available
            @author Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.PdfReader">
            Reads a PDF document.
            @author Paulo Soares
            @author Kazuya Ujihara
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IPdfViewerPreferences">
            Viewer preferences are described in section 3.6.1 and 8.1 of the
            PDF Reference 1.7 (Table 3.25 on p139-142 and Table 8.1 on p579-581).
            They are explained in section 13.1 of the book 'iText in Action'.
            The values of the different preferences were originally stored
            in class PdfWriter, but they have been moved to this separate interface
            for reasons of convenience.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.interfaces.IPdfViewerPreferences.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.interfaces.IPdfViewerPreferences.ViewerPreferences" -->
        <member name="F:iTextSharp.text.pdf.PdfReader.unethicalreading">
            The iText developers are not responsible if you decide to change the
            value of this static parameter.
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfReader.appendable">
            Holds value of property appendable.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(iTextSharp.text.io.IRandomAccessSource,System.Boolean,System.Byte[],Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.ICipherParameters,System.Boolean)">
            Constructs a new PdfReader.  This is the master constructor.
            @param byteSource source of bytes for the reader
            @param partialRead if true, the reader is opened in partial mode (PDF is parsed on demand), if false, the entire PDF is parsed into memory as the reader opens
            @param ownerPassword the password or null if no password is required
            @param certificate the certificate or null if no certificate is required
            @param certificateKey the key or null if no certificate key is required
            @param certificateKeyProvider the name of the key provider, or null if no key is required
            @param closeSourceOnConstructorError if true, the byteSource will be closed if there is an error during construction of this reader
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.String)">
            Reads and parses a PDF document.
            @param filename the file name of the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.String,System.Byte[])">
            Reads and parses a PDF document.
            @param filename the file name of the document
            @param ownerPassword the password to read the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.String,System.Byte[],System.Boolean)">
            Reads and parses a PDF document.
            @param filename the file name of the document
            @param ownerPassword the password to read the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.Byte[])">
            Reads and parses a PDF document.
            @param pdfIn the byte array with the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.Byte[],System.Byte[])">
            Reads and parses a PDF document.
            @param pdfIn the byte array with the document
            @param ownerPassword the password to read the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.String,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.ICipherParameters)">
            Reads and parses a PDF document.
            @param filename the file name of the document
            @param certificate the certificate to read the document
            @param certificateKey the private key of the certificate
            @param certificateKeyProvider the security provider for certificateKey
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.Uri)">
            Reads and parses a PDF document.
            @param url the Uri of the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.Uri,System.Byte[])">
            Reads and parses a PDF document.
            @param url the Uri of the document
            @param ownerPassword the password to read the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.IO.Stream,System.Byte[])">
            Reads and parses a PDF document.
            @param is the <CODE>InputStream</CODE> containing the document. The stream is read to the
            end but is not closed
            @param ownerPassword the password to read the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(System.IO.Stream)">
            Reads and parses a PDF document.
            @param isp the <CODE>InputStream</CODE> containing the document. The stream is read to the
            end but is not closed
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Byte[])">
            Reads and parses a pdf document. Contrary to the other constructors only the xref is read
            into memory. The reader is said to be working in "partial" mode as only parts of the pdf
            are read as needed.
            @param raf the document location
            @param ownerPassword the password or <CODE>null</CODE> for no password
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.Byte[],System.Boolean)">
            Reads and parses a pdf document.
            @param raf the document location
            @param ownerPassword the password or <CODE>null</CODE> for no password
            @param partial indicates if the reader needs to read the document only partially. See {@link PdfReader#PdfReader(RandomAccessFileOrArray, byte[])}
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.#ctor(iTextSharp.text.pdf.PdfReader)">
            Creates an independent duplicate.
            @param reader the <CODE>PdfReader</CODE> to duplicate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetOffsetTokeniser(iTextSharp.text.io.IRandomAccessSource)">
            Utility method that checks the provided byte source to see if it has junk bytes at the beginning.  If junk bytes
            are found, construct a tokeniser that ignores the junk.  Otherwise, construct a tokeniser for the byte source as it is
            @param byteSource the source to check
            @return a tokeniser that is guaranteed to start at the PDF header
            @throws IOException if there is a problem reading the byte source
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageRotation(System.Int32)">
            Gets the page rotation. This value can be 0, 90, 180 or 270.
            @param index the page number. The first page is 1
            @return the page rotation
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageSizeWithRotation(System.Int32)">
            Gets the page size, taking rotation into account. This
            is a <CODE>Rectangle</CODE> with the value of the /MediaBox and the /Rotate key.
            @param index the page number. The first page is 1
            @return a <CODE>Rectangle</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageSizeWithRotation(iTextSharp.text.pdf.PdfDictionary)">
            Gets the rotated page from a page dictionary.
            @param page the page dictionary
            @return the rotated page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageSize(System.Int32)">
            Gets the page size without taking rotation into account. This
            is the value of the /MediaBox key.
            @param index the page number. The first page is 1
            @return the page size
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageSize(iTextSharp.text.pdf.PdfDictionary)">
            Gets the page from a page dictionary
            @param page the page dictionary
            @return the page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetCropBox(System.Int32)">
            Gets the crop box without taking rotation into account. This
            is the value of the /CropBox key. The crop box is the part
            of the document to be displayed or printed. It usually is the same
            as the media box but may be smaller. If the page doesn't have a crop
            box the page size will be returned.
            @param index the page number. The first page is 1
            @return the crop box
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetBoxSize(System.Int32,System.String)">
            Gets the box size. Allowed names are: "crop", "trim", "art", "bleed" and "media".
            @param index the page number. The first page is 1
            @param boxName the box name
            @return the box rectangle or null
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNormalizedRectangle(iTextSharp.text.pdf.PdfArray)">
            Normalizes a <CODE>Rectangle</CODE> so that llx and lly are smaller than urx and ury.
            @param box the original rectangle
            @return a normalized <CODE>Rectangle</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.IsTagged">
            Checks if the PDF is a tagged PDF.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ReadPdf">
            Parses the entire PDF
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ReadDecryptedDocObj">
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObjectRelease(iTextSharp.text.pdf.PdfObject)">
            @param obj
            @return a PdfObject
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObject(iTextSharp.text.pdf.PdfObject)">
            Reads a <CODE>PdfObject</CODE> resolving an indirect reference
            if needed.
            @param obj the <CODE>PdfObject</CODE> to read
            @return the resolved <CODE>PdfObject</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObjectRelease(iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfObject)">
            Reads a <CODE>PdfObject</CODE> resolving an indirect reference
            if needed. If the reader was opened in partial mode the object will be released
            to save memory.
            @param obj the <CODE>PdfObject</CODE> to read
            @param parent
            @return a PdfObject
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObject(iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfObject)">
            @param obj
            @param parent
            @return a PdfObject
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObjectRelease(System.Int32)">
            @param idx
            @return a PdfObject
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPdfObject(System.Int32)">
            @param idx
            @return aPdfObject
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ResetLastXrefPartial">
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ReleaseLastXrefPartial">
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ReleaseLastXrefPartial(iTextSharp.text.pdf.PdfObject)">
            @param obj
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.AddPdfObject(iTextSharp.text.pdf.PdfObject)">
            @param obj
            @return an indirect reference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.DumpPerc">
            @return the percentage of the cross reference table that has been read
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.KillIndirect(iTextSharp.text.pdf.PdfObject)">
            Eliminates the reference to the object freeing the memory used by it and clearing
            the xref entry.
            @param obj the object. If it's an indirect reference it will be eliminated
            @return the object or the already erased dereferenced object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.FlateDecode(System.Byte[])">
            Decodes a stream that has the FlateDecode filter.
            @param in the input data
            @return the decoded data
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.DecodePredictor(System.Byte[],iTextSharp.text.pdf.PdfObject)">
            @param in
            @param dicPar
            @return a byte array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.FlateDecode(System.Byte[],System.Boolean)">
            A helper to FlateDecode.
            @param in the input data
            @param strict <CODE>true</CODE> to read a correct stream. <CODE>false</CODE>
            to try to read a corrupted stream
            @return the decoded data
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ASCIIHexDecode(System.Byte[])">
            Decodes a stream that has the ASCIIHexDecode filter.
            @param in the input data
            @return the decoded data
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ASCII85Decode(System.Byte[])">
            Decodes a stream that has the ASCII85Decode filter.
            @param in the input data
            @return the decoded data
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.LZWDecode(System.Byte[])">
            Decodes a stream that has the LZWDecode filter.
            @param in the input data
            @return the decoded data
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.IsRebuilt">
            Checks if the document had errors and was rebuilt.
             @return true if rebuilt.
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageN(System.Int32)">
            Gets the dictionary that represents a page.
            @param pageNum the page number. 1 is the first
            @return the page dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageNRelease(System.Int32)">
            @param pageNum
            @return a Dictionary object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ReleasePage(System.Int32)">
            @param pageNum
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ResetReleasePage">
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageOrigRef(System.Int32)">
            Gets the page reference to this page.
            @param pageNum the page number. 1 is the first
            @return the page reference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageContent(System.Int32,iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Gets the contents of the page.
            @param pageNum the page number. 1 is the first
            @param file the location of the PDF document
            @throws IOException on error
            @return the content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageContent(iTextSharp.text.pdf.PdfDictionary)">
            Gets the content from the page dictionary.
            @param page the page dictionary
            @throws IOException on error
            @return the content
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageResources(System.Int32)">
            Retrieve the given page's resource dictionary
            @param pageNum 1-based page number from which to retrieve the resource dictionary
            @return The page's resources, or 'null' if the page has none.
            @since 5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageResources(iTextSharp.text.pdf.PdfDictionary)">
            Retrieve the given page's resource dictionary
            @param pageDict the given page
            @return The page's resources, or 'null' if the page has none.
            @since 5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetPageContent(System.Int32)">
            Gets the contents of the page.
            @param pageNum the page number. 1 is the first
            @throws IOException on error
            @return the content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.SetPageContent(System.Int32,System.Byte[])">
            Sets the contents of the page.
            @param content the new page content
            @param pageNum the page number. 1 is the first
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.SetPageContent(System.Int32,System.Byte[],System.Int32,System.Boolean)">
            Sets the contents of the page.
            @param content the new page content
            @param pageNum the page number. 1 is the first
            @since   2.1.3   (the method already existed without param compressionLevel)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.DecodeBytes(System.Byte[],iTextSharp.text.pdf.PdfDictionary)">
            Decode a byte[] applying the filters specified in the provided dictionary using default filter handlers.
            @param b the bytes to decode
            @param streamDictionary the dictionary that contains filter information
            @return the decoded bytes
            @throws IOException if there are any problems decoding the bytes
            @since 5.0.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.DecodeBytes(System.Byte[],iTextSharp.text.pdf.PdfDictionary,System.Collections.Generic.IDictionary{iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.FilterHandlers.IFilterHandler})">
            Decode a byte[] applying the filters specified in the provided dictionary using the provided filter handlers.
            @param b the bytes to decode
            @param streamDictionary the dictionary that contains filter information
            @param filterHandlers the map used to look up a handler for each type of filter
            @return the decoded bytes
            @throws IOException if there are any problems decoding the bytes
            @since 5.0.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetStreamBytes(iTextSharp.text.pdf.PRStream,iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Get the content from a stream applying the required filters.
            @param stream the stream
            @param file the location where the stream is
            @throws IOException on error
            @return the stream content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetStreamBytes(iTextSharp.text.pdf.PRStream)">
            Get the content from a stream applying the required filters.
            @param stream the stream
            @throws IOException on error
            @return the stream content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetStreamBytesRaw(iTextSharp.text.pdf.PRStream,iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Get the content from a stream as it is without applying any filter.
            @param stream the stream
            @param file the location where the stream is
            @throws IOException on error
            @return the stream content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetStreamBytesRaw(iTextSharp.text.pdf.PRStream)">
            Get the content from a stream as it is without applying any filter.
            @param stream the stream
            @throws IOException on error
            @return the stream content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.EliminateSharedStreams">
            Eliminates shared streams if they exist. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.IsEncrypted">
            Returns <CODE>true</CODE> if the PDF is encrypted.
            @return <CODE>true</CODE> if the PDF is encrypted
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.Is128Key">
            Returns <CODE>true</CODE> if the PDF has a 128 bit key encryption.
            @return <CODE>true</CODE> if the PDF has a 128 bit key encryption
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ShuffleSubsetNames">
            Finds all the font subsets and changes the prefixes to some
            random values.
            @return the number of font subsets altered
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.CreateFakeFontSubsets">
            Finds all the fonts not subset but embedded and marks them as subset.
            @return the number of fonts altered
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNamedDestination">
            Gets all the named destinations as an <CODE>Hashtable</CODE>. The key is the name
            and the value is the destinations array.
            @return gets all the named destinations
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNamedDestination(System.Boolean)">
            Gets all the named destinations as an <CODE>HashMap</CODE>. The key is the name
            and the value is the destinations array.
            @param   keepNames   true if you want the keys to be real PdfNames instead of Strings
            @return gets all the named destinations
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNamedDestinationFromNames">
            Gets the named destinations from the /Dests key in the catalog as an <CODE>Hashtable</CODE>. The key is the name
            and the value is the destinations array.
            @return gets the named destinations
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNamedDestinationFromNames(System.Boolean)">
            Gets the named destinations from the /Dests key in the catalog as an <CODE>HashMap</CODE>. The key is the name
            and the value is the destinations array.
            @param   keepNames   true if you want the keys to be real PdfNames instead of Strings
            @return gets the named destinations
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetNamedDestinationFromStrings">
            Gets the named destinations from the /Names key in the catalog as an <CODE>Hashtable</CODE>. The key is the name
            and the value is the destinations array.
            @return gets the named destinations
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.RemoveFields">
            Removes all the fields from the document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.RemoveAnnotations">
            Removes all the annotations and fields from the document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.MakeRemoteNamedDestinationsLocal">
            Replaces remote named links with local destinations that have the same name.
            @since   5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ConvertNamedDestination(iTextSharp.text.pdf.PdfObject,System.Collections.Generic.Dictionary{System.Object,iTextSharp.text.pdf.PdfObject})">
            Converts a remote named destination GoToR with a local named destination
            if there's a corresponding name.
            @param   obj an annotation that needs to be screened for links to external named destinations.
            @param   names   a map with names of local named destinations
            @since   iText 5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.ConsolidateNamedDestinations">
            Replaces all the local named links with the actual destinations. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.Close">
            Closes the reader, and any underlying stream or data source used to create the reader
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.RemoveUnusedObjects">
            Removes all the unreachable objects.
            @return the number of indirect objects removed
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetJavaScript(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Gets the global document JavaScript.
            @param file the document file
            @throws IOException on error
            @return the global document JavaScript
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.SelectPages(System.String)">
            Selects the pages to keep in the document. The pages are described as
            ranges. The page ordering can be changed but
            no page repetitions are allowed. Note that it may be very slow in partial mode.
            @param ranges the comma separated ranges as described in {@link SequenceList}
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.SelectPages(System.Collections.Generic.ICollection{System.Int32})">
            Selects the pages to keep in the document. The pages are described as a
            <CODE>List</CODE> of <CODE>Integer</CODE>. The page ordering can be changed but
            no page repetitions are allowed. Note that it may be very slow in partial mode.
            @param pagesToKeep the pages to keep in the document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.SelectPages(System.Collections.Generic.ICollection{System.Int32},System.Boolean)">
            Selects the pages to keep in the document. The pages are described as a
            <CODE>List</CODE> of <CODE>Integer</CODE>. The page ordering can be changed but
            no page repetitions are allowed. Note that it may be very slow in partial mode.
            @param pagesToKeep the pages to keep in the document
            @param removeUnused indicate if to remove unsed objects. @see removeUnusedObjects
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Adds a viewer preference
            @param key a key for a viewer preference
            @param value a value for the viewer preference
            @see PdfViewerPreferences#addViewerPreference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.IsNewXrefType">
            Getter for property newXrefType.
            @return Value of property newXrefType.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.IsHybridXref">
            Getter for property hybridXref.
            @return Value of property hybridXref.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.HasUsageRights">
             Checks if this PDF has usage rights enabled.
            
             @return <code>true</code> if usage rights are present; <code>false</code> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.RemoveUsageRights">
            Removes any usage rights that this PDF may have. Only Adobe can grant usage rights
            and any PDF modification with iText will invalidate them. Invalidated usage rights may
            confuse Acrobat and it's advisabe to remove them altogether.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.GetCertificationLevel">
            Gets the certification level for this document. The return values can be <code>PdfSignatureAppearance.NOT_CERTIFIED</code>, 
            <code>PdfSignatureAppearance.CERTIFIED_NO_CHANGES_ALLOWED</code>,
            <code>PdfSignatureAppearance.CERTIFIED_FORM_FILLING</code> and
            <code>PdfSignatureAppearance.CERTIFIED_FORM_FILLING_AND_ANNOTATIONS</code>.
            <p>
            No signature validation is made, use the methods availabe for that in <CODE>AcroFields</CODE>.
            </p>
            @return gets the certification level for this document
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.SafeFile">
            Gets a new file instance of the original PDF
            document.
            @return a new file instance of the original PDF document
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.NumberOfPages">
            Gets the number of pages in the document.
            @return the number of pages in the document
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Catalog">
            Returns the document's catalog. This dictionary is not a copy,
            any changes will be reflected in the catalog.
            @return the document's catalog
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.AcroForm">
            Returns the document's acroform, if it has one.
            @return the document's acroform
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Info">
            Returns the content of the document information dictionary as a <CODE>Hashtable</CODE>
            of <CODE>String</CODE>.
            @return content of the document information dictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Tampered">
            Sets the tampered state. A tampered PdfReader cannot be reused in PdfStamper.
            @param tampered the tampered state
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Metadata">
            Gets the XML metadata.
            @throws IOException on error
            @return the XML metadata
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.LastXref">
            Gets the byte address of the last xref table.
            @return the byte address of the last xref table
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.XrefSize">
            Gets the number of xref objects.
            @return the number of xref objects
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.EofPos">
            Gets the byte address of the %%EOF marker.
            @return the byte address of the %%EOF marker
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.PdfVersion">
            Gets the PDF version. Only the last version char is returned. For example
            version 1.4 is returned as '4'.
            @return the PDF version
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Permissions">
            Gets the encryption permissions. It can be used directly in
            <CODE>PdfWriter.SetEncryption()</CODE>.
            @return the encryption permissions
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.Trailer">
            Gets the trailer dictionary
            @return the trailer dictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.AcroFields">
            Gets a read-only version of <CODE>AcroFields</CODE>.
            @return a read-only version of <CODE>AcroFields</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.JavaScript">
            Gets the global document JavaScript.
            @throws IOException on error
            @return the global document JavaScript
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.ViewerPreferences">
            Sets the viewer preferences as the sum of several constants.
            @param preferences the viewer preferences
            @see PdfViewerPreferences#setViewerPreferences
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.SimpleViewerPreferences">
            Returns a bitset representing the PageMode and PageLayout viewer preferences.
            Doesn't return any information about the ViewerPreferences dictionary.
            @return an int that contains the Viewer Preferences.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.FileLength">
            Getter for property fileLength.
            @return Value of property fileLength.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfReader.IsOpenedWithFullPermissions">
            Checks if the document was opened with the owner password so that the end application
            can decide what level of access restrictions to apply. If the document is not encrypted
            it will return <CODE>true</CODE>.
            @return <CODE>true</CODE> if the document was opened with the owner password or if it's not encrypted,
            <CODE>false</CODE> if the document was opened with the user password
        </member>
        <member name="F:iTextSharp.text.pdf.PdfReader.PageRefs.pagesNodes">
            Keeps track of all pages nodes to avoid circular references.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.GetPageN(System.Int32)">
            Gets the dictionary that represents a page.
            @param pageNum the page number. 1 is the first
            @return the page dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.GetPageNRelease(System.Int32)">
            @param pageNum
            @return a dictionary object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.GetPageOrigRefRelease(System.Int32)">
            @param pageNum
            @return an indirect reference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.GetPageOrigRef(System.Int32)">
            Gets the page reference to this page.
            @param pageNum the page number. 1 is the first
            @return the page reference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.ReleasePage(System.Int32)">
            @param pageNum
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReader.PageRefs.ResetReleasePage">
            
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.#ctor(System.String)">
            Reads an FDF form.
            @param filename the file name of the form
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.#ctor(System.Byte[])">
            Reads an FDF form.
            @param pdfIn the byte array with the form
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.#ctor(System.Uri)">
            Reads an FDF form.
            @param url the URL of the document
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.#ctor(System.IO.Stream)">
            Reads an FDF form.
            @param is the <CODE>InputStream</CODE> containing the document. The stream is read to the
            end but is not closed
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.GetField(System.String)">
            Gets the field dictionary.
            @param name the fully qualified field name
            @return the field dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.GetAttachedFile(System.String)">
            Gets a byte[] containing a file that is embedded in the FDF.
            @param name the fully qualified field name
            @return the bytes of the file
            @throws IOException 
            @since 5.0.1 
        </member>
        <member name="M:iTextSharp.text.pdf.FdfReader.GetFieldValue(System.String)">
            Gets the field value or <CODE>null</CODE> if the field does not
            exist or has no value defined.
            @param name the fully qualified field name
            @return the field value or <CODE>null</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.FdfReader.Fields">
            Gets all the fields. The map is keyed by the fully qualified
            field name and the value is a merged <CODE>PdfDictionary</CODE>
            with the field content.
            @return all the fields
        </member>
        <member name="P:iTextSharp.text.pdf.FdfReader.FileSpec">
            Gets the PDF file specification contained in the FDF.
            @return the PDF file specification contained in the FDF
        </member>
        <member name="T:iTextSharp.text.pdf.FdfWriter">
            Writes an FDF form.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.FdfWriter.file">
            The PDF file associated with the FDF. 
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.#ctor">
            Creates a new FdfWriter. 
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.WriteTo(System.IO.Stream)">
            Writes the content to a stream.
            @param os the stream
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.RemoveField(System.String)">
            Removes the field value.
            @param field the field name
            @return <CODE>true</CODE> if the field was found and removed,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.GetFields">
            Gets all the fields. The map is keyed by the fully qualified
            field name and the values are <CODE>PdfObject</CODE>.
            @return a map with all the fields
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.GetField(System.String)">
            Gets the field value.
            @param field the field name
            @return the field value or <CODE>null</CODE> if not found
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFieldAsName(System.String,System.String)">
            Sets the field value as a name.
            @param field the fully qualified field name
            @param value the value
            @return <CODE>true</CODE> if the value was inserted,
            <CODE>false</CODE> if the name is incompatible with
            an existing field
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFieldAsString(System.String,System.String)">
            Sets the field value as a string.
            @param field the fully qualified field name
            @param value the value
            @return <CODE>true</CODE> if the value was inserted,
            <CODE>false</CODE> if the name is incompatible with
            an existing field
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFieldAsAction(System.String,iTextSharp.text.pdf.PdfAction)">
            Sets the field value as a <CODE>PDFAction</CODE>. 
            For example, this method allows setting a form submit button action using {@link PdfAction#createSubmitForm(String, Object[], int)}.
            This method creates an <CODE>A</CODE> entry for the specified field in the underlying FDF file.
            Method contributed by Philippe Laflamme (plaflamme)
            @param field the fully qualified field name
            @param action the field's action
            @return <CODE>true</CODE> if the value was inserted,
            <CODE>false</CODE> if the name is incompatible with
            an existing field
            @since	2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFields(iTextSharp.text.pdf.FdfReader)">
            Sets all the fields from this <CODE>FdfReader</CODE>
            @param fdf the <CODE>FdfReader</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFields(iTextSharp.text.pdf.PdfReader)">
            Sets all the fields from this <CODE>PdfReader</CODE>
            @param pdf the <CODE>PdfReader</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.FdfWriter.SetFields(iTextSharp.text.pdf.AcroFields)">
            Sets all the fields from this <CODE>AcroFields</CODE>
            @param acro the <CODE>AcroFields</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.FdfWriter.File">
            Gets the PDF file name associated with the FDF.
            @return the PDF file name associated with the FDF
        </member>
        <member name="T:iTextSharp.text.pdf.PdfWriter">
            A <CODE>DocWriter</CODE> class for PDF.
            <P>
            When this <CODE>PdfWriter</CODE> is added
            to a certain <CODE>PdfDocument</CODE>, the PDF representation of every Element
            added to this Document will be written to the outputstream.</P>
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings">
            Encryption settings are described in section 3.5 (more specifically
            section 3.5.2) of the PDF Reference 1.7.
            They are explained in section 3.3.3 of the book 'iText in Action'.
            The values of the different  preferences were originally stored
            in class PdfWriter, but they have been moved to this separate interface
            for reasons of convenience.
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
            ownerPassword can be null or have zero length. In this case the ownerPassword
            is replaced by a random string. The open permissions for the document can be
            AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
            AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
            The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfEncryptionSettings.SetEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            Sets the certificate encryption options for this document. An array of one or more public certificates
            must be provided together with an array of the same size for the permissions for each certificate.
             The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param certs the public certificates to be used for the encryption
            @param permissions the user permissions for each of the certicates
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            @throws DocumentException if the document is already open
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IPdfVersion">
            The PDF version is described in the PDF Reference 1.7 p92
            (about the PDF Header) and page 139 (the version entry in
            the Catalog). You'll also find info about setting the version
            in the book 'iText in Action' sections 2.1.3 (PDF Header)
            and 3.3 (Version history).
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfVersion.SetAtLeastPdfVersion(System.Char)">
            If the PDF Header hasn't been written yet,
            this changes the version as it will appear in the PDF Header,
            but only if param refers to a higher version.
            If the PDF header was already written to the Stream,
            this changes the version as it will appear in the Catalog.
            @param version   a character representing the PDF version
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfVersion.SetPdfVersion(iTextSharp.text.pdf.PdfName)">
            Sets the PDF version as it will appear in the Catalog.
            Note that this only has effect if you use a later version
            than the one that appears in the header. This method
            ignores the parameter if you try to set a lower version
            than the one currently set in the Catalog.
            @param version   the PDF name that will be used for the Version key in the catalog
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfVersion.AddDeveloperExtension(iTextSharp.text.pdf.PdfDeveloperExtension)">
            Adds a developer extension to the Extensions dictionary
            in the Catalog.
            @param de an object that contains the extensions prefix and dictionary
            @since    2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfVersion.PdfVersion">
            If the PDF Header hasn't been written yet,
            this changes the version as it will appear in the PDF Header.
            If the PDF header was already written to the Stream,
            this changes the version as it will appear in the Catalog.
            @param version   a character representing the PDF version
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IPdfDocumentActions">
            A PDF document can have an open action and other additional actions.
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfDocumentActions.SetOpenAction(System.String)">
            When the document opens it will jump to the destination with
            this name.
            @param name the name of the destination to jump to
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfDocumentActions.SetOpenAction(iTextSharp.text.pdf.PdfAction)">
            When the document opens this <CODE>action</CODE> will be
            invoked.
            @param action the action to be invoked
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfDocumentActions.SetAdditionalAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
             Additional-actions defining the actions to be taken in
             response to various trigger events affecting the document
             as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,
             <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>
             and <CODE>DID_PRINT</CODE>.
            
             @param actionType the action type
             @param action the action to execute in response to the trigger
             @throws DocumentException on invalid action type
        </member>
        <member name="T:iTextSharp.text.pdf.interfaces.IPdfPageActions">
            A PDF page can have an open and/or close action.
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfPageActions.SetPageAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
            Sets the open and close page additional action.
            @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
            or <CODE>PdfWriter.PAGE_CLOSE</CODE>
            @param action the action to perform
            @throws DocumentException if the action type is invalid
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfPageActions.Duration">
            Sets the display duration for the page (for presentations)
            @param seconds   the number of seconds to display the page
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfPageActions.Transition">
            Sets the transition for the page
            @param transition   the Transition object
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfIsoConformance.IsPdfIso">
            Checks if any PDF ISO conformance is necessary.
            @return <code>true</code> if the PDF has to be in conformance with any of the PDF ISO specifications
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfRunDirection.RunDirection">
            Sets the run direction. This is only used as a placeholder
            as it does not affect anything.
            @param runDirection the run direction
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfAnnotations.AddAnnotation(iTextSharp.text.pdf.PdfAnnotation)">
            Use this methods to add a <CODE>PdfAnnotation</CODE> or a <CODE>PdfFormField</CODE>
            to the document. Only the top parent of a <CODE>PdfFormField</CODE>
            needs to be added.
            @param annot the <CODE>PdfAnnotation</CODE> or the <CODE>PdfFormField</CODE> to add
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfAnnotations.AddCalculationOrder(iTextSharp.text.pdf.PdfFormField)">
            Use this method to adds the <CODE>PdfAnnotation</CODE>
            to the calculation order array.
            @param annot the <CODE>PdfAnnotation</CODE> to be added
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfAnnotations.AcroForm">
            Use this methods to get the AcroForm object.
            Use this method only if you know what you're doing
            @return the PdfAcroform object of the PdfDocument
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfAnnotations.SigFlags">
            Use this method to set the signature flags.
            @param f the flags. This flags are ORed with current ones
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.GENERATION_MAX">
            The highest generation number possible.
            @since   iText 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_2">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_3">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_4">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_5">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_6">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.VERSION_1_7">
            possible PDF version (header) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutSinglePage">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutOneColumn">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutTwoColumnLeft">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutTwoColumnRight">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutTwoPageLeft">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageLayoutTwoPageRight">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeUseNone">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeUseOutlines">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeUseThumbs">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeFullScreen">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeUseOC">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PageModeUseAttachments">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.HideToolbar">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.HideMenubar">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.HideWindowUI">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.FitWindow">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.CenterWindow">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DisplayDocTitle">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.NonFullScreenPageModeUseNone">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.NonFullScreenPageModeUseOutlines">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.NonFullScreenPageModeUseThumbs">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.NonFullScreenPageModeUseOC">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DirectionL2R">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DirectionR2L">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PrintScalingNone">
            A viewer preference 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.SIGNATURE_EXISTS">
            signature value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.SIGNATURE_APPEND_ONLY">
            signature value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDFXNONE">
            PDF/X level 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDFX1A2001">
            PDF/X level 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDFX32002">
            PDF/X level 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.STANDARD_ENCRYPTION_40">
            Type of encryption 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.STANDARD_ENCRYPTION_128">
            Type of encryption 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ENCRYPTION_AES_128">
            Type of encryption 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ENCRYPTION_AES_256">
            Type of encryption 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ENCRYPTION_MASK">
            Mask to separate the encryption type from the encryption mode. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DO_NOT_ENCRYPT_METADATA">
            Add this to the mode to keep the metadata in clear text 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.EMBEDDED_FILES_ONLY">
            Add this to the mode to keep encrypt only the embedded files.
            @since 2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_PRINTING">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_MODIFY_CONTENTS">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_COPY">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_MODIFY_ANNOTATIONS">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_FILL_IN">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_SCREENREADERS">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_ASSEMBLY">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.ALLOW_DEGRADED_PRINTING">
            The operation permitted when the document is opened with the user password
            
             @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowPrinting">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_PRINTING} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowModifyContents">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_MODIFY_CONTENTS} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowCopy">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_COPY} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowModifyAnnotations">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_MODIFY_ANNOTATIONS} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowFillIn">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_FILL_IN} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowScreenReaders">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_SCREENREADERS} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowAssembly">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_ASSEMBLY} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.AllowDegradedPrinting">
            @deprecated As of iText 2.0.7, use {@link #ALLOW_DEGRADED_PRINTING} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.STRENGTH40BITS">
            @deprecated As of iText 2.0.7, use {@link #STANDARD_ENCRYPTION_40} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.STRENGTH128BITS">
            @deprecated As of iText 2.0.7, use {@link #STANDARD_ENCRYPTION_128} instead. Scheduled for removal at or after 2.2.0 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.SPACE_CHAR_RATIO_DEFAULT">
            The default space-char ratio. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.NO_SPACE_CHAR_RATIO">
            Disable the inter-character spacing. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.RUN_DIRECTION_DEFAULT">
            Use the default run direction. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.RUN_DIRECTION_NO_BIDI">
            Do not use bidirectional reordering. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.RUN_DIRECTION_LTR">
            Use bidirectional reordering with left-to-right
            preferential run direction.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.RUN_DIRECTION_RTL">
            Use bidirectional reordering with right-to-left
            preferential run direction.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.#ctor">
            Constructs a <CODE>PdfWriter</CODE>.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.#ctor(iTextSharp.text.pdf.PdfDocument,System.IO.Stream)" -->
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetInstance(iTextSharp.text.Document,System.IO.Stream)">
             Use this method to get an instance of the <CODE>PdfWriter</CODE>.
            
             @param    document    The <CODE>Document</CODE> that has to be written
             @param    os  The <CODE>Stream</CODE> the writer has to write to.
             @return   a new <CODE>PdfWriter</CODE>
            
             @throws   DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetInstance(iTextSharp.text.Document,System.IO.Stream,iTextSharp.text.IDocListener)">
             Use this method to get an instance of the <CODE>PdfWriter</CODE>.
            
             @return a new <CODE>PdfWriter</CODE>
             @param document The <CODE>Document</CODE> that has to be written
             @param os The <CODE>Stream</CODE> the writer has to write to.
             @param listener A <CODE>DocListener</CODE> to pass to the PdfDocument.
             @throws DocumentException on error
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.pdf">
            the pdfdocument object. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetVerticalPosition(System.Boolean)">
            Use this method to get the current vertical page position.
            @param ensureNewLine Tells whether a new line shall be enforced. This may cause side effects 
              for elements that do not terminate the lines they've started because those lines will get
              terminated. 
            @return The current vertical page position.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.directContent">
            The direct content in this document. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.directContentUnder">
            The direct content under in this document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.ResetContent">
            Resets all the direct contents to empty.
            This happens when a new page is started.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.body">
            body of the PDF document 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddLocalDestinations(System.Collections.Generic.SortedDictionary{System.String,iTextSharp.text.pdf.PdfDocument.Destination})">
            Adds the local destinations to the body of the document.
            @param dest the <CODE>Hashtable</CODE> containing the destinations
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject)">
            Adds an object to the PDF body.
            @param object
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject,System.Boolean)">
            Adds an object to the PDF body.
            @param object
            @param inObjStm
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfIndirectReference)">
            Adds an object to the PDF body.
            @param object
            @param ref
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfIndirectReference,System.Boolean)">
            Adds an object to the PDF body.
            @param object
            @param ref
            @param inObjStm
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject,System.Int32)">
            Adds an object to the PDF body.
            @param object
            @param refNumber
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddToBody(iTextSharp.text.pdf.PdfObject,System.Int32,System.Boolean)">
            Adds an object to the PDF body.
            @param object
            @param refNumber
            @param inObjStm
            @return a PdfIndirectObject
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.CacheObject(iTextSharp.text.pdf.PdfIndirectObject)">
            Use this method for caching objects.
            @param iobj @see PdfIndirectObject
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.extraCatalog">
            Holds value of property extraCatalog. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.root">
            The root of the page tree. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.pageReferences">
            The PdfIndirectReference to the pages. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.currentPageNumber">
            The current page number. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.tabs">
            The value of the Tabs entry in the page dictionary.
            @since   2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.pageDictEntries">
            Additional page dictionary entries.
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddPageDictEntry(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Adds an additional entry for the page dictionary.
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.ResetPageDictEntries">
            Resets the additional pageDictEntries.
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetLinearPageMode">
            Use this method to make sure the page tree has a lineair structure
            (every leave is attached directly to the root).
            Use this method to allow page reordering with method reorderPages.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.ReorderPages(System.Int32[])">
            Use this method to reorder the pages in the document.
            A <CODE>null</CODE> argument value only returns the number of pages to process.
            It is advisable to issue a <CODE>Document.NewPage()</CODE> before using this method.
            @return the total number of pages
            @param order an array with the new page sequence. It must have the
            same size as the number of pages.
            @throws DocumentException if all the pages are not present in the array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetPageReference(System.Int32)">
            Use this method to get a reference to a page existing or not.
            If the page does not exist yet the reference will be created
            in advance. If on closing the document, a page number greater
            than the total number of pages was requested, an exception
            is thrown.
            @param page the page number. The first page is 1
            @return the reference to the page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetPageViewport(iTextSharp.text.pdf.PdfArray)">
            Sets the Viewport for the next page.
            @param viewport an array consisting of Viewport dictionaries.
            @since 5.1.0
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.Add(iTextSharp.text.pdf.PdfPage,iTextSharp.text.pdf.PdfContents)" -->
        <member name="F:iTextSharp.text.pdf.PdfWriter.pageEvent">
            The <CODE>PdfPageEvent</CODE> for this document. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.prevxref">
            A number refering to the previous Cross-Reference Table. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.originalFileID">
            The original file ID (if present). 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.Open" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.Close" -->
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_2">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_3">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_4">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_5">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_6">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PDF_VERSION_1_7">
            possible PDF version (catalog) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.pdf_version">
            Stores the version information for the header and the catalog. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetAtLeastPdfVersion(System.Char)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setAtLeastPdfVersion(char)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetPdfVersion(iTextSharp.text.pdf.PdfName)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(com.lowagie.text.pdf.PdfName)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddDeveloperExtension(iTextSharp.text.pdf.PdfDeveloperExtension)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#addDeveloperExtension(com.lowagie.text.pdf.PdfDeveloperExtension)
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetPdfVersion">
            Returns the version information.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Adds a viewer preference
            @param preferences the viewer preferences
            @see PdfViewerPreferences#addViewerPreference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddNamedDestinations(System.Collections.Generic.IDictionary{System.String,System.String},System.Int32)">
            Adds named destinations in bulk.
            Valid keys and values of the map can be found in the map
            that is created by SimpleNamedDestination.
            @param    map a map with strings as keys for the names,
                      and structured strings as values for the destinations
            @param    page_offset number of pages that has to be added to
                      the page numbers in the destinations (useful if you
                     use this method in combination with PdfCopy).
            @since    iText 5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddNamedDestination(System.String,System.Int32,iTextSharp.text.pdf.PdfDestination)">
            Adds one named destination.
            @param    name    the name for the destination
            @param    page    the page number where you want to jump to
            @param    dest    an explicit destination
            @since    iText 5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(iTextSharp.text.pdf.PdfAction)">
            Use this method to add a JavaScript action at the document level.
            When the document opens, all this JavaScript runs.
            @param js The JavaScript action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(System.String,System.Boolean)">
            Adds a JavaScript action at the document level. When the document
            opens all this JavaScript runs.
            @param code the JavaScript code
            @param unicode select JavaScript unicode. Note that the internal
            Acrobat JavaScript engine does not support unicode,
            so this may or may not work for you
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(System.String)">
            Adds a JavaScript action at the document level. When the document
            opens all this JavaScript runs.
            @param code the JavaScript code
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(System.String,iTextSharp.text.pdf.PdfAction)">
            Use this method to add a JavaScript action at the document level.
            When the document opens, all this JavaScript runs.
            @param name The name of the JS Action in the name tree
            @param js The JavaScript action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(System.String,System.String,System.Boolean)">
            Use this method to add a JavaScript action at the document level.
            When the document opens, all this JavaScript runs.
            @param name The name of the JS Action in the name tree
            @param code the JavaScript code
            @param unicode select JavaScript unicode. Note that the internal
            Acrobat JavaScript engine does not support unicode,
            so this may or may not work for you
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddJavaScript(System.String,System.String)">
            Use this method to adds a JavaScript action at the document level.
            When the document opens, all this JavaScript runs.
            @param name The name of the JS Action in the name tree
            @param code the JavaScript code
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddFileAttachment(System.String,System.Byte[],System.String,System.String)">
            Adds a file attachment at the document level.
            @param description the file description
            @param fileStore an array with the file. If it's <CODE>null</CODE>
            the file will be read from the disk
            @param file the path to the file. It will only be used if
            <CODE>fileStore</CODE> is not <CODE>null</CODE>
            @param fileDisplay the actual file name stored in the pdf
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddFileAttachment(System.String,iTextSharp.text.pdf.PdfFileSpecification)">
            Adds a file attachment at the document level.
            @param description the file description
            @param fs the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddFileAttachment(iTextSharp.text.pdf.PdfFileSpecification)">
            Adds a file attachment at the document level.
            @param fs the file specification
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DOCUMENT_CLOSE">
            action value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.WILL_SAVE">
            action value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DID_SAVE">
            action value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.WILL_PRINT">
            action value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.DID_PRINT">
            action value 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetOpenAction(System.String)">
            When the document opens it will jump to the destination with
            this name.
            @param name the name of the destination to jump to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetOpenAction(iTextSharp.text.pdf.PdfAction)">
            When the document opens this <CODE>action</CODE> will be
            invoked.
            @param action the action to be invoked
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetAdditionalAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
            Additional-actions defining the actions to be taken in
             response to various trigger events affecting the document
             as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,
             <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>
             and <CODE>DID_PRINT</CODE>.
            
             @param actionType the action type
             @param action the action to execute in response to the trigger
             @throws PdfException on invalid action type
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddAnnotation(iTextSharp.text.pdf.PdfAnnotation)">
            Adds a <CODE>PdfAnnotation</CODE> or a <CODE>PdfFormField</CODE>
            to the document. Only the top parent of a <CODE>PdfFormField</CODE>
            needs to be added.
            @param annot the <CODE>PdfAnnotation</CODE> or the <CODE>PdfFormField</CODE> to add
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddCalculationOrder(iTextSharp.text.pdf.PdfFormField)">
            Adds the <CODE>PdfAnnotation</CODE> to the calculation order
            array.
            @param annot the <CODE>PdfAnnotation</CODE> to be added
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.xmpMetadata">
            XMP Metadata for the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.CreateXmpMetadata">
            Use this method to creates XMP Metadata based
            on the metadata in the PdfDocument.
            @since 5.4.4 just creates XmpWriter instance which will be serialized in close.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.pdfIsoConformance">
            Stores the PDF ISO conformance. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.IsPdfIso">
            Checks if any PDF ISO conformance is necessary.
            @return <code>true</code> if the PDF has to be in conformance with any of the PDF ISO specifications
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.IsPdfX">
            @see com.lowagie.text.pdf.interfaces.PdfXConformance#isPdfX() 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetOutputIntents(System.String,System.String,System.String,System.String,iTextSharp.text.pdf.ICC_Profile)">
            Sets the values of the output intent dictionary. Null values are allowed to
            suppress any key.
            @param outputConditionIdentifier a value
            @param outputCondition a value
            @param registryName a value
            @param info a value
            @param destOutputProfile a value
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetOutputIntents(System.String,System.String,System.String,System.String,System.Byte[])">
             Sets the values of the output intent dictionary. Null values are allowed to
             suppress any key.
            
             Prefer the <CODE>ICC_Profile</CODE>-based version of this method.
             @param outputConditionIdentifier a value
             @param outputCondition           a value, "PDFA/A" to force GTS_PDFA1, otherwise cued by pdfxConformance.
             @param registryName              a value
             @param info                      a value
             @param destOutputProfile         a value
             @since 1.x
            
             @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetOutputIntents(iTextSharp.text.pdf.PdfReader,System.Boolean)">
            Copies the output intent dictionary from other document to this one.
            @param reader the other document
            @param checkExistence <CODE>true</CODE> to just check for the existence of a valid output intent
            dictionary, <CODE>false</CODE> to insert the dictionary if it exists
            @throws IOException on error
            @return <CODE>true</CODE> if the output intent dictionary exists, <CODE>false</CODE>
            otherwise
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.crypto">
            Contains the business logic for cryptography. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            Sets the certificate encryption options for this document. An array of one or more public certificates
            must be provided together with an array of the same size for the permissions for each certificate.
             The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param certs the public certificates to be used for the encryption
            @param permissions the user permissions for each of the certicates
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetEncryption(System.Boolean,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param strength <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetEncryption(System.Int32,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if the document is already open
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.fullCompression">
            Holds value of property fullCompression.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetFullCompression">
            Sets the document's compression to the new 1.5 mode with object streams and xref
            streams. It can be set at any time but once set it can't be unset.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.compressionLevel">
            The compression level of the content streams.
            @since   2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.documentFonts">
            The fonts of this document 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.fontNumber">
            The font number counter for the fonts in the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddSimple(iTextSharp.text.pdf.BaseFont)">
            Adds a <CODE>BaseFont</CODE> to the document but not to the page resources.
            It is used for templates.
            @param bf the <CODE>BaseFont</CODE> to add
            @return an <CODE>Object[]</CODE> where position 0 is a <CODE>PdfName</CODE>
            and position 1 is an <CODE>PdfIndirectReference</CODE>
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.formXObjects">
            The form XObjects in this document. The key is the xref and the value
                        is Object[]{PdfName, template}.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.formXObjectsCounter">
            The name counter for the form XObjects name. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddDirectTemplateSimple(iTextSharp.text.pdf.PdfTemplate,iTextSharp.text.pdf.PdfName)">
            Adds a template to the document but not to the page resources.
            @param template the template to add
            @param forcedName the template name, rather than a generated one. Can be null
            @return the <CODE>PdfName</CODE> for this template
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.ReleaseTemplate(iTextSharp.text.pdf.PdfTemplate)">
            Releases the memory used by a template by writing it to the output. The template
            can still be added to any content but changes to the template itself won't have
            any effect.
            @param tp the template to release
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetImportedPage(iTextSharp.text.pdf.PdfReader,System.Int32)">
            Gets a page from other PDF document. The page can be used as
            any other PdfTemplate. Note that calling this method more than
            once with the same parameters will retrieve the same object.
            @param reader the PDF document where the page is
            @param pageNumber the page number. The first page is 1
            @return the template representing the imported page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetPdfReaderInstance(iTextSharp.text.pdf.PdfReader)">
            Returns the PdfReaderInstance associated with the specified reader.
            Multiple calls with the same reader object will return the same
            PdfReaderInstance.
            @param reader the PDF reader that you want an instance for
            @return the instance for the provided reader
            @since 5.0.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.FreeReader(iTextSharp.text.pdf.PdfReader)">
            Writes the reader to the document and frees the memory used by it.
            The main use is when concatenating multiple documents to keep the
            memory usage restricted to the current appending document.
            @param reader the <CODE>PdfReader</CODE> to free
            @throws IOException on error
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.documentColors">
            The colors of this document 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.colorNumber">
            The color number counter for the colors in the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddSimple(iTextSharp.text.pdf.ICachedColorSpace)">
            Adds a <CODE>SpotColor</CODE> to the document but not to the page resources.
            @param spc the <CODE>SpotColor</CODE> to add
            @return an <CODE>Object[]</CODE> where position 0 is a <CODE>PdfName</CODE>
            and position 1 is an <CODE>PdfIndirectReference</CODE>
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.documentPatterns">
            The patterns of this document 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.patternNumber">
            The patten number counter for the colors in the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetTagged">
            Mark this document for tagging. It must be called before open.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.IsTagged">
            Check if the document is marked for tagging.
            @return <CODE>true</CODE> if the document is marked for tagging
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.FlushTaggedObjects">
            Fix structure of tagged document: remove unused objects, remove unused items from class map,
            fix xref table due to removed objects.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.FlushAcroFields">
            Flushes merged AcroFields to document (if any). 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddOCGRadioGroup(System.Collections.Generic.List{iTextSharp.text.pdf.PdfLayer})">
            Sets a collection of optional content groups whose states are intended to follow
            a "radio button" paradigm. That is, the state of at most one optional
            content group in the array should be ON at a time: if one group is turned
            ON, all others must be turned OFF.
            @param group the radio group
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.LockLayer(iTextSharp.text.pdf.PdfLayer)">
            Use this method to lock an optional content group.
            The state of a locked group cannot be changed through the user interface
            of a viewer application. Producers can use this entry to prevent the visibility
            of content that depends on these groups from being changed by users.
            @param layer the layer that needs to be added to the array of locked OCGs
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetBoxSize(System.String,iTextSharp.text.Rectangle)">
            Sets the page box sizes. Allowed names are: "crop", "trim", "art" and "bleed".
            @param boxName the box size
            @param size the size
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetBoxSize(System.String)">
            Gives the size of a trim, art, crop or bleed box, or null if not defined.
            @param boxName crop, trim, art or bleed
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetBoxSize(System.String,iTextSharp.text.Rectangle)">
             Returns the intersection between the crop, trim art or bleed box and the parameter intersectingRectangle.
             This method returns null when
             - there is no intersection
             - any of the above boxes are not defined
             - the parameter intersectingRectangle is null
            
             @param boxName crop, trim, art, bleed
             @param intersectingRectangle the rectangle that intersects the rectangle associated to the boxName
             @return the intersection of the two rectangles
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PAGE_OPEN">
            action value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PAGE_CLOSE">
            action value 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.SetPageAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
            Sets the open and close page additional action.
            @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
            or <CODE>PdfWriter.PAGE_CLOSE</CODE>
            @param action the action to perform
            @throws PdfException if the action type is invalid
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.group">
            A group attributes dictionary specifying the attributes
            of the page�s page group for use in the transparent
            imaging model
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.spaceCharRatio">
            The ratio between the extra word spacing and the extra character spacing.
            Extra word spacing will grow <CODE>ratio</CODE> times more than extra character spacing.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.SetDefaultColorspace(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)" -->
        <member name="M:iTextSharp.text.pdf.PdfWriter.ClearTextWrap">
            Clears text wrapping around images (if applicable).
            Method suggested by Pelikan Stephan
            @throws DocumentException
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.imageDictionary">
            Dictionary, containing all the images of the PDF document 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.images">
            This is the list with all the images in the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddDirectImageSimple(iTextSharp.text.Image)">
            Adds an image to the document but not to the page resources. It is used with
            templates and <CODE>Document.Add(Image)</CODE>.
            @param image the <CODE>Image</CODE> to add
            @return the name of the image added
            @throws PdfException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.AddDirectImageSimple(iTextSharp.text.Image,iTextSharp.text.pdf.PdfIndirectReference)">
            Adds an image to the document but not to the page resources. It is used with
            templates and <CODE>Document.Add(Image)</CODE>.
            @param image the <CODE>Image</CODE> to add
            @param fixedRef the reference to used. It may be <CODE>null</CODE>,
            a <CODE>PdfIndirectReference</CODE> or a <CODE>PRIndirectReference</CODE>.
            @return the name of the image added
            @throws PdfException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.Add(iTextSharp.text.pdf.PdfImage,iTextSharp.text.pdf.PdfIndirectReference)">
             Writes a <CODE>PdfImage</CODE> to the outputstream.
            
             @param pdfImage the image to be added
             @return a <CODE>PdfIndirectReference</CODE> to the encapsulated image
             @throws PdfException when a document isn't open yet, or has been closed
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetImageReference(iTextSharp.text.pdf.PdfName)">
             return the <CODE>PdfIndirectReference</CODE> to the image with a given name.
            
             @param name the name of the image
             @return a <CODE>PdfIndirectReference</CODE>
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.JBIG2Globals">
            A Hashtable with Stream objects containing JBIG2 Globals
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetReferenceJBIG2Globals(System.Byte[])">
            Gets an indirect reference to a JBIG2 Globals stream.
            Adds the stream if it hasn't already been added to the writer.
            @param   content a byte array that may already been added to the writer inside a stream object.
            @since  2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.userProperties">
            A flag indicating the presence of structure elements that contain user properties attributes.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.rgbTransparencyBlending">
            Holds value of property RGBTranparency.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.CreateAnnotation(iTextSharp.text.Rectangle,iTextSharp.text.pdf.PdfName)">
             A wrapper around PdfAnnotation constructor.
             It is recommended to use this wrapper instead of direct constructor as this is a convenient way to override PdfAnnotation construction when needed.
            
             @param rect
             @param subtype
             @return
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.CreateAnnotation(System.Single,System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfString,iTextSharp.text.pdf.PdfString,iTextSharp.text.pdf.PdfName)">
             A wrapper around PdfAnnotation constructor.
             It is recommended to use this wrapper instead of direct constructor as this is a convenient way to override PdfAnnotation construction when needed.
            
             @param llx
             @param lly
             @param urx
             @param ury
             @param title
             @param content
             @param subtype
             @return
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.CreateAnnotation(System.Single,System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfAction,iTextSharp.text.pdf.PdfName)">
             A wrapper around PdfAnnotation constructor.
             It is recommended to use this wrapper instead of direct constructor as this is a convenient way to override PdfAnnotation construction when needed.
            
             @param llx
             @param lly
             @param urx
             @param ury
             @param action
             @param subtype
             @return
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.GetStandardStructElems">
            Gets the list of the standard structure element names (roles).
            @return
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfDocument">
            Gets the <CODE>PdfDocument</CODE> associated with this writer.
            @return the <CODE>PdfDocument</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Info">
            Use this method to get the info dictionary if you want to
            change it directly (add keys and values to the info dictionary).
            @return the info dictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.InitialLeading">
            Sets the initial leading for the PDF document.
            This has to be done before the document is opened.
            @param   leading the initial leading
            @since   2.1.6
            @throws  DocumentException       if you try setting the leading after the document was opened.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.DirectContent">
            Use this method to get the direct content for this document.
            There is only one direct content, multiple calls to this method
            will allways retrieve the same object.
            @return the direct content
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.DirectContentUnder">
            Use this method to get the direct content under for this document.
            There is only one direct content, multiple calls to this method
            will allways retrieve the same object.
            @return the direct content
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfIndirectReference">
            Gets a <CODE>PdfIndirectReference</CODE> for an object that
            will be created in the future.
            @return the <CODE>PdfIndirectReference</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Os">
            Returns the outputStreamCounter.
            @return the outputStreamCounter
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.ExtraCatalog">
            Sets extra keys to the catalog.
            @return the catalog to change
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageDictEntries">
            Gets the additional pageDictEntries.
            @since 5.1.0
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageNumber">
            Gets the pagenumber of this document.
            This number can be different from the real pagenumber,
            if you have (re)set the page number previously.
            @return a page number
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Tabs">
            Sets the value for the Tabs entry in the page tree.
            @param	tabs	Can be PdfName.R, PdfName.C or PdfName.S.
            Since the Adobe Extensions Level 3, it can also be PdfName.A
            or PdfName.W
            @since	2.1.5
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageEvent">
            Gets the <CODE>PdfPageEvent</CODE> for this document or <CODE>null</CODE>
            if none is set.
            @return the <CODE>PdfPageEvent</CODE> for this document or <CODE>null</CODE>
            if none is set
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.RootOutline">
            Use this method to get the root outline
            and construct bookmarks.
            @return the root outline
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Outlines">
            Sets the bookmarks. The list structure is defined in
            {@link SimpleBookmark}.
            @param outlines the bookmarks or <CODE>null</CODE> to remove any
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfVersion">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(char)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.ViewerPreferences">
            Sets the viewer preferences as the sum of several constants.
            @param preferences the viewer preferences
            @see PdfViewerPreferences#setViewerPreferences
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageLabels">
            Use this method to add page labels
            @param pageLabels the page labels
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Collection">
            Sets the Collection dictionary.
            @param collection a dictionary of type PdfCollection
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.AcroForm">
            Gets the AcroForm object.
            @return the <CODE>PdfAcroForm</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.SigFlags">
            Set the signature flags.
            @param f the flags. This flags are ORed with current ones
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.XmpMetadata">
            Sets XMP Metadata.
            @param xmpMetadata The xmpMetadata to set.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageXmpMetadata">
            Use this method to set the XMP Metadata for each page.
            @param xmpMetadata The xmpMetadata to set.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PDFXConformance">
            Sets the PDFX conformance level. Allowed values are PDFX1A2001 and PDFX32002. It
            must be called before opening the document.
            @param pdfxConformance the conformance level
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.FullCompression">
            Gets the 1.5 compression status.
            @return <code>true</code> if the 1.5 compression is on
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.CompressionLevel">
            Sets the compression level to be used for streams written by this writer.
            @param compressionLevel a value between 0 (best speed) and 9 (best compression)
            @since   2.1.3
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.CurrentDocumentSize">
            Gets the current document size. This size only includes
            the data already writen to the output stream, it does not
            include templates or fonts. It is usefull if used with
            <CODE>freeReader()</CODE> when concatenating many documents
            and an idea of the current size is needed.
            @return the approximate size without fonts or templates
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.StructureTreeRoot">
            Gets the structure tree root. If the document is not marked for tagging it will return <CODE>null</CODE>.
            @return the structure tree root
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.OCProperties">
            Gets the <B>Optional Content Properties Dictionary</B>. Each call fills the dictionary with the current layer
            state. It's advisable to only call this method right before close and do any modifications
            at that time.
            @return the Optional Content Properties Dictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageSize">
            Gives the size of the media box.
            @return a Rectangle
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.CropBoxSize">
            Sets the crop box. The crop box should not be rotated even if the
            page is rotated. This change only takes effect in the next
            page.
            @param crop the crop box
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PageEmpty">
            Use this method to make sure a page is added,
            even if it's empty. If you use SetPageEmpty(false),
            invoking NewPage() after a blank page will add a newPage.
            SetPageEmpty(true) won't have any effect.
            @param pageEmpty the state
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Duration">
            Sets the display duration for the page (for presentations)
            @param seconds   the number of seconds to display the page
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Transition">
            Sets the transition for the page
            @param transition   the Transition object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Thumbnail">
            Sets the the thumbnail image for the current page.
            @param image the image
            @throws PdfException on error
            @throws DocumentException or error
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.SpaceCharRatio">
            Sets the ratio between the extra word spacing and the extra character spacing
            when the text is fully justified.
            Extra word spacing will grow <CODE>spaceCharRatio</CODE> times more than extra character spacing.
            If the ratio is <CODE>PdfWriter.NO_SPACE_CHAR_RATIO</CODE> then the extra character spacing
            will be zero.
            @param spaceCharRatio the ratio between the extra word spacing and the extra character spacing
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.RunDirection">
            Sets the run direction. This is only used as a placeholder
            as it does not affect anything.
            @param runDirection the run direction
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.Userunit">
            A UserUnit is a value that defines the default user space unit.
            The minimum UserUnit is 1 (1 unit = 1/72 inch).
            The maximum UserUnit is 75,000.
            Remark that this userunit only works starting with PDF1.6!
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.DefaultColorspace">
            Gets the default colorspaces.
            @return the default colorspaces
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.StrictImageSequence">
            Sets the image sequence to follow the text in strict order.
             @param strictImageSequence new value of property strictImageSequence
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.UserProperties">
            Sets the flag indicating the presence of structure elements that contain user properties attributes.
            @param userProperties the user properties flag
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.RgbTransparencyBlending">
            Sets the transparency blending colorspace to RGB. The default blending colorspace is
            CMYK and will result in faded colors in the screen and in printing. Calling this method
            will return the RGB colors to what is expected. The RGB blending will be applied to all subsequent pages
            until other value is set.
            Note that this is a generic solution that may not work in all cases.
            @param rgbTransparencyBlending <code>true</code> to set the transparency blending colorspace to RGB, <code>false</code>
            to use the default blending colorspace
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfWriter.PdfBody" -->
        <member name="F:iTextSharp.text.pdf.PdfWriter.PdfBody.xrefs">
            array containing the cross-reference table of the normal objects. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PdfBody.position">
            the current byteposition in the body. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Constructs a new <CODE>PdfBody</CODE>.
            @param writer
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.PdfBody.Add(iTextSharp.text.pdf.PdfObject)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfWriter.PdfBody.Add(iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfIndirectReference)" -->
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.WriteCrossReferenceTable(System.IO.Stream,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfObject,System.Int64)">
            Returns the CrossReferenceTable of the <CODE>Body</CODE>.
            @param os
            @param root
            @param info
            @param encryption
            @param fileID
            @param prevxref
            @throws IOException
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfIndirectReference">
            Gets a PdfIndirectReference for an object that will be created in the future.
            @return a PdfIndirectReference
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfBody.Offset">
             Returns the offset of the Cross-Reference table.
            
             @return       an offset
        </member>
        <member name="P:iTextSharp.text.pdf.PdfWriter.PdfBody.Size">
             Returns the total number of objects contained in the CrossReferenceTable of this <CODE>Body</CODE>.
            
             @return   a number of objects
        </member>
        <member name="T:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference">
            <CODE>PdfCrossReference</CODE> is an entry in the PDF Cross-Reference table.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.offset">
            Byte offset in the PDF file. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.generation">
            generation of the object. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.#ctor(System.Int32,System.Int64,System.Int32)">
            Constructs a cross-reference element for a PdfIndirectObject.
            @param refnum
            @param    offset      byte offset of the object
            @param    generation  generationnumber of the object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.#ctor(System.Int32,System.Int64)">
            Constructs a cross-reference element for a PdfIndirectObject.
            @param refnum
            @param    offset      byte offset of the object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.ToPdf(System.IO.Stream)">
            Returns the PDF representation of this <CODE>PdfObject</CODE>.
            @param os
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.ToPdf(System.Int32,System.IO.Stream)">
            Writes PDF syntax to the Stream
            @param midSize
            @param os
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.CompareTo(System.Object)">
            @see java.lang.Comparable#compareTo(java.lang.Object)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfBody.PdfCrossReference.Equals(System.Object)">
            @see java.lang.Object#equals(java.lang.Object)
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfWriter.PdfTrailer" -->
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfTrailer.#ctor(System.Int32,System.Int64,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfObject,System.Int64)">
             Constructs a PDF-Trailer.
            
             @param        size        the number of entries in the <CODE>PdfCrossReferenceTable</CODE>
             @param        offset      offset of the <CODE>PdfCrossReferenceTable</CODE>
             @param        root        an indirect reference to the root of the PDF document
             @param        info        an indirect reference to the info object of the PDF document
             @param encryption
             @param fileID
             @param prevxref
        </member>
        <member name="M:iTextSharp.text.pdf.PdfWriter.PdfTrailer.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
            Returns the PDF representation of this <CODE>PdfObject</CODE>.
            @param writer
            @param os
            @throws IOException
        </member>
        <member name="T:iTextSharp.text.pdf.FontDetails">
            Each font in the document will have an instance of this class
             where the characters used will be represented.
            
             @author  Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.indirectReference">
            The indirect reference to this font
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.fontName">
            The font name that appears in the document body stream
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.baseFont">
            The font
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.ttu">
            The font if its an instance of <CODE>TrueTypeFontUnicode</CODE>
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.shortTag">
            The array used with single byte encodings
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.longTag">
            The map used with double byte encodings. The key is Int(glyph) and the
            value is int[]{glyph, width, Unicode code}
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.fontType">
            The font type
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.symbolic">
            <CODE>true</CODE> if the font is symbolic
        </member>
        <member name="F:iTextSharp.text.pdf.FontDetails.subset">
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document.
        </member>
        <member name="M:iTextSharp.text.pdf.FontDetails.#ctor(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.BaseFont)">
            Each font used in a document has an instance of this class.
            This class stores the characters used in the document and other
            specifics unique to the current working document.
            @param fontName the font name
            @param indirectReference the indirect reference to the font
            @param baseFont the <CODE>BaseFont</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.FontDetails.ConvertToBytes(System.String)">
            Converts the text into bytes to be placed in the document.
            The conversion is done according to the font and the encoding and the characters
            used are stored.
            @param text the text to convert
            @return the conversion
        </member>
        <member name="M:iTextSharp.text.pdf.FontDetails.WriteFont(iTextSharp.text.pdf.PdfWriter)">
            Writes the font definition to the document.
            @param writer the <CODE>PdfWriter</CODE> of this document
        </member>
        <member name="P:iTextSharp.text.pdf.FontDetails.IndirectReference">
            Gets the indirect reference to this font.
            @return the indirect reference to this font
        </member>
        <member name="P:iTextSharp.text.pdf.FontDetails.FontName">
            Gets the font name as it appears in the document body.
            @return the font name
        </member>
        <member name="P:iTextSharp.text.pdf.FontDetails.BaseFont">
            Gets the <CODE>BaseFont</CODE> of this font.
            @return the <CODE>BaseFont</CODE> of this font
        </member>
        <member name="P:iTextSharp.text.pdf.FontDetails.Subset">
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document. Set to <CODE>false</CODE>
            to include all.
            @param subset new value of property subset
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.FontSelector" -->
        <member name="M:iTextSharp.text.pdf.FontSelector.AddFont(iTextSharp.text.Font)">
            Adds a <CODE>Font</CODE> to be searched for valid characters.
            @param font the <CODE>Font</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.FontSelector.Process(System.String)">
            Process the text so that it will render with a combination of fonts
            if needed.
            @param text the text
            @return a <CODE>Phrase</CODE> with one or more chunks
        </member>
        <member name="T:iTextSharp.text.pdf.GrayColor">
            
             @author  Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.HyphenationAuto">
            Hyphenates words automatically accordingly to the language and country.
             The hyphenator engine was taken from FOP and uses the TEX patterns. If a language
             is not provided and a TEX pattern for it exists, it can be easily adapted.
            
             @author Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.IHyphenationEvent">
            Called by <code>Chunk</code> to hyphenate a word.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.IHyphenationEvent.GetHyphenatedWordPre(System.String,iTextSharp.text.pdf.BaseFont,System.Single,System.Single)">
            Hyphenates a word and returns the first part of it. To get
            the second part of the hyphenated word call <CODE>getHyphenatedWordPost()</CODE>.
            @param word the word to hyphenate
            @param font the font used by this word
            @param fontSize the font size used by this word
            @param remainingWidth the width available to fit this word in
            @return the first part of the hyphenated word including
            the hyphen symbol, if any
        </member>
        <member name="P:iTextSharp.text.pdf.IHyphenationEvent.HyphenSymbol">
            Gets the hyphen symbol.
            @return the hyphen symbol
        </member>
        <member name="P:iTextSharp.text.pdf.IHyphenationEvent.HyphenatedWordPost">
            Gets the second part of the hyphenated word. Must be called
            after <CODE>getHyphenatedWordPre()</CODE>.
            @return the second part of the hyphenated word
        </member>
        <member name="F:iTextSharp.text.pdf.HyphenationAuto.hyphenator">
            The hyphenator engine.
        </member>
        <member name="F:iTextSharp.text.pdf.HyphenationAuto.post">
            The second part of the hyphenated word.
        </member>
        <member name="M:iTextSharp.text.pdf.HyphenationAuto.#ctor(System.String,System.String,System.Int32,System.Int32)">
            Creates a new hyphenation instance usable in <CODE>Chunk</CODE>.
            @param lang the language ("en" for english, for example)
            @param country the country ("GB" for Great-Britain or "none" for no country, for example)
            @param leftMin the minimun number of letters before the hyphen
            @param rightMin the minimun number of letters after the hyphen
        </member>
        <member name="M:iTextSharp.text.pdf.HyphenationAuto.GetHyphenatedWordPre(System.String,iTextSharp.text.pdf.BaseFont,System.Single,System.Single)">
            Hyphenates a word and returns the first part of it. To get
            the second part of the hyphenated word call <CODE>getHyphenatedWordPost()</CODE>.
            @param word the word to hyphenate
            @param font the font used by this word
            @param fontSize the font size used by this word
            @param remainingWidth the width available to fit this word in
            @return the first part of the hyphenated word including
            the hyphen symbol, if any
        </member>
        <member name="P:iTextSharp.text.pdf.HyphenationAuto.HyphenSymbol">
            Gets the hyphen symbol.
            @return the hyphen symbol
        </member>
        <member name="P:iTextSharp.text.pdf.HyphenationAuto.HyphenatedWordPost">
            Gets the second part of the hyphenated word. Must be called
            after <CODE>getHyphenatedWordPre()</CODE>.
            @return the second part of the hyphenated word
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.ByteVector" -->
        <member name="F:iTextSharp.text.pdf.hyphenation.ByteVector.DEFAULT_BLOCK_SIZE">
            Capacity increment size
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.ByteVector.arr">
            The encapsulated array
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.ByteVector.n">
            Points to next free item
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.ByteVector.Alloc(System.Int32)">
            This is to implement memory allocation in the array. Like Malloc().
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.ByteVector.Length">
            return number of items in array
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.ByteVector.Capacity">
            returns current capacity of array
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.CharVector" -->
        <member name="F:iTextSharp.text.pdf.hyphenation.CharVector.DEFAULT_BLOCK_SIZE">
            Capacity increment size
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.CharVector.array">
            The encapsulated array
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.CharVector.n">
            Points to next free item
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.CharVector.Clear">
            Reset Vector but don't resize or clear elements
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.CharVector.Length">
            return number of items in array
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.CharVector.Capacity">
            returns current capacity of array
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.Hyphen" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.Hyphenation" -->
        <member name="F:iTextSharp.text.pdf.hyphenation.Hyphenation.len">
            number of hyphenation points in word
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenation.#ctor(System.String,System.Int32[])">
            rawWord as made of alternating strings and {@link Hyphen Hyphen}
            instances
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenation.GetPreHyphenText(System.Int32)">
            @return the pre-break text, not including the hyphen character
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenation.GetPostHyphenText(System.Int32)">
            @return the post-break text
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.Hyphenation.Length">
            @return the number of hyphenation points in the word
        </member>
        <member name="P:iTextSharp.text.pdf.hyphenation.Hyphenation.HyphenationPoints">
            @return the hyphenation points
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.HyphenationException" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.HyphenationTree" -->
        <member name="T:iTextSharp.text.pdf.hyphenation.TernaryTree">
             <h2>Ternary Search Tree</h2>
            
             <p>A ternary search tree is a hibrid between a binary tree and
             a digital search tree (trie). Keys are limited to strings.
             A data value of type char is stored in each leaf node.
             It can be used as an index (or pointer) to the data.
             Branches that only contain one key are compressed to one node
             by storing a pointer to the trailer substring of the key.
             This class is intended to serve as base class or helper class
             to implement Dictionary collections or the like. Ternary trees
             have some nice properties as the following: the tree can be
             traversed in sorted order, partial matches (wildcard) can be
             implemented, retrieval of all keys within a given distance
             from the target, etc. The storage requirements are higher than
             a binary tree but a lot less than a trie. Performance is
             comparable with a hash table, sometimes it outperforms a hash
             function (most of the time can determine a miss faster than a hash).</p>
            
             <p>The main purpose of this java port is to serve as a base for
             implementing TeX's hyphenation algorithm (see The TeXBook,
             appendix H). Each language requires from 5000 to 15000 hyphenation
             patterns which will be keys in this tree. The strings patterns
             are usually small (from 2 to 5 characters), but each char in the
             tree is stored in a node. Thus memory usage is the main concern.
             We will sacrify 'elegance' to keep memory requirenments to the
             minimum. Using java's char type as pointer (yes, I know pointer
             it is a forbidden word in java) we can keep the size of the node
             to be just 8 bytes (3 pointers and the data char). This gives
             room for about 65000 nodes. In my tests the english patterns
             took 7694 nodes and the german patterns 10055 nodes,
             so I think we are safe.</p>
            
             <p>All said, this is a map with strings as keys and char as value.
             Pretty limited!. It can be extended to a general map by
             using the string representation of an object and using the
             char value as an index to an array that contains the object
             values.</p>
            
             @author cav@uniscope.co.jp
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.lo">
            Pointer to low branch and to rest of the key when it is
            stored directly in this node, we don't have unions in java!
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.hi">
            Pointer to high branch.
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.eq">
            Pointer to equal branch and to data when this node is a string terminator.
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.sc">
            <P>The character stored in this node: splitchar
            Two special values are reserved:</P>
            <ul><li>0x0000 as string terminator</li>
            <li>0xFFFF to indicate that the branch starting at
            this node is compressed</li></ul>
            <p>This shouldn't be a problem if we give the usual semantics to
            strings since 0xFFFF is garanteed not to be an Unicode character.</p>
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.kv">
            This vector holds the trailing of the keys when the branch is compressed.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Insert(System.String,System.Char)">
            Branches are initially compressed, needing
            one node per key plus the size of the string
            key. They are decompressed as needed when
            another key with same prefix
            is inserted. This saves a lot of space,
            specially for long keys.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Insert(System.Char,System.Char[],System.Int32,System.Char)">
            The actual insertion function, recursive version.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Strcmp(System.Char[],System.Int32,System.Char[],System.Int32)">
            Compares 2 null terminated char arrays
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Strcmp(System.String,System.Char[],System.Int32)">
            Compares a string with null terminated char array
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.InsertBalanced(System.String[],System.Char[],System.Int32,System.Int32)">
            Recursively insert the median first and then the median of the
            lower and upper halves, and so on in order to get a balanced
            tree. The array of keys is assumed to be sorted in ascending
            order.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Balance">
            Balance the tree for best search performance
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.TrimToSize">
             Each node stores a character (splitchar) which is part of
             some Key(s). In a compressed branch (one that only contain
             a single string key) the trailer of the key which is not
             already in nodes is stored  externally in the kv array.
             As items are inserted, key substrings decrease.
             Some substrings may completely  disappear when the whole
             branch is totally decompressed.
             The tree is traversed to find the key substrings actually
             used. In addition, duplicate substrings are removed using
             a map (implemented with a TernaryTree!).
            
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.cur">
            current node index
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.curkey">
            current key
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.parent">
            TernaryTree parent
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.ns">
            Node stack
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.ks">
            key stack implemented with a StringBuilder
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.Up">
            traverse upwards
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.TernaryTree.Iterator.Run">
            traverse the tree to find next key
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.IPatternConsumer" -->
        <member name="M:iTextSharp.text.pdf.hyphenation.IPatternConsumer.AddClass(System.String)">
            Add a character class.
            A character class defines characters that are considered
            equivalent for the purpose of hyphenation (e.g. "aA"). It
            usually means to ignore case.
            @param chargroup character group
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.IPatternConsumer.AddException(System.String,System.Collections.Generic.List{System.Object})">
            Add a hyphenation exception. An exception replaces the
            result obtained by the algorithm for cases for which this
            fails or the user wants to provide his own hyphenation.
            A hyphenatedword is a vector of alternating String's and
            {@link Hyphen Hyphen} instances
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.IPatternConsumer.AddPattern(System.String,System.String)">
            Add hyphenation patterns.
            @param pattern the pattern
            @param values interletter values expressed as a string of
            digit characters.
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.HyphenationTree.vspace">
            value space: stores the inteletter values
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.HyphenationTree.stoplist">
            This map stores hyphenation exceptions
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.HyphenationTree.classmap">
            This map stores the character classes
        </member>
        <member name="F:iTextSharp.text.pdf.hyphenation.HyphenationTree.ivalues">
            Temporary map to store interletter values on pattern loading.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.PackValues(System.String)">
            Packs the values by storing them in 4 bits, two values into a byte
            Values range is from 0 to 9. We use zero as terminator,
            so we'll add 1 to the value.
            @param values a string of digits from '0' to '9' representing the
            interletter values.
            @return the index into the vspace array where the packed values
            are stored.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.Hstrcmp(System.Char[],System.Int32,System.Char[],System.Int32)">
            String compare, returns 0 if equal or
            t is a substring of s
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.hyphenation.HyphenationTree.SearchPatterns(System.Char[],System.Int32,System.Byte[])" -->
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.Hyphenate(System.String,System.Int32,System.Int32)">
            Hyphenate word and return a Hyphenation object.
            @param word the word to be hyphenated
            @param remainCharCount Minimum number of characters allowed
            before the hyphenation point.
            @param pushCharCount Minimum number of characters allowed after
            the hyphenation point.
            @return a {@link Hyphenation Hyphenation} object representing
            the hyphenated word or null if word is not hyphenated.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.Hyphenate(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            Hyphenate word and return an array of hyphenation points.
            @param w char array that contains the word
            @param offset Offset to first character in word
            @param len Length of word
            @param remainCharCount Minimum number of characters allowed
            before the hyphenation point.
            @param pushCharCount Minimum number of characters allowed after
            the hyphenation point.
            @return a {@link Hyphenation Hyphenation} object representing
            the hyphenated word or null if word is not hyphenated.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.AddClass(System.String)">
            Add a character class to the tree. It is used by
            {@link SimplePatternParser SimplePatternParser} as callback to
            add character classes. Character classes define the
            valid word characters for hyphenation. If a word contains
            a character not defined in any of the classes, it is not hyphenated.
            It also defines a way to normalize the characters in order
            to compare them with the stored patterns. Usually pattern
            files use only lower case characters, in this case a class
            for letter 'a', for example, should be defined as "aA", the first
            character being the normalization char.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.AddException(System.String,System.Collections.Generic.List{System.Object})">
            Add an exception to the tree. It is used by
            {@link SimplePatternParser SimplePatternParser} class as callback to
            store the hyphenation exceptions.
            @param word normalized word
            @param hyphenatedword a vector of alternating strings and
            {@link Hyphen hyphen} objects.
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.HyphenationTree.AddPattern(System.String,System.String)">
            Add a pattern to the tree. Mainly, to be used by
            {@link SimplePatternParser SimplePatternParser} class as callback to
            add a pattern to the tree.
            @param pattern the hyphenation pattern
            @param ivalue interletter weight values indicating the
            desirability and priority of hyphenating at a given point
            within the pattern. It should contain only digit characters.
            (i.e. '0' to '9').
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.hyphenation.Hyphenator" -->
        <member name="F:iTextSharp.text.pdf.hyphenation.Hyphenator.hyphenTrees">
            TODO: Don't use statics 
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.#ctor(System.String,System.String,System.Int32,System.Int32)">
            @param lang
            @param country
            @param leftMin
            @param rightMin
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.GetHyphenationTree(System.String,System.String)">
            @param lang
            @param country
            @return the hyphenation tree
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.GetResourceHyphenationTree(System.String)">
            @param key
            @return a hyphenation tree
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.Hyphenate(System.String,System.String,System.String,System.Int32,System.Int32)">
            @param lang
            @param country
            @param word
            @param leftMin
            @param rightMin
            @return a hyphenation object
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.Hyphenate(System.String,System.String,System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            @param lang
            @param country
            @param word
            @param offset
            @param len
            @param leftMin
            @param rightMin
            @return a hyphenation object
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.SetMinRemainCharCount(System.Int32)">
            @param min
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.SetMinPushCharCount(System.Int32)">
            @param min
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.SetLanguage(System.String,System.String)">
            @param lang
            @param country
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.Hyphenate(System.Char[],System.Int32,System.Int32)">
            @param word
            @param offset
            @param len
            @return a hyphenation object
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.Hyphenator.Hyphenate(System.String)">
            @param word
            @return a hyphenation object
        </member>
        <member name="T:iTextSharp.text.pdf.hyphenation.SimplePatternParser">
            Parses the xml hyphenation pattern.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.hyphenation.SimplePatternParser.#ctor">
            Creates a new instance of PatternParser2 
        </member>
        <member name="T:iTextSharp.text.pdf.ICC_Profile">
            <summary>
            Summary description for ICC_Profile.
            </summary>
        </member>
        <member name="T:iTextSharp.text.pdf.IExtraEncoding">
            Classes implementing this interface can create custom encodings or
            replace existing ones. It is used in the context of <code>PdfEncoding</code>.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.IExtraEncoding.CharToByte(System.String,System.String)">
            Converts an Unicode string to a byte array according to some encoding.
            @param text the Unicode string
            @param encoding the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            @return the conversion or <CODE>null</CODE> if no conversion is supported
        </member>
        <member name="M:iTextSharp.text.pdf.IExtraEncoding.CharToByte(System.Char,System.String)">
            Converts an Unicode char to a byte array according to some encoding.
            @param char1 the Unicode char
            @param encoding the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            @return the conversion or <CODE>null</CODE> if no conversion is supported
        </member>
        <member name="M:iTextSharp.text.pdf.IExtraEncoding.ByteToChar(System.Byte[],System.String)">
            Converts a byte array to an Unicode string according to some encoding.
            @param b the input byte array
            @param encoding the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            @return the conversion or <CODE>null</CODE> if no conversion is supported
        </member>
        <member name="M:iTextSharp.text.pdf.interfaces.IPdfXConformance.IsPdfX">
            Checks if the PDF/X Conformance is necessary.
            @return true if the PDF has to be in conformance with any of the PDF/X specifications
        </member>
        <member name="P:iTextSharp.text.pdf.interfaces.IPdfXConformance.PDFXConformance">
            Sets the PDF/X conformance level.
            Allowed values are PDFX1A2001, PDFX32002, PDFA1A and PDFA1B.
            It must be called before opening the document.
            @param pdfxConformance the conformance level
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfAnnotationsImp.acroForm">
            This is the AcroForm object for the complete document.
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfAnnotationsImp.annotations">
            This is the array containing the references to annotations
            that were added to the document.
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfAnnotationsImp.delayedAnnotations">
            This is an array containg references to some delayed annotations
            (that were added for a page that doesn't exist yet).
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfAnnotationsImp.HasValidAcroForm">
            Checks if the AcroForm is valid.
        </member>
        <member name="P:iTextSharp.text.pdf.intern.PdfAnnotationsImp.AcroForm">
            Gets the AcroForm object.
            @return the PdfAcroform object of the PdfDocument
        </member>
        <member name="T:iTextSharp.text.pdf.intern.PdfVersionImp">
            Stores the PDF version information,
            knows how to write a PDF Header,
            and how to add the version to the catalog (if necessary).
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.HEADER">
            Contains different strings that are part of the header. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.headerWasWritten">
            Indicates if the header was already written. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.appendmode">
            Indicates if we are working in append mode. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.header_version">
            The version that was or will be written to the header. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.catalog_version">
            The version that will be written to the catalog. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.version">
            The version that user can use to get the actual version of PDF document *
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfVersionImp.extensions">
            The extensions dictionary.
            @since	2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.SetAtLeastPdfVersion(System.Char)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setAtLeastPdfVersion(char)
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.SetPdfVersion(iTextSharp.text.pdf.PdfName)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(com.lowagie.text.pdf.PdfName)
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.SetAppendmode(System.Boolean)">
            Sets the append mode.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.WriteHeader(iTextSharp.text.pdf.OutputStreamCounter)">
            Writes the header to the OutputStreamCounter.
            @throws IOException 
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.GetVersionAsName(System.Char)">
            Returns the PDF version as a name.
            @param version    the version character.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.GetVersionAsByteArray(System.Char)">
            Returns the version as a byte[].
            @param version the version character
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.AddToCatalog(iTextSharp.text.pdf.PdfDictionary)">
            Adds the version to the Catalog dictionary. 
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfVersionImp.AddDeveloperExtension(iTextSharp.text.pdf.PdfDeveloperExtension)">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#addDeveloperExtension(com.lowagie.text.pdf.PdfDeveloperExtension)
            @since   2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.intern.PdfVersionImp.PdfVersion">
            @see com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(char)
        </member>
        <member name="T:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp">
            Stores the information concerning viewer preferences,
            and contains the business logic that allows you to set viewer preferences.
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.viewerPreferencesMask">
            The mask to decide if a ViewerPreferences dictionary is needed 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.NONFULLSCREENPAGEMODE_PREFERENCES">
            A series of viewer preferences. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.DIRECTION_PREFERENCES">
            A series of viewer preferences. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.PAGE_BOUNDARIES">
            A series of viewer preferences. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.PRINTSCALING_PREFERENCES">
            A series of viewer preferences 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.DUPLEX_PREFERENCES">
            A series of viewer preferences. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.pageLayoutAndMode">
            This value will hold the viewer preferences for the page layout and page mode. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.viewerPreferences">
            This dictionary holds the viewer preferences (other than page layout and page mode). 
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.GetViewerPreferences">
            Returns the viewer preferences.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.GetIndex(iTextSharp.text.pdf.PdfName)">
            Given a key for a viewer preference (a PdfName object),
            this method returns the index in the VIEWER_PREFERENCES array.
            @param key    a PdfName referring to a viewer preference
            @return   an index in the VIEWER_PREFERENCES array
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.IsPossibleValue(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfName[])">
            Checks if some value is valid for a certain key.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Sets the viewer preferences for printing.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.AddToCatalog(iTextSharp.text.pdf.PdfDictionary)">
            Adds the viewer preferences defined in the preferences parameter to a
            PdfDictionary (more specifically the root or catalog of a PDF file).
            
            @param catalog
        </member>
        <member name="P:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.PageLayoutAndMode">
            Returns the page layout and page mode value.
        </member>
        <member name="P:iTextSharp.text.pdf.intern.PdfViewerPreferencesImp.ViewerPreferences">
            Sets the viewer preferences as the sum of several constants.
            
            @param preferences
                       the viewer preferences
            @see PdfWriter#setViewerPreferences
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfXConformanceImp.pdfxConformance">
            The value indicating if the PDF has to be in conformance with PDF/X.
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfXConformanceImp.IsPdfIso">
            @see com.itextpdf.text.pdf.interfaces.PdfIsoConformance#isPdfIso()
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfXConformanceImp.IsPdfX">
            Checks if the PDF/X Conformance is necessary.
            @return true if the PDF has to be in conformance with any of the PDF/X specifications
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfXConformanceImp.IsPdfX1A2001">
            Checks if the PDF has to be in conformance with PDF/X-1a:2001
            @return true of the PDF has to be in conformance with PDF/X-1a:2001
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfXConformanceImp.IsPdfX32002">
            Checks if the PDF has to be in conformance with PDF/X-3:2002
            @return true of the PDF has to be in conformance with PDF/X-3:2002
        </member>
        <member name="M:iTextSharp.text.pdf.intern.PdfXConformanceImp.CheckPdfIsoConformance(System.Int32,System.Object)">
            Business logic that checks if a certain object is in conformance with PDF/X.
            @param writer    the writer that is supposed to write the PDF/X file
            @param key       the type of PDF ISO conformance that has to be checked
            @param obj1      the object that is checked for conformance
        </member>
        <member name="P:iTextSharp.text.pdf.intern.PdfXConformanceImp.PDFXConformance">
            @see com.lowagie.text.pdf.interfaces.PdfXConformance#setPDFXConformance(int)
        </member>
        <member name="T:iTextSharp.text.pdf.IntHashtable">
            A Hashtable that uses ints as the keys.
        </member>
        <member name="F:iTextSharp.text.pdf.IntHashtable.table">
            The hash table data.
        </member>
        <member name="F:iTextSharp.text.pdf.IntHashtable.count">
            The total number of entries in the hash table.
        </member>
        <member name="F:iTextSharp.text.pdf.IntHashtable.threshold">
            Rehashes the table when count exceeds this threshold.
        </member>
        <member name="F:iTextSharp.text.pdf.IntHashtable.loadFactor">
            The load factor for the hashtable.
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.#ctor(System.Int32,System.Single)">
            Constructs a new, empty hashtable with the specified initial
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.#ctor(System.Int32)">
            Constructs a new, empty hashtable with the specified initial
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.#ctor">
            Constructs a new, empty hashtable. A default capacity and load factor
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.IsEmpty">
            Returns true if the hashtable contains no elements.
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.Contains(System.Int32)">
            Returns true if the specified object is an element of the hashtable.
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.ContainsKey(System.Int32)">
            Returns true if the collection contains an element for the key.
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.Rehash">
            Rehashes the content of the table into a bigger table.
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.Remove(System.Int32)">
            Removes the element corresponding to the key. Does nothing if the
        </member>
        <member name="M:iTextSharp.text.pdf.IntHashtable.Clear">
            Clears the hash table so that it has no more elements in it.
        </member>
        <member name="P:iTextSharp.text.pdf.IntHashtable.Size">
            Returns the number of elements contained in the hashtable.
        </member>
        <member name="P:iTextSharp.text.pdf.IntHashtable.Item(System.Int32)">
            Gets the object associated with the specified key in the
        </member>
        <member name="T:iTextSharp.text.pdf.IPdfOCG">
             The interface common to all layer types.
            
             @author Paulo Soares
        </member>
        <member name="P:iTextSharp.text.pdf.IPdfOCG.Ref">
            Gets the <CODE>PdfIndirectReference</CODE> that represents this layer.
            @return the <CODE>PdfIndirectReference</CODE> that represents this layer
        </member>
        <member name="P:iTextSharp.text.pdf.IPdfOCG.PdfObject">
            Gets the object representing the layer.
            @return the object representing the layer
        </member>
        <member name="T:iTextSharp.text.pdf.LZWDecoder">
             A class for performing LZW decoding.
            
            
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.Decode(System.Byte[],System.IO.Stream)">
             Method to decode LZW compressed data.
            
             @param data            The compressed data.
             @param uncompData      Array to return the uncompressed data in.
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.InitializeStringTable">
            Initialize the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.WriteString(System.Byte[])">
            Write out the string just uncompressed.
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.AddStringToTable(System.Byte[],System.Byte)">
            Add a new string to the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.AddStringToTable(System.Byte[])">
            Add a new string to the string table.
        </member>
        <member name="M:iTextSharp.text.pdf.LZWDecoder.ComposeString(System.Byte[],System.Byte)">
            Append <code>newstring</code> to the end of <code>oldstring</code>.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.ContentByteUtils">
            @author kevin
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ContentByteUtils.GetContentBytesFromContentObject(iTextSharp.text.pdf.PdfObject)">
            Gets the content bytes from a content object, which may be a reference
            a stream or an array.
            @param contentObject the object to read bytes from
            @return the content bytes
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ContentByteUtils.GetContentBytesForPage(iTextSharp.text.pdf.PdfReader,System.Int32)">
            Gets the content bytes of a page from a reader
            @param reader  the reader to get content bytes from
            @param pageNum   the page number of page you want get the content stream from
            @return  a byte array with the effective content stream of a page
            @throws IOException
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.FilteredRenderListener">
            A text render listener that filters text operations before passing them on to a deleg
            @since 5.0.1
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.parser.IRenderListener" -->
        <member name="M:iTextSharp.text.pdf.parser.IRenderListener.BeginTextBlock">
            Called when a new text block is beginning (i.e. BT)
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IRenderListener.RenderText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            Called when text should be rendered
            @param renderInfo information specifying what to render
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IRenderListener.EndTextBlock">
            Called when a text block has ended (i.e. ET)
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IRenderListener.RenderImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            Called when image should be rendered
            @param renderInfo information specifying what to render
            @since iText 5.0.1
        </member>
        <member name="F:iTextSharp.text.pdf.parser.FilteredRenderListener.deleg">
            The deleg that will receive the text render operation if the filters all pass 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.FilteredRenderListener.filters">
            The filters to be applied 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredRenderListener.#ctor(iTextSharp.text.pdf.parser.IRenderListener,iTextSharp.text.pdf.parser.RenderFilter[])">
            Construction
            @param deleg the deleg {@link RenderListener} that will receive filtered text operations
            @param filters the Filter(s) to apply
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredRenderListener.RenderText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            Applies filters, then delegates to the deleg if all filters pass
            @param renderInfo contains info to render text
            @see com.itextpdf.text.pdf.parser.RenderListener#renderText(com.itextpdf.text.pdf.parser.TextRenderInfo)
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredRenderListener.BeginTextBlock">
            This class delegates this call
            @see com.itextpdf.text.pdf.parser.RenderListener#beginTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredRenderListener.EndTextBlock">
            This class delegates this call
            @see com.itextpdf.text.pdf.parser.RenderListener#endTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredRenderListener.RenderImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            Applies filters, then delegates to the deleg if all filters pass
            @see com.itextpdf.text.pdf.parser.RenderListener#renderImage(com.itextpdf.text.pdf.parser.ImageRenderInfo)
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.FilteredTextRenderListener">
            A text render listener that filters text operations before passing them on to a deleg
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.ITextExtractionStrategy">
            Defines an interface for {@link RenderListener}s that can return text
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ITextExtractionStrategy.GetResultantText">
            Returns the result so far.
            @return  a String with the resulting text.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.FilteredTextRenderListener.deleg">
            The deleg that will receive the text render operation if the filters all pass 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredTextRenderListener.#ctor(iTextSharp.text.pdf.parser.ITextExtractionStrategy,iTextSharp.text.pdf.parser.RenderFilter[])">
            Construction
            @param deleg the deleg {@link RenderListener} that will receive filtered text operations
            @param filters the Filter(s) to apply
        </member>
        <member name="M:iTextSharp.text.pdf.parser.FilteredTextRenderListener.GetResultantText">
            This class delegates this call
            @see com.itextpdf.text.pdf.parser.TextExtractionStrategy#getResultantText()
        </member>
        <member name="T:iTextSharp.text.pdf.parser.GraphicsState">
            Keeps all the parameters of the graphics state.
            @since   2.1.4
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.ctm">
            The current transformation matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.characterSpacing">
            The current character spacing. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.wordSpacing">
            The current word spacing. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.horizontalScaling">
            The current horizontal scaling 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.leading">
            The current leading. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.font">
            The active font. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.fontSize">
            The current font size. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.renderMode">
            The current render mode. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.rise">
            The current text rise 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.knockout">
            The current knockout value. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.colorSpaceFill">
            The current color space for stroke. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.colorSpaceStroke">
            The current color space for stroke. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.fillColor">
            The current fill color. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.strokeColor">
            The current stroke color. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.lineWidth">
            The line width for stroking operations 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.lineCapStyle">
            The line cap style. For possible values
            see {@link PdfContentByte}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.lineJoinStyle">
            The line join style. For possible values
            see {@link PdfContentByte}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.miterLimit">
            The mitir limit value 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.GraphicsState.lineDashPattern">
            The line dash pattern 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.#ctor">
            Constructs a new Graphics State object with the default values.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.#ctor(iTextSharp.text.pdf.parser.GraphicsState)">
            Copy constructor.
            @param source    another GraphicsState object
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetCtm">
            Getter for the current transformation matrix
            @return the ctm
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetCharacterSpacing">
            Getter for the character spacing.
            @return the character spacing
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetWordSpacing">
            Getter for the word spacing
            @return the word spacing
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetHorizontalScaling">
            Getter for the horizontal scaling
            @return the horizontal scaling
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetLeading">
            Getter for the leading
            @return the leading
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetFont">
            Getter for the font
            @return the font
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetFontSize">
            Getter for the font size
            @return the font size
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetRenderMode">
            Getter for the render mode
            @return the renderMode
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetRise">
            Getter for text rise
            @return the text rise
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.IsKnockout">
            Getter for knockout
            @return the knockout
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.GetLineDashPattern">
            Getter for the line dash pattern.
            @return The line dash pattern.
            @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.GraphicsState.SetLineDashPattern(iTextSharp.text.pdf.parser.LineDashPattern)">
            Setter for the line dash pattern.
            @param lineDashPattern New line dash pattern.
            @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.ColorSpaceFill">
            Gets the current color space for fill operations
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.ColorSpaceStroke">
            Gets the current color space for stroke operations
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.FillColor">
            Gets the current fill color
            @return a BaseColor
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.StrokeColor">
            Gets the current stroke color
            @return a BaseColor
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.LineWidth">
            Getter  and setter for the line width.
            @return The line width
            @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.LineCapStyle">
            Getter and setter for the line cap style.
            For possible values see {@link PdfContentByte}
            @return The line cap style.
            @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.LineJoinStyle">
            Getter and setter for the line join style.
            For possible values see {@link PdfContentByte}
            @return The line join style.
            @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.parser.GraphicsState.MiterLimit">
            Getter and setter for the miter limit value.
            @return The miter limit.
            @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.IContentOperator">
            Interface implemented by a series of content operators
            @since 2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IContentOperator.Invoke(iTextSharp.text.pdf.parser.PdfContentStreamProcessor,iTextSharp.text.pdf.PdfLiteral,System.Collections.Generic.List{iTextSharp.text.pdf.PdfObject})">
            Invokes a content operator.
            @param processor the processor that is dealing with the PDF content
            @param operator  the literal PDF syntax of the operator
            @param operands  the operands that come with the operator
            @throws Exception any exception can be thrown - it will be re-packaged into a runtime exception and re-thrown by the {@link PdfContentStreamProcessor}
        </member>
        <member name="T:iTextSharp.text.pdf.parser.ImageRenderInfo">
            Represents image data from a PDF
            @since 5.0.1
        </member>
        <member name="F:iTextSharp.text.pdf.parser.ImageRenderInfo.gs">
            The graphics state that was in effect when the image was rendered 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.ImageRenderInfo.refi">
            A reference to the image XObject 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.ImageRenderInfo.inlineImageInfo">
            A reference to an inline image 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.ImageRenderInfo.colorSpaceDictionary">
            the color space associated with the image 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.ImageRenderInfo.imageObject">
            the image object to be rendered, if it has been parsed already.  Null otherwise. 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.CreateForXObject(iTextSharp.text.pdf.parser.GraphicsState,iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfDictionary)">
            Create an ImageRenderInfo object based on an XObject (this is the most common way of including an image in PDF)
            @param ctm the coordinate transformation matrix at the time the image is rendered
            @param ref a reference to the image XObject
            @return the ImageRenderInfo representing the rendered XObject
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.CreateForEmbeddedImage(iTextSharp.text.pdf.parser.GraphicsState,iTextSharp.text.pdf.parser.InlineImageInfo,iTextSharp.text.pdf.PdfDictionary)">
            Create an ImageRenderInfo object based on inline image data.  This is nowhere near completely thought through
            and really just acts as a placeholder.
            @param ctm the coordinate transformation matrix at the time the image is rendered
            @param imageObject the image object representing the inline image
            @return the ImageRenderInfo representing the rendered embedded image
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetImage">
            Gets an object containing the image dictionary and bytes.
            @return an object containing the image dictionary and byte[]
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetStartPoint">
            @return a vector in User space representing the start point of the xobject
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetImageCTM">
            @return The coordinate transformation matrix active when this image was rendered.  Coordinates are in User space.
            @since 5.0.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetArea">
            @return the size of the image, in User space units
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetRef">
            @return an indirect reference to the image
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.ImageRenderInfo.GetCurrentFillColor">
            @return the current fill color from the graphics state at the time this render operation occured
            @since 5.5.7
        </member>
        <member name="T:iTextSharp.text.pdf.parser.LineSegment">
            Represents a line segment in a particular coordinate system.  This class is immutable.
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LineSegment.startPoint">
            Start vector of the segment. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LineSegment.endPoint">
            End vector of the segment. 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.#ctor(iTextSharp.text.pdf.parser.Vector,iTextSharp.text.pdf.parser.Vector)">
            Creates a new line segment.
            @param startPoint the start point of a line segment.
            @param endPoint the end point of a line segment.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.GetStartPoint">
            @return the start point
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.GetEndPoint">
            @return the end point
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.GetLength">
            @return the length of this line segment
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.GetBoundingRectange">
            Computes the bounding rectangle for this line segment.  The rectangle has a rotation 0 degrees
            with respect to the coordinate system that the line system is in.  For example, if a line segment
            is 5 unit long and sits at a 37 degree angle from horizontal, the bounding rectangle will have
            origin of the lower left hand end point of the segment, with width = 4 and height = 3. 
            @return the bounding rectangle
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineSegment.TransformBy(iTextSharp.text.pdf.parser.Matrix)">
            Transforms the segment by the specified matrix
            @param m the matrix for the transformation
            @return the transformed segment
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy" -->
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.DUMP_STATE">
            set to true for debugging 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.locationalResult">
            a summary of all found text 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.#ctor">
            Creates a new text extraction renderer.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.BeginTextBlock">
            @see com.itextpdf.text.pdf.parser.RenderListener#beginTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.EndTextBlock">
            @see com.itextpdf.text.pdf.parser.RenderListener#endTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.StartsWithSpace(System.String)">
            @param str
            @return true if the string starts with a space character, false if the string is empty or starts with a non-space character
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.EndsWithSpace(System.String)">
            @param str
            @return true if the string ends with a space character, false if the string is empty or ends with a non-space character
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk,iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)">
            Determines if a space character should be inserted between a previous chunk and the current chunk.
            This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.
            By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the
            previous chunk and the beginning of the current chunk.  It will also indicate that a space is needed if the starting point of the new chunk 
            appears *before* the end of the previous chunk (i.e. overlapping text).
            @param chunk the new chunk being evaluated
            @param previousChunk the chunk that appeared immediately before the current chunk
            @return true if the two chunks represent different words (i.e. should have a space between them).  False otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.filterTextChunks(System.Collections.Generic.List{iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk},iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.ITextChunkFilter)">
            Filters the provided list with the provided filter
            @param textChunks a list of all TextChunks that this strategy found during processing
            @param filter the filter to apply.  If null, filtering will be skipped.
            @return the filtered list
            @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.GetResultantText(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.ITextChunkFilter)">
            Gets text that meets the specified filter
            If multiple text extractions will be performed for the same page (i.e. for different physical regions of the page), 
            filtering at this level is more efficient than filtering using {@link FilteredRenderListener} - but not nearly as powerful
            because most of the RenderInfo state is not captured in {@link TextChunk}
            @param chunkFilter the filter to to apply
            @return the text results so far, filtered using the specified filter
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.GetResultantText">
            Returns the result so far.
            @return  a String with the resulting text.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.DumpState">
            Used for debugging only 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.RenderText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            
            @see com.itextpdf.text.pdf.parser.RenderListener#renderText(com.itextpdf.text.pdf.parser.TextRenderInfo)
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.RenderImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            no-op method - this renderer isn't interested in image events
            @see com.itextpdf.text.pdf.parser.RenderListener#renderImage(com.itextpdf.text.pdf.parser.ImageRenderInfo)
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk">
            Represents a chunk of text, it's orientation, and location relative to the orientation vector
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.text">
            the text of the chunk 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.startLocation">
            the starting location of the chunk 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.endLocation">
            the ending location of the chunk 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.orientationVector">
            unit vector in the orientation of the chunk 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.orientationMagnitude">
            the orientation as a scalar for quick sorting 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.distPerpendicular">
            perpendicular distance to the orientation unit vector (i.e. the Y position in an unrotated coordinate system)
            we round to the nearest integer to handle the fuzziness of comparing floats 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.distParallelStart">
            distance of the start of the chunk parallel to the orientation unit vector (i.e. the X position in an unrotated coordinate system) 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.distParallelEnd">
            distance of the end of the chunk parallel to the orientation unit vector (i.e. the X position in an unrotated coordinate system) 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.charSpaceWidth">
            the width of a single space character in the font of the chunk 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.SameLine(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)">
            @param as the location to compare to
            @return true is this location is on the the same line as the other
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.DistanceFromEndOf(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)">
            Computes the distance between the end of 'other' and the beginning of this chunk
            in the direction of this chunk's orientation vector.  Note that it's a bad idea
            to call this for chunks that aren't on the same line and orientation, but we don't
            explicitly check for that condition for performance reasons.
            @param other
            @return the number of spaces between the end of 'other' and the beginning of this chunk
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.CompareTo(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)">
            Compares based on orientation, perpendicular distance, then parallel distance
            @see java.lang.Comparable#compareTo(java.lang.Object)
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.CompareInts(System.Int32,System.Int32)">
            
             @param int1
             @param int2
             @return comparison of the two integers
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.Text">
            @return the text captured by this chunk
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.CharSpaceWidth">
            @return the width of a single space character as rendered by this chunk
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.StartLocation">
            @return the start location of the text
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk.EndLocation">
            @return the end location of the text
        </member>
        <member name="T:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.ITextChunkFilter">
            Specifies a filter for filtering {@link TextChunk} objects during text extraction 
            @see LocationTextExtractionStrategy#getResultantText(TextChunkFilter)
            @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.ITextChunkFilter.Accept(iTextSharp.text.pdf.parser.LocationTextExtractionStrategy.TextChunk)">
            @param textChunk the chunk to check
            @return true if the chunk should be allowed
        </member>
        <member name="T:iTextSharp.text.pdf.parser.MarkedContentInfo">
            Represents a Marked Content block in a PDF
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MarkedContentInfo.GetTag">
            Get the tag of this marked content
            @return the tag of this marked content
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MarkedContentInfo.HasMcid">
            Determine if an MCID is available
            @return true if the MCID is available, false otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MarkedContentInfo.GetMcid">
            Gets the MCID value  If the Marked Content contains
            an MCID entry, returns that value.  Otherwise, a {@link NullPointerException} is thrown.
            @return the MCID value
            @throws NullPointerException if there is no MCID (see {@link MarkedContentInfo#hasMcid()})
        </member>
        <member name="T:iTextSharp.text.pdf.parser.MarkedContentRenderFilter">
            A {@link RenderFilter} that only allows text within a specified marked content sequence.
            @since 5.0.2
        </member>
        <member name="T:iTextSharp.text.pdf.parser.RenderFilter">
            Interface for defining filters for use with {@link FilteredRenderListener}
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.RenderFilter.AllowText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            @param renderInfo
            @return true if the text render operation should be performed
        </member>
        <member name="M:iTextSharp.text.pdf.parser.RenderFilter.AllowImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            
            @param renderInfo
            @return true if the image render operation should be performed
        </member>
        <member name="F:iTextSharp.text.pdf.parser.MarkedContentRenderFilter.mcid">
            The MCID to match. 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MarkedContentRenderFilter.#ctor(System.Int32)">
            Constructs a filter
            @param mcid the MCID to match
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MarkedContentRenderFilter.AllowText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            @see com.itextpdf.text.pdf.parser.RenderFilter#allowText(com.itextpdf.text.pdf.parser.TextRenderInfo)
        </member>
        <member name="T:iTextSharp.text.pdf.parser.Matrix">
            Keeps all the values of a 3 by 3 matrix
            and allows you to do some math with matrices.
            @since   2.1.4
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I11">
            the row=1, col=1 position ('a') in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I12">
            the row=1, col=2 position ('b') in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I13">
            the row=1, col=3 position (always 0 for 2-D) in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I21">
            the row=2, col=1 position ('c') in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I22">
            the row=2, col=2 position ('d') in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I23">
            the row=2, col=3 position (always 0 for 2-D) in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I31">
            the row=3, col=1 ('e', or X translation) position in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I32">
            the row=3, col=2 ('f', or Y translation) position in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.I33">
            the row=3, col=3 position (always 1 for 2-D) in the matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Matrix.vals">
            the values inside the matrix (the identity matrix by default).
            default initialization is performed in the default constructor.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.#ctor">
            constructs a new Matrix with identity.
            !shall be called from any other constructor!
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.#ctor(System.Single,System.Single)">
            Constructs a matrix that represents translation
            @param tx
            @param ty
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Creates a Matrix with 6 specified entries
            @param a
            @param b
            @param c
            @param d
            @param e
            @param f
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.Multiply(iTextSharp.text.pdf.parser.Matrix)">
            multiplies this matrix by 'b' and returns the result
            See http://en.wikipedia.org/wiki/Matrix_multiplication
            @param by The matrix to multiply by
            @return  the resulting matrix
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.Subtract(iTextSharp.text.pdf.parser.Matrix)">
            Subtracts a matrix from this matrix and returns the results
            @param arg the matrix to subtract from this matrix
            @return a Matrix object
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.GetDeterminant">
            Computes the determinant of the matrix.
            @return the determinant of the matrix
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.Equals(System.Object)">
            Checks equality of matrices.
            @param obj   the other Matrix that needs to be compared with this matrix.
            @return  true if both matrices are equal
            @see java.lang.Object#equals(java.lang.Object)
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.GetHashCode">
            Generates a hash code for this object.
            @return  the hash code of this object
            @see java.lang.Object#hashCode()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Matrix.ToString">
            Generates a String representation of the matrix.
            @return  the values, delimited with tabs and newlines.
            @see java.lang.Object#toString()
        </member>
        <member name="P:iTextSharp.text.pdf.parser.Matrix.Item(System.Int32)">
            Gets a specific value inside the matrix.
            @param   index   an array index corresponding with a value inside the matrix
            @return  the value at that specific position.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentReaderTool">
            Tool that parses the content of a PDF document.
            @since   2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.GetDictionaryDetail(iTextSharp.text.pdf.PdfDictionary)">
            Shows the detail of a dictionary.
            This is similar to the PdfLister functionality.
            @param dic   the dictionary of which you want the detail
            @return  a String representation of the dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.GetDictionaryDetail(iTextSharp.text.pdf.PdfDictionary,System.Int32)">
            Shows the detail of a dictionary.
            @param dic   the dictionary of which you want the detail
            @param depth the depth of the current dictionary (for nested dictionaries)
            @return  a String representation of the dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.GetXObjectDetail(iTextSharp.text.pdf.PdfDictionary)">
            Displays a summary of the entries in the XObject dictionary for the stream
            @param resourceDic the resource dictionary for the stream
            @return a string with the summary of the entries
            @throws IOException
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.ListContentStreamForPage(iTextSharp.text.pdf.PdfReader,System.Int32,System.IO.TextWriter)">
            Writes information about a specific page from PdfReader to the specified output stream.
            @since 2.1.5
            @param reader    the PdfReader to read the page content from
            @param pageNum   the page number to read
            @param out       the output stream to send the content to
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.ListContentStream(System.String,System.IO.TextWriter)">
            Writes information about each page in a PDF file to the specified output stream.
            @since 2.1.5
            @param pdfFile   a File instance referring to a PDF file
            @param out       the output stream to send the content to
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.ListContentStream(System.String,System.Int32,System.IO.TextWriter)">
            Writes information about the specified page in a PDF file to the specified output stream.
            @since 2.1.5
            @param pdfFile   a File instance referring to a PDF file
            @param pageNum   the page number to read
            @param out       the output stream to send the content to
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentReaderTool.Main(System.String[])">
            Writes information about each page in a PDF file to the specified file, or System.out.
            @param args
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor">
            Processor for a PDF content Stream.
            @since   2.1.4
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.DEFAULTOPERATOR">
            Default oper
            @since 5.0.1
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.operators">
            A map with all supported operators (PDF syntax). 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.resources">
            Resources for the content stream. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.gsStack">
            Stack keeping track of the graphics state. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.textMatrix">
            Text matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.textLineMatrix">
            Text line matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.renderListener">
            Listener that will be notified of render events 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.xobjectDoHandlers">
            A map with all supported XObject handlers 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.cachedFonts">
            The font cache.
            @since 5.0.6
             
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.markedContentStack">
            A stack containing marked content info.
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.#ctor(iTextSharp.text.pdf.parser.IRenderListener)">
             Creates a new PDF Content Stream Processor that will send it's output to the
             designated render listener.
            
             @param renderListener the {@link RenderListener} that will receive rendering notifications
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.RegisterXObjectDoHandler(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.parser.IXObjectDoHandler)" -->
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.GetFont(iTextSharp.text.pdf.PRIndirectReference)">
            Gets the font pointed to by the indirect reference. The font may have been cached.
            @param ind the indirect reference ponting to the font
            @return the font
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PopulateOperators">
            Loads all the supported graphics and text state operators in a map.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.RegisterContentOperator(System.String,iTextSharp.text.pdf.parser.IContentOperator)" -->
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.Reset">
            Resets the graphics state stack, matrices and resources.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.Gs">
            Returns the current graphics state.
            @return  the graphics state
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.InvokeOperator(iTextSharp.text.pdf.PdfLiteral,System.Collections.Generic.List{iTextSharp.text.pdf.PdfObject})">
            Invokes an oper.
            @param oper  the PDF Syntax of the oper
            @param operands  a list with operands
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.BeginMarkedContent(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfDictionary)">
            Add to the marked content stack
            @param tag the tag of the marked content
            @param dict the PdfDictionary associated with the marked content
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.EndMarkedContent">
            Remove the latest marked content from the stack.  Keeps track of the BMC, BDC and EMC operators.
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.BeginText">
            Used to trigger beginTextBlock on the renderListener
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.EndText">
            Used to trigger endTextBlock on the renderListener
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.DisplayPdfString(iTextSharp.text.pdf.PdfString)">
            Displays text.
            @param string    the text to display
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.DisplayXObject(iTextSharp.text.pdf.PdfName)">
            Displays an XObject using the registered handler for this XObject's subtype
            @param xobjectName the name of the XObject to retrieve from the resource dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PaintPath(System.Int32,System.Int32,System.Boolean)">
             Displays the current path.
            
             @param operation One of the possible combinations of {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#STROKE}
                              and {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#FILL} values or
                              {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#NO_OP}
             @param rule      Either {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#NONZERO_WINDING_RULE} or
                              {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#EVEN_ODD_RULE}
                              In case it isn't applicable pass any <CODE>int</CODE> value.
             @param close     Indicates whether the path should be closed or not.
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ModifyPath(System.Int32,System.Collections.Generic.IList{System.Single})">
             Modifies the current path.
            
             @param operation   Indicates which path-construction operation should be performed.
             @param segmentData Contains x, y components of points of a new segment being added to the current path.
                                E.g. x1 y1 x2 y2 x3 y3 etc. It's ignored for "close subpath" operarion (h).
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ApplyTextAdjust(System.Single)">
            Adjusts the text matrix for the specified adjustment value (see TJ oper in the PDF spec for information)
            @param tj the text adjustment
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ProcessContent(System.Byte[],iTextSharp.text.pdf.PdfDictionary)">
            Processes PDF syntax.
            <b>Note:</b> If you re-use a given {@link PdfContentStreamProcessor}, you must call {@link PdfContentStreamProcessor#reset()}
            @param contentBytes  the bytes of a content stream
            @param resources     the resources that come with the content stream
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.HandleInlineImage(iTextSharp.text.pdf.parser.InlineImageInfo,iTextSharp.text.pdf.PdfDictionary)">
            Callback when an inline image is found.  This requires special handling because inline images don't follow the standard operator syntax
            @param info the inline image
            @param colorSpaceDic the color space for the inline immage
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.GetColor(iTextSharp.text.pdf.PdfName,System.Collections.Generic.List{iTextSharp.text.pdf.PdfObject})">
            Gets a color based on a list of operands.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.GetColor(System.Int32,System.Collections.Generic.List{iTextSharp.text.pdf.PdfObject})">
            Gets a color based on a list of operands.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.RegisteredOperatorStrings">
            @return {@link java.util.Collection} containing all the registered operators strings
            @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ResourceDictionary">
            A resource dictionary that allows stack-like behavior to support resource dictionary inheritance
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.IgnoreOperatorContentOperator">
            A content oper implementation (unregistered).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ShowTextArray">
            A content oper implementation (TJ).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.MoveNextLineAndShowTextWithSpacing">
            A content oper implementation (").
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.MoveNextLineAndShowText">
            A content oper implementation (').
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ShowText">
            A content oper implementation (Tj).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.TextMoveNextLine">
            A content oper implementation (T*).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.TextSetTextMatrix">
            A content oper implementation (Tm).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.TextMoveStartNextLineWithLeading">
            A content oper implementation (TD).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.TextMoveStartNextLine">
            A content oper implementation (Td).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextFont">
            A content oper implementation (Tf).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextRenderMode">
            A content oper implementation (Tr).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextRise">
            A content oper implementation (Ts).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextLeading">
            A content oper implementation (TL).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextHorizontalScaling">
            A content oper implementation (Tz).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextCharacterSpacing">
            A content oper implementation (Tc).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetTextWordSpacing">
            A content oper implementation (Tw).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ProcessGraphicsStateResource">
            A content oper implementation (gs).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PushGraphicsState">
            A content oper implementation (q).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ModifyCurrentTransformationMatrix">
            A content oper implementation (cm).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetGrayFill">
            A content operator implementation (g).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetGrayStroke">
            A content operator implementation (G).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetRGBFill">
            A content operator implementation (rg).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetRGBStroke">
            A content operator implementation (RG).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetCMYKFill">
            A content operator implementation (rg).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetCMYKStroke">
            A content operator implementation (RG).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetColorSpaceFill">
            A content operator implementation (cs).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetColorSpaceStroke">
            A content operator implementation (CS).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetColorFill">
            A content operator implementation (sc / scn).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetColorStroke">
            A content operator implementation (SC / SCN).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PopGraphicsState">
            A content oper implementation (Q).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.BeginTextC">
            A content oper implementation (BT).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.EndTextC">
            A content oper implementation (ET).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.BeginMarkedContentC">
            A content oper implementation (BMC).
            @since 5.0.2
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.BeginMarkedContentDictionary">
            A content oper implementation (BDC).
            @since 5.0.2
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.EndMarkedContentC">
            A content oper implementation (EMC).
            @since 5.0.2
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.Do">
            A content oper implementation (Do).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetLineWidth">
            A content operator implementation (w).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetLineCap">
            A content operator implementation (J).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetLineJoin">
            A content operator implementation (j).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetMiterLimit">
            A content operator implementation (M).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.SetLineDashPattern">
            A content operator implementation (d).
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.MoveTo">
             A content operator implementation (m).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.LineTo">
             A content operator implementation (l).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.Curve">
             A content operator implementation (c).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.CurveFirstPointDuplicated">
             A content operator implementation (v).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.CurveFourhPointDuplicated">
             A content operator implementation (y).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.CloseSubpath">
             A content operator implementation (h).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.Rectangle">
             A content operator implementation (re).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PaintPathOp">
             A content operator implementation (S, s, f, F, f*, B, B*, b, b*).
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.PaintPathOp.#ctor(System.Int32,System.Int32,System.Boolean)">
             Constructs PainPath object.
            
             @param operation One of the possible combinations of {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#STROKE}
                              and {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#FILL} values or
                              {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#NO_OP}
             @param rule      Either {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#NONZERO_WINDING_RULE} or
                              {@link com.itextpdf.text.pdf.parser.PathPaintingRenderInfo#EVEN_ODD_RULE}
                              In case it isn't applicable pass any value.
             @param close     Indicates whether the path should be closed or not.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.EndPath">
             A content operator implementation (n).
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.FormXObjectDoHandler">
            An XObject subtype handler for FORM
        </member>
        <member name="T:iTextSharp.text.pdf.parser.IXObjectDoHandler">
            @author Kevin Day
            @since iText 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.ImageXObjectDoHandler">
            An XObject subtype handler for IMAGE
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfContentStreamProcessor.IgnoreXObjectDoHandler">
            An XObject subtype handler that does nothing
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfImageObject">
            An object that contains an image dictionary and image bytes.
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfImageObject.dictionary">
            The image dictionary. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfImageObject.imageBytes">
            The decoded image bytes (after applying filters), or the raw image bytes if unable to decode 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfImageObject.streamContentType">
            Tracks the type of data that is actually stored in the streamBytes member
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.GetImageBytesType">
            @return the type of image data that is returned by getImageBytes()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.#ctor(iTextSharp.text.pdf.PRStream)">
            Creates a PdfImage object.
            @param stream a PRStream
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.#ctor(iTextSharp.text.pdf.PRStream,iTextSharp.text.pdf.PdfDictionary)">
            Creates a PdfImage object.
            @param stream a PRStream
            @param colorSpaceDic a color space dictionary
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.#ctor(iTextSharp.text.pdf.PdfDictionary,System.Byte[],iTextSharp.text.pdf.PdfDictionary)">
            Creats a PdfImage object using an explicitly provided dictionary and image bytes
            @param dictionary the dictionary for the image
            @param samples the samples
            @since 5.0.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.Get(iTextSharp.text.pdf.PdfName)">
            Returns an entry from the image dictionary.
            @param key a key
            @return the value
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.GetDictionary">
            Returns the image dictionary.
            @return the dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.FindColorspace(iTextSharp.text.pdf.PdfObject,System.Boolean)">
            Sets state of this object according to the color space 
            @param colorspace the colorspace to use
            @param allowIndexed whether indexed color spaces will be resolved (used for recursive call)
            @throws IOException if there is a problem with reading from the underlying stream  
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.DecodeImageBytes">
            decodes the bytes currently captured in the streamBytes and replaces it with an image representation of the bytes
            (this will either be a png or a tiff, depending on the color depth of the image)
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.GetImageAsBytes">
            @return the bytes of the image (the format will be as specified in {@link PdfImageObject#getImageBytesType()}
            @throws IOException
            @since 5.0.4
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfImageObject.ImageBytesType">
            Different types of data that can be stored in the bytes of a {@link PdfImageObject}
            @since 5.0.4
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfImageObject.ImageBytesType.fileExtension">
            the recommended file extension for streams of this type
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfImageObject.ImageBytesType.#ctor(System.String)">
            @param fileExtension the recommended file extension for use with data of this type (for example, if the bytes were just saved to a file, what extension should the file have)
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PdfImageObject.ImageBytesType.FileExtension">
            @return the file extension registered when this type was created
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfImageObject.TrackingFilter">
            A filter that does nothing, but keeps track of the filter type that was used
            @since 5.0.4 
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.IFilterHandler">
            The main interface for creating a new {@link IFilterHandler}
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers">
            Encapsulates filter behavior for PDF streams.  Classes generally interace with this
            using the static GetDefaultFilterHandlers() method, then obtain the desired {@link IFilterHandler}
            via a lookup.
            @since 5.0.4
        </member>
        <member name="F:iTextSharp.text.pdf.FilterHandlers.defaults">
            The default {@link IFilterHandler}s used by iText 
        </member>
        <member name="M:iTextSharp.text.pdf.FilterHandlers.GetDefaultFilterHandlers">
            @return the default {@link IFilterHandler}s used by iText
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.IFilterHandler">
            The main interface for creating a new {@link IFilterHandler}
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_FLATEDECODE">
            Handles FLATEDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_ASCIIHEXDECODE">
            Handles ASCIIHEXDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_ASCII85DECODE">
            Handles ASCIIHEXDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_LZWDECODE">
            Handles LZWDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_CCITTFAXDECODE">
            Handles CCITTFAXDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_DoNothing">
            A filter that doesn't modify the stream at all
        </member>
        <member name="T:iTextSharp.text.pdf.FilterHandlers.Filter_RUNLENGTHDECODE">
            Handles RUNLENGTHDECODE filter
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PdfReaderContentParser">
            A utility class that makes it cleaner to process content from pages of a PdfReader
            through a specified RenderListener.
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PdfReaderContentParser.reader">
            the reader this parser will process 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.parser.PdfReaderContentParser.ProcessContent``1(System.Int32,``0)" -->
        <member name="T:iTextSharp.text.pdf.parser.PdfTextExtractor">
            Extracts text from a PDF file.
            @since   2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PdfTextExtractor.GetTextFromPage(iTextSharp.text.pdf.PdfReader,System.Int32,iTextSharp.text.pdf.parser.ITextExtractionStrategy)">
            Extract text from a specified page using an extraction strategy.
            @param reader the reader to extract text from
            @param pageNumber the page to extract text from
            @param strategy the strategy to use for extracting text
            @return the extracted text
            @throws IOException if any operation fails while reading from the provided PdfReader
            @since 5.0.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.parser.PdfTextExtractor.GetTextFromPage(iTextSharp.text.pdf.PdfReader,System.Int32)" -->
        <member name="T:iTextSharp.text.pdf.parser.RegionTextRenderFilter">
            A {@link RenderFilter} that only allows text within a specified rectangular region
            @since 5.0.1
        </member>
        <member name="F:iTextSharp.text.pdf.parser.RegionTextRenderFilter.filterRect">
            the region to allow text from 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.RegionTextRenderFilter.#ctor(System.util.RectangleJ)">
            Constructs a filter
            @param filterRect the rectangle to filter text against.  Note that this is a java.awt.Rectangle !
        </member>
        <member name="M:iTextSharp.text.pdf.parser.RegionTextRenderFilter.#ctor(iTextSharp.text.Rectangle)">
            Constructs a filter
            @param filterRect the rectangle to filter text against.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.RegionTextRenderFilter.AllowText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            @see com.itextpdf.text.pdf.parser.RenderFilter#allowText(com.itextpdf.text.pdf.parser.TextRenderInfo)
        </member>
        <member name="T:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy">
            A simple text extraction renderer.
            
            This renderer keeps track of the current Y position of each string.  If it detects
            that the y position has changed, it inserts a line break into the output.  If the
            PDF renders text in a non-top-to-bottom fashion, this will result in the text not
            being a true representation of how it appears in the PDF.
            
            This renderer also uses a simple strategy based on the font metrics to determine if
            a blank space should be inserted into the output.
            
            @since   2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.result">
            used to store the resulting String. 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.#ctor">
            Creates a new text extraction renderer.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.BeginTextBlock">
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.EndTextBlock">
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.GetResultantText">
            Returns the result so far.
            @return  a String with the resulting text.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.AppendTextChunk(System.String)">
            Used to actually append text to the text results.  Subclasses can use this to insert
            text that wouldn't normally be included in text parsing (e.g. result of OCR performed against
            image content)
            @param text the text to append to the text results accumulated so far
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.RenderText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            Captures text using a simplified algorithm for inserting hard returns and spaces
            @param   renderInfo  render info
        </member>
        <member name="M:iTextSharp.text.pdf.parser.SimpleTextExtractionStrategy.RenderImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            no-op method - this renderer isn't interested in image events
            @see com.itextpdf.text.pdf.parser.RenderListener#renderImage(com.itextpdf.text.pdf.parser.ImageRenderInfo)
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.parser.TaggedPdfReaderTool">
            Converts a tagged PDF document into an XML file.
            
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.reader">
            The reader obj from which the content streams are read. 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.outp">
            The writer obj to which the XML will be written 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.ConvertToXml(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Text.Encoding)">
            Parses a string with structured content.
            
            @param reader
                       the PdfReader that has access to the PDF file
            @param os
                       the Stream to which the resulting xml will be written
            @param charset
                       the charset to encode the data
            @since 5.0.5
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.ConvertToXml(iTextSharp.text.pdf.PdfReader,System.IO.Stream)">
            Parses a string with structured content.
            
            @param reader
                       the PdfReader that has access to the PDF file
            @param os
                       the Stream to which the resulting xml will be written
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.InspectChild(iTextSharp.text.pdf.PdfObject)">
            Inspects a child of a structured element. This can be an array or a
            dictionary.
            
            @param k
                       the child to inspect
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.InspectChildArray(iTextSharp.text.pdf.PdfArray)">
            If the child of a structured element is an array, we need to loop over
            the elements.
            
            @param k
                       the child array to inspect
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.InspectChildDictionary(iTextSharp.text.pdf.PdfDictionary)">
             If the child of a structured element is a dictionary, we inspect the
             child; we may also draw a tag.
            
             @param k
                        the child dictionary to inspect
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.InspectChildDictionary(iTextSharp.text.pdf.PdfDictionary,System.Boolean)">
            If the child of a structured element is a dictionary, we inspect the
            child; we may also draw a tag.
            
            @param k
                       the child dictionary to inspect
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TaggedPdfReaderTool.ParseTag(System.String,iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfDictionary)">
            Searches for a tag in a page.
            
            @param tag
                       the name of the tag
            @param obj
                       an identifier to find the marked content
            @param page
                       a page dictionary
            @throws IOException
        </member>
        <member name="T:iTextSharp.text.pdf.parser.TextMarginFinder">
            Allows you to find the rectangle that contains all the text in a page.
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.RenderText(iTextSharp.text.pdf.parser.TextRenderInfo)">
            Method invokes by the PdfContentStreamProcessor.
            Passes a TextRenderInfo for every text chunk that is encountered.
            We'll use this object to obtain coordinates.
            @see com.itextpdf.text.pdf.parser.RenderListener#renderText(com.itextpdf.text.pdf.parser.TextRenderInfo)
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetLlx">
            Getter for the left margin.
            @return the X position of the left margin
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetLly">
            Getter for the bottom margin.
            @return the Y position of the bottom margin
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetUrx">
            Getter for the right margin.
            @return the X position of the right margin
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetUry">
            Getter for the top margin.
            @return the Y position of the top margin
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetWidth">
            Gets the width of the text block.
            @return a width
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.GetHeight">
            Gets the height of the text block.
            @return a height
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.BeginTextBlock">
            @see com.itextpdf.text.pdf.parser.RenderListener#beginTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.EndTextBlock">
            @see com.itextpdf.text.pdf.parser.RenderListener#endTextBlock()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextMarginFinder.RenderImage(iTextSharp.text.pdf.parser.ImageRenderInfo)">
            @see com.itextpdf.text.pdf.parser.RenderListener#renderImage(com.itextpdf.text.pdf.parser.ImageRenderInfo)
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.parser.TextRenderInfo" -->
        <member name="F:iTextSharp.text.pdf.parser.TextRenderInfo.utf_16BeEncoding">
            ! .NET SPECIFIC ! 
            is used for caching "UTF-16BE" encoding to improve performance
        </member>
        <member name="F:iTextSharp.text.pdf.parser.TextRenderInfo.markedContentInfos">
            Array containing marked content info for the text.
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.#ctor(iTextSharp.text.pdf.PdfString,iTextSharp.text.pdf.parser.GraphicsState,iTextSharp.text.pdf.parser.Matrix,System.Collections.ICollection)">
            Creates a new TextRenderInfo object
            @param string the PDF string that should be displayed
            @param gs the graphics state (note: at this time, this is not immutable, so don't cache it)
            @param textMatrix the text matrix at the time of the render operation
            @param markedContentInfo the marked content sequence, if available
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.#ctor(iTextSharp.text.pdf.parser.TextRenderInfo,iTextSharp.text.pdf.PdfString,System.Single)">
            Used for creating sub-TextRenderInfos for each individual character
            @param parent the parent TextRenderInfo
            @param string the content of a TextRenderInfo
            @param horizontalOffset the unscaled horizontal offset of the character that this TextRenderInfo represents
            @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetText">
            @return the text to render
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.HasMcid(System.Int32)">
            Checks if the text belongs to a marked content sequence
            with a given mcid.
            @param mcid a marked content id
            @return true if the text is marked with this id
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.HasMcid(System.Int32,System.Boolean)">
            	     * Checks if the text belongs to a marked content sequence
            	     * with a given mcid.
                     * @param mcid a marked content id
                     * @param checkTheTopmostLevelOnly indicates whether to check the topmost level of marked content stack only
                     * @return true if the text is marked with this id
                     * @since 5.3.5
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetMcid">
            @return the marked content associated with the TextRenderInfo instance.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetUnscaledWidth">
            @return the unscaled (i.e. in Text space) width of the text
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetBaseline">
            Gets the baseline for the text (i.e. the line that the text 'sits' on)
            This value includes the Rise of the draw operation - see {@link #getRise()} for the amount added by Rise
            @return the baseline line segment
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetAscentLine">
            Gets the ascentline for the text (i.e. the line that represents the topmost extent that a string of the current font could have)
            This value includes the Rise of the draw operation - see {@link #getRise()} for the amount added by Rise
            @return the ascentline line segment
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetDescentLine">
            Gets the descentline for the text (i.e. the line that represents the bottom most extent that a string of the current font could have)
            This value includes the Rise of the draw operation - see {@link #getRise()} for the amount added by Rise
            @return the descentline line segment
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetFont">
            Getter for the font
            @return the font
            @since iText 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetRise">
            The rise represents how far above the nominal baseline the text should be rendered.  The {@link #getBaseline()}, {@link #getAscentLine()} and {@link #getDescentLine()} methods already include Rise.
            This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)
            @return The Rise for the text draw operation, in user space units (Ts value, scaled to user space)
            @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.ConvertWidthFromTextSpaceToUserSpace(System.Single)">
            
             @param width the width, in text space
             @return the width in user space
             @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.ConvertHeightFromTextSpaceToUserSpace(System.Single)">
            
             @param height the height, in text space
             @return the height in user space
             @since 5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetSingleSpaceWidth">
            @return The width, in user space units, of a single space character in the current font
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetTextRenderMode">
            @return the text render mode that should be used for the text.  From the
            PDF specification, this means:
            <ul>
              <li>0 = Fill text</li>
              <li>1 = Stroke text</li>
              <li>2 = Fill, then stroke text</li>
              <li>3 = Invisible</li>
              <li>4 = Fill text and add to path for clipping</li>
              <li>5 = Stroke text and add to path for clipping</li>
              <li>6 = Fill, then stroke text and add to path for clipping</li>
              <li>7 = Add text to padd for clipping</li>
            </ul>
            @since iText 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetFillColor">
            @return the current fill color.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetStrokeColor">
            @return the current stroke color.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetUnscaledFontSpaceWidth">
            Calculates the width of a space character.  If the font does not define
            a width for a standard space character \u0020, we also attempt to use
            the width of \u00A0 (a non-breaking space in many fonts)
            @return the width of a single space character in text space units
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetStringWidth(System.String)">
            Gets the width of a String in text space units
            @param string    the string that needs measuring
            @return          the width of a String in text space units
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetPdfStringWidth(iTextSharp.text.pdf.PdfString,System.Boolean)">
            Gets the width of a PDF string in text space units
            @param string        the string that needs measuring
            @return  the width of a String in text space units
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetCharacterRenderInfos">
            Provides detail useful if a listener needs access to the position of each individual glyph in the text render operation
            @return  A list of {@link TextRenderInfo} objects that represent each glyph used in the draw operation. The next effect is if there was a separate Tj opertion for each character in the rendered string
            @since   5.3.3
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetWidthAndWordSpacing(iTextSharp.text.pdf.PdfString,System.Boolean)">
            Calculates width and word spacing of a single character PDF string.
            @param string            a character to calculate width.
            @param singleCharString  true if PDF string represents single character, false otherwise.
            @return                  array of 2 items: first item is a character width, second item is a calculated word spacing.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.Decode(iTextSharp.text.pdf.PdfString)">
            Decodes a PdfString (which will contain glyph ids encoded in the font's encoding)
            based on the active font, and determine the unicode equivalent
            @param in	the String that needs to be encoded
            @return	    the encoded String
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.DecodeSingleCharacter(iTextSharp.text.pdf.PdfString)">
            ! .NET SPECIFIC; this method is used to avoid unecessary using of StringBuilder because it is slow in .NET !
            Decodes a single character PdfString (which will contain glyph ids encoded in the font's encoding)
            based on the active font, and determine the unicode equivalent
            @param in	the String that needs to be encoded
            @return	    the encoded String
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.GetCharCode(System.String)">
             Converts a single character string to char code.
            
             @param string single character string to convert to.
             @return char code.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.TextRenderInfo.SplitString(iTextSharp.text.pdf.PdfString)">
            Split PDF string into array of single character PDF strings.
            @param string    PDF string to be splitted.
            @return          splitted PDF string.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.TextRenderInfo.PdfString">
            @return original PDF string
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.parser.Vector" -->
        <member name="F:iTextSharp.text.pdf.parser.Vector.I1">
            index of the X coordinate 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Vector.I2">
            index of the Y coordinate 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Vector.I3">
            index of the Z coordinate 
        </member>
        <member name="F:iTextSharp.text.pdf.parser.Vector.vals">
            the values inside the vector 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.#ctor(System.Single,System.Single,System.Single)">
            Creates a new Vector
            @param x the X coordinate
            @param y the Y coordinate
            @param z the Z coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Cross(iTextSharp.text.pdf.parser.Matrix)">
            Computes the cross product of this vector and the specified matrix
            @param by the matrix to cross this vector with
            @return the result of the cross product
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Subtract(iTextSharp.text.pdf.parser.Vector)">
            Computes the difference between this vector and the specified vector
            @param v the vector to subtract from this one
            @return the results of the subtraction
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Cross(iTextSharp.text.pdf.parser.Vector)">
            Computes the cross product of this vector and the specified vector
            @param with the vector to cross this vector with
            @return the cross product
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Normalize">
            Normalizes the vector (i.e. returns the unit vector in the same orientation as this vector)
            @return the unit vector
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Multiply(System.Single)">
            Multiplies the vector by a scalar
            @param by the scalar to multiply by
            @return the result of the scalar multiplication
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Dot(iTextSharp.text.pdf.parser.Vector)">
            Computes the dot product of this vector with the specified vector
            @param with the vector to dot product this vector with
            @return the dot product
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.ToString">
            @see java.lang.Object#toString()
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Vector.Equals(System.Object)">
            @since 5.0.1
            @see java.lang.Object#equals(java.lang.Object)
        </member>
        <member name="P:iTextSharp.text.pdf.parser.Vector.Item(System.Int32)">
            Gets the value from a coordinate of the vector
            @param index the index of the value to get (I1, I2 or I3)
            @return a coordinate value
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.parser.Vector.Length" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.parser.Vector.LengthSquared" -->
        <member name="T:iTextSharp.text.pdf.PatternColor">
            Represents a pattern. Can be used in high-level constructs (Paragraph, Cell, etc.).
        </member>
        <member name="F:iTextSharp.text.pdf.PatternColor.painter">
            The actual pattern.
        </member>
        <member name="M:iTextSharp.text.pdf.PatternColor.#ctor(iTextSharp.text.pdf.PdfPatternPainter)">
            Creates a color representing a pattern.
            @param painter the actual pattern
        </member>
        <member name="P:iTextSharp.text.pdf.PatternColor.Painter">
            Gets the pattern.
            @return the pattern
        </member>
        <member name="T:iTextSharp.text.pdf.PdfAcroForm">
            Each PDF document can contain maximum 1 AcroForm.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAcroForm.fieldTemplates">
            This is a map containing FieldTemplates. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAcroForm.documentFields">
            This is an array containing DocumentFields. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAcroForm.calculationOrder">
            This is an array containing the calculationorder of the fields. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAcroForm.sigFlags">
            Contains the signature flags. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates new PdfAcroForm 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.AddFieldTemplates(System.Collections.Generic.Dictionary{iTextSharp.text.pdf.PdfTemplate,System.Object})">
            Adds fieldTemplates.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.AddDocumentField(iTextSharp.text.pdf.PdfIndirectReference)">
            Adds documentFields.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.IsValid">
            Closes the AcroForm.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.AddCalculationOrder(iTextSharp.text.pdf.PdfFormField)">
            Adds an object to the calculationOrder.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.AddFormField(iTextSharp.text.pdf.PdfFormField)">
            Adds a formfield to the AcroForm.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.SetSignatureParams(iTextSharp.text.pdf.PdfFormField,System.String,System.Single,System.Single,System.Single,System.Single)">
            @param field
            @param name
            @param llx
            @param lly
            @param urx
            @param ury
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAcroForm.DrawSignatureAppearences(iTextSharp.text.pdf.PdfFormField,System.Single,System.Single,System.Single,System.Single)">
            @param field
            @param llx
            @param lly
            @param urx
            @param ury
        </member>
        <member name="P:iTextSharp.text.pdf.PdfAcroForm.SigFlags">
            Sets the signature flags.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfAction">
             A <CODE>PdfAction</CODE> defines an action that can be triggered from a PDF file.
            
             @see     PdfDictionary
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.FIRSTPAGE">
            A named action to go to the first page.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.PREVPAGE">
            A named action to go to the previous page.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.NEXTPAGE">
            A named action to go to the next page.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.LASTPAGE">
            A named action to go to the last page.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.PRINTDIALOG">
            A named action to open a print dialog.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_XFDF">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_INCLUDE_APPEND_SAVES">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_INCLUDE_ANNOTATIONS">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_PDF">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_CANONICAL_FORMAT">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_EXCL_NON_USER_ANNOTS">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_EXCL_F_KEY">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.SUBMIT_EMBED_FORM">
            a possible submitvalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAction.RESET_EXCLUDE">
            a possible submitvalue 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor">
            Create an empty action.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.Uri)">
             Constructs a new <CODE>PdfAction</CODE> of Subtype URI.
            
             @param url the Url to go to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.String)">
             Constructs a new <CODE>PdfAction</CODE> of Subtype URI.
            
             @param url the url to go to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(iTextSharp.text.pdf.PdfIndirectReference)">
            Constructs a new <CODE>PdfAction</CODE> of Subtype GoTo.
            @param destination the destination to go to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.String,System.String)">
            Constructs a new <CODE>PdfAction</CODE> of Subtype GoToR.
            @param filename the file name to go to
            @param name the named destination to go to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.String,System.Int32)">
            Constructs a new <CODE>PdfAction</CODE> of Subtype GoToR.
            @param filename the file name to go to
            @param page the page destination to go to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.Int32)">
            Implements name actions. The action can be FIRSTPAGE, LASTPAGE,
            NEXTPAGE and PREVPAGE.
            @param named the named action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.#ctor(System.String,System.String,System.String,System.String)">
            Launchs an application or a document.
            @param application the application to be launched or the document to be opened or printed.
            @param parameters (Windows-specific) A parameter string to be passed to the application.
            It can be <CODE>null</CODE>.
            @param operation (Windows-specific) the operation to perform: "open" - Open a document,
            "print" - Print a document.
            It can be <CODE>null</CODE>.
            @param defaultDir (Windows-specific) the default directory in standard DOS syntax.
            It can be <CODE>null</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.CreateLaunch(System.String,System.String,System.String,System.String)">
            Launchs an application or a document.
            @param application the application to be launched or the document to be opened or printed.
            @param parameters (Windows-specific) A parameter string to be passed to the application.
            It can be <CODE>null</CODE>.
            @param operation (Windows-specific) the operation to perform: "open" - Open a document,
            "print" - Print a document.
            It can be <CODE>null</CODE>.
            @param defaultDir (Windows-specific) the default directory in standard DOS syntax.
            It can be <CODE>null</CODE>.
            @return a Launch action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.Rendition(System.String,iTextSharp.text.pdf.PdfFileSpecification,System.String,iTextSharp.text.pdf.PdfIndirectReference)">
            Creates a Rendition action
            @param file
            @param fs
            @param mimeType
            @param ref
            @return a Media Clip action
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.JavaScript(System.String,iTextSharp.text.pdf.PdfWriter,System.Boolean)">
            Creates a JavaScript action. If the JavaScript is smaller than
            50 characters it will be placed as a string, otherwise it will
            be placed as a compressed stream.
            @param code the JavaScript code
            @param writer the writer for this action
            @param unicode select JavaScript unicode. Note that the internal
            Acrobat JavaScript engine does not support unicode,
            so this may or may not work for you
            @return the JavaScript action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.JavaScript(System.String,iTextSharp.text.pdf.PdfWriter)">
            Creates a JavaScript action. If the JavaScript is smaller than
            50 characters it will be place as a string, otherwise it will
            be placed as a compressed stream.
            @param code the JavaScript code
            @param writer the writer for this action
            @return the JavaScript action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.Next(iTextSharp.text.pdf.PdfAction)">
            Add a chained action.
            @param na the next action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.GotoLocalPage(System.Int32,iTextSharp.text.pdf.PdfDestination,iTextSharp.text.pdf.PdfWriter)">
            Creates a GoTo action to an internal page.
            @param page the page to go. First page is 1
            @param dest the destination for the page
            @param writer the writer for this action
            @return a GoTo action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.GotoLocalPage(System.String,System.Boolean)">
            Creates a GoTo action to a named destination.
            @param dest the named destination
            @param isName if true sets the destination as a name, if false sets it as a String
            @return a GoToR action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.GotoRemotePage(System.String,System.String,System.Boolean,System.Boolean)">
            Creates a GoToR action to a named destination.
            @param filename the file name to go to
            @param dest the destination name
            @param isName if true sets the destination as a name, if false sets it as a String
            @param newWindow open the document in a new window if <CODE>true</CODE>, if false the current document is replaced by the new document.
            @return a GoToR action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.GotoEmbedded(System.String,iTextSharp.text.pdf.collection.PdfTargetDictionary,System.String,System.Boolean,System.Boolean)">
            Creates a GoToE action to an embedded file.
            @param filename   the root document of the target (null if the target is in the same document)
            @param dest the named destination
            @param isName if true sets the destination as a name, if false sets it as a String
            @return a GoToE action
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAction.GotoEmbedded(System.String,iTextSharp.text.pdf.collection.PdfTargetDictionary,iTextSharp.text.pdf.PdfObject,System.Boolean)">
            Creates a GoToE action to an embedded file.
            @param filename   the root document of the target (null if the target is in the same document)
            @param target a path to the target document of this action
            @param dest       the destination inside the target document, can be of type PdfDestination, PdfName, or PdfString
            @param newWindow  if true, the destination document should be opened in a new window
            @return a GoToE action
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfAction.SetOCGstate(System.Collections.Generic.List{System.Object},System.Boolean)" -->
        <member name="T:iTextSharp.text.pdf.PdfAnnotation">
             A <CODE>PdfAnnotation</CODE> is a note that is associated with a page.
            
             @see     PdfDictionary
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAnnotation.FLAGS_LOCKEDCONTENTS">
            flagvalue PDF 1.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAnnotation.MARKUP_SQUIGGLY">
            attributevalue 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAnnotation.used">
            Holds value of property used. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfAnnotation.placeInPage">
            Holds value of property placeInPage. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.#ctor(iTextSharp.text.pdf.PdfWriter,System.Single,System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfString,iTextSharp.text.pdf.PdfString)">
            Constructs a new <CODE>PdfAnnotation</CODE> of subtype text.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.#ctor(iTextSharp.text.pdf.PdfWriter,System.Single,System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfAction)">
            Constructs a new <CODE>PdfAnnotation</CODE> of subtype link (Action).
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.CreateScreen(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String,iTextSharp.text.pdf.PdfFileSpecification,System.String,System.Boolean)">
            Creates a screen PdfAnnotation
            @param writer
            @param rect
            @param clipTitle
            @param fs
            @param mimeType
            @param playOnDisplay
            @return a screen PdfAnnotation
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.CreateFileAttachment(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String,System.Byte[],System.String,System.String)">
            Creates a file attachment annotation.
            @param writer the <CODE>PdfWriter</CODE>
            @param rect the dimensions in the page of the annotation
            @param contents the file description
            @param fileStore an array with the file. If it's <CODE>null</CODE>
            the file will be read from the disk
            @param file the path to the file. It will only be used if
            <CODE>fileStore</CODE> is not <CODE>null</CODE>
            @param fileDisplay the actual file name stored in the pdf
            @throws IOException on error
            @return the annotation
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.CreateFileAttachment(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String,iTextSharp.text.pdf.PdfFileSpecification)">
            Creates a file attachment annotation
            @param writer
            @param rect
            @param contents
            @param fs
            @return the annotation
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.CreatePolygonPolyline(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String,System.Boolean,iTextSharp.text.pdf.PdfArray)">
            Creates a polygon or -line annotation
            @param writer the PdfWriter
            @param rect the annotation position
            @param contents the textual content of the annotation
            @param polygon if true, the we're creating a polygon annotation, if false, a polyline
            @param vertices an array with the vertices of the polygon or -line
            @since 5.0.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.SetHighlighting(iTextSharp.text.pdf.PdfName)">
            Sets the annotation's highlighting mode. The values can be
            <CODE>HIGHLIGHT_NONE</CODE>, <CODE>HIGHLIGHT_INVERT</CODE>,
            <CODE>HIGHLIGHT_OUTLINE</CODE> and <CODE>HIGHLIGHT_PUSH</CODE>;
            @param highlight the annotation's highlighting mode
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.IsForm">
            Getter for property form.
            @return Value of property form.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.IsAnnotation">
            Getter for property annotation.
            @return Value of property annotation.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfAnnotation.PlaceInPage">
            Getter for property placeInPage.
            @return Value of property placeInPage.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfAnnotation.Layer">
            Sets the layer this annotation belongs to.
            @param layer the layer this annotation belongs to
        </member>
        <member name="P:iTextSharp.text.pdf.PdfAnnotation.Name">
            Sets the name of the annotation.
            With this name the annotation can be identified among
            all the annotations on a page (it has to be unique).
        </member>
        <member name="T:iTextSharp.text.pdf.PdfAnnotation.PdfImportedLink">
            This class processes links from imported pages so that they may be active. The following example code reads a group
            of files and places them all on the output PDF, four pages in a single page, keeping the links active.
            <pre>
            String[] files = new String[] {&quot;input1.pdf&quot;, &quot;input2.pdf&quot;};
            String outputFile = &quot;output.pdf&quot;;
            int firstPage=1;
            Document document = new Document();
            PdfWriter writer = PdfWriter.GetInstance(document, new FileOutputStream(outputFile));
            document.SetPageSize(PageSize.A4);
            float W = PageSize.A4.GetWidth() / 2;
            float H = PageSize.A4.GetHeight() / 2;
            document.Open();
            PdfContentByte cb = writer.GetDirectContent();
            for (int i = 0; i &lt; files.length; i++) {
               PdfReader currentReader = new PdfReader(files[i]);
               currentReader.ConsolidateNamedDestinations();
               for (int page = 1; page &lt;= currentReader.GetNumberOfPages(); page++) {
                   PdfImportedPage importedPage = writer.GetImportedPage(currentReader, page);
                   float a = 0.5f;
                   float e = (page % 2 == 0) ? W : 0;
                   float f = (page % 4 == 1 || page % 4 == 2) ? H : 0;
                   ArrayList links = currentReader.GetLinks(page);
                   cb.AddTemplate(importedPage, a, 0, 0, a, e, f);
                   for (int j = 0; j &lt; links.Size(); j++) {
                       PdfAnnotation.PdfImportedLink link = (PdfAnnotation.PdfImportedLink)links.Get(j);
                       if (link.IsInternal()) {
                           int dPage = link.GetDestinationPage();
                           int newDestPage = (dPage-1)/4 + firstPage;
                           float ee = (dPage % 2 == 0) ? W : 0;
                           float ff = (dPage % 4 == 1 || dPage % 4 == 2) ? H : 0;
                           link.SetDestinationPage(newDestPage);
                           link.TransformDestination(a, 0, 0, a, ee, ff);
                       }
                       link.TransformRect(a, 0, 0, a, e, f);
                       writer.AddAnnotation(link.CreateAnnotation(writer));
                   }
                   if (page % 4 == 0)
                   document.NewPage();
               }
               if (i &lt; files.length - 1)
               document.NewPage();
               firstPage += (currentReader.GetNumberOfPages()+3)/4;
            }
            document.Close();
            </pre>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAnnotation.PdfImportedLink.ToString">
            Returns a String representation of the link.
            @return	a String representation of the imported link
            @since	2.1.6
        </member>
        <member name="T:iTextSharp.text.pdf.PdfAppearance">
            Implements the appearance stream to be used with form fields..
        </member>
        <member name="T:iTextSharp.text.pdf.PdfTemplate">
            Implements the form XObject.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfContentByte">
            <CODE>PdfContentByte</CODE> is an object containing the user positioned
            text and graphic contents of a page. It knows how to apply the proper
            font encoding.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.ALIGN_CENTER">
            The alignement is center 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.ALIGN_LEFT">
            The alignement is left 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.ALIGN_RIGHT">
            The alignement is right 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_CAP_BUTT">
            A possible line cap value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_CAP_ROUND">
            A possible line cap value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_CAP_PROJECTING_SQUARE">
            A possible line cap value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_JOIN_MITER">
            A possible line join value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_JOIN_ROUND">
            A possible line join value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.LINE_JOIN_BEVEL">
            A possible line join value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_FILL">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_STROKE">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_INVISIBLE">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_FILL_CLIP">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_STROKE_CLIP">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE_CLIP">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.TEXT_RENDER_MODE_CLIP">
            A possible text rendering value 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.content">
            This is the actual content 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.writer">
            This is the writer 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.pdf">
            This is the PdfDocument 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.state">
            This is the GraphicState in use 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.layerDepth">
            The list were we save/restore the layer depth 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.stateList">
            The list were we save/restore the state 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.separator">
            The separator between commands.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.#ctor(iTextSharp.text.pdf.PdfWriter)">
             Constructs a new <CODE>PdfContentByte</CODE>-object.
            
             @param wr the writer associated to this content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ToString">
             Returns the <CODE>string</CODE> representation of this <CODE>PdfContentByte</CODE>-object.
            
             @return      a <CODE>string</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.IsTagged">
            Checks if the content needs to be tagged.
            @return false if no tags need to be added
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ToPdf(iTextSharp.text.pdf.PdfWriter)">
            Returns the PDF representation of this <CODE>PdfContentByte</CODE>-object.
            
             @param writer the <CODE>PdfWriter</CODE>
             @return a <CODE>byte</CODE> array with the representation
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Add(iTextSharp.text.pdf.PdfContentByte)">
             Adds the content of another <CODE>PdfContent</CODE>-object to this object.
            
             @param       other       another <CODE>PdfByteContent</CODE>-object
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetFlatness(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetFlatness(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineCap(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetRenderingIntent(iTextSharp.text.pdf.PdfName)">
            Set the rendering intent, possible values are: PdfName.ABSOLUTECOLORIMETRIC,
            PdfName.RELATIVECOLORIMETRIC, PdfName.SATURATION, PdfName.PERCEPTUAL.
            @param ri
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Single,System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Double,System.Double,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Single[],System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineDash(System.Double[],System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineJoin(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineWidth(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetLineWidth(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetMiterLimit(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetMiterLimit(System.Double)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Clip">
            Modify the current clipping path by intersecting it with the current path, using the
            nonzero winding number rule to determine which regions lie inside the clipping
            path.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EoClip">
            Modify the current clipping path by intersecting it with the current path, using the
            even-odd rule to determine which regions lie inside the clipping path.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetGrayFill(System.Single)">
             Changes the currentgray tint for filling paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceGray</B> (or the <B>DefaultGray</B> color space),
             and sets the gray tint to use for filling paths.</P>
            
             @param   gray    a value between 0 (black) and 1 (white)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetGrayFill">
            Changes the current gray tint for filling paths to black.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetGrayStroke(System.Single)">
             Changes the currentgray tint for stroking paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceGray</B> (or the <B>DefaultGray</B> color space),
             and sets the gray tint to use for stroking paths.</P>
            
             @param   gray    a value between 0 (black) and 1 (white)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetGrayStroke">
            Changes the current gray tint for stroking paths to black.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.HelperRGB(System.Single,System.Single,System.Single)">
            Helper to validate and write the RGB color components
            @param   red     the intensity of red. A value between 0 and 1
            @param   green   the intensity of green. A value between 0 and 1
            @param   blue    the intensity of blue. A value between 0 and 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetRGBColorFillF(System.Single,System.Single,System.Single)">
             Changes the current color for filling paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceRGB</B> (or the <B>DefaultRGB</B> color space),
             and sets the color to use for filling paths.</P>
             <P>
             Following the PDF manual, each operand must be a number between 0 (minimum intensity) and
             1 (maximum intensity).</P>
            
             @param   red     the intensity of red. A value between 0 and 1
             @param   green   the intensity of green. A value between 0 and 1
             @param   blue    the intensity of blue. A value between 0 and 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetRGBColorFill">
            Changes the current color for filling paths to black.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetRGBColorStrokeF(System.Single,System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetRGBColorStroke">
             Changes the current color for stroking paths to black.
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.HelperCMYK(System.Single,System.Single,System.Single,System.Single)">
             Helper to validate and write the CMYK color components.
            
             @param   cyan    the intensity of cyan. A value between 0 and 1
             @param   magenta the intensity of magenta. A value between 0 and 1
             @param   yellow  the intensity of yellow. A value between 0 and 1
             @param   black   the intensity of black. A value between 0 and 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetCMYKColorFillF(System.Single,System.Single,System.Single,System.Single)">
             Changes the current color for filling paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceCMYK</B> (or the <B>DefaultCMYK</B> color space),
             and sets the color to use for filling paths.</P>
             <P>
             Following the PDF manual, each operand must be a number between 0 (no ink) and
             1 (maximum ink).</P>
            
             @param   cyan    the intensity of cyan. A value between 0 and 1
             @param   magenta the intensity of magenta. A value between 0 and 1
             @param   yellow  the intensity of yellow. A value between 0 and 1
             @param   black   the intensity of black. A value between 0 and 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetCMYKColorFill">
             Changes the current color for filling paths to black.
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetCMYKColorStrokeF(System.Single,System.Single,System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ResetCMYKColorStroke">
             Changes the current color for stroking paths to black.
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.MoveTo(System.Single,System.Single)">
             Move the current point <I>(x, y)</I>, omitting any connecting line segment.
            
             @param       x               new x-coordinate
             @param       y               new y-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.MoveTo(System.Double,System.Double)">
             Move the current point <I>(x, y)</I>, omitting any connecting line segment.
            
             @param       x               new x-coordinate
             @param       y               new y-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.LineTo(System.Single,System.Single)">
             Appends a straight line segment from the current point <I>(x, y)</I>. The new current
             point is <I>(x, y)</I>.
            
             @param       x               new x-coordinate
             @param       y               new y-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.LineTo(System.Double,System.Double)">
             Appends a straight line segment from the current point <I>(x, y)</I>. The new current
             point is <I>(x, y)</I>.
            
             @param       x               new x-coordinate
             @param       y               new y-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveTo(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x1      x-coordinate of the first control point
             @param       y1      y-coordinate of the first control point
             @param       x2      x-coordinate of the second control point
             @param       y2      y-coordinate of the second control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveTo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x1      x-coordinate of the first control point
             @param       y1      y-coordinate of the first control point
             @param       x2      x-coordinate of the second control point
             @param       y2      y-coordinate of the second control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveTo(System.Single,System.Single,System.Single,System.Single)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x2      x-coordinate of the second control point
             @param       y2      y-coordinate of the second control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveTo(System.Double,System.Double,System.Double,System.Double)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x2      x-coordinate of the second control point
             @param       y2      y-coordinate of the second control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveFromTo(System.Single,System.Single,System.Single,System.Single)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x1      x-coordinate of the first control point
             @param       y1      y-coordinate of the first control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CurveFromTo(System.Double,System.Double,System.Double,System.Double)">
             Appends a Bezier curve to the path, starting from the current point.
            
             @param       x1      x-coordinate of the first control point
             @param       y1      y-coordinate of the first control point
             @param       x3      x-coordinaat of the ending point (= new current point)
             @param       y3      y-coordinaat of the ending point (= new current point)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Circle(System.Single,System.Single,System.Single)">
            Draws a circle. The endpoint will (x+r, y).
            
             @param x x center of circle
             @param y y center of circle
             @param r radius of circle
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Circle(System.Double,System.Double,System.Double)">
            Draws a circle. The endpoint will (x+r, y).
            
             @param x x center of circle
             @param y y center of circle
             @param r radius of circle
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Rectangle(System.Single,System.Single,System.Single,System.Single)">
             Adds a rectangle to the current path.
            
             @param       x       x-coordinate of the starting point
             @param       y       y-coordinate of the starting point
             @param       w       width
             @param       h       height
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Rectangle(System.Double,System.Double,System.Double,System.Double)">
             Adds a rectangle to the current path.
            
             @param       x       x-coordinate of the starting point
             @param       y       y-coordinate of the starting point
             @param       w       width
             @param       h       height
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.VariableRectangle(iTextSharp.text.Rectangle)">
            Adds a variable width border to the current path.
            Only use if {@link com.lowagie.text.Rectangle#isUseVariableBorders() Rectangle.isUseVariableBorders}
            = true.
            @param rect a <CODE>Rectangle</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Rectangle(iTextSharp.text.Rectangle)">
             Adds a border (complete or partially) to the current path..
            
             @param        rectangle        a <CODE>Rectangle</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ClosePath">
            Closes the current subpath by appending a straight line segment from the current point
            to the starting point of the subpath.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.NewPath">
            Ends the path without filling or stroking it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Stroke">
            Strokes the path.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ClosePathStroke">
            Closes the path and strokes it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Fill">
            Fills the path, using the non-zero winding number rule to determine the region to fill.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EoFill">
            Fills the path, using the even-odd rule to determine the region to fill.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.FillStroke">
            Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ClosePathFillStroke">
            Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EoFillStroke">
            Fills the path, using the even-odd rule to determine the region to fill and strokes it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ClosePathEoFillStroke">
            Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image)">
            Adds an <CODE>Image</CODE> to the page. The <CODE>Image</CODE> must have
            absolute positioning.
            @param image the <CODE>Image</CODE> object
            @throws DocumentException if the <CODE>Image</CODE> does not have absolute positioning
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Boolean)">
            Adds an <CODE>Image</CODE> to the page. The <CODE>Image</CODE> must have
            absolute positioning. The image can be placed inline.
            @param image the <CODE>Image</CODE> object
            @param inlineImage <CODE>true</CODE> to place this image inline, <CODE>false</CODE> otherwise
            @throws DocumentException if the <CODE>Image</CODE> does not have absolute positioning
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Adds an <CODE>Image</CODE> to the page. The positioning of the <CODE>Image</CODE>
            is done with the transformation matrix. To position an <CODE>image</CODE> at (x,y)
            use AddImage(image, image_width, 0, 0, image_height, x, y).
            @param image the <CODE>Image</CODE> object
            @param a an element of the transformation matrix
            @param b an element of the transformation matrix
            @param c an element of the transformation matrix
            @param d an element of the transformation matrix
            @param e an element of the transformation matrix
            @param f an element of the transformation matrix
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            Adds an <CODE>Image</CODE> to the page. The positioning of the <CODE>Image</CODE>
            is done with the transformation matrix. To position an <CODE>image</CODE> at (x,y)
            use AddImage(image, image_width, 0, 0, image_height, x, y).
            @param image the <CODE>Image</CODE> object
            @param a an element of the transformation matrix
            @param b an element of the transformation matrix
            @param c an element of the transformation matrix
            @param d an element of the transformation matrix
            @param e an element of the transformation matrix
            @param f an element of the transformation matrix
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,iTextSharp.awt.geom.AffineTransform)">
            adds an image with the given matrix.
            @param image image to add
            @param transform transform to apply to the template prior to adding it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Drawing.Drawing2D.Matrix)">
            adds an image with the given matrix.
            @param image image to add
            @param transform transform to apply to the template prior to adding it.
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            Adds an <CODE>Image</CODE> to the page. The positioning of the <CODE>Image</CODE>
            is done with the transformation matrix. To position an <CODE>image</CODE> at (x,y)
            use AddImage(image, image_width, 0, 0, image_height, x, y). The image can be placed inline.
            @param image the <CODE>Image</CODE> object
            @param a an element of the transformation matrix
            @param b an element of the transformation matrix
            @param c an element of the transformation matrix
            @param d an element of the transformation matrix
            @param e an element of the transformation matrix
            @param f an element of the transformation matrix
            @param inlineImage <CODE>true</CODE> to place this image inline, <CODE>false</CODE> otherwise
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            Adds an <CODE>Image</CODE> to the page. The positioning of the <CODE>Image</CODE>
            is done with the transformation matrix. To position an <CODE>image</CODE> at (x,y)
            use AddImage(image, image_width, 0, 0, image_height, x, y). The image can be placed inline.
            @param image the <CODE>Image</CODE> object
            @param a an element of the transformation matrix
            @param b an element of the transformation matrix
            @param c an element of the transformation matrix
            @param d an element of the transformation matrix
            @param e an element of the transformation matrix
            @param f an element of the transformation matrix
            @param inlineImage <CODE>true</CODE> to place this image inline, <CODE>false</CODE> otherwise
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddImage(iTextSharp.text.Image,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
            Adds an <CODE>Image</CODE> to the page. The positioning of the <CODE>Image</CODE>
            is done with the transformation matrix. To position an <CODE>image</CODE> at (x,y)
            The image can be placed inline.
            @param image the <CODE>Image</CODE> object
            @param a an element of the transformation matrix
            @param b an element of the transformation matrix
            @param c an element of the transformation matrix
            @param d an element of the transformation matrix
            @param e an element of the transformation matrix
            @param f an element of the transformation matrix
            @param inlineImage <CODE>true</CODE> to place this image inline, <CODE>false</CODE> otherwise
            @param isMCBlockOpened <CODE>true</CODE> not to open MCBlock, <CODE>false</CODE> otherwise
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Reset">
            Makes this <CODE>PdfContentByte</CODE> empty.
            Calls <code>reset( true )</code>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Reset(System.Boolean)">
            Makes this <CODE>PdfContentByte</CODE> empty.
            @param validateContent will call <code>sanityCheck()</code> if true.
            @since 2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginText(System.Boolean)">
            Starts the writing of text.
            @param restoreTM indicates if to restore text matrix of the previous text block.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginText">
            Starts the writing of text.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EndText">
            Ends the writing of text and makes the current font invalid.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SaveState">
            Saves the graphic state. <CODE>saveState</CODE> and
            <CODE>restoreState</CODE> must be balanced.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.RestoreState">
            Restores the graphic state. <CODE>saveState</CODE> and
            <CODE>restoreState</CODE> must be balanced.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetCharacterSpacing(System.Single)">
             Sets the character spacing parameter.
            
             @param       charSpace           a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetWordSpacing(System.Single)">
             Sets the word spacing parameter.
            
             @param       wordSpace           a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetHorizontalScaling(System.Single)">
             Sets the horizontal scaling parameter.
            
             @param       scale               a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetFontAndSize(iTextSharp.text.pdf.BaseFont,System.Single)">
             Set the font and the size for the subsequent text writing.
            
             @param bf the font
             @param size the font size in points
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetTextRenderingMode(System.Int32)">
             Sets the text rendering parameter.
            
             @param       rendering               a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetTextRise(System.Single)">
             Sets the text rise parameter.
             <P>
             This allows to write text in subscript or basescript mode.</P>
            
             @param       rise                a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetTextRise(System.Double)">
             Sets the text rise parameter.
             <P>
             This allows to write text in subscript or basescript mode.</P>
            
             @param       rise                a parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowText2(System.String)">
             A helper to insert into the content stream the <CODE>text</CODE>
             converted to bytes according to the font's encoding.
            
             @param text the text to write
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowText(System.String)">
             Shows the <CODE>text</CODE>.
            
             @param text the text to write
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.GetKernArray(System.String,iTextSharp.text.pdf.BaseFont)">
            Constructs a kern array for a text in a certain font
            @param text the text
            @param font the font
            @return a PdfTextArray
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowTextKerned(System.String)">
             Shows the <CODE>text</CODE> kerned.
            
             @param text the text to write
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.NewlineShowText(System.String)">
             Moves to the next line and shows <CODE>text</CODE>.
            
             @param text the text to write
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.NewlineShowText(System.Single,System.Single,System.String)">
             Moves to the next line and shows text string, using the given values of the character and word spacing parameters.
            
             @param       wordSpacing     a parameter
             @param       charSpacing     a parameter
             @param text the text to write
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetTextMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             Changes the text matrix.
             <P>
             Remark: this operation also initializes the current point position.</P>
            
             @param       a           operand 1,1 in the matrix
             @param       b           operand 1,2 in the matrix
             @param       c           operand 2,1 in the matrix
             @param       d           operand 2,2 in the matrix
             @param       x           operand 3,1 in the matrix
             @param       y           operand 3,2 in the matrix
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetTextMatrix(iTextSharp.awt.geom.AffineTransform)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.SetTextMatrix(System.Drawing.Drawing2D.Matrix)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetTextMatrix(System.Single,System.Single)">
             Changes the text matrix. The first four parameters are {1,0,0,1}.
             <P>
             Remark: this operation also initializes the current point position.</P>
            
             @param       x           operand 3,1 in the matrix
             @param       y           operand 3,2 in the matrix
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.MoveText(System.Single,System.Single)">
             Moves to the start of the next line, offset from the start of the current line.
            
             @param       x           x-coordinate of the new current point
             @param       y           y-coordinate of the new current point
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.MoveTextWithLeading(System.Single,System.Single)">
             Moves to the start of the next line, offset from the start of the current line.
             <P>
             As a side effect, this sets the leading parameter in the text state.</P>
            
             @param       x           offset of the new current point
             @param       y           y-coordinate of the new current point
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.NewlineText">
            Moves to the start of the next line.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddOutline(iTextSharp.text.pdf.PdfOutline,System.String)">
             Adds a named outline to the document.
            
             @param outline the outline
             @param name the name for the local destination
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.GetEffectiveStringWidth(System.String,System.Boolean)">
            Computes the width of the given string taking in account
            the current values of "Character spacing", "Word Spacing"
            and "Horizontal Scaling".
            The additional spacing is not computed for the last character
            of the string.
            @param text the string to get width of
            @param kerned the kerning option
            @return the width
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.GetEffectiveStringWidth(System.String,System.Boolean,System.Single)">
            Computes the width of the given string taking in account
            the current values of "Character spacing", "Word Spacing"
            and "Horizontal Scaling".
            The spacing for the last character is also computed.
            It also takes into account kerning that can be specified within TJ operator (e.g. [(Hello) 123 (World)] TJ)
            @param text the string to get width of
            @param kerned the kerning option
            @param kerning the kerning option from TJ array
            @return the width
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowTextAligned(System.Int32,System.String,System.Single,System.Single,System.Single)">
            Shows text right, left or center aligned with rotation.
            @param alignment the alignment can be ALIGN_CENTER, ALIGN_RIGHT or ALIGN_LEFT
            @param text the text to show
            @param x the x pivot position
            @param y the y pivot position
            @param rotation the rotation to be applied in degrees counterclockwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowTextAlignedKerned(System.Int32,System.String,System.Single,System.Single,System.Single)">
            Shows text kerned right, left or center aligned with rotation.
            @param alignment the alignment can be ALIGN_CENTER, ALIGN_RIGHT or ALIGN_LEFT
            @param text the text to show
            @param x the x pivot position
            @param y the y pivot position
            @param rotation the rotation to be applied in degrees counterclockwise
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.ConcatCTM(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.ConcatCTM(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ConcatCTM(iTextSharp.awt.geom.AffineTransform)">
            Concatenate a matrix to the current transformation matrix.
            @param transform added to the Current Transformation Matrix
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ConcatCTM(System.Drawing.Drawing2D.Matrix)">
            Concatenate a matrix to the current transformation matrix.
            @param transform added to the Current Transformation Matrix
            @since 5.0.1
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.BezierArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.BezierArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Arc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             Draws a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
             starting at startAng degrees and covering extent degrees. Angles
             start with 0 to the right (+x) and increase counter-clockwise.
            
             @param x1 a corner of the enclosing rectangle
             @param y1 a corner of the enclosing rectangle
             @param x2 a corner of the enclosing rectangle
             @param y2 a corner of the enclosing rectangle
             @param startAng starting angle in degrees
             @param extent angle extent in degrees
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Arc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
             Draws a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
             starting at startAng degrees and covering extent degrees. Angles
             start with 0 to the right (+x) and increase counter-clockwise.
            
             @param x1 a corner of the enclosing rectangle
             @param y1 a corner of the enclosing rectangle
             @param x2 a corner of the enclosing rectangle
             @param y2 a corner of the enclosing rectangle
             @param startAng starting angle in degrees
             @param extent angle extent in degrees
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Ellipse(System.Double,System.Double,System.Double,System.Double)">
             Draws an ellipse inscribed within the rectangle x1,y1,x2,y2.
            
             @param x1 a corner of the enclosing rectangle
             @param y1 a corner of the enclosing rectangle
             @param x2 a corner of the enclosing rectangle
             @param y2 a corner of the enclosing rectangle
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Ellipse(System.Single,System.Single,System.Single,System.Single)">
             Draws an ellipse inscribed within the rectangle x1,y1,x2,y2.
            
             @param x1 a corner of the enclosing rectangle
             @param y1 a corner of the enclosing rectangle
             @param x2 a corner of the enclosing rectangle
             @param y2 a corner of the enclosing rectangle
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CreatePattern(System.Single,System.Single,System.Single,System.Single)">
             Create a new colored tiling pattern.
            
             @param width the width of the pattern
             @param height the height of the pattern
             @param xstep the desired horizontal spacing between pattern cells.
             May be either positive or negative, but not zero.
             @param ystep the desired vertical spacing between pattern cells.
             May be either positive or negative, but not zero.
             @return the <CODE>PdfPatternPainter</CODE> where the pattern will be created
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CreatePattern(System.Single,System.Single)">
            Create a new colored tiling pattern. Variables xstep and ystep are set to the same values
            of width and height.
            @param width the width of the pattern
            @param height the height of the pattern
            @return the <CODE>PdfPatternPainter</CODE> where the pattern will be created
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CreatePattern(System.Single,System.Single,System.Single,System.Single,iTextSharp.text.BaseColor)">
             Create a new uncolored tiling pattern.
            
             @param width the width of the pattern
             @param height the height of the pattern
             @param xstep the desired horizontal spacing between pattern cells.
             May be either positive or negative, but not zero.
             @param ystep the desired vertical spacing between pattern cells.
             May be either positive or negative, but not zero.
             @param color the default color. Can be <CODE>null</CODE>
             @return the <CODE>PdfPatternPainter</CODE> where the pattern will be created
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CreatePattern(System.Single,System.Single,iTextSharp.text.BaseColor)">
            Create a new uncolored tiling pattern.
            Variables xstep and ystep are set to the same values
            of width and height.
            @param width the width of the pattern
            @param height the height of the pattern
            @param color the default color. Can be <CODE>null</CODE>
            @return the <CODE>PdfPatternPainter</CODE> where the pattern will be created
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.CreateTemplate(System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CreateAppearance(System.Single,System.Single)">
             Creates a new appearance to be used with form fields.
            
             @param width the bounding box width
             @param height the bounding box height
             @return the appearance created
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddPSXObject(iTextSharp.text.pdf.PdfPSXObject)">
             Adds a PostScript XObject to this content.
            
             @param psobject the object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             Adds a template to this content.
            
             @param template the template
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
             Adds a template to this content.
            
             @param template the template
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
             Adds a template to this content.
            
             @param template the template
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
             @param tagContent <code>true</code> - template content will be tagged(all that will be added after), <code>false</code> - only a Do operator will be tagged.
                               taken into account only if <code>isTagged()</code> - <code>true</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
             Adds a template to this content.
            
             @param template the template
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
             @param tagContent <code>true</code> - template content will be tagged(all that will be added after), <code>false</code> - only a Do operator will be tagged.
                               taken into account only if <code>isTagged()</code> - <code>true</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
             Adds a template to this content.
            
             @param template the template
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
             @param tagContent <code>true</code> - template content will be tagged(all that will be added after), <code>false</code> - only a Do operator will be tagged.
                               taken into account only if <code>isTagged()</code> - <code>true</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddFormXObj(iTextSharp.text.pdf.PdfStream,iTextSharp.text.pdf.PdfName,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
             Adds a form XObject to this content.
            
             @param formXObj the form XObject
             @param name the name of form XObject in content stream. The name is changed, if if it already exists in page resources
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
             
             @return Name under which XObject was stored in resources. See <code>name</code> parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddFormXObj(iTextSharp.text.pdf.PdfStream,iTextSharp.text.pdf.PdfName,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
             Adds a form XObject to this content.
            
             @param formXObj the form XObject
             @param name the name of form XObject in content stream. The name is changed, if if it already exists in page resources
             @param a an element of the transformation matrix
             @param b an element of the transformation matrix
             @param c an element of the transformation matrix
             @param d an element of the transformation matrix
             @param e an element of the transformation matrix
             @param f an element of the transformation matrix
             
             @return Name under which XObject was stored in resources. See <code>name</code> parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,iTextSharp.awt.geom.AffineTransform)">
            adds a template with the given matrix.
            @param template template to add
            @param transform transform to apply to the template prior to adding it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,iTextSharp.awt.geom.AffineTransform,System.Boolean)">
            adds a template with the given matrix.
            @param template template to add
            @param transform transform to apply to the template prior to adding it.
            @param tagContent <code>true</code> - template content will be tagged(all that will be added after), <code>false</code> - only a Do operator will be tagged.
                              taken into account only if <code>isTagged()</code> - <code>true</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Drawing.Drawing2D.Matrix,System.Boolean)">
            adds a template with the given matrix.
            @param template template to add
            @param transform transform to apply to the template prior to adding it.
            @param tagContent <code>true</code> - template content will be tagged(all that will be added after), <code>false</code> - only a Do operator will be tagged.
                              taken into account only if <code>isTagged()</code> - <code>true</code>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Drawing.Drawing2D.Matrix)">
            adds a template with the given matrix.
            @param template template to add
            @param transform transform to apply to the template prior to adding it.
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Single,System.Single)">
             Adds a template to this content.
            
             @param template the template
             @param x the x location of this template
             @param y the y location of this template
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Double,System.Double)">
             Adds a template to this content.
            
             @param template the template
             @param x the x location of this template
             @param y the y location of this template
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetCMYKColorFill(System.Int32,System.Int32,System.Int32,System.Int32)">
             Changes the current color for filling paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceCMYK</B> (or the <B>DefaultCMYK</B> color space),
             and sets the color to use for filling paths.</P>
             <P>
             This method is described in the 'Portable Document Format Reference Manual version 1.3'
             section 8.5.2.1 (page 331).</P>
             <P>
             Following the PDF manual, each operand must be a number between 0 (no ink) and
             1 (maximum ink). This method however accepts only ints between 0x00 and 0xFF.</P>
            
             @param cyan the intensity of cyan
             @param magenta the intensity of magenta
             @param yellow the intensity of yellow
             @param black the intensity of black
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetCMYKColorStroke(System.Int32,System.Int32,System.Int32,System.Int32)">
             Changes the current color for stroking paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceCMYK</B> (or the <B>DefaultCMYK</B> color space),
             and sets the color to use for stroking paths.</P>
             <P>
             This method is described in the 'Portable Document Format Reference Manual version 1.3'
             section 8.5.2.1 (page 331).</P>
             Following the PDF manual, each operand must be a number between 0 (miniumum intensity) and
             1 (maximum intensity). This method however accepts only ints between 0x00 and 0xFF.
            
             @param cyan the intensity of red
             @param magenta the intensity of green
             @param yellow the intensity of blue
             @param black the intensity of black
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetRGBColorFill(System.Int32,System.Int32,System.Int32)">
             Changes the current color for filling paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceRGB</B> (or the <B>DefaultRGB</B> color space),
             and sets the color to use for filling paths.</P>
             <P>
             This method is described in the 'Portable Document Format Reference Manual version 1.3'
             section 8.5.2.1 (page 331).</P>
             <P>
             Following the PDF manual, each operand must be a number between 0 (miniumum intensity) and
             1 (maximum intensity). This method however accepts only ints between 0x00 and 0xFF.</P>
            
             @param red the intensity of red
             @param green the intensity of green
             @param blue the intensity of blue
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetRGBColorStroke(System.Int32,System.Int32,System.Int32)">
             Changes the current color for stroking paths (device dependent colors!).
             <P>
             Sets the color space to <B>DeviceRGB</B> (or the <B>DefaultRGB</B> color space),
             and sets the color to use for stroking paths.</P>
             <P>
             This method is described in the 'Portable Document Format Reference Manual version 1.3'
             section 8.5.2.1 (page 331).</P>
             Following the PDF manual, each operand must be a number between 0 (miniumum intensity) and
             1 (maximum intensity). This method however accepts only ints between 0x00 and 0xFF.
            
             @param red the intensity of red
             @param green the intensity of green
             @param blue the intensity of blue
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetColorStroke(iTextSharp.text.BaseColor)">
            Sets the stroke color. <CODE>color</CODE> can be an
            <CODE>ExtendedColor</CODE>.
            @param color the color
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetColorFill(iTextSharp.text.BaseColor)">
            Sets the fill color. <CODE>color</CODE> can be an
            <CODE>ExtendedColor</CODE>.
            @param color the color
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetColorFill(iTextSharp.text.pdf.PdfSpotColor,System.Single)">
            Sets the fill color to a spot color.
            @param sp the spot color
            @param tint the tint for the spot color. 0 is no color and 1
            is 100% color
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetColorStroke(iTextSharp.text.pdf.PdfSpotColor,System.Single)">
            Sets the stroke color to a spot color.
            @param sp the spot color
            @param tint the tint for the spot color. 0 is no color and 1
            is 100% color
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternFill(iTextSharp.text.pdf.PdfPatternPainter)">
            Sets the fill color to a pattern. The pattern can be
            colored or uncolored.
            @param p the pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.OutputColorNumbers(iTextSharp.text.BaseColor,System.Single)">
            Outputs the color values to the content.
            @param color The color
            @param tint the tint if it is a spot color, ignored otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternFill(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor)">
            Sets the fill color to an uncolored pattern.
            @param p the pattern
            @param color the color of the pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternFill(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor,System.Single)">
            Sets the fill color to an uncolored pattern.
            @param p the pattern
            @param color the color of the pattern
            @param tint the tint if the color is a spot color, ignored otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternStroke(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor)">
            Sets the stroke color to an uncolored pattern.
            @param p the pattern
            @param color the color of the pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternStroke(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor,System.Single)">
            Sets the stroke color to an uncolored pattern.
            @param p the pattern
            @param color the color of the pattern
            @param tint the tint if the color is a spot color, ignored otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetPatternStroke(iTextSharp.text.pdf.PdfPatternPainter)">
            Sets the stroke color to a pattern. The pattern can be
            colored or uncolored.
            @param p the pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.PaintShading(iTextSharp.text.pdf.PdfShading)">
            Paints using a shading object. 
            @param shading the shading object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.PaintShading(iTextSharp.text.pdf.PdfShadingPattern)">
            Paints using a shading pattern. 
            @param shading the shading pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetShadingFill(iTextSharp.text.pdf.PdfShadingPattern)">
            Sets the shading fill pattern.
            @param shading the shading pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetShadingStroke(iTextSharp.text.pdf.PdfShadingPattern)">
            Sets the shading stroke pattern
            @param shading the shading pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CheckWriter">
            Check if we have a valid PdfWriter.
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.ShowText(iTextSharp.text.pdf.PdfTextArray)">
            Show an array of text.
            @param text array of text
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.LocalGoto(System.String,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to other part of the document. The jump will
            be made to a local destination with the same name, that must exist.
            @param name the name for this link
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.LocalDestination(System.String,iTextSharp.text.pdf.PdfDestination)">
            The local destination to where a local goto with the same
            name will jump.
            @param name the name of this local destination
            @param destination the <CODE>PdfDestination</CODE> with the jump coordinates
            @return <CODE>true</CODE> if the local destination was added,
            <CODE>false</CODE> if a local destination with the same name
            already exists
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.RemoteGoto(System.String,System.String,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to another document.
            @param filename the filename for the remote document
            @param name the name to jump to
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.RemoteGoto(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to another document.
            @param filename the filename for the remote document
            @param page the page to jump to
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.RoundRectangle(System.Single,System.Single,System.Single,System.Single,System.Single)">
             Adds a round rectangle to the current path.
            
             @param x x-coordinate of the starting point
             @param y y-coordinate of the starting point
             @param w width
             @param h height
             @param r radius of the arc corner
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.RoundRectangle(System.Double,System.Double,System.Double,System.Double,System.Double)">
             Adds a round rectangle to the current path.
            
             @param x x-coordinate of the starting point
             @param y y-coordinate of the starting point
             @param w width
             @param h height
             @param r radius of the arc corner
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetAction(iTextSharp.text.pdf.PdfAction,System.Single,System.Single,System.Single,System.Single)">
            Implements an action in an area.
            @param action the <CODE>PdfAction</CODE>
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetLiteral(System.String)">
            Outputs a <CODE>string</CODE> directly to the content.
            @param s the <CODE>string</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetLiteral(System.Char)">
            Outputs a <CODE>char</CODE> directly to the content.
            @param c the <CODE>char</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetLiteral(System.Single)">
            Outputs a <CODE>float</CODE> directly to the content.
            @param n the <CODE>float</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.CheckNoPattern(iTextSharp.text.pdf.PdfTemplate)">
            Throws an error if it is a pattern.
            @param t the object to check
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawRadioField(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            Draws a TextField.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawRadioField(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            Draws a TextField.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawTextField(System.Single,System.Single,System.Single,System.Single)">
            Draws a TextField.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawTextField(System.Double,System.Double,System.Double,System.Double)">
            Draws a TextField.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawButton(System.Single,System.Single,System.Single,System.Single,System.String,iTextSharp.text.pdf.BaseFont,System.Single)">
            Draws a button.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.DrawButton(System.Double,System.Double,System.Double,System.Double,System.String,iTextSharp.text.pdf.BaseFont,System.Single)">
            Draws a button.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetGState(iTextSharp.text.pdf.PdfGState)">
            Sets the graphic state
            @param gstate the graphic state
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfContentByte.BeginLayer(iTextSharp.text.pdf.IPdfOCG)" -->
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EndLayer">
            Ends a layer controled graphic block. It will end the most recent open block.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SetDefaultColorspace(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Sets the default colorspace.
            @param name the name of the colorspace. It can be <CODE>PdfName.DEFAULTGRAY</CODE>, <CODE>PdfName.DEFAULTRGB</CODE>
            or <CODE>PdfName.DEFAULTCMYK</CODE>
            @param obj the colorspace. A <CODE>null</CODE> or <CODE>PdfNull</CODE> removes any colorspace with the same name
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.Transform(iTextSharp.awt.geom.AffineTransform)">
            Concatenates a transformation to the current transformation
            matrix.
            @param af the transformation
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginMarkedContentSequence(iTextSharp.text.pdf.PdfStructureElement)">
            Begins a marked content sequence. This sequence will be tagged with the structure <CODE>struc</CODE>.
            The same structure can be used several times to connect text that belongs to the same logical segment
            but is in a different location, like the same paragraph crossing to another page, for example.
            @param struc the tagging structure
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginMarkedContentSequence(iTextSharp.text.pdf.PdfStructureElement,System.String)">
            Begins a marked content sequence. This sequence will be tagged with the structure <CODE>struc</CODE>.
            The same structure can be used several times to connect text that belongs to the same logical segment
            but is in a different location, like the same paragraph crossing to another page, for example.
            @param struc the tagging structure
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.EndMarkedContentSequence">
            Ends a marked content sequence
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginMarkedContentSequence(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfDictionary,System.Boolean)">
            Begins a marked content sequence. If property is <CODE>null</CODE> the mark will be of the type
            <CODE>BMC</CODE> otherwise it will be <CODE>BDC</CODE>.
            @param tag the tag
            @param property the property
            @param inline <CODE>true</CODE> to include the property in the content or <CODE>false</CODE>
            to include the property in the resource dictionary with the possibility of reusing
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.BeginMarkedContentSequence(iTextSharp.text.pdf.PdfName)">
            This is just a shorthand to <CODE>beginMarkedContentSequence(tag, null, false)</CODE>.
            @param tag the tag
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentByte.SanityCheck">
            Checks for any dangling state: Mismatched save/restore state, begin/end text,
            begin/end layer, or begin/end marked content sequence.
            If found, this function will throw.  This function is called automatically
            during a Reset() (from Document.NewPage() for example), and before writing 
            itself out in ToPdf().
            One possible cause: not calling myPdfGraphics2D.Dispose() will leave dangling
                                SaveState() calls.
            @since 2.1.6
            @throws IllegalPdfSyntaxException (a runtime exception)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.InternalBuffer">
            Gets the internal buffer.
            @return the internal buffer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.XTLM">
             Gets the x position of the text line matrix.
            
             @return the x position of the text line matrix
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.YTLM">
             Gets the y position of the text line matrix.
            
             @return the y position of the text line matrix
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.CharacterSpacing">
             Gets the current character spacing.
            
             @return the current character spacing
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.WordSpacing">
             Gets the current word spacing.
            
             @return the current word spacing
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.HorizontalScaling">
             Gets the current character spacing.
            
             @return the current character spacing
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.Leading">
             Gets the current text leading.
            
             @return the current text leading
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.Size">
             Gets the size of this content.
            
             @return the size of the content
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.RootOutline">
             Gets the root outline.
            
             @return the root outline
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.PdfWriter">
            Gets the <CODE>PdfWriter</CODE> in use by this object.
            @return the <CODE>PdfWriter</CODE> in use by this object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.PdfDocument">
            Gets the <CODE>PdfDocument</CODE> in use by this object.
            @return the <CODE>PdfDocument</CODE> in use by this object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentByte.Duplicate">
             Gets a duplicate of this <CODE>PdfContentByte</CODE>. All
             the members are copied by reference but the buffer stays different.
            
             @return a copy of this <CODE>PdfContentByte</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfContentByte.GraphicState">
            This class keeps the graphic state of the current page
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.fontDetails">
            This is the font in use 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.colorDetails">
            This is the color in use 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.size">
            This is the font size in use 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.xTLM">
            The x position of the text line matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.yTLM">
            The y position of the text line matrix. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.leading">
            The current text leading. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.scale">
            The current horizontal scaling 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.charSpace">
            The current character spacing 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentByte.GraphicState.wordSpace">
            The current word spacing 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTemplate.thisReference">
            The indirect reference to this template 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTemplate.pageResources">
            The resources used by this template 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTemplate.bBox">
            The bounding box of this template 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTemplate.additional">
            A dictionary with additional information
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTemplate.#ctor">
            Creates a <CODE>PdfTemplate</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTemplate.#ctor(iTextSharp.text.pdf.PdfWriter)">
             Creates new PdfTemplate
            
             @param wr the <CODE>PdfWriter</CODE>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfTemplate.CreateTemplate(iTextSharp.text.pdf.PdfWriter,System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfTemplate.GetFormXObject(System.Int32)">
             Gets the stream representing this template.
            
             @param   compressionLevel    the compressionLevel
             @return the stream representing this template
             @since   2.1.3   (replacing the method without param compressionLevel)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Width">
             Gets the bounding width of this template.
            
             @return width the bounding width
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Height">
             Gets the bounding heigth of this template.
            
             @return heigth the bounding height
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Layer">
            Gets the layer this template belongs to.
            @return the layer this template belongs to or <code>null</code> for no layer defined
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.IndirectReference">
             Gets the indirect reference to this template.
            
             @return the indirect reference to this template
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Resources">
             Constructs the resources used by this template.
            
             @return the resources used by this template
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Duplicate">
            Gets a duplicate of this <CODE>PdfTemplate</CODE>. All
            the members are copied by reference but the buffer stays different.
            @return a copy of this <CODE>PdfTemplate</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTemplate.Additional">
             Sets/gets a dictionary with extra entries, for instance /Measure.
            
             @param additional
                        a PdfDictionary with additional information.
             @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAppearance.#ctor">
            Creates a <CODE>PdfAppearance</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAppearance.#ctor(iTextSharp.text.pdf.PdfWriter)">
             Creates new PdfTemplate
            
             @param wr the <CODE>PdfWriter</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAppearance.CreateAppearance(iTextSharp.text.pdf.PdfWriter,System.Single,System.Single)">
             Creates a new appearance to be used with form fields.
            
             @param width the bounding box width
             @param height the bounding box height
             @return the appearance created
        </member>
        <member name="M:iTextSharp.text.pdf.PdfAppearance.SetFontAndSize(iTextSharp.text.pdf.BaseFont,System.Single)">
             Set the font and the size for the subsequent text writing.
            
             @param bf the font
             @param size the font size in points
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfArray" -->
        <member name="F:iTextSharp.text.pdf.PdfArray.arrayList">
            this is the actual array of PdfObjects 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.#ctor">
            Constructs an empty <CODE>PdfArray</CODE>-object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.#ctor(iTextSharp.text.pdf.PdfObject)">
             Constructs an <CODE>PdfArray</CODE>-object, containing 1 <CODE>PdfObject</CODE>.
            
             @param    object        a <CODE>PdfObject</CODE> that has to be added to the array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.#ctor(System.Collections.Generic.IList{iTextSharp.text.pdf.PdfObject})">
            Constructs a PdfArray with the elements of an ArrayList.
            Throws a ClassCastException if the ArrayList contains something
            that isn't a PdfObject.
            @param   l   an ArrayList with PdfObjects
            @since 2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.#ctor(iTextSharp.text.pdf.PdfArray)">
             Constructs an <CODE>PdfArray</CODE>-object, containing all the <CODE>PdfObject</CODE>s in a given <CODE>PdfArray</CODE>.
            
             @param    array        a <CODE>PdfArray</CODE> that has to be added to the array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
             Returns the PDF representation of this <CODE>PdfArray</CODE>.
            
             @return        an array of <CODE>byte</CODE>s
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.GetPdfObject(System.Int32)">
             Returns the <CODE>PdfObject</CODE> with the specified index.
            
             A possible indirect references is not resolved, so the returned
             <CODE>PdfObject</CODE> may be either a direct object or an indirect
             reference, depending on how the object is stored in the
             <CODE>PdfArray</CODE>.
            
             @param idx The index of the <CODE>PdfObject</CODE> to be returned
             @return A <CODE>PdfObject</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.Set(System.Int32,iTextSharp.text.pdf.PdfObject)">
             Overwrites a specified location of the array, returning the previous
             value
            
             @param idx The index of the element to be overwritten
             @param obj new value for the specified index
             @throws IndexOutOfBoundsException if the specified position doesn't exist
             @return the previous value
             @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.Remove(System.Int32)">
            Remove the element at the specified position from the array.
            
            Shifts any subsequent elements to the left (subtracts one from their
            indices).
            
            @param idx The index of the element to be removed.
            @throws IndexOutOfBoundsException the specified position doesn't exist
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.IsEmpty">
            Returns <CODE>true</CODE> if the array is empty.
            
            @return <CODE>true</CODE> if the array is empty
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.Add(iTextSharp.text.pdf.PdfObject)">
             Adds a <CODE>PdfObject</CODE> to the <CODE>PdfArray</CODE>.
            
             @param        object            <CODE>PdfObject</CODE> to add
             @return        <CODE>true</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.Add(System.Int32,iTextSharp.text.pdf.PdfObject)">
             Inserts the specified element at the specified position.
             
             Shifts the element currently at that position (if any) and
             any subsequent elements to the right (adds one to their indices).
            
             @param index The index at which the specified element is to be inserted
             @param element The element to be inserted
             @throws IndexOutOfBoundsException if the specified index is larger than the
               last position currently set, plus 1. 
             @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.AddFirst(iTextSharp.text.pdf.PdfObject)">
             Inserts a <CODE>PdfObject</CODE> at the beginning of the
             <CODE>PdfArray</CODE>.
             
             The <CODE>PdfObject</CODE> will be the first element, any other elements
             will be shifted to the right (adds one to their indices).
            
             @param object The <CODE>PdfObject</CODE> to add
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.Contains(iTextSharp.text.pdf.PdfObject)">
             Checks if the <CODE>PdfArray</CODE> already contains a certain <CODE>PdfObject</CODE>.
            
             @param        object            <CODE>PdfObject</CODE> to check
             @return        <CODE>true</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.AsLongArray">
            
            @return this PdfArray's values as a long[] 
            @since 5.3.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfArray.AsDoubleArray">
            
             @return this PdfArray's values as a double[]
             @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.PdfArray.Item(System.Int32)">
            Overwrites a specified location of the array.
            
            @param idx The index of the element to be overwritten
            @param obj new value for the specified index
            @throws IndexOutOfBoundsException if the specified position doesn't exist
            @return the previous value
            @since 2.1.5
        </member>
        <member name="P:iTextSharp.text.pdf.PdfArray.ArrayList">
             Returns an ArrayList containing <CODE>PdfObject</CODE>s.
            
             @return        an ArrayList
        </member>
        <member name="P:iTextSharp.text.pdf.PdfArray.Size">
             Returns the number of entries in the array.
            
             @return        the size of the ArrayList
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfBoolean" -->
        <member name="F:iTextSharp.text.pdf.PdfBoolean.TRUE">
            A possible value of <CODE>PdfBoolean</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfBoolean.FALSE">
            A possible value of <CODE>PdfBoolean</CODE> 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfBoolean.value">
            the bool value of this object 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfBoolean.#ctor(System.Boolean)">
             Constructs a <CODE>PdfBoolean</CODE>-object.
            
             @param        value            the value of the new <CODE>PdfObject</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfBoolean.#ctor(System.String)">
             Constructs a <CODE>PdfBoolean</CODE>-object.
            
             @param        value            the value of the new <CODE>PdfObject</CODE>, represented as a <CODE>string</CODE>
            
             @throws        BadPdfFormatException    thrown if the <VAR>value</VAR> isn't '<CODE>true</CODE>' or '<CODE>false</CODE>'
        </member>
        <member name="P:iTextSharp.text.pdf.PdfBoolean.BooleanValue">
             Returns the primitive value of the <CODE>PdfBoolean</CODE>-object.
            
             @return        the actual value of the object.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfBorderArray">
             A <CODE>PdfBorderArray</CODE> defines the border of a <CODE>PdfAnnotation</CODE>.
            
             @see        PdfArray
        </member>
        <member name="M:iTextSharp.text.pdf.PdfBorderArray.#ctor(System.Single,System.Single,System.Single)">
            Constructs a new <CODE>PdfBorderArray</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfBorderArray.#ctor(System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfDashPattern)">
            Constructs a new <CODE>PdfBorderArray</CODE>.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfBorderDictionary">
             A <CODE>PdfBorderDictionary</CODE> define the appearance of a Border (Annotations).
            
             @see     PdfDictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfBorderDictionary.#ctor(System.Single,System.Int32,iTextSharp.text.pdf.PdfDashPattern)">
            Constructs a <CODE>PdfBorderDictionary</CODE>.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfChunk" -->
        <member name="F:iTextSharp.text.pdf.PdfChunk.keysAttributes">
            The allowed attributes in variable <CODE>attributes</CODE>. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.keysNoStroke">
            The allowed attributes in variable <CODE>noStroke</CODE>. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.value">
            The value of this object. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.encoding">
            The encoding. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.font">
            The font for this <CODE>PdfChunk</CODE>. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.pdf.PdfChunk.attributes" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.pdf.PdfChunk.noStroke" -->
        <member name="F:iTextSharp.text.pdf.PdfChunk.newlineSplit">
            <CODE>true</CODE> if the chunk split was cause by a newline. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.image">
            The image in this <CODE>PdfChunk</CODE>, if it has one 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.offsetX">
            The offset in the x direction for the image 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.offsetY">
            The offset in the y direction for the image 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.changeLeading">
            Indicates if the height and offset of the Image has to be taken into account 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfChunk.leading">
            The leading that can overrule the existing leading. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.#ctor(System.String,iTextSharp.text.pdf.PdfChunk)">
             Constructs a <CODE>PdfChunk</CODE>-object.
            
             @param string the content of the <CODE>PdfChunk</CODE>-object
             @param font the <CODE>PdfFont</CODE>
             @param attributes the metrics attributes
             @param noStroke the non metric attributes
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.#ctor(iTextSharp.text.Chunk,iTextSharp.text.pdf.PdfAction)">
             Constructs a <CODE>PdfChunk</CODE>-object.
            
             @param chunk the original <CODE>Chunk</CODE>-object
             @param action the <CODE>PdfAction</CODE> if the <CODE>Chunk</CODE> comes from an <CODE>Anchor</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.#ctor(iTextSharp.text.Chunk,iTextSharp.text.pdf.PdfAction,iTextSharp.text.TabSettings)">
             Constructs a <CODE>PdfChunk</CODE>-object.
            
             @param chunk     the original <CODE>Chunk</CODE>-object
             @param action    the <CODE>PdfAction</CODE> if the <CODE>Chunk</CODE> comes from an <CODE>Anchor</CODE>
             @param tabSettings  the Phrase tab settings
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfChunk.GetUnicodeEquivalent(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfChunk.Split(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfChunk.Truncate(System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfChunk.Width">
             Returns the width of this <CODE>PdfChunk</CODE>.
            
             @return  a width
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsNewlineSplit">
            Checks if the <CODE>PdfChunk</CODE> split was caused by a newline.
            @return <CODE>true</CODE> if the <CODE>PdfChunk</CODE> split was caused by a newline.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.GetWidthCorrected(System.Single,System.Single)">
            Gets the width of the <CODE>PdfChunk</CODE> taking into account the
            extra character and word spacing.
            @param charSpacing the extra character spacing
            @param wordSpacing the extra word spacing
            @return the calculated width
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.TrimLastSpace">
            Trims the last space.
            @return the width of the space trimmed, otherwise 0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.GetAttribute(System.String)">
            Gets an attribute. The search is made in <CODE>attributes</CODE>
            and <CODE>noStroke</CODE>.
            @param name the attribute key
            @return the attribute value or null if not found
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsAttribute(System.String)">
            Checks if the attribute exists.
             @param name the attribute key
             @return <CODE>true</CODE> if the attribute exists
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsStroked">
            Checks if this <CODE>PdfChunk</CODE> needs some special metrics handling.
            @return <CODE>true</CODE> if this <CODE>PdfChunk</CODE> needs some special metrics handling.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsSeparator">
            Checks if this <CODE>PdfChunk</CODE> is a Separator Chunk.
            @return  true if this chunk is a separator.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsHorizontalSeparator">
            Checks if this <CODE>PdfChunk</CODE> is a horizontal Separator Chunk.
            @return  true if this chunk is a horizontal separator.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsTab">
            Checks if this <CODE>PdfChunk</CODE> is a tab Chunk.
            @return  true if this chunk is a separator.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.AdjustLeft(System.Single)">
            Correction for the tab position based on the left starting position.
            @param   newValue    the new value for the left X.
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsImage">
            Checks if there is an image in the <CODE>PdfChunk</CODE>.
            @return <CODE>true</CODE> if an image is present
        </member>
        <member name="M:iTextSharp.text.pdf.PdfChunk.IsSpecialEncoding">
            Tells you if this string is in Chinese, Japanese, Korean or Identity-H.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfChunk.Trim(System.String)" -->
        <member name="P:iTextSharp.text.pdf.PdfChunk.Font">
             Returns the font of this <CODE>Chunk</CODE>.
            
             @return  a <CODE>PdfFont</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.Color">
             Returns the color of this <CODE>Chunk</CODE>.
            
             @return  a <CODE>BaseColor</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.TextRise">
            Gets the text displacement relatiev to the baseline.
            @return a displacement in points
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.Image">
            Gets the image in the <CODE>PdfChunk</CODE>.
            @return the image or <CODE>null</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.ImageScalePercentage">
            Returns a scalePercentage in case the image needs to be scaled.
            Sets a scale percentage in case the image needs to be scaled.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.ImageOffsetX">
            Gets the image offset in the x direction
            @return the image offset in the x direction
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.ImageOffsetY">
            Gets the image offset in the y direction
            @return Gets the image offset in the y direction
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.Value">
            sets the value.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfChunk.Encoding">
             Gets the encoding of this string.
            
             @return      a <CODE>string</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfColor">
             A <CODE>PdfColor</CODE> defines a Color (it's a <CODE>PdfArray</CODE> containing 3 values).
            
             @see        PdfDictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfColor.#ctor(System.Int32,System.Int32,System.Int32)">
             Constructs a new <CODE>PdfColor</CODE>.
            
             @param        red            a value between 0 and 255
             @param        green        a value between 0 and 255
             @param        blue        a value between 0 and 255
        </member>
        <member name="T:iTextSharp.text.pdf.PdfContentParser">
            Parses the page or template content.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentParser.COMMAND_TYPE">
            Commands have this type.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfContentParser.tokeniser">
            Holds value of property tokeniser.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.#ctor(iTextSharp.text.pdf.PRTokeniser)">
            Creates a new instance of PdfContentParser
            @param tokeniser the tokeniser with the content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.Parse(System.Collections.Generic.List{iTextSharp.text.pdf.PdfObject})">
            Parses a single command from the content. Each command is output as an array of arguments
            having the command itself as the last element. The returned array will be empty if the
            end of content was reached.
            @param ls an <CODE>ArrayList</CODE> to use. It will be cleared before using. If it's
            <CODE>null</CODE> will create a new <CODE>ArrayList</CODE>
            @return the same <CODE>ArrayList</CODE> given as argument or a new one
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.GetTokeniser">
            Gets the tokeniser.
            @return the tokeniser.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.ReadDictionary">
            Reads a dictionary. The tokeniser must be positioned past the "&lt;&lt;" token.
            @return the dictionary
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.ReadArray">
            Reads an array. The tokeniser must be positioned past the "[" token.
            @return an array
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.ReadPRObject">
            Reads a pdf object.
            @return the pdf object
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContentParser.NextValidToken">
            Reads the next token skipping over the comments.
            @return <CODE>true</CODE> if a token was read, <CODE>false</CODE> if the end of content was reached
            @throws IOException on error
        </member>
        <member name="P:iTextSharp.text.pdf.PdfContentParser.Tokeniser">
            Sets the tokeniser.
            @param tokeniser the tokeniser
        </member>
        <member name="T:iTextSharp.text.pdf.PdfContents">
            <CODE>PdfContents</CODE> is a <CODE>PdfStream</CODE> containing the contents (text + graphics) of a <CODE>PdfPage</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfContents.#ctor(iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.Rectangle)">
             Constructs a <CODE>PdfContents</CODE>-object, containing text and general graphics.
            
             @param under the direct content that is under all others
             @param content the graphics in a page
             @param text the text in a page
             @param secondContent the direct content that is over all others
             @throws BadPdfFormatException on error
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopy">
            Make copies of PDF documents. Documents can be edited after reading and
            before writing them out.
            @author Mark Thompson
        </member>
        <member name="F:iTextSharp.text.pdf.PdfCopy.rotateContents">
            Holds value of property rotateContents. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.#ctor(iTextSharp.text.Document,System.IO.Stream)">
            Constructor
            @param document
            @param os outputstream
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.GetImportedPage(iTextSharp.text.pdf.PdfReader,System.Int32)">
            Grabs a page from the input document
            @param reader the reader of the document
            @param pageNumber which page to get
            @return the page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyIndirect(iTextSharp.text.pdf.PRIndirectReference,System.Boolean,System.Boolean)">
            Translate a PRIndirectReference to a PdfIndirectReference
            In addition, translates the object numbers, and copies the
            referenced object to the output file.
            NB: PRIndirectReferences (and PRIndirectObjects) really need to know what
            file they came from, because each file has its own namespace. The translation
            we do from their namespace to ours is *at best* heuristic, and guaranteed to
            fail under some circumstances.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyIndirect(iTextSharp.text.pdf.PRIndirectReference)">
            Translate a PRIndirectReference to a PdfIndirectReference
            In addition, translates the object numbers, and copies the
            referenced object to the output file.
            NB: PRIndirectReferences (and PRIndirectObjects) really need to know what
            file they came from, because each file has its own namespace. The translation
            we do from their namespace to ours is *at best* heuristic, and guaranteed to
            fail under some circumstances.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyDictionary(iTextSharp.text.pdf.PdfDictionary,System.Boolean,System.Boolean)">
            Translate a PRDictionary to a PdfDictionary. Also translate all of the
            objects contained in it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyDictionary(iTextSharp.text.pdf.PdfDictionary)">
            Translate a PRDictionary to a PdfDictionary. Also translate all of the
            objects contained in it.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyStream(iTextSharp.text.pdf.PRStream)">
            Translate a PRStream to a PdfStream. The data part copies itself.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyArray(iTextSharp.text.pdf.PdfArray,System.Boolean,System.Boolean)">
            Translate a PRArray to a PdfArray. Also translate all of the objects contained
            in it
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyArray(iTextSharp.text.pdf.PdfArray)">
            Translate a PRArray to a PdfArray. Also translate all of the objects contained
            in it
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyObject(iTextSharp.text.pdf.PdfObject,System.Boolean,System.Boolean)">
            Translate a PR-object to a Pdf-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyObject(iTextSharp.text.pdf.PdfObject)">
            Translate a PR-object to a Pdf-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.SetFromIPage(iTextSharp.text.pdf.PdfImportedPage)">
            convenience method. Given an importedpage, set our "globals"
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.SetFromReader(iTextSharp.text.pdf.PdfReader)">
            convenience method. Given a reader, set our "globals"
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.AddPage(iTextSharp.text.pdf.PdfImportedPage)">
            Add an imported page to our output
            @param iPage an imported page
            @throws IOException, BadPdfFormatException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.AddPage(iTextSharp.text.Rectangle,System.Int32)">
            Adds a blank page.
            @param	rect The page dimension
            @param	rotation The rotation angle in degrees
            @since	2.1.5
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.CopyDocumentFields(iTextSharp.text.pdf.PdfReader)">
            Copy document fields to a destination document.
            @param reader a document where fields are copied from.
            @throws DocumentException
            @throws IOException
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfCopy.Close" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfCopy.CreatePageStamp(iTextSharp.text.pdf.PdfImportedPage)" -->
        <member name="P:iTextSharp.text.pdf.PdfCopy.PageEvent">
            Setting page events isn't possible with Pdf(Smart)Copy.
            Use the PageStamp class if you want to add content to copied pages.
            @see com.itextpdf.text.pdf.PdfWriter#setPageEvent(com.itextpdf.text.pdf.PdfPageEvent)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopy.RotateContents">
            Checks if the content is automatically adjusted to compensate
            the original page rotation.
            @return the auto-rotation status
            Flags the content to be automatically adjusted to compensate
            the original page rotation. The default is <CODE>true</CODE>.
            @param rotateContents <CODE>true</CODE> to set auto-rotation, <CODE>false</CODE>
            otherwise
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopy.IndirectReferences">
            This class holds information about indirect references, since they are
            renumbered by iText.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopy.StampContent.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PageResources)">
            Creates a new instance of StampContent 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopy.StampContent.Duplicate">
             Gets a duplicate of this <CODE>PdfContentByte</CODE>. All
             the members are copied by reference but the buffer stays different.
            
             @return a copy of this <CODE>PdfContentByte</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopyFields">
            Concatenates PDF documents including form fields. The rules for the form field
            concatenation are the same as in Acrobat. All the documents are kept in memory unlike
            PdfCopy.
            @author  Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.#ctor(System.IO.Stream)">
            Creates a new instance.
            @param os the output stream
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.#ctor(System.IO.Stream,System.Char)">
            Creates a new instance.
            @param os the output stream
            @param pdfVersion the pdf version the output will have
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.AddDocument(iTextSharp.text.pdf.PdfReader)">
            Concatenates a PDF document.
            @param reader the PDF document
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.AddDocument(iTextSharp.text.pdf.PdfReader,System.Collections.Generic.IList{System.Int32})">
            Concatenates a PDF document selecting the pages to keep. The pages are described as a
            <CODE>List</CODE> of <CODE>Integer</CODE>. The page ordering can be changed but
            no page repetitions are allowed.
            @param reader the PDF document
            @param pagesToKeep the pages to keep
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.AddDocument(iTextSharp.text.pdf.PdfReader,System.String)">
            Concatenates a PDF document selecting the pages to keep. The pages are described as
            ranges. The page ordering can be changed but
            no page repetitions are allowed.
            @param reader the PDF document
            @param ranges the comma separated ranges as described in {@link SequenceList}
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.SetEncryption(System.Boolean,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param strength true for 128 bit key length. false for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.Close">
            Closes the output document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.Open">
            Opens the document. This is usually not needed as AddDocument() will do it
            automatically.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.AddJavaScript(System.String)">
            Adds JavaScript to the global document
            @param js the JavaScript
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.SetFullCompression">
            Sets the document's compression to the new 1.5 mode with object streams and xref
            streams. It can be set at any time but once set it can't be unset.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.interfaces.PdfEncryptionSettings#setEncryption(byte[], byte[], int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#addViewerPreference(com.lowagie.text.pdf.PdfName, com.lowagie.text.pdf.PdfObject)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFields.SetEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            @see com.lowagie.text.pdf.interfaces.PdfEncryptionSettings#setEncryption(java.security.cert.Certificate[], int[], int)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyFields.Outlines">
            Sets the bookmarks. The list structure is defined in
            {@link SimpleBookmark}.
            @param outlines the bookmarks or <CODE>null</CODE> to remove any
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyFields.Writer">
            Gets the underlying PdfWriter.
            @return the underlying PdfWriter
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyFields.FullCompression">
            Gets the 1.5 compression status.
            @return <code>true</code> if the 1.5 compression is on
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyFields.ViewerPreferences">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#setViewerPreferences(int)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopyFieldsImp">
            
             @author  psoares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFieldsImp.SetVisited(iTextSharp.text.pdf.PRIndirectReference)">
            Sets a reference to "visited" in the copy process.
            @param   ref the reference that needs to be set to "visited"
            @return  true if the reference was set to visited
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFieldsImp.IsVisited(iTextSharp.text.pdf.PRIndirectReference)">
            Checks if a reference has already been "visited" in the copy process.
            @param   ref the reference that needs to be checked
            @return  true if the reference was already visited
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFieldsImp.IsPage(iTextSharp.text.pdf.PRIndirectReference)">
            Checks if a reference refers to a page object.
            @param   ref the reference that needs to be checked
            @return  true is the reference refers to a page object.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopyForms">
            Allows you to add one (or more) existing PDF document(s) to
            create a new PDF and add the form of another PDF document to
            this new PDF.
            @since 2.1.5
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfCopyForms.fc">
            The class with the actual implementations. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.#ctor(System.IO.Stream)">
            Creates a new instance.
            @param os the output stream
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.AddDocument(iTextSharp.text.pdf.PdfReader)">
            Concatenates a PDF document.
            @param reader the PDF document
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.AddDocument(iTextSharp.text.pdf.PdfReader,System.Collections.Generic.ICollection{System.Int32})">
            Concatenates a PDF document selecting the pages to keep. The pages are described as a
            <CODE>List</CODE> of <CODE>Integer</CODE>. The page ordering can be changed but
            no page repetitions are allowed.
            @param reader the PDF document
            @param pagesToKeep the pages to keep
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.AddDocument(iTextSharp.text.pdf.PdfReader,System.String)">
            Concatenates a PDF document selecting the pages to keep. The pages are described as
            ranges. The page ordering can be changed but
            no page repetitions are allowed.
            @param reader the PDF document
            @param ranges the comma separated ranges as described in {@link SequenceList}
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.CopyDocumentFields(iTextSharp.text.pdf.PdfReader)">
            Copies the form fields of this PDFDocument onto the PDF-Document which was added
             @param reader the PDF document
             @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.SetEncryption(System.Boolean,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param strength true for 128 bit key length. false for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.Close">
            Closes the output document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.Open">
            Opens the document. This is usually not needed as addDocument() will do it
            automatically.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.AddJavaScript(System.String)">
            Adds JavaScript to the global document
            @param js the JavaScript
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfCopyForms.SetFullCompression" -->
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.interfaces.PdfEncryptionSettings#setEncryption(byte[], byte[], int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#addViewerPreference(com.lowagie.text.pdf.PdfName, com.lowagie.text.pdf.PdfObject)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyForms.SetEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            @see com.lowagie.text.pdf.interfaces.PdfEncryptionSettings#setEncryption(java.security.cert.Certificate[], int[], int)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyForms.Outlines">
            Sets the bookmarks. The list structure is defined in
            <CODE>SimpleBookmark#</CODE>.
            @param outlines the bookmarks or <CODE>null</CODE> to remove any
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyForms.Writer">
            Gets the underlying PdfWriter.
            @return the underlying PdfWriter
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyForms.FullCompression">
            Gets the 1.5 compression status.
            @return <code>true</code> if the 1.5 compression is on
        </member>
        <member name="P:iTextSharp.text.pdf.PdfCopyForms.ViewerPreferences">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#setViewerPreferences(int)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfCopyFormsImp">
            Allows you to add one (or more) existing PDF document(s)
            and add the form(s) of (an)other PDF document(s).
            @since 2.1.5
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFormsImp.#ctor(System.IO.Stream)">
            This sets up the output document 
            @param os The Outputstream pointing to the output document
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFormsImp.CopyDocumentFields(iTextSharp.text.pdf.PdfReader)">
            This method feeds in the source document
            @param reader The PDF reader containing the source document
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfCopyFormsImp.MergeFields">
            This merge fields is slightly different from the mergeFields method
            of PdfCopyFields.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfDashPattern">
             A <CODE>PdfDashPattern</CODE> defines a dash pattern as described in
             the PDF Reference Manual version 1.3 p 325 (section 8.4.3).
            
             @see        PdfArray
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDashPattern.dash">
            This is the length of a dash. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDashPattern.gap">
            This is the length of a gap. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDashPattern.phase">
            This is the phase. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDashPattern.#ctor">
            Constructs a new <CODE>PdfDashPattern</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDashPattern.#ctor(System.Single)">
            Constructs a new <CODE>PdfDashPattern</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDashPattern.#ctor(System.Single,System.Single)">
            Constructs a new <CODE>PdfDashPattern</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDashPattern.#ctor(System.Single,System.Single,System.Single)">
            Constructs a new <CODE>PdfDashPattern</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDashPattern.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
             Returns the PDF representation of this <CODE>PdfArray</CODE>.
            
             @return        an array of <CODE>byte</CODE>s
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfDate" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfString" -->
        <member name="F:iTextSharp.text.pdf.PdfString.value">
            The value of this object. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfString.encoding">
            The encoding. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.#ctor">
            Constructs an empty <CODE>PdfString</CODE>-object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.#ctor(System.String)">
             Constructs a <CODE>PdfString</CODE>-object.
            
             @param        value        the content of the string
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.#ctor(System.String,System.String)">
             Constructs a <CODE>PdfString</CODE>-object.
            
             @param        value        the content of the string
             @param        encoding    an encoding
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.#ctor(System.Byte[])">
             Constructs a <CODE>PdfString</CODE>-object.
            
             @param        bytes    an array of <CODE>byte</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
             Returns the PDF representation of this <CODE>PdfString</CODE>.
            
             @return        an array of <CODE>byte</CODE>s
        </member>
        <member name="M:iTextSharp.text.pdf.PdfString.ToString">
             Returns the <CODE>string</CODE> value of the <CODE>PdfString</CODE>-object.
            
             @return        a <CODE>string</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfString.Encoding">
             Gets the encoding of this string.
            
             @return        a <CODE>string</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDate.#ctor(System.DateTime)">
             Constructs a <CODE>PdfDate</CODE>-object.
            
             @param       d           the date that has to be turned into a <CODE>PdfDate</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDate.#ctor">
            Constructs a <CODE>PdfDate</CODE>-object, representing the current day and time.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDate.SetLength(System.Int32,System.Int32)">
             Adds a number of leading zeros to a given <CODE>string</CODE> in order to get a <CODE>string</CODE>
             of a certain length.
            
             @param       i           a given number
             @param       length      the length of the resulting <CODE>string</CODE>
             @return      the resulting <CODE>string</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDate.GetW3CDate">
            Gives the W3C format of the PdfDate.
            @return a formatted date
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDate.GetW3CDate(System.String)">
            Gives the W3C format of the PdfDate.
            @param d the date in the format D:YYYYMMDDHHmmSSOHH'mm'
            @return a formatted date
        </member>
        <member name="T:iTextSharp.text.pdf.PdfDestination">
             A <CODE>PdfColor</CODE> defines a Color (it's a <CODE>PdfArray</CODE> containing 3 values).
            
             @see        PdfDictionary
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.XYZ">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FIT">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITH">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITV">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITR">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITB">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITBH">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.FITBV">
            This is a possible destination type 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDestination.status">
            Is the indirect reference to a page already added? 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDestination.#ctor(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDestination.#ctor(System.Int32,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDestination.#ctor(System.Int32,System.Single,System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDestination.#ctor(System.Int32,System.Single,System.Single,System.Single,System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfDestination.#ctor(System.String)">
            Creates a PdfDestination based on a String.
            Valid Strings are for instance the values returned by SimpleNamedDestination:
            "Fit", "XYZ 36 806 0",...
            @param    dest    a String notation of a destination.
            @since    iText 5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDestination.HasPage">
             Checks if an indirect reference to a page has been added.
            
             @return    <CODE>true</CODE> or <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDestination.AddPage(iTextSharp.text.pdf.PdfIndirectReference)">
            Adds the indirect reference of the destination page.
            
             @param page    an indirect reference
             @return true if the page reference was added
        </member>
        <member name="T:iTextSharp.text.pdf.PdfDeveloperExtension">
            Beginning with BaseVersion 1.7, the extensions dictionary lets developers
            designate that a given document contains extensions to PDF. The presence
            of the extension dictionary in a document indicates that it may contain
            developer-specific PDF properties that extend a particular base version
            of the PDF specification.
            The extensions dictionary enables developers to identify their own extensions
            relative to a base version of PDF. Additionally, the convention identifies
            extension levels relative to that base version. The intent of this dictionary
            is to enable developers of PDF-producing applications to identify company-specific
            specifications (such as this one) that PDF-consuming applications use to
            interpret the extensions.
            @since   2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.ADOBE_1_7_EXTENSIONLEVEL3">
            An instance of this class for Adobe 1.7 Extension level 3. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL2">
            An instance of this class for ETSI 1.7 Extension level 2. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL5">
            An instance of this class for ETSI 1.7 Extension level 5. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.prefix">
            The prefix used in the Extensions dictionary added to the Catalog. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.baseversion">
            The base version. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDeveloperExtension.extensionLevel">
            The extension level within the baseversion. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDeveloperExtension.#ctor(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfName,System.Int32)">
            Creates a PdfDeveloperExtension object.
            @param prefix    the prefix referring to the developer
            @param baseversion   the number of the base version
            @param extensionLevel    the extension level within the baseverion.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDeveloperExtension.GetDeveloperExtensions">
            Generations the developer extension dictionary corresponding
            with the prefix.
            @return  a PdfDictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDeveloperExtension.Prefix">
            Gets the prefix name.
            @return  a PdfName
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDeveloperExtension.Baseversion">
            Gets the baseversion name.
            @return  a PdfName
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDeveloperExtension.ExtensionLevel">
            Gets the extension level within the baseversion.
            @return  an integer
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfDocument" -->
        <member name="F:iTextSharp.text.pdf.PdfDocument.hangingPunctuation">
            The characters to be applied the hanging punctuation. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.#ctor">
            Constructs a new PDF document.
            @throws DocumentException on error
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.writer">
            The <CODE>PdfWriter</CODE>. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddWriter(iTextSharp.text.pdf.PdfWriter)">
             Adds a <CODE>PdfWriter</CODE> to the <CODE>PdfDocument</CODE>.
            
             @param writer the <CODE>PdfWriter</CODE> that writes everything
                                 what is added to this document to an outputstream.
             @throws DocumentException on error
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.text">
            This is the PdfContentByte object, containing the text. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.graphics">
            This is the PdfContentByte object, containing the borders and other Graphics. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.leading">
            This represents the leading of the lines. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.currentHeight">
            This is the current height of the document. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.isSectionTitle">
            Signals that onParagraph is valid (to avoid that a Chapter/Section title is treated as a Paragraph).
            @since 2.1.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.alignment">
            This represents the current alignment of the PDF Elements. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.anchorAction">
            The current active <CODE>PdfAction</CODE> when processing an <CODE>Anchor</CODE>. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.tabSettings">
            The current tab settings.
            @return	the current
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.leadingStack">
            Signals that the current leading has to be subtracted from a YMark object when positive
            and save current leading
            @since 2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PushLeading">
            Save current @leading
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PopLeading">
            Restore @leading from leadingStack
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.Add(iTextSharp.text.IElement)">
             Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
            
             @param element the element to add
             @return <CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
             @throws DocumentException when a document isn't open yet, or has been closed
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDocument.Open" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDocument.Close" -->
        <member name="M:iTextSharp.text.pdf.PdfDocument.NewPage">
             Makes a new page and sends it to the <CODE>PdfWriter</CODE>.
            
             @return true if new page was added
             @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.SetPageSize(iTextSharp.text.Rectangle)">
             Sets the pagesize.
            
             @param pageSize the new pagesize
             @return <CODE>true</CODE> if the page size was set
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.nextMarginLeft">
            margin in x direction starting from the left. Will be valid in the next page 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.nextMarginRight">
            margin in x direction starting from the right. Will be valid in the next page 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.nextMarginTop">
            margin in y direction starting from the top. Will be valid in the next page 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.nextMarginBottom">
            margin in y direction starting from the bottom. Will be valid in the next page 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.SetMargins(System.Single,System.Single,System.Single,System.Single)">
             Sets the margins.
            
             @param    marginLeft      the margin on the left
             @param    marginRight     the margin on the right
             @param    marginTop       the margin on the top
             @param    marginBottom    the margin on the bottom
             @return   a <CODE>bool</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.SetMarginMirroring(System.Boolean)">
            @see com.lowagie.text.DocListener#setMarginMirroring(bool)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.SetMarginMirroringTopBottom(System.Boolean)">
            @see com.lowagie.text.DocListener#setMarginMirroring(boolean)
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.ResetPageCount">
            Sets the page number to 0.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.firstPageEvent">
            Signals that OnOpenDocument should be called. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDocument.InitPage" -->
        <member name="F:iTextSharp.text.pdf.PdfDocument.line">
            The line that is currently being written. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.lines">
            The lines that are written until now. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.NewLine">
            Adds the current line to the list of lines and also adds an empty line.
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.CalculateLineHeight">
             line.height() is usually the same as the leading
             We should take leading into account if it is not the same as the line.height
            
             @return float combined height of the line
             @since 5.5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.CarriageReturn">
            If the current line is not empty or null, it is added to the arraylist
            of lines and a new empty line is added.
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.GetVerticalPosition(System.Boolean)">
            Gets the current vertical page position.
            @param ensureNewLine Tells whether a new line shall be enforced. This may cause side effects 
              for elements that do not terminate the lines they've started because those lines will get
              terminated. 
            @return The current vertical page position.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.lastElementType">
            Holds the type of the last element, that has been added to the document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.EnsureNewLine">
            Ensures that a new line has been started. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.FlushLines">
             Writes all the lines to the text-object.
            
             @return the displacement that was caused
             @throws DocumentException on error
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfDocument.WriteLineToContent(iTextSharp.text.pdf.PdfLine,iTextSharp.text.pdf.PdfContentByte,iTextSharp.text.pdf.PdfContentByte,System.Object[],System.Single)" -->
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddSpacing(System.Single,System.Single,iTextSharp.text.Font)">
            Calls addSpacing(float, float, Font, boolean (false)).
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddSpacing(System.Single,System.Single,iTextSharp.text.Font,System.Boolean)">
            Adds extra space.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.info">
            some meta information about the Document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.GetCatalog(iTextSharp.text.pdf.PdfIndirectReference)">
             Gets the <CODE>PdfCatalog</CODE>-object.
            
             @param pages an indirect reference to this document pages
             @return <CODE>PdfCatalog</CODE>
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.rootOutline">
            This is the root outline of the document. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.currentOutline">
            This is the current <CODE>PdfOutline</CODE> in the hierarchy of outlines. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddOutline(iTextSharp.text.pdf.PdfOutline,System.String)">
            Adds a named outline to the document .
            @param outline the outline to be added
            @param name the name of this local destination
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.viewerPreferences">
            Contains the Viewer preferences of this PDF document. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#addViewerPreference(com.lowagie.text.pdf.PdfName, com.lowagie.text.pdf.PdfObject) 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.LocalGoto(System.String,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to other part of the document. The jump will
            be made to a local destination with the same name, that must exist.
            @param name the name for this link
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.RemoteGoto(System.String,System.String,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to another document.
            @param filename the filename for the remote document
            @param name the name to jump to
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.RemoteGoto(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            Implements a link to another document.
            @param filename the filename for the remote document
            @param page the page to jump to
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.SetAction(iTextSharp.text.pdf.PdfAction,System.Single,System.Single,System.Single,System.Single)">
            Implements an action in an area.
            @param action the <CODE>PdfAction</CODE>
            @param llx the lower left x corner of the activation area
            @param lly the lower left y corner of the activation area
            @param urx the upper right x corner of the activation area
            @param ury the upper right y corner of the activation area
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.localDestinations">
            Stores the destinations keyed by name. Value is
            <CODE>Object[]{PdfAction,PdfIndirectReference,PdfDestintion}</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.LocalDestination(System.String,iTextSharp.text.pdf.PdfDestination)">
            The local destination to where a local goto with the same
            name will jump to.
            @param name the name of this local destination
            @param destination the <CODE>PdfDestination</CODE> with the jump coordinates
            @return <CODE>true</CODE> if the local destination was added,
            <CODE>false</CODE> if a local destination with the same name
            already existed
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.jsCounter">
            Stores a list of document level JavaScript actions.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.nextPageSize">
            This is the size of the next page. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.thisBoxSize">
            This is the size of the several boxes of the current Page. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.boxSize">
            This is the size of the several boxes that will be used in
            the next page. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.GetBoxSize(System.String)">
            Gives the size of a trim, art, crop or bleed box, or null if not defined.
            @param boxName crop, trim, art or bleed
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.pageEmpty">
            This checks if the page is empty. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.pageResources">
            This are the page resources of the current Page. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.strictImageSequence">
            Holds value of property strictImageSequence. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.imageEnd">
            This is the position where the image ends. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.ClearTextWrap">
            Method added by Pelikan Stephan
            @see com.lowagie.text.DocListener#clearTextWrap()
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.imageWait">
            This is the image that could not be shown on a previous page. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.Add(iTextSharp.text.Image)">
            Adds an image to the document.
            @param image the <CODE>Image</CODE> to add
            @throws PdfException on error
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.AddPTable(iTextSharp.text.pdf.PdfPTable)">
            Adds a <CODE>PdfPTable</CODE> to the document.
            @param ptable the <CODE>PdfPTable</CODE> to be added to the document.
            @throws DocumentException on error
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.Leading">
            Getter for the current leading.
            @return  the current leading
            @since   2.1.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.TabSettings">
            Getter and setter for the current tab stops.
            @since	5.4.0
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.XmpMetadata">
            Use this method to set the XMP Metadata.
            @param xmpMetadata The xmpMetadata to set.
            @throws IOException 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.PageCount">
             Sets the page number.
            
             @param    pageN       the new page number
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.IndentLeft">
             Gets the indentation on the left side.
            
             @return   a margin
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.IndentRight">
             Gets the indentation on the right side.
            
             @return   a margin
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.IndentTop">
             Gets the indentation on the top side.
            
             @return   a margin
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.IndentBottom">
             Gets the indentation on the bottom side.
            
             @return   a margin
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.PdfDocument.Info" -->
        <member name="P:iTextSharp.text.pdf.PdfDocument.RootOutline">
            Gets the root outline. All the outlines must be created with a parent.
            The first level is created with this outline.
            @return the root outline
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.ViewerPreferences">
            @see com.lowagie.text.pdf.interfaces.PdfViewerPreferences#setViewerPreferences(int) 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.Collection">
            Sets the collection dictionary.
            @param collection a dictionary of type PdfCollection
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.AcroForm">
            Gets the AcroForm object.
            @return the PdfAcroform object of the PdfDocument
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.Duration">
            Sets the display duration for the page (for presentations)
            @param seconds   the number of seconds to display the page
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.Transition">
            Sets the transition for the page
            @param transition   the PdfTransition object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.StrictImageSequence">
            Setter for property strictImageSequence.
             @param strictImageSequence New value of property strictImageSequence.
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfDocument.PdfInfo" -->
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.#ctor">
            Construct a <CODE>PdfInfo</CODE>-object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.#ctor(System.String,System.String,System.String)">
             Constructs a <CODE>PdfInfo</CODE>-object.
            
             @param        author      name of the author of the document
             @param        title       title of the document
             @param        subject     subject of the document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddTitle(System.String)">
             Adds the title of the document.
            
             @param    title       the title of the document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddSubject(System.String)">
             Adds the subject to the document.
            
             @param    subject     the subject of the document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddKeywords(System.String)">
             Adds some keywords to the document.
            
             @param    keywords        the keywords of the document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddAuthor(System.String)">
             Adds the name of the author to the document.
            
             @param    author      the name of the author
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddCreator(System.String)">
             Adds the name of the creator to the document.
            
             @param    creator     the name of the creator
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddProducer">
            Adds the name of the producer to the document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfInfo.AddCreationDate">
            Adds the date of creation to the document.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfDocument.PdfCatalog" -->
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfCatalog.#ctor(iTextSharp.text.pdf.PdfIndirectReference,iTextSharp.text.pdf.PdfWriter)">
             Constructs a <CODE>PdfCatalog</CODE>.
            
             @param        pages       an indirect reference to the root of the document's Pages tree.
             @param writer the writer the catalog applies to
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDocument.PdfCatalog.AddNames(System.Collections.Generic.SortedDictionary{System.String,iTextSharp.text.pdf.PdfDocument.Destination},System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.PdfObject},System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.PdfObject},iTextSharp.text.pdf.PdfWriter)">
            Adds the names of the named destinations to the catalog.
            @param localDestinations the local destinations
            @param documentJavaScript the javascript used in the document
            @param writer the writer the catalog applies to
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDocument.PdfCatalog.AdditionalActions">
            Sets the document level additional actions.
            @param actions   dictionary of actions
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.indentLeft">
            This represents the current indentation of the PDF Elements on the left side. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.sectionIndentLeft">
            Indentation to the left caused by a section. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.listIndentLeft">
            This represents the current indentation of the PDF Elements on the left side. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.imageIndentLeft">
            This is the indentation caused by an image on the left. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.indentRight">
            This represents the current indentation of the PDF Elements on the right side. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.sectionIndentRight">
            Indentation to the right caused by a section. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.imageIndentRight">
            This is the indentation caused by an image on the right. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.indentTop">
            This represents the current indentation of the PDF Elements on the top side. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDocument.Indentation.indentBottom">
            This represents the current indentation of the PDF Elements on the bottom side. 
        </member>
        <member name="T:iTextSharp.text.pdf.PdfDocument.Destination">
            @since 5.0.1
        </member>
        <member name="T:iTextSharp.text.pdf.PdfEFStream">
            Extends PdfStream and should be used to create Streams for Embedded Files
            (file attachments).
            @since	2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEFStream.#ctor(System.IO.Stream,iTextSharp.text.pdf.PdfWriter)">
            Creates a Stream object using an InputStream and a PdfWriter object
            @param	in	the InputStream that will be read to get the Stream object
            @param	writer	the writer to which the stream will be added
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEFStream.#ctor(System.Byte[])">
            Creates a Stream object using a byte array
            @param	fileStore	the bytes for the stream
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEFStream.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
            @see com.lowagie.text.pdf.PdfDictionary#toPdf(com.lowagie.text.pdf.PdfWriter, java.io.OutputStream)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfEncodings">
            Supports fast encodings for winansi and PDFDocEncoding.
            
             @author Paulo Soares
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfEncodings.ConvertToBytes(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfEncodings.ConvertToBytes(System.Char,System.String)" -->
        <member name="M:iTextSharp.text.pdf.PdfEncodings.IsPdfDocEncoding(System.String)">
            Checks is <CODE>text</CODE> only has PdfDocEncoding characters.
            @param text the <CODE>String</CODE> to test
            @return <CODE>true</CODE> if only PdfDocEncoding characters are present
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncodings.AddExtraEncoding(System.String,iTextSharp.text.pdf.IExtraEncoding)">
            Adds an extra encoding.
            @param name the name of the encoding. The encoding recognition is case insensitive
            @param enc the conversion class
        </member>
        <member name="T:iTextSharp.text.pdf.PdfEncryption">
            
             @author  Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.key">
            The encryption key for a particular object/generation 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.keySize">
            The encryption key length for a particular object/generation 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.mkey">
            The global encryption key 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.extra">
            Work area to prepare the object/generation bytes 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.md5">
            The message digest algorithm MD5 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.ownerKey">
            The encryption key for the owner 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.userKey">
            The encryption key for the user 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.publicKeyHandler">
            The public key security handler for certificate encryption 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.keyLength">
            The generic key length. It may be 40 or 128. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfEncryption.embeddedFilesOnly">
            Indicates if the encryption is only necessary for embedded files.
            @since 2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.IsEmbeddedFilesOnly">
            Indicates if only the embedded files have to be encrypted.
            @return  if true only the embedded files will be encrypted
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.ComputeOwnerKey(System.Byte[],System.Byte[])">
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.SetupGlobalEncryptionKey(System.Byte[],System.Byte[],System.Byte[],System.Int64)">
            
             ownerKey, documentID must be setuped
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.SetupUserKey">
            
             mkey must be setuped
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.SetupByUserPad(System.Byte[],System.Byte[],System.Byte[],System.Int64)">
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryption.SetupByOwnerPassword(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Int64)">
        </member>
        <member name="T:iTextSharp.text.pdf.PdfEncryptor">
            This class takes any PDF and returns exactly the same but
            encrypted. All the content, links, outlines, etc, are kept.
            It is also possible to change the info dictionary.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @throws DocumentException on error
            @throws IOException on error 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Byte[],System.Byte[],System.Int32,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String})">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @param newInfo an optional <CODE>String</CODE> map to add or change
            the info dictionary. Entries with <CODE>null</CODE>
            values delete the key in the original info dictionary
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Boolean,System.String,System.String,System.Int32)">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param strength <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException on error
            @throws IOException on error 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Boolean,System.String,System.String,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String})">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param strength <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param newInfo an optional <CODE>String</CODE> map to add or change
            the info dictionary. Entries with <CODE>null</CODE>
            values delete the key in the original info dictionary
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Int32,System.String,System.String,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String})">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param type the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param newInfo an optional <CODE>String</CODE> map to add or change
            the info dictionary. Entries with <CODE>null</CODE>
            values delete the key in the original info dictionary
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.Encrypt(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Int32,System.String,System.String,System.Int32)">
            Entry point to encrypt a PDF document. The encryption parameters are the same as in
            <code>PdfWriter</code>. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param reader the read PDF
            @param os the output destination
            @param type the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            values delete the key in the original info dictionary
            @throws DocumentException on error
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.GetPermissionsVerbose(System.Int32)">
            Give you a verbose analysis of the permissions.
            @param permissions the permissions value of a PDF file
            @return a String that explains the meaning of the permissions value
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsPrintingAllowed(System.Int32)">
             Tells you if printing is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if printing is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsModifyContentsAllowed(System.Int32)">
             Tells you if modifying content is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if modifying content is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsCopyAllowed(System.Int32)">
             Tells you if copying is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if copying is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsModifyAnnotationsAllowed(System.Int32)">
             Tells you if modifying annotations is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if modifying annotations is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsFillInAllowed(System.Int32)">
             Tells you if filling in fields is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if filling in fields is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsScreenReadersAllowed(System.Int32)">
             Tells you if repurposing for screenreaders is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if repurposing for screenreaders is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsAssemblyAllowed(System.Int32)">
             Tells you if document assembly is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if document assembly is allowed
            
             @since 2.0.7
        </member>
        <member name="M:iTextSharp.text.pdf.PdfEncryptor.IsDegradedPrintingAllowed(System.Int32)">
             Tells you if degraded printing is allowed.
             @param permissions the permissions value of a PDF file
             @return  true if degraded printing is allowed
            
             @since 2.0.7
        </member>
        <member name="T:iTextSharp.text.pdf.PdfException">
             Signals that an unspecified problem while constructing a PDF document.
            
             @see        BadPdfFormatException
        </member>
        <member name="T:iTextSharp.text.pdf.PdfFileSpecification">
            Specifies a file or an URL. The file can be extern or embedded.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.#ctor">
            Creates a new instance of PdfFileSpecification. The static methods are preferred. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.Url(iTextSharp.text.pdf.PdfWriter,System.String)">
            Creates a file specification of type URL.
            @param writer the <CODE>PdfWriter</CODE>
            @param url the URL
            @return the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileEmbedded(iTextSharp.text.pdf.PdfWriter,System.String,System.String,System.Byte[])">
            Creates a file specification with the file embedded. The file may
            come from the file system or from a byte array. The data is flate compressed.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @param fileDisplay the file information that is presented to the user
            @param fileStore the byte array with the file. If it is not <CODE>null</CODE>
            it takes precedence over <CODE>filePath</CODE>
            @throws IOException on error
            @return the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileEmbedded(iTextSharp.text.pdf.PdfWriter,System.String,System.String,System.Byte[],System.Int32)">
            Creates a file specification with the file embedded. The file may
            come from the file system or from a byte array. The data is flate compressed.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @param fileDisplay the file information that is presented to the user
            @param fileStore the byte array with the file. If it is not <CODE>null</CODE>
            it takes precedence over <CODE>filePath</CODE>
            @param compressionLevel   the compression level to be used for compressing the file
            it takes precedence over <CODE>filePath</CODE>
            @throws IOException on error
            @return the file specification
            @since    2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileEmbedded(iTextSharp.text.pdf.PdfWriter,System.String,System.String,System.Byte[],System.Boolean)">
            Creates a file specification with the file embedded. The file may
            come from the file system or from a byte array.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @param fileDisplay the file information that is presented to the user
            @param fileStore the byte array with the file. If it is not <CODE>null</CODE>
            it takes precedence over <CODE>filePath</CODE>
            @param compress sets the compression on the data. Multimedia content will benefit little
            from compression
            @throws IOException on error
            @return the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileEmbedded(iTextSharp.text.pdf.PdfWriter,System.String,System.String,System.Byte[],System.Boolean,System.String,iTextSharp.text.pdf.PdfDictionary)">
            Creates a file specification with the file embedded. The file may
            come from the file system or from a byte array.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @param fileDisplay the file information that is presented to the user
            @param fileStore the byte array with the file. If it is not <CODE>null</CODE>
            it takes precedence over <CODE>filePath</CODE>
            @param compress sets the compression on the data. Multimedia content will benefit little
            from compression
            @param mimeType the optional mimeType
            @param fileParameter the optional extra file parameters such as the creation or modification date
            @throws IOException on error
            @return the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileEmbedded(iTextSharp.text.pdf.PdfWriter,System.String,System.String,System.Byte[],System.String,iTextSharp.text.pdf.PdfDictionary,System.Int32)">
            Creates a file specification with the file embedded. The file may
            come from the file system or from a byte array.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @param fileDisplay the file information that is presented to the user
            @param fileStore the byte array with the file. If it is not <CODE>null</CODE>
            it takes precedence over <CODE>filePath</CODE>
            @param mimeType the optional mimeType
            @param fileParameter the optional extra file parameters such as the creation or modification date
            @param compressionLevel the level of compression
            @throws IOException on error
            @return the file specification
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.FileExtern(iTextSharp.text.pdf.PdfWriter,System.String)">
            Creates a file specification for an external file.
            @param writer the <CODE>PdfWriter</CODE>
            @param filePath the file path
            @return the file specification
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.SetUnicodeFileName(System.String,System.Boolean)">
            Adds the unicode file name (the key /UF). This entry was introduced
            in PDF 1.7. The filename must have the slash and backslash escaped
            according to the file specification rules.
            @param filename  the filename
            @param unicode   if true, the filename is UTF-16BE encoded; otherwise PDFDocEncoding is used;
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.AddDescription(System.String,System.Boolean)">
            Adds a description for the file that is specified here.
            @param description   some text
            @param unicode       if true, the text is added as a unicode string
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFileSpecification.AddCollectionItem(iTextSharp.text.pdf.collection.PdfCollectionItem)">
            Adds the Collection item dictionary.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFileSpecification.Reference">
            Gets the indirect reference to this file specification.
            Multiple invocations will retrieve the same value.
            @throws IOException on error
            @return the indirect reference
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFileSpecification.MultiByteFileName">
            Sets the file name (the key /F) string as an hex representation
            to support multi byte file names. The name must have the slash and
            backslash escaped according to the file specification rules
            @param fileName the file name as a byte array
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFileSpecification.Volatile">
            Sets a flag that indicates whether an external file referenced by the file
            specification is volatile. If the value is true, applications should never
            cache a copy of the file.
            @param volatile_file if true, the external file should not be cached
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfFont" -->
        <member name="F:iTextSharp.text.pdf.PdfFont.font">
            the font metrics. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFont.size">
            the size. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFont.CompareTo(iTextSharp.text.pdf.PdfFont)">
             Compares this <CODE>PdfFont</CODE> with another
            
             @param    object    the other <CODE>PdfFont</CODE>
             @return    a value
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFont.Width">
             Returns the approximative width of 1 character of this font.
            
             @return        a width in Text Space
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFont.Width(System.Int32)">
             Returns the width of a certain character of this font.
            
             @param        character    a certain character
             @return        a width in Text Space
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFont.Size">
             Returns the size of this font.
            
             @return        a size
        </member>
        <member name="T:iTextSharp.text.pdf.PdfFormField">
            Implements form fields.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFormField.FF_RICHTEXT">
            Allows text fields to support rich text.
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFormField.parent">
            Holds value of property parent. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFormField.#ctor(iTextSharp.text.pdf.PdfWriter,System.Single,System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfAction)">
            Constructs a new <CODE>PdfAnnotation</CODE> of subtype link (Action).
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFormField.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates new PdfFormField 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFormField.Parent">
            Getter for property parent.
            @return Value of property parent.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfFormField.RichValue">
            Sets the rich value for this field.  
            It is suggested that the regular value of this field be set to an 
            equivalent value.  Rich text values are only supported since PDF 1.5,
            and require that the FF_RV flag be set.  See PDF Reference chapter 
            12.7.3.4 for details.
            @param rv HTML markup for the rich value of this field
            @since 5.0.6
        </member>
        <member name="T:iTextSharp.text.pdf.PdfFormXObject">
            <CODE>PdfFormObject</CODE> is a type of XObject containing a template-object.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFormXObject.ZERO">
            This is a PdfNumber representing 0. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFormXObject.ONE">
            This is a PdfNumber representing 1. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfFormXObject.MATRIX">
            This is the 1 - matrix. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFormXObject.#ctor(iTextSharp.text.pdf.PdfTemplate,System.Int32)">
             Constructs a <CODE>PdfFormXObject</CODE>-object.
            
             @param        template        the template
             @param   compressionLevel    the compression level for the stream
             @since   2.1.3 (Replacing the existing constructor with param compressionLevel)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfFunction">
            Implements PDF functions.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfFunction.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates new PdfFunction 
        </member>
        <member name="T:iTextSharp.text.pdf.PdfGState">
            The graphic state dictionary.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_NORMAL">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_COMPATIBLE">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_MULTIPLY">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_SCREEN">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_OVERLAY">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_DARKEN">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_LIGHTEN">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_COLORDODGE">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_COLORBURN">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_HARDLIGHT">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_SOFTLIGHT">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_DIFFERENCE">
            A possible blend mode 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfGState.BM_EXCLUSION">
            A possible blend mode 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.OverPrintStroking">
            Sets the flag whether to apply overprint for stroking.
            @param ov
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.OverPrintNonStroking">
            Sets the flag whether to apply overprint for non stroking painting operations.
            @param ov
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.OverPrintMode">
            Sets the flag whether to toggle knockout behavior for overprinted objects.
            @param ov - accepts 0 or 1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.StrokeOpacity">
            Sets the current stroking alpha constant, specifying the constant shape or
            constant opacity value to be used for stroking operations in the transparent
            imaging model.
            @param n
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.FillOpacity">
            Sets the current stroking alpha constant, specifying the constant shape or
            constant opacity value to be used for nonstroking operations in the transparent
            imaging model.
            @param n
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.AlphaIsShape">
            The alpha source flag specifying whether the current soft mask
            and alpha constant are to be interpreted as shape values (true)
            or opacity values (false). 
            @param v
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.TextKnockout">
            Determines the behaviour of overlapping glyphs within a text object
            in the transparent imaging model.
            @param v
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.BlendMode">
            The current blend mode to be used in the transparent imaging model.
            @param bm
        </member>
        <member name="P:iTextSharp.text.pdf.PdfGState.RenderingIntent">
            Set the rendering intent, possible values are: PdfName.ABSOLUTECOLORIMETRIC,
            PdfName.RELATIVECOLORIMETRIC, PdfName.SATURATION, PdfName.PERCEPTUAL.
            @param ri
        </member>
        <member name="T:iTextSharp.text.pdf.PdfICCBased">
             A <CODE>PdfICCBased</CODE> defines a ColorSpace
            
             @see        PdfStream
        </member>
        <member name="M:iTextSharp.text.pdf.PdfICCBased.#ctor(iTextSharp.text.pdf.ICC_Profile)">
            Creates an ICC stream.
            @param   profile an ICC profile
        </member>
        <member name="M:iTextSharp.text.pdf.PdfICCBased.#ctor(iTextSharp.text.pdf.ICC_Profile,System.Int32)">
             Creates an ICC stream.
            
             @param   compressionLevel    the compressionLevel
            
             @param   profile an ICC profile
             @since   2.1.3   (replacing the constructor without param compressionLevel)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfImage">
            <CODE>PdfImage</CODE> is a <CODE>PdfStream</CODE> containing an image-<CODE>Dictionary</CODE> and -stream.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfImage.name">
            This is the <CODE>PdfName</CODE> of the image. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImage.#ctor(iTextSharp.text.Image,System.String,iTextSharp.text.pdf.PdfIndirectReference)">
             Constructs a <CODE>PdfImage</CODE>-object.
            
             @param image the <CODE>Image</CODE>-object
             @param name the <CODE>PdfName</CODE> for this image
             @throws BadPdfFormatException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImage.GenerateImgResName(iTextSharp.text.Image)">
            Called when no resource name is provided in our constructor.  This generates a 
            name that is required to be unique within a given resource dictionary.
            @since 5.0.1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfImage.Name">
             Returns the <CODE>PdfName</CODE> of the image.
            
             @return        the name
        </member>
        <member name="T:iTextSharp.text.pdf.PdfImportedPage">
            Represents an imported page.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfImportedPage.toCopy">
            True if the imported page has been copied to a writer.
            @since iText 5.0.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.AddImage(iTextSharp.text.Image,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Always throws an error. This operation is not allowed.
            @param image dummy
            @param a dummy
            @param b dummy
            @param c dummy
            @param d dummy
            @param e dummy
            @param f dummy
            @throws DocumentException  dummy 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.AddTemplate(iTextSharp.text.pdf.PdfTemplate,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Always throws an error. This operation is not allowed.
            @param template dummy
            @param a dummy
            @param b dummy
            @param c dummy
            @param d dummy
            @param e dummy
            @param f  dummy 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.GetFormXObject(System.Int32)">
             Gets the stream representing this page.
            
             @param   compressionLevel    the compressionLevel
             @return the stream representing this page
             @since   2.1.3   (replacing the method without param compressionLevel)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.SetFontAndSize(iTextSharp.text.pdf.BaseFont,System.Single)">
            Always throws an error. This operation is not allowed.
            @param bf dummy
            @param size dummy 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.IsToCopy">
            Checks if the page has to be copied.
            @return true if the page has to be copied.
            @since iText 5.0.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfImportedPage.SetCopied">
            Indicate that the resources of the imported page have been copied.
            @since iText 5.0.4
        </member>
        <member name="P:iTextSharp.text.pdf.PdfImportedPage.FromReader">
            Reads the content from this <CODE>PdfImportedPage</CODE>-object from a reader.
            
             @return self
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfImportedPage.Duplicate">
            Always throws an error. This operation is not allowed.
            @return  dummy 
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfIndirectObject" -->
        <member name="F:iTextSharp.text.pdf.PdfIndirectObject.number">
            The object number 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfIndirectObject.generation">
            the generation number 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIndirectObject.#ctor(System.Int32,iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfWriter)">
             Constructs a <CODE>PdfIndirectObject</CODE>.
            
             @param        number            the objecti number
             @param        objecti            the direct objecti
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIndirectObject.#ctor(System.Int32,System.Int32,iTextSharp.text.pdf.PdfObject,iTextSharp.text.pdf.PdfWriter)">
             Constructs a <CODE>PdfIndirectObject</CODE>.
            
             @param        number            the objecti number
             @param        generation        the generation number
             @param        objecti            the direct objecti
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIndirectObject.WriteTo(System.IO.Stream)">
             Writes eficiently to a stream
            
             @param os the stream to write to
             @throws IOException on write error
        </member>
        <member name="P:iTextSharp.text.pdf.PdfIndirectObject.IndirectReference">
             Returns a <CODE>PdfIndirectReference</CODE> to this <CODE>PdfIndirectObject</CODE>.
            
             @return        a <CODE>PdfIndirectReference</CODE>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfIndirectReference" -->
        <member name="F:iTextSharp.text.pdf.PdfIndirectReference.number">
            the object number 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfIndirectReference.generation">
            the generation number 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIndirectReference.#ctor(System.Int32,System.Int32,System.Int32)">
             Constructs a <CODE>PdfIndirectReference</CODE>.
            
             @param        type            the type of the <CODE>PdfObject</CODE> that is referenced to
             @param        number            the object number.
             @param        generation        the generation number.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIndirectReference.#ctor(System.Int32,System.Int32)">
             Constructs a <CODE>PdfIndirectReference</CODE>.
            
             @param        type            the type of the <CODE>PdfObject</CODE> that is referenced to
             @param        number            the object number.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfIndirectReference.Number">
             Returns the number of the object.
            
             @return        a number.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfIndirectReference.Generation">
             Returns the generation of the object.
            
             @return        a number.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfLayer">
             An optional content group is a dictionary representing a collection of graphics
             that can be made visible or invisible dynamically by users of viewer applications.
             In iText they are referenced as layers.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayer.on">
            Holds value of property on.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayer.onPanel">
            Holds value of property onPanel.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.CreateTitle(System.String,iTextSharp.text.pdf.PdfWriter)">
            Creates a title layer. A title layer is not really a layer but a collection of layers
            under the same title heading.
            @param title the title text
            @param writer the <CODE>PdfWriter</CODE>
            @return the title layer
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.#ctor(System.String,iTextSharp.text.pdf.PdfWriter)">
            Creates a new layer.
            @param name the name of the layer
            @param writer the writer
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.AddChild(iTextSharp.text.pdf.PdfLayer)">
            Adds a child layer. Nested layers can only have one parent.
            @param child the child layer
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.SetCreatorInfo(System.String,System.String)">
            Used by the creating application to store application-specific
            data associated with this optional content group.
            @param creator a text string specifying the application that created the group
            @param subtype a string defining the type of content controlled by the group. Suggested
            values include but are not limited to <B>Artwork</B>, for graphic-design or publishing
            applications, and <B>Technical</B>, for technical designs such as building plans or
            schematics
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.SetLanguage(System.String,System.Boolean)">
            Specifies the language of the content controlled by this
            optional content group
            @param lang a language string which specifies a language and possibly a locale
            (for example, <B>es-MX</B> represents Mexican Spanish)
            @param preferred used by viewer applications when there is a partial match but no exact
            match between the system language and the language strings in all usage dictionaries
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.SetZoom(System.Single,System.Single)">
            Specifies a range of magnifications at which the content
            in this optional content group is best viewed.
            @param min the minimum recommended magnification factors at which the group
            should be ON. A negative value will set the default to 0
            @param max the maximum recommended magnification factor at which the group
            should be ON. A negative value will set the largest possible magnification supported by the
            viewer application
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.SetPrint(System.String,System.Boolean)">
            Specifies that the content in this group is intended for
            use in printing
            @param subtype a name specifying the kind of content controlled by the group;
            for example, <B>Trapping</B>, <B>PrintersMarks</B> and <B>Watermark</B>
            @param printstate indicates that the group should be
            set to that state when the document is printed from a viewer application
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayer.SetUser(System.String,System.String[])">
            One of more users for whom this optional content group is primarily intended.
            @param type should be "Ind" (Individual), "Ttl" (Title), or "Org" (Organization).
            @param names one or more names
            @since 5.0.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.Parent">
            Gets the parent layer.
            @return the parent layer or <CODE>null</CODE> if the layer has no parent
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.Children">
            Gets the children layers.
            @return the children layers or <CODE>null</CODE> if the layer has no children
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.Ref">
            Gets the <CODE>PdfIndirectReference</CODE> that represents this layer.
            @return the <CODE>PdfIndirectReference</CODE> that represents this layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.Name">
            Sets the name of this layer.
            @param name the name of this layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.PdfObject">
            Gets the dictionary representing the layer. It just returns <CODE>this</CODE>.
            @return the dictionary representing the layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.On">
            Gets the initial visibility of the layer.
            @return the initial visibility of the layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.Export">
            Specifies the recommended state for content in this
            group when the document (or part of it) is saved by a viewer application to a format
            that does not support optional content (for example, an earlier version of
            PDF or a raster image format).
            @param export the export state
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.View">
            Indicates that the group should be set to that state when the
            document is opened in a viewer application.
            @param view the view state
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.PageElement">
            Indicates that the group contains a pagination artifact.
            @param pe one of the following names: "HF" (Header Footer),
            "FG" (Foreground), "BG" (Background), or "L" (Logo).
            @since 5.0.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayer.OnPanel">
            Gets the layer visibility in Acrobat's layer panel
            @return the layer visibility in Acrobat's layer panel
            Sets the visibility of the layer in Acrobat's layer panel. If <CODE>false</CODE>
            the layer cannot be directly manipulated by the user. Note that any children layers will
            also be absent from the panel.
            @param onPanel the visibility of the layer in Acrobat's layer panel
        </member>
        <member name="T:iTextSharp.text.pdf.PdfLayerMembership">
             Content typically belongs to a single optional content group,
             and is visible when the group is <B>ON</B> and invisible when it is <B>OFF</B>. To express more
             complex visibility policies, content should not declare itself to belong to an optional
             content group directly, but rather to an optional content membership dictionary
             represented by this class.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayerMembership.ALLON">
            Visible only if all of the entries are <B>ON</B>.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayerMembership.ANYON">
            Visible if any of the entries are <B>ON</B>.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayerMembership.ANYOFF">
            Visible if any of the entries are <B>OFF</B>.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLayerMembership.ALLOFF">
            Visible only if all of the entries are <B>OFF</B>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayerMembership.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates a new, empty, membership layer.
            @param writer the writer
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLayerMembership.AddMember(iTextSharp.text.pdf.PdfLayer)">
            Adds a new member to the layer.
            @param layer the new member to the layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayerMembership.Ref">
            Gets the <CODE>PdfIndirectReference</CODE> that represents this membership layer.
            @return the <CODE>PdfIndirectReference</CODE> that represents this layer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayerMembership.Layers">
            Gets the member layers.
            @return the member layers
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayerMembership.VisibilityPolicy">
            Sets the visibility policy for content belonging to this
            membership dictionary. Possible values are ALLON, ANYON, ANYOFF and ALLOFF.
            The default value is ANYON.
            @param type the visibility policy
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayerMembership.VisibilityExpression">
            Sets the visibility expression for content belonging to this
            membership dictionary.
            @param ve A (nested) array of which the first value is /And, /Or, or /Not
            followed by a series of indirect references to OCGs or other visibility
            expressions.
            @since 5.0.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLayerMembership.PdfObject">
            Gets the dictionary representing the membership layer. It just returns <CODE>this</CODE>.
            @return the dictionary representing the layer
        </member>
        <member name="T:iTextSharp.text.pdf.PdfLine">
            <CODE>PdfLine</CODE> defines an array with <CODE>PdfChunk</CODE>-objects
            that fit into 1 line.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.line">
            The arraylist containing the chunks. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.left">
            The left indentation of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.width">
            The width of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.alignment">
            The alignment of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.height">
            The heigth of the line. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.newlineSplit">
            <CODE>true</CODE> if the chunk splitting was caused by a newline. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfLine.originalWidth">
            The original width. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.#ctor(System.Single,System.Single,System.Int32,System.Single)">
             Constructs a new <CODE>PdfLine</CODE>-object.
            
             @param    left        the limit of the line at the left
             @param    right        the limit of the line at the right
             @param    alignment    the alignment of the line
             @param    height        the height of the line
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.#ctor(System.Single,System.Single,System.Single,System.Int32,System.Boolean,System.Collections.Generic.List{iTextSharp.text.pdf.PdfChunk},System.Boolean)">
            Creates a PdfLine object.
            @param left              the left offset
            @param originalWidth     the original width of the line
            @param remainingWidth    bigger than 0 if the line isn't completely filled
            @param alignment         the alignment of the line
            @param newlineSplit      was the line splitted (or does the paragraph end with this line)
            @param line              an array of PdfChunk objects
            @param isRTL             do you have to read the line from Right to Left?
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.Add(iTextSharp.text.pdf.PdfChunk,System.Single)">
             Adds a <CODE>PdfChunk</CODE> to the <CODE>PdfLine</CODE>.
            
             @param		chunk		        the <CODE>PdfChunk</CODE> to add
             @param		currentLeading		new value for the height of the line
             @return		<CODE>null</CODE> if the chunk could be added completely; if not
            				a <CODE>PdfChunk</CODE> containing the part of the chunk that could
            				not be added is returned
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.Add(iTextSharp.text.pdf.PdfChunk)">
             Adds a <CODE>PdfChunk</CODE> to the <CODE>PdfLine</CODE>.
            
             @param        chunk        the <CODE>PdfChunk</CODE> to add
             @return        <CODE>null</CODE> if the chunk could be added completely; if not
                            a <CODE>PdfChunk</CODE> containing the part of the chunk that could
                            not be added is returned
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.GetEnumerator">
             Returns an iterator of <CODE>PdfChunk</CODE>s.
            
             @return    an <CODE>Iterator</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.HasToBeJustified">
             Checks if this line has to be justified.
            
             @return    <CODE>true</CODE> if the alignment equals <VAR>ALIGN_JUSTIFIED</VAR> and there is some width left.
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfLine.ResetAlignment" -->
        <member name="M:iTextSharp.text.pdf.PdfLine.SetExtraIndent(System.Single)">
            Adds extra indentation to the left (for Paragraph.setFirstLineIndent). 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.ToString">
             Get the string representation of what is in this line.
            
             @return    a <CODE>string</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.GetChunk(System.Int32)">
            Gets a <CODE>PdfChunk</CODE> by index.
            @param idx the index
            @return the <CODE>PdfChunk</CODE> or null if beyond the array
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.GetMaxSize(System.Single,System.Single)">
            Gets the difference between the "normal" leading and the maximum
            size (for instance when there are images in the chunk and the leading
            has to be taken into account).
            @return  an extra leading for images
            @since   2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfLine.GetSeparatorCount">
            Gets the number of separators in the line.
            Returns -1 if there's a tab in the line.
            @return  the number of separators in the line
            @since   2.1.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.Size">
             Returns the number of chunks in the line.
            
             @return    a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.Height">
             Returns the height of the line.
            
             @return    a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.IndentLeft">
             Returns the left indentation of the line taking the alignment of the line into account.
            
             @return    a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.WidthLeft">
             Returns the width that is left, after a maximum of characters is added to the line.
            
             @return    a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.NumberOfSpaces">
             Returns the number of space-characters in this line.
            
             @return    a value
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.PdfLine.ListItem" -->
        <member name="P:iTextSharp.text.pdf.PdfLine.ListSymbol">
             Returns the listsymbol of this line.
            
             @return    a <CODE>PdfChunk</CODE> if the line has a listsymbol; <CODE>null</CODE> otherwise
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.ListIndent">
             Return the indentation needed to show the listsymbol.
            
             @return    a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.NewlineSplit">
            Checks if a newline caused the line split.
            @return <CODE>true</CODE> if a newline caused the line split
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.LastStrokeChunk">
            Gets the index of the last <CODE>PdfChunk</CODE> with metric attributes
            @return the last <CODE>PdfChunk</CODE> with metric attributes
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.OriginalWidth">
            Gets the original width of the line.
            @return the original width of the line
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.Ascender">
            Gets the maximum size of the ascender for all the fonts used
            in this line.
            @return maximum size of all the ascenders used in this line
        </member>
        <member name="P:iTextSharp.text.pdf.PdfLine.Descender">
            Gets the biggest descender for all the fonts used 
            in this line.  Note that this is a negative number.
            @return maximum size of all the ascenders used in this line
        </member>
        <member name="T:iTextSharp.text.pdf.PdfLiteral">
            a Literal
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfName" -->
        <member name="F:iTextSharp.text.pdf.PdfName._3D">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.A">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.A85">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ABSOLUTECOLORIMETRIC">
            A name
            @since 2.1.5 renamed from ABSOLUTECALORIMETRIC
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ACROFORM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ACTION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ACTIVATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ACTUALTEXT">
            a name used in PDF structure
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE_PKCS7_DETACHED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE_PKCS7_S4">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE_PKCS7_S5">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE_PKCS7_SHA1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADBE_X509_RSA_SHA1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADOBE_PPKLITE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ADOBE_PPKMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AESV2">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AESV3">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AFRELATIONSHIP">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AHX">
            A name
            @since 5.0.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AIS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALLPAGES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALT">
            Use ALT to specify alternate texts in Tagged PDF.
            For alternate ICC profiles, use {@link #ALTERNATE}
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALTERNATE">
            Use ALTERNATE only in ICC profiles. It specifies an alternative color
            space, in case the primary one is not supported, for legacy purposes.
            For various types of alternate texts in Tagged PDF, use {@link #ALT}
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AF">
            A name
            @since 5.5.8
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALTERNATEPRESENTATION">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ALTERNATES">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ANIMATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ANNOT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ANNOTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ANTIALIAS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.APP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.APPDEFAULT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ART">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ARTBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ARTIFACT">
            A name
            @since 5.4.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ASCENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ASCII85DECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ASCIIHEXDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ASSET">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ASSETS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ATTACHED">
            A name
            @since 5.4.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AUTHEVENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.AUTHOR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.B">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BACKGROUND">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BACKGROUNDCOLOR">
            A name
            @since	5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BASEENCODING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BASEFONT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BASEVERSION">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BG">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BIBENTRY">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BIGFIVE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BINDING">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BINDINGMATERIALNAME">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BITSPERCOMPONENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BITSPERSAMPLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BLACKIS1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BLACKPOINT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BLOCKQUOTE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BLEEDBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BLINDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BORDER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BOTH">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BOUNDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BTN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.BYTERANGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.C">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.C0">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.C1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ca">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CALGRAY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CALRGB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CAPHEIGHT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CARET">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CAPTION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CATALOG">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CATEGORY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CB">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CCITTFAXDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CENTER">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CENTERWINDOW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CERT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CFM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CH">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CHARPROCS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CHECKSUM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIDFONTTYPE0">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIDFONTTYPE2">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIDSET">
            A name
            @since 2.0.7
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIDSYSTEMINFO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIDTOGIDMAP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CIRCLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CLASSMAP">
            A name
            @since 5.3.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CLOUD">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CMD">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CODE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLOR">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLORS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLORSPACE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLORTRANSFORM">
            A name
            @since 5.4.4 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTIONFIELD">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTIONITEM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTIONSCHEMA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTIONSORT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLLECTIONSUBITEM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLSPAN">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLUMN">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COLUMNS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONDITION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONFIGS">
            A name
            @since 5.4.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONFIGURATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONFIGURATIONS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONTACTINFO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONTENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CONTENTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COORDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COUNT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COURIER">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COURIER_BOLD">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COURIER_OBLIQUE">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.COURIER_BOLDOBLIQUE">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CREATIONDATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CREATOR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CREATORINFO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CROPBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CRYPT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CUEPOINT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CUEPOINTS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.CYX">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.D">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DATA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DCS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DCTDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DECIMAL">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEACTIVATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DECODEPARMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEFAULT">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEFAULTCRYPTFILTER">
            A name
            @since	2.1.5 renamed from DEFAULTCRYPTFILER
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEFAULTCMYK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEFAULTGRAY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEFAULTRGB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DESC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DESCENDANTFONTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DESCENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEST">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DESTOUTPUTPROFILE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DESTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEVICEGRAY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEVICERGB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEVICECMYK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DEVICEN">
            A name
            @since 5.2.1
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DIFFERENCES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DISSOLVE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DIRECTION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DISPLAYDOCTITLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DIV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOS">
            A name
            @since 5.2.1
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOCMDP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOCOPEN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOCTIMESTAMP">
            A name
            @since 5.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOCUMENT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DOMAIN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DUR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DUPLEX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DUPLEXFLIPSHORTEDGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DUPLEXFLIPLONGEDGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.DW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.E">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EARLYCHANGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EFF">
            A name
            @since	2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EFOPEN">
            A name
            @since	2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EMBEDDED">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EMBEDDEDFILE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EMBEDDEDFILES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENCODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENCODEDBYTEALIGN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENCODING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENCRYPT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENCRYPTMETADATA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.END">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENDINDENT">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENDOFBLOCK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ENDOFLINE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EPSG">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ESIC">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXCLUDE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXTEND">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXTENSIONS">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXTENSIONLEVEL">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXTGSTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXPORT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EXPORTSTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.EVENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.F">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FAR">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FD">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FDECODEPARMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FDF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FFILTER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIELDMDP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIELDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIGURE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FILEATTACHMENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FILESPEC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FILTER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIRST">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIRSTCHAR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIRSTPAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FIT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITH">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITBH">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITBV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FITWINDOW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FLAGS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FLASH">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FLASHVARS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FLATEDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTBBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTDESCRIPTOR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTFAMILY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTFILE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTFILE2">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTFILE3">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTMATRIX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTNAME">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FONTWEIGHT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FOREGROUND">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FORM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FORMTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FORMULA">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FREETEXT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FRM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FULLSCREEN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FUNCTION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FUNCTIONS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.FUNCTIONTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GAMMA">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GBK">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GCS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GEO">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GEOGCS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GLITTER">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GOTO">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GOTO3DVIEW">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GOTOE">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GOTOR">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GPTS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GROUP">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GTS_PDFA1">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GTS_PDFX">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.GTS_PDFXVERSION">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H1">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H2">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H3">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H4">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H5">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.H6">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HALFTONENAME">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HALFTONETYPE">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HALIGN">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HEADERS">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HEIGHT">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HELV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HELVETICA">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HELVETICA_BOLD">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HELVETICA_OBLIQUE">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HELVETICA_BOLDOBLIQUE">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HID">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HIDE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HIDEMENUBAR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HIDETOOLBAR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HIDEWINDOWUI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HIGHLIGHT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HOFFSET">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HT">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.HTP">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.I">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IC">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ICCBASED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ID">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IDENTITY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IDTREE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IM">
            A name
            @since 5.5.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMAGEB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMAGEC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMAGEI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMAGEMASK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INCLUDE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INDEX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INDEXED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INFO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INKLIST">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INSTANCES">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IMPORTDATA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INTENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.INTERPOLATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ISMAP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IRT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ITALICANGLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ITXT">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.IX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JAVASCRIPT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JBIG2DECODE">
            A name
            @since	2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JBIG2GLOBALS">
            A name
            @since	2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JPXDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.JUSTIFY">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.K">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.KEYWORDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.KIDS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.L">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.L2R">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LAB">
            A name
            @since 5.1.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LANG">
            An entry specifying the natural language, and optionally locale. Use this
            to specify the Language attribute on a Tagged Pdf element.
            For the content usage dictionary, use {@link #LANGUAGE}
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LANGUAGE">
            A dictionary type, strictly for use in the content usage dictionary. For
            dictionary entries in Tagged Pdf, use {@link #LANG}
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LAST">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LASTCHAR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LASTPAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LAUNCH">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LAYOUT">
            A name
            @since 5.5.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LBL">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LBODY">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LENGTH">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LENGTH1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LI">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LIMITS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LINE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LINEAR">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LINEHEIGHT">
            A name
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LINK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LIST">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LISTMODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LISTNUMBERING">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LOCATION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LOCK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LOCKED">
            A name
            @since	2.1.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LOWERALPHA">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LOWERROMAN">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LPTS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.LZWDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.M">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAC">
            A name
            @since 5.2.1
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MATERIAL">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MATRIX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAC_EXPERT_ENCODING">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAC_ROMAN_ENCODING">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MARKED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MARKINFO">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MASK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAX_LOWER_CASE">
            A name
            @since	2.1.6 renamed from MAX
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAX_CAMEL_CASE">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MAXLEN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MEDIABOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MCID">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MCR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MEASURE">
            A name
            @since   5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.METADATA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MIN_LOWER_CASE">
            A name
            @since	2.1.6 renamed from MIN
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MIN_CAMEL_CASE">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MMTYPE1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MODDATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.MOVIE">
            A name
            @since	5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N0">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N2">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N3">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.N4">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NAME">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NAMED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NAMES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NAVIGATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NAVIGATIONPANE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEAR">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEEDAPPEARANCES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEEDRENDERING">
            A name.
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEWWINDOW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEXT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NEXTPAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NONE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NONFULLSCREENPAGEMODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NONSTRUCT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NOTE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NUMBERFORMAT">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NUMCOPIES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.NUMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.O">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OBJ">
            A name used with Document Structure
            @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OBJR">
            a name used with Document Structure
            @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OBJSTM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OCG">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OCGS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OCMD">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OCPROPERTIES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.Off_">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OFF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ON">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ONECOLUMN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OPEN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OPENACTION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.op_">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OPI">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OPM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OPT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ORDER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ORDERING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OSCILLATING">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OUTLINES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OUTPUTCONDITION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OUTPUTCONDITIONIDENTIFIER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OUTPUTINTENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OUTPUTINTENTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.OVERLAYTEXT">
            A name
            @since 5.5.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.P">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAGELABELS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAGELAYOUT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAGEMODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAGES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PAINTTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PANOSE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PARAMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PARENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PARENTTREE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PARENTTREENEXTKEY">
            A name used in defining Document Structure.
            @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PART">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PASSCONTEXTCLICK">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PATTERN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PATTERNTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PB">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PC">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PDF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PDFDOCENCODING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PDU">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PERCEPTUAL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PERMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PG">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PI">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PICKTRAYBYPDFSIZE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PIECEINFO">
            A name
            @since 5.5.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PLAYCOUNT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PO">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.POLYGON">
            A name
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.POLYLINE">
            A name
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.POPUP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.POSITION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PREDICTOR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PREFERRED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRESENTATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRESERVERB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRESSTEPS">
            A name.
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PREV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PREVPAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTAREA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTCLIP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTERMARK">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTFIELD">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTPAGERANGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTSCALING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRINTSTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRIVATE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PROCSET">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PRODUCER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PROJCS">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PROP_BUILD">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PROPERTIES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PTDATA">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PUBSEC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.PV">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.Q">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.QUADPOINTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.QUOTE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.R">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.R2L">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RANGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RB">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.rb">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RBGROUPS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RD">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REASON">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RECIPIENTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RECT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REDACT">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REFERENCE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REGISTRY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REGISTRYNAME">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RELATIVECOLORIMETRIC">
            A name
            @since	2.1.5 renamed from RELATIVECALORIMETRIC
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RENDITION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.REPEAT">
            A name
            @since 5.5.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RESETFORM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RESOURCES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIA">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAACTIVATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAANIMATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIACOMMAND">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIACONFIGURATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIACONTENT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIADEACTIVATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAEXECUTE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAINSTANCE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAPARAMS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAPOSITION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAPRESENTATION">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIASETTINGS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RICHMEDIAWINDOW">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RL">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROLE">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RO">
            A name
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROLEMAP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROOT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROW">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROWS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ROWSPAN">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RP">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RT">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RUBY">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RUNLENGTHDECODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.RV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.S">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SATURATION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SCHEMA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SCOPE">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SCREEN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SCRIPTS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SECT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SEPARATION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SETOCGSTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SETTINGS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SHADING">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SHADINGTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SHIFT_JIS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIG">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIGFIELDLOCK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIGFLAGS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIGREF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIMPLEX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SINGLEPAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SIZE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SMASK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SORT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SOUND">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SPACEAFTER">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SPACEBEFORE">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SPAN">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SPEED">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SPLIT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SQUARE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SQUIGGLY">
            A name
            @since 2.1.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SS">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ST">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STAMP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STANDARD">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.START">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STARTINDENT">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STATUS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STDCF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STEMV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STMF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRIKEOUT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRUCTELEM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRUCTPARENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRUCTPARENTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STRUCTTREEROOT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.STYLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUBFILTER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUBJECT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUBMITFORM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUBTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUMMARY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SUPPLEMENT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SV">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.SYMBOL">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.T">
            T is very commonly used for various dictionary entries, including title
            entries in a Tagged PDF element dictionary, and target dictionaries.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TA">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TABLE">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TABS">
            A name
            @since	2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TBODY">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TD">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TR">
            A name
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TR2">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXTALIGN">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXTDECORATIONCOLOR">
            A name
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXTDECORATIONTHICKNESS">
            A name
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXTDECORATIONTYPE">
            A name
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TEXTINDENT">
            A name
            @since 5.3.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TFOOT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TH">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.THEAD">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.THUMB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.THREADS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TIME">
            A name
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TILINGTYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TIMES_ROMAN">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TIMES_BOLD">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TIMES_ITALIC">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TIMES_BOLDITALIC">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TITLE">
            Use Title for the document's top level title (optional), and for document
            outline dictionaries, which can store bookmarks.
            For all other uses of a title entry, including Tagged PDF, use {@link #T}
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TK">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TOC">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TOCI">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TOGGLE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TOOLBAR">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TOUNICODE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TABLEROW">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRANS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRANSFORMPARAMS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRANSFORMMETHOD">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRANSPARENCY">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRANSPARENT">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRAPNET">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRAPPED">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRIMBOX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TRUETYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TU">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TV">
            A name 
            @since 5.4.4
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TWOCOLUMNLEFT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TWOCOLUMNRIGHT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TWOPAGELEFT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TWOPAGERIGHT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TX">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TYPE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TYPE0">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TYPE1">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.TYPE3">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.U">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UF">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UHC">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UNDERLINE">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UNIX">
            A name
            @since 5.2.1
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UPPERALPHA">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UPPERROMAN">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UR">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UR3">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.URI">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.URL">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USAGE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USEATTACHMENTS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USENONE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USEOC">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USEOUTLINES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USER">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USERPROPERTIES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USERUNIT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.USETHUMBS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.UTF_8">
            A name
            @since 5.4.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.V">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.V2">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VALIGN">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VERISIGN_PPKVS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VERSION">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VERTICES">
            A name
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIDEO">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEW">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWS">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWAREA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWCLIP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWERPREFERENCES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWPORT">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VIEWSTATE">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VISIBLEPAGES">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VOFFSET">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.VP">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.W">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.W2">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WARICHU">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WATERMARK">
            A name
            @since 5.4.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WC">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIDGET">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIDTH">
            A name of an attribute. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIDTHS">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIN">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIN_ANSI_ENCODING">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WINDOW">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WINDOWED">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WIPE">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WHITEPOINT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WKT">
            A name of an attribute.
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WS">
            A name of an encoding 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.WT">
            A name
            @since 5.4.3
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.X">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XA">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XD">
            A name
            @since 2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XFA">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XML">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XOBJECT">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XPTS">
            A name
            @since 5.1.0
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XREF">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XREFSTM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XSTEP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.XYZ">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.YSTEP">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ZADB">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ZAPFDINGBATS">
            A name of a base 14 type 1 font 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.ZOOM">
            A name 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfName.staticNames">
            map strings to all known static names
            @since 2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.#cctor">
            Use reflection to cache all the static public readonly names so
            future <code>PdfName</code> additions don't have to be "added twice".
            A bit less efficient (around 50ms spent here on a 2.2ghz machine),
             but Much Less error prone.
            @since 2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.#ctor(System.String)">
            Constructs a new <CODE>PdfName</CODE>. The name length will be checked.
            @param name the new name
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.#ctor(System.String,System.Boolean)">
            Constructs a new <CODE>PdfName</CODE>.
            @param name the new name
            @param lengthCheck if <CODE>true</CODE> check the lenght validity, if <CODE>false</CODE> the name can
            have any length
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfName.CompareTo(iTextSharp.text.pdf.PdfName)" -->
        <member name="M:iTextSharp.text.pdf.PdfName.Equals(System.Object)">
             Indicates whether some other object is "equal to" this one.
            
             @param   obj   the reference object with which to compare.
             @return  <code>true</code> if this object is the same as the obj
                      argument; <code>false</code> otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.GetHashCode">
             Returns a hash code value for the object. This method is
             supported for the benefit of hashtables such as those provided by
             <code>java.util.Hashtable</code>.
            
             @return  a hash code value for this object.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.EncodeName(System.String)">
             Encodes a plain name given in the unescaped form "AB CD" into "/AB#20CD".
            
             @param name the name to encode
             @return the encoded name
             @since	2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfName.DecodeName(System.String)">
            Decodes an escaped name in the form "/AB#20CD" into "AB CD".
            @param name the name to decode
            @return the decoded name
        </member>
        <member name="T:iTextSharp.text.pdf.PdfNameTree">
            Creates a name tree.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNameTree.WriteTree``1(System.Collections.Generic.Dictionary{System.String,``0},iTextSharp.text.pdf.PdfWriter)">
            Creates a name tree.
            @param items the item of the name tree. The key is a <CODE>String</CODE>
            and the value is a <CODE>PdfObject</CODE>. Note that although the
            keys are strings only the lower byte is used and no check is made for chars
            with the same lower byte and different upper byte. This will generate a wrong
            tree name.
            @param writer the writer
            @throws IOException on error
            @return the dictionary with the name tree. This dictionary is the one
            generally pointed to by the key /Dests, for example
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfNull" -->
        <member name="F:iTextSharp.text.pdf.PdfNull.PDFNULL">
            This is an instance of the <CODE>PdfNull</CODE>-object. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfNull.#ctor" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfNumber" -->
        <member name="F:iTextSharp.text.pdf.PdfNumber.value">
            actual value of this <CODE>PdfNumber</CODE>, represented as a <CODE>double</CODE> 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.#ctor(System.String)">
             Constructs a <CODE>PdfNumber</CODE>-object.
            
             @param        content            value of the new <CODE>PdfNumber</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.#ctor(System.Int32)">
             Constructs a new int <CODE>PdfNumber</CODE>-object.
            
             @param        value                value of the new <CODE>PdfNumber</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.#ctor(System.Int64)">
             Constructs a new long <CODE>PdfNumber</CODE>-object.
            
             @param        value                value of the new <CODE>PdfNumber</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.#ctor(System.Double)">
             Constructs a new REAL <CODE>PdfNumber</CODE>-object.
            
             @param        value                value of the new <CODE>PdfNumber</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.#ctor(System.Single)">
             Constructs a new REAL <CODE>PdfNumber</CODE>-object.
            
             @param        value                value of the new <CODE>PdfNumber</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumber.Increment">
            Increments the value of the <CODE>PdfNumber</CODE>-object with 1.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfNumber.IntValue">
             Returns the primitive <CODE>int</CODE> value of this object.
            
             @return        a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfNumber.LongValue">
             Returns the primitive <CODE>long</CODE> value of this object.
            
             @return        a value
        </member>
        <member name="P:iTextSharp.text.pdf.PdfNumber.DoubleValue">
             Returns the primitive <CODE>double</CODE> value of this object.
            
             @return        a value
        </member>
        <member name="T:iTextSharp.text.pdf.PdfNumberTree">
            Creates a number tree.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfNumberTree.WriteTree``1(System.Collections.Generic.Dictionary{System.Int32,``0},iTextSharp.text.pdf.PdfWriter)">
            Creates a number tree.
            @param items the item of the number tree. The key is an <CODE>Integer</CODE>
            and the value is a <CODE>PdfObject</CODE>.
            @param writer the writer
            @throws IOException on error
            @return the dictionary with the number tree.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfOutline" -->
        <member name="F:iTextSharp.text.pdf.PdfOutline.reference">
            the <CODE>PdfIndirectReference</CODE> of this object 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.count">
            value of the <B>Count</B>-key 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.parent">
            value of the <B>Parent</B>-key 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.destination">
            value of the <B>Destination</B>-key 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.action">
            The <CODE>PdfAction</CODE> for this outline.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.tag">
            Holds value of property tag. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.open">
            Holds value of property open. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.color">
            Holds value of property color. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfOutline.style">
            Holds value of property style. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfWriter)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,iTextSharp.text.pdf.PdfString)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,iTextSharp.text.pdf.PdfString,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,iTextSharp.text.pdf.PdfString)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,iTextSharp.text.pdf.PdfString,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfAction,iTextSharp.text.Paragraph,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,iTextSharp.text.Paragraph)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfOutline.#ctor(iTextSharp.text.pdf.PdfOutline,iTextSharp.text.pdf.PdfDestination,iTextSharp.text.Paragraph,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.PdfOutline.InitOutline(iTextSharp.text.pdf.PdfOutline,System.String,System.Boolean)">
            Helper for the constructors.
            @param parent the parent outline
            @param title the title for this outline
            @param open <CODE>true</CODE> if the children are visible
        </member>
        <member name="M:iTextSharp.text.pdf.PdfOutline.SetDestinationPage(iTextSharp.text.pdf.PdfIndirectReference)">
             Set the page of the <CODE>PdfDestination</CODE>-object.
            
             @param pageReference indirect reference to the page
             @return <CODE>true</CODE> if this page was set as the <CODE>PdfDestination</CODE>-page.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfOutline.ToPdf(iTextSharp.text.pdf.PdfWriter,System.IO.Stream)">
             Returns the PDF representation of this <CODE>PdfOutline</CODE>.
            
             @param writer the encryption information
             @param os
             @throws IOException
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.IndirectReference">
             Gets the indirect reference of this <CODE>PdfOutline</CODE>.
            
             @return      the <CODE>PdfIndirectReference</CODE> to this outline.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.Parent">
             Gets the parent of this <CODE>PdfOutline</CODE>.
            
             @return      the <CODE>PdfOutline</CODE> that is the parent of this outline.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.PdfDestination">
            Gets the destination for this outline.
            @return the destination
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.Level">
             returns the level of this outline.
            
             @return      a level
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.Tag">
            Getter for property tag.
            @return Value of property tag.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfOutline.Open">
            Setter for property open.
            @param open New value of property open.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfPage" -->
        <member name="F:iTextSharp.text.pdf.PdfPage.PORTRAIT">
            value of the <B>Rotate</B> key for a page in PORTRAIT 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPage.LANDSCAPE">
            value of the <B>Rotate</B> key for a page in LANDSCAPE 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPage.INVERTEDPORTRAIT">
            value of the <B>Rotate</B> key for a page in INVERTEDPORTRAIT 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPage.SEASCAPE">
            value of the <B>Rotate</B> key for a page in SEASCAPE 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPage.mediaBox">
            value of the <B>MediaBox</B> key 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPage.#ctor(iTextSharp.text.pdf.PdfRectangle,System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.PdfRectangle},iTextSharp.text.pdf.PdfDictionary,System.Int32)">
             Constructs a <CODE>PdfPage</CODE>.
            
             @param		mediaBox		a value for the <B>MediaBox</B> key
             @param		resources		an indirect reference to a <CODE>PdfResources</CODE>-object
             @param		rotate			a value for the <B>Rotate</B> key
             @throws DocumentException 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPage.#ctor(iTextSharp.text.pdf.PdfRectangle,System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.PdfRectangle},iTextSharp.text.pdf.PdfDictionary)">
             Constructs a <CODE>PdfPage</CODE>.
            
             @param		mediaBox		a value for the <B>MediaBox</B> key
             @param		resources		an indirect reference to a <CODE>PdfResources</CODE>-object
             @throws DocumentException 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPage.IsParent" -->
        <member name="M:iTextSharp.text.pdf.PdfPage.Add(iTextSharp.text.pdf.PdfIndirectReference)">
             Adds an indirect reference pointing to a <CODE>PdfContents</CODE>-object.
            
             @param       contents        an indirect reference to a <CODE>PdfContents</CODE>-object
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPage.RotateMediaBox">
             Rotates the mediabox, but not the text in it.
            
             @return      a <CODE>PdfRectangle</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPage.MediaBox">
             Returns the MediaBox of this Page.
            
             @return      a <CODE>PdfRectangle</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPageLabels">
            Page labels are used to identify each
            page visually on the screen or in print.
            @author  Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.DECIMAL_ARABIC_NUMERALS">
            Logical pages will have the form 1,2,3,...
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.UPPERCASE_ROMAN_NUMERALS">
            Logical pages will have the form I,II,III,IV,...
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.LOWERCASE_ROMAN_NUMERALS">
            Logical pages will have the form i,ii,iii,iv,...
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.UPPERCASE_LETTERS">
            Logical pages will have the form of uppercase letters
            (A to Z for the first 26 pages, AA to ZZ for the next 26, and so on)
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.LOWERCASE_LETTERS">
            Logical pages will have the form of uppercase letters
            (a to z for the first 26 pages, aa to zz for the next 26, and so on)
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.EMPTY">
            No logical page numbers are generated but fixed text may
            still exist
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.numberingStyle">
            Dictionary values to set the logical page styles
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPageLabels.map">
            The sequence of logical pages. Will contain at least a value for page 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.#ctor">
            Creates a new PdfPageLabel with a default logical page 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.AddPageLabel(System.Int32,System.Int32,System.String,System.Int32)">
            Adds or replaces a page label.
            @param page the real page to start the numbering. First page is 1
            @param numberStyle the numbering style such as LOWERCASE_ROMAN_NUMERALS
            @param text the text to prefix the number. Can be <CODE>null</CODE> or empty
            @param firstPage the first logical page number
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.AddPageLabel(System.Int32,System.Int32,System.String,System.Int32,System.Boolean)">
            Adds or replaces a page label.
            @param page the real page to start the numbering. First page is 1
            @param numberStyle the numbering style such as LOWERCASE_ROMAN_NUMERALS
            @param text the text to prefix the number. Can be <CODE>null</CODE> or empty
            @param firstPage the first logical page number
            @param includeFirstPage If true, the page label will be added to the first page if it is page 1.  
            	 If the first page is not page 1 or this value is false, the value will not be added to the dictionary.  
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.AddPageLabel(System.Int32,System.Int32,System.String)">
            Adds or replaces a page label. The first logical page has the default
            of 1.
            @param page the real page to start the numbering. First page is 1
            @param numberStyle the numbering style such as LOWERCASE_ROMAN_NUMERALS
            @param text the text to prefix the number. Can be <CODE>null</CODE> or empty
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.AddPageLabel(System.Int32,System.Int32)">
            Adds or replaces a page label. There is no text prefix and the first
            logical page has the default of 1.
            @param page the real page to start the numbering. First page is 1
            @param numberStyle the numbering style such as LOWERCASE_ROMAN_NUMERALS
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.AddPageLabel(iTextSharp.text.pdf.PdfPageLabels.PdfPageLabelFormat)">
            Adds or replaces a page label.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.RemovePageLabel(System.Int32)">
            Removes a page label. The first page lagel can not be removed, only changed.
            @param page the real page to remove
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.GetDictionary(iTextSharp.text.pdf.PdfWriter)">
            Gets the page label dictionary to insert into the document.
            @return the page label dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.GetPageLabels(iTextSharp.text.pdf.PdfReader)">
            Retrieves the page labels from a PDF as an array of String objects.
            @param reader a PdfReader object that has the page labels you want to retrieve
            @return  a String array or <code>null</code> if no page labels are present
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.GetPageLabelFormats(iTextSharp.text.pdf.PdfReader)">
            Retrieves the page labels from a PDF as an array of {@link PdfPageLabelFormat} objects.
            @param reader a PdfReader object that has the page labels you want to retrieve
            @return  a PdfPageLabelEntry array, containing an entry for each format change
            or <code>null</code> if no page labels are present
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPageLabels.PdfPageLabelFormat.#ctor(System.Int32,System.Int32,System.String,System.Int32)">
            Creates a page label format.
            @param physicalPage the real page to start the numbering. First page is 1
            @param numberStyle the numbering style such as LOWERCASE_ROMAN_NUMERALS
            @param prefix the text to prefix the number. Can be <CODE>null</CODE> or empty
            @param logicalPage the first logical page number
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfPages" -->
        <member name="M:iTextSharp.text.pdf.PdfPages.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Constructs a <CODE>PdfPages</CODE>-object.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPattern">
             A <CODE>PdfPattern</CODE> defines a ColorSpace
            
             @see     PdfStream
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPattern.#ctor(iTextSharp.text.pdf.PdfPatternPainter)">
            Creates a PdfPattern object.
            @param   painter a pattern painter instance
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPattern.#ctor(iTextSharp.text.pdf.PdfPatternPainter,System.Int32)">
            Creates a PdfPattern object.
            @param   painter a pattern painter instance
            @param   compressionLevel the compressionLevel for the stream
            @since   2.1.3
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPatternPainter">
            Implements the pattern.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.#ctor">
            Creates a <CODE>PdfPattern</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.#ctor(iTextSharp.text.pdf.PdfWriter)">
             Creates new PdfPattern
            
             @param wr the <CODE>PdfWriter</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.GetPattern">
            Gets the stream representing this pattern
            @return the stream representing this pattern
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.GetPattern(System.Int32)">
            Gets the stream representing this pattern
            @param   compressionLevel    the compression level of the stream
            @return the stream representing this pattern
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetGrayFill(System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setGrayFill(float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetGrayFill">
            @see com.lowagie.text.pdf.PdfContentByte#resetGrayFill()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetGrayStroke(System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setGrayStroke(float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetGrayStroke">
            @see com.lowagie.text.pdf.PdfContentByte#resetGrayStroke()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetRGBColorFillF(System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setRGBColorFillF(float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetRGBColorFill">
            @see com.lowagie.text.pdf.PdfContentByte#resetRGBColorFill()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetRGBColorStrokeF(System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setRGBColorStrokeF(float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetRGBColorStroke">
            @see com.lowagie.text.pdf.PdfContentByte#resetRGBColorStroke()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetCMYKColorFillF(System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setCMYKColorFillF(float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetCMYKColorFill">
            @see com.lowagie.text.pdf.PdfContentByte#resetCMYKColorFill()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetCMYKColorStrokeF(System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setCMYKColorStrokeF(float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.ResetCMYKColorStroke">
            @see com.lowagie.text.pdf.PdfContentByte#resetCMYKColorStroke()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.AddImage(iTextSharp.text.Image,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#addImage(com.lowagie.text.Image, float, float, float, float, float, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetCMYKColorFill(System.Int32,System.Int32,System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.PdfContentByte#setCMYKColorFill(int, int, int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetCMYKColorStroke(System.Int32,System.Int32,System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.PdfContentByte#setCMYKColorStroke(int, int, int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetRGBColorFill(System.Int32,System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.PdfContentByte#setRGBColorFill(int, int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetRGBColorStroke(System.Int32,System.Int32,System.Int32)">
            @see com.lowagie.text.pdf.PdfContentByte#setRGBColorStroke(int, int, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetColorStroke(iTextSharp.text.BaseColor)">
            @see com.lowagie.text.pdf.PdfContentByte#setColorStroke(java.awt.Color)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetColorFill(iTextSharp.text.BaseColor)">
            @see com.lowagie.text.pdf.PdfContentByte#setColorFill(java.awt.Color)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetColorFill(iTextSharp.text.pdf.PdfSpotColor,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setColorFill(com.lowagie.text.pdf.PdfSpotColor, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetColorStroke(iTextSharp.text.pdf.PdfSpotColor,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setColorStroke(com.lowagie.text.pdf.PdfSpotColor, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetPatternFill(iTextSharp.text.pdf.PdfPatternPainter)">
            @see com.lowagie.text.pdf.PdfContentByte#setPatternFill(com.lowagie.text.pdf.PdfPatternPainter)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetPatternFill(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setPatternFill(com.lowagie.text.pdf.PdfPatternPainter, java.awt.Color, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetPatternStroke(iTextSharp.text.pdf.PdfPatternPainter,iTextSharp.text.BaseColor,System.Single)">
            @see com.lowagie.text.pdf.PdfContentByte#setPatternStroke(com.lowagie.text.pdf.PdfPatternPainter, java.awt.Color, float)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPatternPainter.SetPatternStroke(iTextSharp.text.pdf.PdfPatternPainter)">
            @see com.lowagie.text.pdf.PdfContentByte#setPatternStroke(com.lowagie.text.pdf.PdfPatternPainter)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPatternPainter.Duplicate">
            Gets a duplicate of this <CODE>PdfPatternPainter</CODE>. All
            the members are copied by reference but the buffer stays different.
            @return a copy of this <CODE>PdfPatternPainter</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPCell">
            A cell in a PdfPTable.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.verticalAlignment">
            Holds value of property verticalAlignment. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.paddingLeft">
            Holds value of property paddingLeft. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.paddingRight">
            Holds value of property paddingLeft. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.paddingTop">
            Holds value of property paddingTop. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.paddingBottom">
            Holds value of property paddingBottom. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.fixedHeight">
            Holds value of property fixedHeight. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.calculatedHeight">
            Fixed height of the cell.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.noWrap">
            Holds value of property noWrap. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.table">
            Holds value of property table. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.minimumHeight">
            Holds value of property minimumHeight. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.cachedMaxHeight">
            This field is used to cache the height which is calculated on getMaxHeight() method call;
            this helps to avoid unnecessary recalculations on table drawing.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.colspan">
            Holds value of property colspan. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.rowspan">
            Holds value of property rowspan.
            @since    2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.image">
            Holds value of property image. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.cellEvent">
            Holds value of property cellEvent. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.useDescender">
            Holds value of property useDescender. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.useBorderPadding">
            Increases padding to include border if true 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.phrase">
            The text in the cell. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPCell.rotation">
            The rotation of the cell. Possible values are
            0, 90, 180 and 270.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor">
            Constructs an empty <CODE>PdfPCell</CODE>.
            The default padding is 2.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.Phrase)">
            Constructs a <CODE>PdfPCell</CODE> with a <CODE>Phrase</CODE>.
            The default padding is 2.
            @param phrase the text
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.Image)">
            Constructs a <CODE>PdfPCell</CODE> with an <CODE>Image</CODE>.
            The default padding is 0.
            @param image the <CODE>Image</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.Image,System.Boolean)">
            Constructs a <CODE>PdfPCell</CODE> with an <CODE>Image</CODE>.
            The default padding is 0.25 for a border width of 0.5.
            @param image the <CODE>Image</CODE>
            @param fit <CODE>true</CODE> to fit the image to the cell
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.pdf.PdfPTable)">
            Constructs a <CODE>PdfPCell</CODE> with a <CODE>PdfPtable</CODE>.
            This constructor allows nested tables.
            The default padding is 0.
            @param table The <CODE>PdfPTable</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.pdf.PdfPTable,iTextSharp.text.pdf.PdfPCell)">
            Constructs a <CODE>PdfPCell</CODE> with a <CODE>PdfPtable</CODE>.
            This constructor allows nested tables.
            
            @param table The <CODE>PdfPTable</CODE>
            @param style  The style to apply to the cell (you could use getDefaultCell())
            @since 2.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.#ctor(iTextSharp.text.pdf.PdfPCell)">
            Constructs a deep copy of a <CODE>PdfPCell</CODE>.
            @param cell the <CODE>PdfPCell</CODE> to duplicate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.AddElement(iTextSharp.text.IElement)">
            Adds an iText element to the cell.
            @param element
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.SetLeading(System.Single,System.Single)">
            Sets the leading fixed and variable. The resultant leading will be
            fixedLeading+multipliedLeading*maxFontSize where maxFontSize is the
            size of the bigest font in the line.
            @param fixedLeading the fixed leading
            @param multipliedLeading the variable leading
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.HasFixedHeight">
            Tells you whether the cell has a fixed height.
            
            @return   true is a fixed height was set.
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.HasMinimumHeight">
            Tells you whether the cell has a minimum height.
            
            @return   true if a minimum height was set.
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPCell.GetMaxHeight">
            Returns the height of the cell.
            @return  the height of the cell
            @since   3.0.0
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Phrase">
            Gets the <CODE>Phrase</CODE> from this cell.
            @return the <CODE>Phrase</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.HorizontalAlignment">
            Gets the horizontal alignment for the cell.
            @return the horizontal alignment for the cell
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.VerticalAlignment">
            Gets the vertical alignment for the cell.
            @return the vertical alignment for the cell
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.EffectivePaddingLeft">
            Gets the effective left padding.  This will include
             the left border width if {@link #UseBorderPadding} is true.
            @return effective value of property paddingLeft.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.PaddingLeft">
            @return Value of property paddingLeft.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.EffectivePaddingRight">
            Gets the effective right padding.  This will include
             the right border width if {@link #UseBorderPadding} is true.
            @return effective value of property paddingRight.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.PaddingRight">
            Getter for property paddingRight.
            @return Value of property paddingRight.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.EffectivePaddingTop">
            Gets the effective top padding.  This will include
             the top border width if {@link #isUseBorderPadding()} is true.
            @return effective value of property paddingTop.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.PaddingTop">
            Getter for property paddingTop.
            @return Value of property paddingTop.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.EffectivePaddingBottom">
                    /** Gets the effective bottom padding.  This will include
                    *  the bottom border width if {@link #UseBorderPadding} is true.
                    * @return effective value of property paddingBottom.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.PaddingBottom">
            Getter for property paddingBottom.
            @return Value of property paddingBottom.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Padding">
            Sets the padding of the contents in the cell (space between content and border).
            @param padding
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.UseBorderPadding">
            Adjusts effective padding to include border widths.
            @param use adjust effective padding if true
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Leading">
            Gets the fixed leading
            @return the leading
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.MultipliedLeading">
            Gets the variable leading
            @return the leading
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Indent">
            Gets the first paragraph line indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.ExtraParagraphSpace">
            Gets the extra space between paragraphs.
            @return the extra space between paragraphs
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.FixedHeight">
            Getter for property fixedHeight.
            @return Value of property fixedHeight.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.CachedMaxHeight">
            Gets the height which was calculated on last call of getMaxHeight().
            If cell's bBox and content wasn't changed this value is actual maxHeight of the cell.
            @return max height which was calculated on last call of getMaxHeight(); if getMaxHeight() wasn't called the return value is 0
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.NoWrap">
            Setter for property noWrap.
            @param noWrap New value of property noWrap.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Table">
            Getter for property table.
            @return Value of property table.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.MinimumHeight">
            Getter for property minimumHeight.
            @return Value of property minimumHeight.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Colspan">
            Getter for property colspan.
            @return Value of property colspan.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Rowspan">
            Getter for property rowspan.
            @return Value of property rowspan.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.FollowingIndent">
            Gets the following paragraph lines indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.RightIndent">
            Gets the right paragraph lines indent.
            @return the indent
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.SpaceCharRatio">
            Gets the space/character extra spacing ratio for
            fully justified text.
            @return the space/character extra spacing ratio
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.RunDirection">
            Gets the run direction of the text content in the cell
            @return One of the following values: PdfWriter.RUN_DIRECTION_DEFAULT, PdfWriter.RUN_DIRECTION_NO_BIDI, PdfWriter.RUN_DIRECTION_LTR or PdfWriter.RUN_DIRECTION_RTL.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Image">
            Getter for property image.
             @return Value of property image.
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.CellEvent">
            Gets the cell event for this cell.
             @return the cell event
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.ArabicOptions">
            Gets the arabic shaping options.
            @return the arabic shaping options
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.UseAscender">
            Gets state of first line height based on max ascender
            @return true if an ascender is to be used.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.UseDescender">
            Getter for property useDescender.
             @return Value of property useDescender.
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Column">
            Gets the ColumnText with the content of the cell.
            @return a columntext object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.CompositeElements">
            Returns the list of composite elements of the column.
            @return   a List object.
            @since    2.1.1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPCell.Rotation">
            Sets the rotation of the cell. Possible values are
            0, 90, 180 and 270.
            @param rotation the rotation of the cell
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPRow">
            A row in a PdfPTable.
            
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPRow.BOTTOM_LIMIT">
            the bottom limit (bottom right y) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPRow.RIGHT_LIMIT">
            the right limit
            @since    2.1.5
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPRow.mayNotBreak">
            True if the table may not break after this row. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPRow.extraHeights">
            extra heights that needs to be added to a cell because of rowspans.
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.#ctor(iTextSharp.text.pdf.PdfPCell[])">
            Constructs a new PdfPRow with the cells in the array that was passed
            as a parameter.
            
            @param cells
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.#ctor(iTextSharp.text.pdf.PdfPRow)">
            Makes a copy of an existing row.
            
            @param row
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SetWidths(System.Single[])">
            Sets the widths of the columns in the row.
            
            @param widths
            @return true if everything went right
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.InitExtraHeights">
            Initializes the extra heights array.
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SetExtraHeight(System.Int32,System.Single)">
            Sets an extra height for a cell.
            @param    cell    the index of the cell that needs an extra height
            @param    height  the extra height
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.CalculateHeights">
            Calculates the heights of each cell in the row.
            
            @return the maximum height of the row.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.WriteBorderAndBackground(System.Single,System.Single,System.Single,iTextSharp.text.pdf.PdfPCell,iTextSharp.text.pdf.PdfContentByte[])">
            Writes the border and background of one cell in the row.
            
            @param xPos The x-coordinate where the table starts on the canvas
            @param yPos The y-coordinate where the table starts on the canvas
            @param currentMaxHeight The height of the cell to be drawn.
            @param cell
            @param canvases
            @since    2.1.6   extra parameter currentMaxHeight
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SaveAndRotateCanvases(iTextSharp.text.pdf.PdfContentByte[],System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            @since    2.1.6 private is now protected
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.RestoreCanvases(iTextSharp.text.pdf.PdfContentByte[])">
            @since    2.1.6 private is now protected
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SetColumn(iTextSharp.text.pdf.ColumnText,System.Single,System.Single,System.Single,System.Single)">
            @since	3.0.0 protected is now public static
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.WriteCells(System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte[],System.Boolean)">
                    * Writes a number of cells (not necessarily all cells).
                    * 
                    * @param    colStart The first column to be written.
                    * Remember that the column index starts with 0.
                    * @param    colEnd The last column to be written.
                    * Remember that the column index starts with 0.
                    * If -1, all the columns to the end are written.
                    * @param    xPos The x-coordinate where the table starts on the canvas
                    * @param    yPos The y-coordinate where the table starts on the canvas
                     * @param   reusable if set to false, the content in the cells is "consumed";
                     * if true, you can reuse the cells, the row, the parent table as many times you want.
                     * @since 5.1.0 added the reusable parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.IsCalculated">
            Checks if the dimensions of the columns were calculated.
            
            @return true if the dimensions of the columns were calculated
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.CopyRowContent(iTextSharp.text.pdf.PdfPTable,System.Int32)">
            Copies the content of a specific row in a table to this row.
            Don't do this if the rows have a different number of cells.
            @param table the table from which you want to copy a row
            @param idx   the index of the row that needs to be copied
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SplitRow(iTextSharp.text.pdf.PdfPTable,System.Int32,System.Single)">
            Splits a row to newHeight.
            The returned row is the remainder. It will return null if the newHeight
            was so small that only an empty row would result.
            
            @param new_height the new height
            @return the remainder row or null if the newHeight was so small that only
            an empty row would result
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.SplitRowspans(iTextSharp.text.pdf.PdfPTable,System.Int32,iTextSharp.text.pdf.PdfPTable,System.Int32)">
            Split rowspan of cells with rowspan on next page by inserting copies with the remaining rowspan
            and reducing the previous rowspan appropriately, i.e. if a cell with rowspan 7 gets split after 3 rows
            of that rowspan have been laid out, its column on the next page should start with an empty cell
            having the same attributes and rowspan 7 - 3 = 4.
            
            @since iText 5.4.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.GetCells">
            Returns the array of cells in the row.
            Please be extremely careful with this method.
            Use the cells as read only objects.
            
            @return   an array of cells
            @since    2.1.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPRow.HasRowspan">
            Checks if a cell in the row has a rowspan greater than 1.
            @since 5.1.0
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPRow.MaxHeights">
            Gets the maximum height of the row (i.e. of the 'highest' cell).
            @return the maximum height of the row
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPSXObject">
            Implements the PostScript XObject.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPSXObject.#ctor">
            Creates a new instance of PdfPSXObject 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPSXObject.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Constructs a PSXObject
            @param wr
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPSXObject.GetFormXObject(System.Int32)">
             Gets the stream representing this object.
            
             @param   compressionLevel    the compressionLevel
             @return the stream representing this template
             @since   2.1.3   (replacing the method without param compressionLevel)
             @throws IOException
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPSXObject.Duplicate">
            Gets a duplicate of this <CODE>PdfPSXObject</CODE>. All
            the members are copied by reference but the buffer stays different.
            @return a copy of this <CODE>PdfPSXObject</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPTable">
            This is a table that can be put at an absolute position but can also
            be added to the document as the class <CODE>Table</CODE>.
            In the last case when crossing pages the table always break at full rows; if a
            row is bigger than the page it is dropped silently to avoid infinite loops.
            <p/>
            A PdfPTableEvent can be associated to the table to do custom drawing
            when the table is rendered.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.BASECANVAS">
            The index of the original <CODE>PdfcontentByte</CODE>.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.BACKGROUNDCANVAS">
            The index of the duplicate <CODE>PdfContentByte</CODE> where the background will be drawn.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.LINECANVAS">
            The index of the duplicate <CODE>PdfContentByte</CODE> where the border lines will be drawn.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.TEXTCANVAS">
            The index of the duplicate <CODE>PdfContentByte</CODE> where the text will be drawn.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.currentColIdx">
            The current column index.
            
            @since 5.1.0 renamed from currentColIdx
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.headerRows">
            Holds value of property headerRows. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.widthPercentage">
            Holds value of property widthPercentage. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.horizontalAlignment">
            Holds value of property horizontalAlignment. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.skipFirstHeader">
            Holds value of property skipFirstHeader. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.skipLastFooter">
            Holds value of property skipLastFooter.
            
            @since    2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.lockedWidth">
            Holds value of property lockedWidth.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.splitRows">
            Holds value of property splitRows.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.spacingBefore">
            The spacing before the table. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.spacingAfter">
            The spacing after the table. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.extendLastRow">
            Holds value of property extendLastRow.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.headersInEvent">
            Holds value of property headersInEvent.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.splitLate">
            Holds value of property splitLate.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.keepTogether">
            Defines if the table should be kept
            on one page if possible
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.complete">
            Indicates if the PdfPTable is complete once added to the document.
            @since iText 2.0.8
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPTable.rowCompleted">
            Keeps track of the completeness of the current row.
            
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.#ctor(System.Single[])">
            Constructs a <CODE>PdfPTable</CODE> with the relative column widths.
            @param relativeWidths the relative column widths
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.#ctor(System.Int32)">
            Constructs a <CODE>PdfPTable</CODE> with <CODE>numColumns</CODE> columns.
            @param numColumns the number of columns
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.#ctor(iTextSharp.text.pdf.PdfPTable)">
            Constructs a copy of a <CODE>PdfPTable</CODE>.
            @param table the <CODE>PdfPTable</CODE> to be copied
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.ShallowCopy(iTextSharp.text.pdf.PdfPTable)">
            Makes a shallow copy of a table (format without content).
            @param table
            @return a shallow copy of the table
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.CopyFormat(iTextSharp.text.pdf.PdfPTable)">
            Copies the format of the sourceTable without copying the content. 
            @param sourceTable
            @since 2.1.6 private is now protected
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetWidths(System.Single[])">
            Sets the relative widths of the table.
            @param relativeWidths the relative widths of the table.
            @throws DocumentException if the number of widths is different than the number
                                      of columns
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetWidths(System.Int32[])">
            Sets the relative widths of the table.
            @param relativeWidths the relative widths of the table.
            @throws DocumentException if the number of widths is different than the number
                                      of columns
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.CalculateWidths">
            @since 2.1.6 private is now protected
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetTotalWidth(System.Single[])">
            Sets the full width of the table from the absolute column width.
            @param columnWidth the absolute width of each column
            @throws DocumentException if the number of widths is different than the number
                                      of columns
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetWidthPercentage(System.Single[],iTextSharp.text.Rectangle)">
            Sets the percentage width of the table from the absolute column width.  Warning: Don't use this with setLockedWidth(true). These two settings don't mix.
            @param columnWidth the absolute width of each column
            @param pageSize    the page size
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.CalculateHeights">
             Calculates the heights of the table.
            
             @return the total height of the table. Note that it will be 0 if you didn't
             specify the width of the table with SetTotalWidth().
             and made it public
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.ResetColumnCount(System.Int32)">
            Changes the number of columns. Any existing rows will be deleted.
            
            @param the new number of columns
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AddCell(iTextSharp.text.pdf.PdfPCell)">
            Adds a cell element.
            
            @param cell the cell element
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SkipColsWithRowspanAbove">
            When updating the row index, cells with rowspan should be taken into account.
            This is what happens in this method.
            
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.CellAt(System.Int32,System.Int32)">
             Added by timmo3.  This will return the correct cell taking it's cellspan into account
            
             @param row the row index
             @param col the column index
             @return PdfPCell at the given row and position or null otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.RowSpanAbove(System.Int32,System.Int32)">
            Checks if there are rows above belonging to a rowspan.
            @param    currRow the current row to check
            @param    currCol the current column to check
            @return   true if there's a cell above that belongs to a rowspan
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AddCell(System.String)">
            Adds a cell element.
            @param text the text for the cell
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AddCell(iTextSharp.text.pdf.PdfPTable)">
            Adds a nested table.
            @param table the table to be added to the cell
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AddCell(iTextSharp.text.Image)">
            Adds an Image as Cell.
            @param image the <CODE>Image</CODE> to add to the table.
                         This image will fit in the cell
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AddCell(iTextSharp.text.Phrase)">
            Adds a cell element.
            @param phrase the <CODE>Phrase</CODE> to be added to the cell
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte[])" -->
        <member name="M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte[],System.Boolean)">
             Writes the selected rows and columns to the document.
             This method does not clip the columns; this is only important
             if there are columns with colspan at boundaries.
             <CODE>canvases</CODE> is obtained from <CODE>beginWritingRows()</CODE>.
             The table event is only fired for complete rows.
            
             @param colStart  the first column to be written, zero index
             @param colEnd    the last column to be written + 1. If it is -1 all the
                              columns to the end are written
             @param rowStart  the first row to be written, zero index
             @param rowEnd    the last row to be written + 1. If it is -1 all the
                              rows to the end are written
             @param xPos      the x write coordinate
             @param yPos      the y write coordinate
             @param canvases  an array of 4 <CODE>PdfContentByte</CODE> obtained from
                              <CODE>beginWritingRows()</CODE>
             @param   reusable if set to false, the content in the cells is "consumed";
             if true, you can reuse the cells, the row, the parent table as many times you want.
             @return the y coordinate position of the bottom of the last row
             @see #beginWritingRows(com.itextpdf.text.pdf.PdfContentByte)
             @since 5.1.0 added the reusable parameter
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte)">
            Writes the selected rows to the document.
            
            @param rowStart   the first row to be written, zero index
            @param rowEnd     the last row to be written + 1. If it is -1 all the
                              rows to the end are written
            @param xPos       the x write coodinate
            @param yPos       the y write coodinate
            @param canvas     the <CODE>PdfContentByte</CODE> where the rows will
                              be written to
            @return the y coordinate position of the bottom of the last row
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte)" -->
        <member name="M:iTextSharp.text.pdf.PdfPTable.WriteSelectedRows(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,iTextSharp.text.pdf.PdfContentByte,System.Boolean)">
             Writes the selected rows and columns to the document.
             This method clips the columns; this is only important
             if there are columns with colspan at boundaries.
             The table event is only fired for complete rows.
            
             @param colStart  the first column to be written, zero index
             @param colEnd    the last column to be written + 1. If it is -1 all the
                              columns to the end are written
             @param rowStart  the first row to be written, zero index
             @param rowEnd    the last row to be written + 1. If it is -1 all the
                              rows to the end are written
             @param xPos      the x write coordinate
             @param yPos      the y write coordinate
             @param canvas    the <CODE>PdfContentByte</CODE> where the rows will
                              be written to     
             @return the y coordinate position of the bottom of the last row
             @param   reusable if set to false, the content in the cells is "consumed";
             if true, you can reuse the cells, the row, the parent table as many times you want.
             @since 5.1.0 added the reusable parameter
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfPTable.BeginWritingRows(iTextSharp.text.pdf.PdfContentByte)" -->
        <member name="M:iTextSharp.text.pdf.PdfPTable.EndWritingRows(iTextSharp.text.pdf.PdfContentByte[])">
            Finishes writing the table.
            @param canvases the array returned by <CODE>beginWritingRows()</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetRowHeight(System.Int32)">
            Gets the height of a particular row.
            @param idx the row index (starts at 0)
            @return the height of a particular row
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetRowHeight(System.Int32,System.Boolean)">
            Gets the height of a particular row.
            
            @param idx        the row index (starts at 0)
            @param firsttime  is this the first time the row heigh is calculated?
            @return the height of a particular row
            @since 5.0.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetRowspanHeight(System.Int32,System.Int32)">
            Gets the maximum height of a cell in a particular row (will only be different
            from getRowHeight is one of the cells in the row has a rowspan > 1).
            
            @param rowIndex    the row index
            @param cellIndex   the cell index
            @return the height of a particular row including rowspan
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.HasRowspan(System.Int32)">
            Checks if a cell in a row has a rowspan greater than 1.
            
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.NormalizeHeadersFooters">
            Makes sure the footers value is lower than the headers value.
            
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.DeleteRow(System.Int32)">
            Deletes a row from the table.
            @param rowNumber the row to be deleted
            @return <CODE>true</CODE> if the row was deleted
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.DeleteLastRow">
            Deletes the last row in the table.
            @return <CODE>true</CODE> if the last row was deleted
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.DeleteBodyRows">
            Removes all of the rows except headers
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.IsContent">
            @since   iText 2.0.8
            @see com.lowagie.text.Element#isContent()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.IsNestable">
            @since   iText 2.0.8
            @see com.lowagie.text.Element#isNestable()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.Process(iTextSharp.text.IElementListener)">
             Processes the element by adding it (or the different parts) to an
             <CODE>ElementListener</CODE>.
            
             @param    listener    an <CODE>ElementListener</CODE>
             @return    <CODE>true</CODE> if the element was processed successfully
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetRow(System.Int32)">
             Gets a row with a given index.
            
             @param idx
             @return the row at position idx
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.getLastCompletedRowIndex">
             Returns the index of the last completed row.
            
             @return the index of a row
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetBreakPoints(System.Int32[])">
             Defines where the table may be broken (if necessary).
            
             @param breakPoints int[]
             @throws System.IndexOutOfRangeException if a row index is passed that is out of bounds
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.KeepRowsTogether(System.Int32[])">
             Defines which rows should not allow a page break (if possible).
            
             @param rows int[]
             @throws System.IndexOutOfRangeException if a row index is passed that is out of bounds
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.KeepRowsTogether(System.Int32,System.Int32)">
             Defines a range of rows that should not allow a page break (if possible).
            
             @param start int
             @param end int
             @throws System.IndexOutOfRangeException if a row index is passed that is out of bounds
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.KeepRowsTogether(System.Int32)">
             Defines a range of rows (from the parameter to the last row) that should not allow a page break (if possible).
             The equivalent of calling {@link #keepRowsTogether(int,int) keepRowsTogether(start, rows.size()}.
            
             @param start int
             @throws System.IndexOutOfRangeException if a row index is passed that is out of bounds
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetRows(System.Int32,System.Int32)">
            Gets an arraylist with a selection of rows.
            @param    start   the first row in the selection
            @param    end     the first row that isn't part of the selection
            @return a selection of rows
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.AdjustCellsInRow(System.Int32,System.Int32)">
            Calculates the extra height needed in a row because of rowspans.
            @param    start   the index of the start row (the one to adjust)
            @param    end     the index of the end row on the page
            @since    2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.SetExtendLastRow(System.Boolean,System.Boolean)">
            When set the last row on every page will be extended to fill
            all the remaining space to the bottom boundary; except maybe the
            row.
            
            @param extendLastRows true to extend the last row on each page; false otherwise
            @param extendFinalRow false if you don't want to extend the row of the complete table
            @since iText 5.0.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.IsExtendLastRow(System.Boolean)">
                    * Gets the value of the last row extension, taking into account
                    * if the row is reached or not.
                    * 
                    * @return true if the last row will extend; 
                     *        false otherwise
                    * @since iText 5.0.0
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.CompleteRow">
            Completes the current row with the default cell. An incomplete row will be dropped
            but calling this method will make sure that it will be present in the table.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.FlushContent">
            @since   iText 2.0.8
            @see com.lowagie.text.LargeElement#flushContent()
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetCellStartRowIndex(System.Int32,System.Int32)">
            Gets row index where cell overlapping (rowIdx, colIdx) starts
            @param rowIdx
            @param colIdx
            @return row index
            @since iText 5.4.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.GetFittingRows(System.Single,System.Int32)">
            Determine which rows fit on the page, respecting isSplitLate().
            Note: sets max heights of the inspected rows as a side effect,
            just like PdfPTable.getRowHeight(int, boolean) does.
            Respect row.getMaxHeights() if it has been previously set (which might be independent of the height of
            individual cells).
            The last row written on the page will be chosen by the caller who might choose not
            the calculated one but an earlier one (due to mayNotBreak settings on the rows).
            The height of the chosen last row has to be corrected if splitLate == true
            by calling FittingRows.correctLastRowChosen() by the caller to avoid splitting the content of
            cells with open rowspans.
            
            @since iText 5.4.3
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.TotalWidth">
            Gets the full width of the table.
            @return the full width of the table
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.DefaultCell">
            Gets the default <CODE>PdfPCell</CODE> that will be used as
            reference for all the <CODE>addCell</CODE> methods except
            <CODE>addCell(PdfPCell)</CODE>.
            @return default <CODE>PdfPCell</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.Size">
            Gets the number of rows in this table.
            @return the number of rows in this table
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.TotalHeight">
            Gets the total height of the table.
            @return the total height of the table
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.HeaderHeight">
            Gets the height of the rows that constitute the header as defined by
            <CODE>setHeaderRows()</CODE>.
            @return the height of the rows that constitute the header and footer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.FooterHeight">
            Gets the height of the rows that constitute the header as defined by
            <CODE>setFooterRows()</CODE>.
            @return the height of the rows that constitute the footer
            @since 2.1.1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.NumberOfColumns">
            Returns the number of columns.
            @return  the number of columns.
            @since   2.1.1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.Chunks">
             Gets all the chunks in this element.
            
             @return    an <CODE>List</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.Type">
             Gets the type of the text element.
            
             @return    a type
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.Rows">
            Gets an arraylist with all the rows in the table.
            @return an arraylist
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.TableEvent">
             Sets the table event for this table.
            
             @param event the table event for this table
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.AbsoluteWidths">
            Gets the absolute sizes of each column width.
            @return he absolute sizes of each column width
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.SkipLastFooter">
            Tells you if the last footer needs to be skipped
            (for instance if the footer says "continued on the next page")
            
            @return Value of property skipLastFooter.
            @since 2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.KeepTogether">
             If true the table will be kept on one page if it fits, by forcing a 
             new page if it doesn't fit on the current page. The default is to
             split the table over multiple pages.
            
             @param p_KeepTogether whether to try to keep the table on one page
        </member>
        <member name="P:iTextSharp.text.pdf.PdfPTable.ElementComplete">
            @since   iText 2.0.8
            @see com.lowagie.text.LargeElement#isComplete()
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPTable.FittingRows">
            
            @since iText 5.4.3
        </member>
        <member name="M:iTextSharp.text.pdf.PdfPTable.FittingRows.CorrectLastRowChosen(iTextSharp.text.pdf.PdfPTable,System.Int32)">
             Correct chosen last fitting row so that the content of all cells with open rowspans will fit on the page,
             i.e. the cell content won't be split.
            (Only to be used with splitLate == true)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPTable.ColumnMeasurementState">
            
            @since iText 5.4.3
        </member>
        <member name="T:iTextSharp.text.pdf.PdfPublicKeySecurityHandler">
            @author Aiken Sam (aikensam@ieee.org)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfReaderInstance">
             Instance of PdfReader in each output document.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfReaderInstance.GetFormXObject(System.Int32,System.Int32)">
            Gets the content stream of a page as a PdfStream object.
            @param   pageNumber          the page of which you want the stream
            @param   compressionLevel    the compression level you want to apply to the stream
            @return  a PdfStream object
            @since   2.1.3 (the method already existed without param compressionLevel)
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfRectangle" -->
        <member name="T:iTextSharp.text.pdf.NumberArray">
            A PdfArray object consisting of nothing but PdfNumber objects
            @since 5.1.0
        </member>
        <member name="M:iTextSharp.text.pdf.NumberArray.#ctor">
            Creates a PdfArray consisting of PdfNumber objects.
            @param numbers float values
        </member>
        <member name="M:iTextSharp.text.pdf.NumberArray.#ctor(System.Collections.Generic.IList{iTextSharp.text.pdf.PdfNumber})">
            Creates a PdfArray consisting of PdfNumber objects.
            @param numbers a List containing PdfNumber objects
        </member>
        <member name="F:iTextSharp.text.pdf.PdfRectangle.llx">
            lower left x 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfRectangle.lly">
            lower left y 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfRectangle.urx">
            upper right x 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfRectangle.ury">
            upper right y 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32)">
             Constructs a <CODE>PdfRectangle</CODE>-object.
            
             @param       llx         lower left x
             @param       lly         lower left y
             @param       urx         upper right x
             @param       ury         upper right y
            
             @since       rugPdf0.10
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.#ctor(System.Single,System.Single,System.Int32)">
             Constructs a <CODE>PdfRectangle</CODE>-object starting from the origin (0, 0).
            
             @param       urx         upper right x
             @param       ury         upper right y
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.#ctor(iTextSharp.text.Rectangle,System.Int32)">
             Constructs a <CODE>PdfRectangle</CODE>-object with a <CODE>Rectangle</CODE>-object.
            
             @param   rectangle   a <CODE>Rectangle</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.Add(iTextSharp.text.pdf.PdfObject)">
             Overrides the <CODE>add</CODE>-method in <CODE>PdfArray</CODE> in order to prevent the adding of extra object to the array.
            
             @param       object          <CODE>PdfObject</CODE> to add (will not be added here)
             @return      <CODE>false</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.Add(System.Single[])">
            Block changes to the underlying PdfArray
            @param values stuff we'll ignore.  Ha!
            @return false.  You can't add anything to a PdfRectangle
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.Add(System.Int32[])">
            Block changes to the underlying PdfArray
            @param values stuff we'll ignore.  Ha!
            @return false.  You can't add anything to a PdfRectangle
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.AddFirst(iTextSharp.text.pdf.PdfObject)">
            Block changes to the underlying PdfArray
            @param object Ignored.
            @since 2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.GetLeft(System.Int32)">
             Returns the lower left x-coordinate, considering a given margin.
            
             @param       margin      a margin
             @return      the lower left x-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.GetRight(System.Int32)">
             Returns the upper right x-coordinate, considering a given margin.
            
             @param       margin      a margin
             @return      the upper right x-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.GetTop(System.Int32)">
             Returns the upper right y-coordinate, considering a given margin.
            
             @param       margin      a margin
             @return      the upper right y-coordinate
        </member>
        <member name="M:iTextSharp.text.pdf.PdfRectangle.GetBottom(System.Int32)">
             Returns the lower left y-coordinate, considering a given margin.
            
             @param       margin      a margin
             @return      the lower left y-coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Rectangle">
            Returns the high level version of this PdfRectangle
            @return this PdfRectangle translated to class Rectangle
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Left">
             Returns the lower left x-coordinate.
            
             @return      the lower left x-coordinaat
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Right">
             Returns the upper right x-coordinate.
            
             @return      the upper right x-coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Top">
             Returns the upper right y-coordinate.
            
             @return      the upper right y-coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Bottom">
             Returns the lower left y-coordinate.
            
             @return      the lower left y-coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Width">
             Returns the width of the rectangle.
            
             @return      a width
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Height">
             Returns the height of the rectangle.
            
             @return      a height
        </member>
        <member name="P:iTextSharp.text.pdf.PdfRectangle.Rotate">
             Swaps the values of urx and ury and of lly and llx in order to rotate the rectangle.
            
             @return a <CODE>PdfRectangle</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfRendition">
            A Rendition dictionary (pdf spec 1.5)
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfResources" -->
        <member name="M:iTextSharp.text.pdf.PdfResources.#ctor">
            Constructs a PDF ResourcesDictionary.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfShading">
            Implements the shading dictionary (or stream).
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfShading.bBox">
            Holds value of property bBox. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfShading.antiAlias">
            Holds value of property antiAlias. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfShading.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates new PdfShading 
        </member>
        <member name="T:iTextSharp.text.pdf.PdfShadingPattern">
            Implements the shading pattern dictionary.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfShadingPattern.#ctor(iTextSharp.text.pdf.PdfShading)">
            Creates new PdfShadingPattern 
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSignature">
            Implements the signature dictionary.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignature.#ctor(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfName)">
            Creates new PdfSignature 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignature.SignatureCreator">
            Sets the signature creator name in the
            {@link PdfSignatureBuildProperties} dictionary.
            
            @param name
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignature.PdfSignatureBuildProperties">
            Gets the {@link PdfSignatureBuildProperties} instance if it exists, if
            not it adds a new one and returns this.
            
            @return {@link PdfSignatureBuildProperties}
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSignatureAppearance">
            Class that takes care of the cryptographic options
            and appearances that form a signature.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.NOT_CERTIFIED">
            Approval signature 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.CERTIFIED_NO_CHANGES_ALLOWED">
            Author signature, no changes allowed 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.CERTIFIED_FORM_FILLING">
            Author signature, form filling allowed 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.CERTIFIED_FORM_FILLING_AND_ANNOTATIONS">
            Author signature, form filling and annotations allowed 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.questionMark">
            An appearance that can be used for layer 1 (if acro6Layers is false). 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.TOP_SECTION">
            extra space at the top. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.MARGIN">
            margin for the content inside the signature rectangle. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.#ctor(iTextSharp.text.pdf.PdfStamperImp)">
            Constructs a PdfSignatureAppearance object.
            @param writer    the writer to which the signature will be written.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.certificationLevel">
            The certification level 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.reasonCaption">
            The caption for the reason for signing. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.locationCaption">
            The caption for the location of signing. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.reason">
            The reason for signing. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.location">
            Holds value of property location. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.signDate">
            Holds value of property signDate. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.signatureCreator">
            Holds value of the application that creates the signature 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.contact">
            The contact name of the signer. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.raf">
            The file right before the signature is added (can be null). 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.bout">
            The bytes of the file right before the signature is added (if raf is null) 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.range">
            Array containing the byte positions of the bytes that need to be hashed. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.GetRangeStream" -->
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.GetUnderlyingSource">
            @return the underlying source
            @throws IOException
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.signCertificate">
            The signing certificate 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.AddDeveloperExtension(iTextSharp.text.pdf.PdfDeveloperExtension)">
            Adds the appropriate developer extension.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.cryptoDictionary">
            The crypto dictionary 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.signatureEvent">
            Holds value of property signatureEvent.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.fieldName">
            The name of the field 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.GetNewSigName">
            Gets a new signature field name that
            doesn't clash with any existing name.
            @return a new signature field name
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.page">
            The page where the signature will appear.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.rect">
            The coordinates of the rectangle for a visible signature,
            or a zero-width, zero-height rectangle for an invisible signature.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.pageRect">
            rectangle that represent the position and dimension of the signature in the page. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.IsInvisible">
            Gets the visibility status of the signature.
            @return the visibility status of the signature
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.SetVisibleSignature(iTextSharp.text.Rectangle,System.Int32,System.String)">
            Sets the signature to be visible. It creates a new visible signature field.
            @param pageRect the position and dimension of the field in the page
            @param page the page to place the field. The fist page is 1
            @param fieldName the field name or <CODE>null</CODE> to generate automatically a new field name
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.SetVisibleSignature(System.String)">
            Sets the signature to be visible. An empty signature field with the same name must already exist.
            @param fieldName the existing empty signature field name
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.renderingMode">
            The rendering mode chosen for visible signatures 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.signatureGraphic">
            The image that needs to be used for a visible signature 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.acro6Layers">
            Appearance compliant with the recommendations introduced in Acrobat 6? 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.app">
            Layers for a visible signature. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.GetLayer(System.Int32)" -->
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.reuseAppearance">
            Indicates if we need to reuse the existing appearance as layer 0. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.image">
            A background image for the text in layer 2. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.imageScale">
            the scaling to be applied to the background image.t  
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.layer2Text">
            The text that goes in Layer 2 of the signature appearance. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.layer2Font">
            Font for the text in Layer 2. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.runDirection">
            Run direction for the text in layers 2 and 4. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.layer4Text">
            The text that goes in Layer 4 of the appearance. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.frm">
            Template containing all layers drawn on top of each other. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.GetTopLayer" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.GetAppearance" -->
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.stamper">
            The PdfStamper that creates the signed PDF. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.SetStamper(iTextSharp.text.pdf.PdfStamper)">
            Sets the PdfStamper
            @param stamper PdfStamper
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.writer">
            The PdfStamperImp object corresponding with the stamper. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.sigout">
            A byte buffer containing the bytes of the Stamper. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.originalout">
            OutputStream for the bytes of the stamper. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.tempFile">
            Temporary file in case you don't want to sign in memory. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.exclusionLocations">
            Name and content of keys that can only be added in the close() method. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.boutLen">
            Length of the output. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.preClosed">
            Indicates if the stamper has already been pre-closed. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.fieldLock">
            <summary>
            Signature field lock dictionary.
            </summary>
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.IsPreClosed">
            Checks if the document is in the process of closing.
            @return <CODE>true</CODE> if the document is in the process of closing,
            <CODE>false</CODE> otherwise
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.PreClose(System.Collections.Generic.Dictionary{iTextSharp.text.pdf.PdfName,System.Int32})" -->
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.AddDocMDP(iTextSharp.text.pdf.PdfDictionary)">
            Adds keys to the signature dictionary that define
            the certification level and the permissions.
            This method is only used for Certifying signatures.
            @param crypto the signature dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.AddFieldMDP(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary)">
            Adds keys to the signature dictionary that define
            the field permissions.
            This method is only used for signatures that lock fields.
            @param crypto the signature dictionary
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfSignatureAppearance.Close(iTextSharp.text.pdf.PdfDictionary)" -->
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.CertificationLevel">
            Sets the document type to certified instead of simply signed.
            @param certificationLevel the values can be: <code>NOT_CERTIFIED</code>, <code>CERTIFIED_NO_CHANGES_ALLOWED</code>,
            <code>CERTIFIED_FORM_FILLING</code> and <code>CERTIFIED_FORM_FILLING_AND_ANNOTATIONS</code>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Reason">
            Gets and setsthe signing reason.
            @return the signing reason
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.ReasonCaption">
            Sets the caption for signing reason.
            @param reasonCaption the signing reason caption
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Location">
            Gets and sets the signing location.
            @return the signing location
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.LocationCaption">
            Sets the caption for the signing location.
            @param locationCaption the signing location caption
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.SignatureCreator">
             Gets the signature creator.
             @return the signature creator
            
             Sets the name of the application used to create the signature.
             @param signatureCreator the name of the signature creating application
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Contact">
            Gets the signing contact.
            @return the signing contact
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.SignDate">
            Gets the signature date.
            @return the signature date
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.CryptoDictionary">
            Gets the user made signature dictionary. This is the dictionary at the /V key.
            @return the user made signature dictionary
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Certificate">
            Sets the certificate used to provide the text in the appearance.
            This certificate doesn't take part in the actual signing process.
            @param signCertificate the certificate 
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.SignatureEvent">
            Sets the signature event to allow modification of the signature dictionary.
            @param signatureEvent the signature event
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.FieldName">
            Gets the field name.
            @return the field name
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Page">
            Gets the page number of the field.
            @return the page number of the field
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Rect">
            Gets the rectangle representing the signature dimensions.
            @return the rectangle representing the signature dimensions. It may be <CODE>null</CODE>
            or have zero width or height for invisible signatures
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.PageRect">
            Gets the rectangle that represent the position and dimension of the signature in the page.
            @return the rectangle that represent the position and dimension of the signature in the page
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.SignatureRenderingMode">
            Gets the rendering mode for this signature.
            @return the rendering mode for this signature
            @since 5.0.1
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.SignatureGraphic">
            Sets the Image object to render when Render is set to <CODE>RenderingMode.GRAPHIC</CODE>
            or <CODE>RenderingMode.GRAPHIC_AND_DESCRIPTION</CODE>.
            @param signatureGraphic image rendered. If <CODE>null</CODE> the mode is defaulted
            to <CODE>RenderingMode.DESCRIPTION</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Acro6Layers">
            Acrobat 6.0 and higher recommends that only layer n0 and n2 be present.
            Use this method with value <code>false</code> if you want to ignore this recommendation.
            @param acro6Layers if <code>true</code> only the layers n0 and n2 will be present
            @deprecated Adobe no longer supports Adobe Acrobat / Reader versions older than 9
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.ReuseAppearance">
            Indicates that the existing appearances needs to be reused as layer 0.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Image">
            Gets the background image for the layer 2.
            @return the background image for the layer 2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.ImageScale">
            Sets the scaling to be applied to the background image. If it's zero the image
            will fully fill the rectangle. If it's less than zero the image will fill the rectangle but
            will keep the proportions. If it's greater than zero that scaling will be applied.
            In any of the cases the image will always be centered. It's zero by default.
            @param imageScale the scaling to be applied to the background image
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Layer2Text">
            Sets the signature text identifying the signer.
            @param text the signature text identifying the signer. If <CODE>null</CODE> or not set
            a standard description will be used
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Layer2Font">
            Sets the n2 and n4 layer font. If the font size is zero, auto-fit will be used.
            @param layer2Font the n2 and n4 font
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.RunDirection">
            Sets the run direction in the n2 and n4 layer.
            @param runDirection the run direction
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Layer4Text">
            Sets the text identifying the signature status. Will be ignored if acro6Layers is true.
            @param text the text identifying the signature status. If <CODE>null</CODE> or not set
            the description "Signature Not Verified" will be used
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Stamper">
            Gets the <CODE>PdfStamper</CODE> associated with this instance.
            @return the <CODE>PdfStamper</CODE> associated with this instance
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.Sigout">
            Getter for the byte buffer.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.TempFile">
            Gets the temporary file.
            @return the temporary file or <CODE>null</CODE> is the document is created in memory
        </member>
        <member name="P:iTextSharp.text.pdf.PdfSignatureAppearance.FieldLockDict">
            <summary>
            Signature field lock dictionary.
            </summary>
            <remarks>
            If a signature is created on an existing signature field, then its /Lock dictionary 
            takes the precedence (if it exists).
            </remarks>
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSignatureAppearance.ISignatureEvent">
            An interface to retrieve the signature dictionary for modification.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSignatureAppearance.ISignatureEvent.GetSignatureDictionary(iTextSharp.text.pdf.PdfDictionary)">
            Allows modification of the signature dictionary.
            @param sig the signature dictionary
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSignatureAppearance.RenderingMode">
            Signature rendering modes
            @since 5.0.1
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.RenderingMode.DESCRIPTION">
            The rendering mode is just the description.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.RenderingMode.NAME_AND_DESCRIPTION">
            The rendering mode is the name of the signer and the description.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.RenderingMode.GRAPHIC_AND_DESCRIPTION">
            The rendering mode is an image and the description.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSignatureAppearance.RenderingMode.GRAPHIC">
            The rendering mode is just an image.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSmartCopy">
            PdfSmartCopy has the same functionality as PdfCopy,
            but when resources (such as fonts, images,...) are
            encountered, a reference to these resources is saved
            in a cache, so that they can be reused.
            This requires more memory, but reduces the file size
            of the resulting PDF document.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfSmartCopy.streamMap">
            the cache with the streams and references. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSmartCopy.#ctor(iTextSharp.text.Document,System.IO.Stream)">
            Creates a PdfSmartCopy instance. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSmartCopy.CopyIndirect(iTextSharp.text.pdf.PRIndirectReference)">
            Translate a PRIndirectReference to a PdfIndirectReference
            In addition, translates the object numbers, and copies the
            referenced object to the output file if it wasn't available
            in the cache yet. If it's in the cache, the reference to
            the already used stream is returned.
            
            NB: PRIndirectReferences (and PRIndirectObjects) really need to know what
            file they came from, because each file has its own namespace. The translation
            we do from their namespace to ours is *at best* heuristic, and guaranteed to
            fail under some circumstances.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSpotColor">
             A <CODE>PdfSpotColor</CODE> defines a ColorSpace
            
             @see     PdfDictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSpotColor.#ctor(System.String,iTextSharp.text.BaseColor)">
             Constructs a new <CODE>PdfSpotColor</CODE>.
            
             @param       name        a string value
             @param       tint        a tint value between 0 and 1
             @param       altcs       a altnative colorspace value
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfStamper" -->
        <member name="F:iTextSharp.text.pdf.PdfStamper.stamper">
            The writer
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.#ctor(iTextSharp.text.pdf.PdfReader,System.IO.Stream)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.#ctor(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.#ctor(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.PdfStamper.ReplacePage(iTextSharp.text.pdf.PdfReader,System.Int32,System.Int32)">
            Replaces a page from this document with a page from other document. Only the content
            is replaced not the fields and annotations. This method must be called before 
            getOverContent() or getUndercontent() are called for the same page.
            @param r the <CODE>PdfReader</CODE> from where the new page will be imported
            @param pageImported the page number of the imported page
            @param pageReplaced the page to replace in this document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.InsertPage(System.Int32,iTextSharp.text.Rectangle)">
            Inserts a blank page. All the pages above and including <CODE>pageNumber</CODE> will
            be shifted up. If <CODE>pageNumber</CODE> is bigger than the total number of pages
            the new page will be the last one.
            @param pageNumber the page number position where the new page will be inserted
            @param mediabox the size of the new page
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.Close" -->
        <member name="M:iTextSharp.text.pdf.PdfStamper.GetUnderContent(System.Int32)">
            Gets a <CODE>PdfContentByte</CODE> to write under the page of
            the original document.
            @param pageNum the page number where the extra content is written
            @return a <CODE>PdfContentByte</CODE> to write under the page of
            the original document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.GetOverContent(System.Int32)">
            Gets a <CODE>PdfContentByte</CODE> to write over the page of
            the original document.
            @param pageNum the page number where the extra content is written
            @return a <CODE>PdfContentByte</CODE> to write over the page of
            the original document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param strength128Bits <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @throws DocumentException if anything was already written to the output
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetEncryption(System.Boolean,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param strength <code>true</code> for 128 bit key length, <code>false</code> for 40 bit key length
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if anything was already written to the output
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetEncryption(System.Int32,System.String,System.String,System.Int32)">
            Sets the encryption options for this document. The userPassword and the
             ownerPassword can be null or have zero length. In this case the ownerPassword
             is replaced by a random string. The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param userPassword the user password. Can be null or empty
            @param ownerPassword the owner password. Can be null or empty
            @param permissions the user permissions
            @throws DocumentException if the document is already open
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            Sets the certificate encryption options for this document. An array of one or more public certificates
            must be provided together with an array of the same size for the permissions for each certificate.
             The open permissions for the document can be
             AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
             AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
             The permissions can be combined by ORing them.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            @param certs the public certificates to be used for the encryption
            @param permissions the user permissions for each of the certicates
            @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            @throws DocumentException if the encryption was set too late
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.GetImportedPage(iTextSharp.text.pdf.PdfReader,System.Int32)">
            Gets a page from other PDF document. Note that calling this method more than
            once with the same parameters will retrieve the same object.
            @param reader the PDF document where the page is
            @param pageNumber the page number. The first page is 1
            @return the template representing the imported page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddAnnotation(iTextSharp.text.pdf.PdfAnnotation,System.Int32)">
            Adds an annotation of form field in a specific page. This page number
            can be overridden with {@link PdfAnnotation#setPlaceInPage(int)}.
            @param annot the annotation
            @param page the page
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddSignature(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            Adds an empty signature.
            @param name   the name of the signature
            @param page   the page number
            @param llx    lower left x coordinate of the signature's position
            @param lly    lower left y coordinate of the signature's position
            @param urx    upper right x coordinate of the signature's position
            @param ury    upper right y coordinate of the signature's position
            @return   a signature form field
            @since    2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddComments(iTextSharp.text.pdf.FdfReader)">
            Adds the comments present in an FDF file.
            @param fdf the FDF file
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetThumbnail(iTextSharp.text.Image,System.Int32)">
            Sets the thumbnail image for a page.
            @param image the image
            @param page the page
            @throws PdfException on error
            @throws DocumentException on error
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.PartialFormFlattening(System.String)" -->
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddJavaScript(System.String,System.String)">
            Adds a JavaScript action at the document level. When the document
            opens all this JavaScript runs. The existing JavaScript will be replaced.
            @param name the name for the JavaScript snippet in the name tree
            @param js the JavaScript code
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddFileAttachment(System.String,System.Byte[],System.String,System.String)">
            Adds a file attachment at the document level. Existing attachments will be kept.
            @param description the file description
            @param fileStore an array with the file. If it's <CODE>null</CODE>
            the file will be read from the disk
            @param file the path to the file. It will only be used if
            <CODE>fileStore</CODE> is not <CODE>null</CODE>
            @param fileDisplay the actual file name stored in the pdf
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddFileAttachment(System.String,iTextSharp.text.pdf.PdfFileSpecification)">
            Adds a file attachment at the document level. Existing attachments will be kept.
            @param description the file description
            @param fs the file specification
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.MakePackage(iTextSharp.text.pdf.PdfName)" -->
        <member name="M:iTextSharp.text.pdf.PdfStamper.MakePackage(iTextSharp.text.pdf.collection.PdfCollection)">
            Adds or replaces the Collection Dictionary in the Catalog.
            @param    collection  the new collection dictionary.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Adds a viewer preference
            @param preferences the viewer preferences
            @see PdfViewerPreferences#addViewerPreference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetFullCompression">
            Sets the document's compression to the new 1.5 mode with object streams and xref
            streams. Be attentive!!! If you want set full compression , you should set immediately after creating PdfStamper,
            before editing the document.It can be set once and it can't be unset.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetPageAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction,System.Int32)">
            Sets the open and close page additional action.
            @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
            or <CODE>PdfWriter.PAGE_CLOSE</CODE>
            @param action the action to perform
            @param page the page where the action will be applied. The first page is 1
            @throws PdfException if the action type is invalid
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetDuration(System.Int32,System.Int32)">
            Sets the display duration for the page (for presentations)
            @param seconds   the number of seconds to display the page. A negative value removes the entry
            @param page the page where the duration will be applied. The first page is 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamper.SetTransition(iTextSharp.text.pdf.PdfTransition,System.Int32)">
            Sets the transition for the page
            @param transition   the transition object. A <code>null</code> removes the transition
            @param page the page where the transition will be applied. The first page is 1
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.CreateSignature(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.CreateSignature(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.PdfStamper.CreateSignature(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char,System.String)" -->
        <member name="M:iTextSharp.text.pdf.PdfStamper.GetPdfLayers">
            Gets the PdfLayer objects in an existing document as a Map
            with the names/titles of the layers as keys.
            @return   a Map with all the PdfLayers in the document (and the name/title of the layer as key)
            @since    2.1.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.MoreInfo">
            Gets the optional <CODE>String</CODE> map to add or change values in
             the info dictionary.
             @return the map or <CODE>null</CODE>
            
            An optional <CODE>String</CODE> map to add or change values in
             the info dictionary. Entries with <CODE>null</CODE>
             values delete the key in the original info dictionary
             @param moreInfo additional entries to the info dictionary
            
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.SignatureAppearance">
            Gets the signing instance. The appearances and other parameters can the be set.
            @return the signing instance
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.XmlSignatureAppearance">
            Gets the xml signing instance. The appearances and other parameters can the be set.
            @return the signing instance
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.RotateContents">
            Checks if the content is automatically adjusted to compensate
            the original page rotation.
            @return the auto-rotation status
            Flags the content to be automatically adjusted to compensate
            the original page rotation. The default is <CODE>true</CODE>.
            @param rotateContents <CODE>true</CODE> to set auto-rotation, <CODE>false</CODE>
            otherwise
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.Writer">
            Gets the underlying PdfWriter.
            @return the underlying PdfWriter
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.Reader">
            Gets the underlying PdfReader.
            @return the underlying PdfReader
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.AcroFields">
            Gets the <CODE>AcroFields</CODE> object that allows to get and set field values
            and to merge FDF forms.
            @return the <CODE>AcroFields</CODE> object
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.FormFlattening">
            Determines if the fields are flattened on close. The fields added with
            {@link #addAnnotation(PdfAnnotation,int)} will never be flattened.
            @param flat <CODE>true</CODE> to flatten the fields, <CODE>false</CODE>
            to keep the fields
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.FreeTextFlattening">
            Determines if the FreeText annotations are flattened on close. 
            @param flat <CODE>true</CODE> to flatten the FreeText annotations, <CODE>false</CODE>
            (the default) to keep the FreeText annotations as active content.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.AnnotationFlattening">
             Flatten annotations with an appearance stream on close().
            
             @param flat boolean to indicate whether iText should flatten annotations or not.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.Outlines">
            Sets the bookmarks. The list structure is defined in
            {@link SimpleBookmark}.
            @param outlines the bookmarks or <CODE>null</CODE> to remove any
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.JavaScript">
            Adds a JavaScript action at the document level. When the document
            opens all this JavaScript runs. The existing JavaScript will be replaced.
            @param js the JavaScript code
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.ViewerPreferences">
            Sets the viewer preferences.
            @param preferences the viewer preferences
            @see PdfViewerPreferences#setViewerPreferences(int)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.XmpMetadata">
            Sets the XMP metadata.
            @param xmp
            @see PdfWriter#setXmpMetadata(byte[])
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamper.FullCompression">
            Gets the 1.5 compression status.
            @return <code>true</code> if the 1.5 compression is on
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStamperImp.pagesToContent">
            Integer(page number) -> PageStamp 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStamperImp.rotateContents">
            Holds value of property rotateContents. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.#ctor(iTextSharp.text.pdf.PdfReader,System.IO.Stream,System.Char,System.Boolean)">
            Creates new PdfStamperImp.
            @param reader the read PDF
            @param os the output destination
            @param pdfVersion the new pdf version or '\0' to keep the same version as the original
            document
            @param append
            @throws DocumentException on error
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.RegisterReader(iTextSharp.text.pdf.PdfReader,System.Boolean)">
            @param reader
            @param openFile
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.UnRegisterReader(iTextSharp.text.pdf.PdfReader)">
            @param reader
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.AddComments(iTextSharp.text.pdf.FdfReader)">
            @param fdf
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.GetPageReference(System.Int32)">
            @see com.lowagie.text.pdf.PdfWriter#getPageReference(int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.AddAnnotation(iTextSharp.text.pdf.PdfAnnotation)">
            @see com.lowagie.text.pdf.PdfWriter#addAnnotation(com.lowagie.text.pdf.PdfAnnotation)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.MakePackage(iTextSharp.text.pdf.collection.PdfCollection)">
            Adds or replaces the Collection Dictionary in the Catalog.
            @param   collection  the new collection dictionary.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.AddViewerPreference(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Adds a viewer preference
            @param preferences the viewer preferences
            @see PdfViewerPreferences#addViewerPreference
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetPageAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
            Always throws an <code>UnsupportedOperationException</code>.
            @param actionType ignore
            @param action ignore
            @throws PdfException ignore
            @see PdfStamper#setPageAction(PdfName, PdfAction, int)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetPageAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction,System.Int32)">
            Sets the open and close page additional action.
            @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
            or <CODE>PdfWriter.PAGE_CLOSE</CODE>
            @param action the action to perform
            @param page the page where the action will be applied. The first page is 1
            @throws PdfException if the action type is invalid
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetDuration(System.Int32,System.Int32)">
            Sets the display duration for the page (for presentations)
            @param seconds   the number of seconds to display the page. A negative value removes the entry
            @param page the page where the duration will be applied. The first page is 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetTransition(iTextSharp.text.pdf.PdfTransition,System.Int32)">
            Sets the transition for the page
            @param transition   the transition object. A <code>null</code> removes the transition
            @param page the page where the transition will be applied. The first page is 1
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.IsAppend">
            Getter for property append.
            @return Value of property append.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetAdditionalAction(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfAction)">
            Additional-actions defining the actions to be taken in
             response to various trigger events affecting the document
             as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,
             <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>
             and <CODE>DID_PRINT</CODE>.
            
             @param actionType the action type
             @param action the action to execute in response to the trigger
             @throws PdfException on invalid action type
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetOpenAction(iTextSharp.text.pdf.PdfAction)">
            @see com.lowagie.text.pdf.PdfWriter#setOpenAction(com.lowagie.text.pdf.PdfAction)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.SetOpenAction(System.String)">
            @see com.lowagie.text.pdf.PdfWriter#setOpenAction(java.lang.String)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.ReadOCProperties">
            Reads the OCProperties dictionary from the catalog of the existing document
            and fills the documentOCG, documentOCGorder and OCGRadioGroup variables in PdfWriter.
            Note that the original OCProperties of the existing document can contain more information.
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.AddOrder(iTextSharp.text.pdf.PdfLayer,iTextSharp.text.pdf.PdfArray,System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.PdfLayer})">
            Recursive method to reconstruct the documentOCGorder variable in the writer.
            @param    parent  a parent PdfLayer (can be null)
            @param    arr     an array possibly containing children for the parent PdfLayer
            @param    ocgmap  a Hashtable with indirect reference Strings as keys and PdfLayer objects as values.
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStamperImp.GetPdfLayers">
            Gets the PdfLayer objects in an existing document as a Map
            with the names/titles of the layers as keys.
            @return   a Map with all the PdfLayers in the document (and the name/title of the layer as key)
            @since    2.1.2
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.FlatAnnotations">
             If true, annotations with an appearance stream will be flattened.
            
             @since 5.5.3
             @param flatAnnotations boolean
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.ViewerPreferences">
            Sets the viewer preferences.
            @param preferences the viewer preferences
            @see PdfWriter#setViewerPreferences(int)
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.SigFlags">
            Set the signature flags.
            @param f the flags. This flags are ORed with current ones
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.Duration">
            Always throws an <code>UnsupportedOperationException</code>.
            @param seconds ignore
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.Transition">
            Always throws an <code>UnsupportedOperationException</code>.
            @param transition ignore
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStamperImp.Thumbnail">
            @see com.lowagie.text.pdf.PdfWriter#setThumbnail(com.lowagie.text.Image)
        </member>
        <member name="T:iTextSharp.text.pdf.PdfStructureElement">
            This is a node in a document logical structure. It may contain a mark point or it may contain
            other nodes.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStructureElement.parent">
            Holds value of property kids.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStructureElement.reference">
            Holds value of property reference.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureElement.#ctor(iTextSharp.text.pdf.PdfStructureElement,iTextSharp.text.pdf.PdfName)">
            Creates a new instance of PdfStructureElement.
            @param parent the parent of this node
            @param structureType the type of structure. It may be a standard type or a user type mapped by the role map
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureElement.#ctor(iTextSharp.text.pdf.PdfStructureTreeRoot,iTextSharp.text.pdf.PdfName)">
            Creates a new instance of PdfStructureElement.
            @param parent the parent of this node
            @param structureType the type of structure. It may be a standard type or a user type mapped by the role map
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureElement.GetAttribute(iTextSharp.text.pdf.PdfName)">
            Gets the first entarance of attribute.
            @returns PdfObject
            @since 5.3.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureElement.SetAttribute(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Sets the attribute value.
            @since 5.3.4
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStructureElement.Parent">
            Gets the parent of this node.
            @return the parent of this node
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStructureElement.Reference">
            Gets the reference this object will be written to.
            @return the reference this object will be written to
        </member>
        <member name="T:iTextSharp.text.pdf.PdfStructureTreeRoot">
            The structure tree root corresponds to the highest hierarchy level in a tagged PDF.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfStructureTreeRoot.writer">
            Holds value of property writer.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureTreeRoot.#ctor(iTextSharp.text.pdf.PdfWriter)">
            Creates a new instance of PdfStructureTreeRoot 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureTreeRoot.MapRole(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfName)">
            Maps the user tags to the standard tags. The mapping will allow a standard application to make some sense of the tagged
            document whatever the user tags may be.
            @param used the user tag
            @param standard the standard tag
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureTreeRoot.GetAttribute(iTextSharp.text.pdf.PdfName)">
            Gets the first entarance of attribute.
            @returns PdfObject
            @since 5.3.4
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructureTreeRoot.SetAttribute(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Sets the attribute value.
            @since 5.3.4
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStructureTreeRoot.Writer">
            Gets the writer.
            @return the writer
        </member>
        <member name="P:iTextSharp.text.pdf.PdfStructureTreeRoot.Reference">
            Gets the reference this object will be written to.
            @return the reference this object will be written to
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PdfTextArray" -->
        <member name="M:iTextSharp.text.pdf.PdfTextArray.Add(iTextSharp.text.pdf.PdfNumber)">
             Adds a <CODE>PdfNumber</CODE> to the <CODE>PdfArray</CODE>.
            
             @param  number   displacement of the string
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.SPLITVOUT">
            Out Vertical Split
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.SPLITHOUT">
            Out Horizontal Split
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.SPLITVIN">
            In Vertical Split
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.SPLITHIN">
            IN Horizontal Split
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.BLINDV">
            Vertical Blinds
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.BLINDH">
            Vertical Blinds
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.INBOX">
            Inward Box
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.OUTBOX">
            Outward Box
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.LRWIPE">
            Left-Right Wipe
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.RLWIPE">
            Right-Left Wipe
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.BTWIPE">
            Bottom-Top Wipe
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.TBWIPE">
            Top-Bottom Wipe
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.DISSOLVE">
            Dissolve
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.LRGLITTER">
            Left-Right Glitter
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.TBGLITTER">
            Top-Bottom Glitter
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.DGLITTER">
            Diagonal Glitter
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.duration">
            duration of the transition effect
        </member>
        <member name="F:iTextSharp.text.pdf.PdfTransition.type">
            type of the transition effect
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTransition.#ctor">
              Constructs a <CODE>Transition</CODE>.
            
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTransition.#ctor(System.Int32)">
              Constructs a <CODE>Transition</CODE>.
            
            @param  type      type of the transition effect
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTransition.#ctor(System.Int32,System.Int32)">
              Constructs a <CODE>Transition</CODE>.
            
            @param  type      type of the transition effect
            @param  duration  duration of the transition effect
        </member>
        <member name="T:iTextSharp.text.pdf.PdfTransparencyGroup">
            The transparency group dictionary.
            
             @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PdfTransparencyGroup.#ctor">
            Constructs a transparencyGroup.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTransparencyGroup.Isolated">
            Determining the initial backdrop against which its stack is composited.
            @param isolated
        </member>
        <member name="P:iTextSharp.text.pdf.PdfTransparencyGroup.Knockout">
            Determining whether the objects within the stack are composited with one another or only with the group's backdrop.
            @param knockout
        </member>
        <member name="T:iTextSharp.text.pdf.PdfVisibilityExpression">
            An array specifying a visibility expression, used to compute visibility
            of content based on a set of optional content groups.
            @since 5.0.2
        </member>
        <member name="F:iTextSharp.text.pdf.PdfVisibilityExpression.OR">
            A boolean operator. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfVisibilityExpression.AND">
            A boolean operator. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfVisibilityExpression.NOT">
            A boolean operator. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.#ctor(System.Int32)">
            Creates a visibility expression.
            @param type should be AND, OR, or NOT
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.Add(System.Int32,iTextSharp.text.pdf.PdfObject)">
            @see com.itextpdf.text.pdf.PdfArray#add(int, com.itextpdf.text.pdf.PdfObject)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.Add(iTextSharp.text.pdf.PdfObject)">
            @see com.itextpdf.text.pdf.PdfArray#add(com.itextpdf.text.pdf.PdfObject)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.AddFirst(iTextSharp.text.pdf.PdfObject)">
            @see com.itextpdf.text.pdf.PdfArray#addFirst(com.itextpdf.text.pdf.PdfObject)
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.Add(System.Single[])">
            @see com.itextpdf.text.pdf.PdfArray#add(float[])
        </member>
        <member name="M:iTextSharp.text.pdf.PdfVisibilityExpression.Add(System.Int32[])">
            @see com.itextpdf.text.pdf.PdfArray#add(int[])
        </member>
        <member name="T:iTextSharp.text.pdf.PdfXConformanceException">
            
             @author  psoares
        </member>
        <member name="F:iTextSharp.text.pdf.PdfIsoConformanceException.serialVersionUID">
            Serial version UID 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIsoConformanceException.#ctor">
            Creates a new instance of PdfIsoConformanceException. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfIsoConformanceException.#ctor(System.String)">
            Creates a new instance of PdfIsoConformanceException.
            @param s
        </member>
        <member name="M:iTextSharp.text.pdf.PdfXConformanceException.#ctor">
            Creates a new instance of PdfXConformanceException. 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfXConformanceException.#ctor(System.String)">
            Creates a new instance of PdfXConformanceException.
            @param s
        </member>
        <member name="T:iTextSharp.text.pdf.Pfm2afm">
            Converts a PFM file into an AFM file.
        </member>
        <member name="M:iTextSharp.text.pdf.Pfm2afm.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray,System.IO.Stream)">
            Creates a new instance of Pfm2afm 
        </member>
        <member name="M:iTextSharp.text.pdf.Pfm2afm.Convert(iTextSharp.text.pdf.RandomAccessFileOrArray,System.IO.Stream)">
            Converts a PFM file into an AFM file.
            @param inp the PFM file
            @param outp the AFM file
            @throws IOException on error
        </member>
        <member name="F:iTextSharp.text.pdf.Pfm2afm.Win2PSStd">
            Translate table from 1004 to psstd.  1004 is an extension of the
            Windows translate table used in PM.
        </member>
        <member name="F:iTextSharp.text.pdf.Pfm2afm.WinClass">
            Character class.  This is a minor attempt to overcome the problem that
            in the pfm file, all unused characters are given the width of space.
            Note that this array isn't used in iText.
        </member>
        <member name="F:iTextSharp.text.pdf.Pfm2afm.WinChars">
            Windows character names.  Give a name to the used locations
            for when the all flag is specified.
        </member>
        <member name="T:iTextSharp.text.pdf.PRAcroForm">
            This class captures an AcroForm on input. Basically, it extends Dictionary
            by indexing the fields of an AcroForm
            @author Mark Thompson
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.#ctor(iTextSharp.text.pdf.PdfReader)">
            Constructor
            @param reader reader of the input file
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.GetRefByName(System.String)">
            Given the title (/T) of a reference, return the associated reference
            @param name a string containing the path
            @return a reference to the field, or null
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.ReadAcroForm(iTextSharp.text.pdf.PdfDictionary)">
            Read, and comprehend the acroform
            @param root the docment root
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.IterateFields(iTextSharp.text.pdf.PdfArray,iTextSharp.text.pdf.PRIndirectReference,System.String)">
            After reading, we index all of the fields. Recursive.
            @param fieldlist An array of fields
            @param fieldDict the last field dictionary we encountered (recursively)
            @param parentPath the pathname of the field, up to this point or null
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.MergeAttrib(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary)">
            merge field attributes from two dictionaries
            @param parent one dictionary
            @param child the other dictionary
            @return a merged dictionary
        </member>
        <member name="M:iTextSharp.text.pdf.PRAcroForm.PushAttrib(iTextSharp.text.pdf.PdfDictionary)">
            stack a level of dictionary. Merge in a dictionary from this level
        </member>
        <member name="P:iTextSharp.text.pdf.PRAcroForm.Size">
            Number of fields found
            @return size
        </member>
        <member name="T:iTextSharp.text.pdf.PRAcroForm.FieldInformation">
            This class holds the information for a single field
        </member>
        <member name="P:iTextSharp.text.pdf.PRAcroForm.FieldInformation.WidgetName">
            Returns the name of the widget annotation (the /NM entry).
            @return	a String or null (if there's no /NM key)
        </member>
        <member name="M:iTextSharp.text.pdf.PRIndirectReference.#ctor(iTextSharp.text.pdf.PdfReader,System.Int32,System.Int32)">
             Constructs a <CODE>PdfIndirectReference</CODE>.
            
             @param        reader            a <CODE>PdfReader</CODE>
             @param        number            the object number.
             @param        generation        the generation number.
        </member>
        <member name="M:iTextSharp.text.pdf.PRIndirectReference.#ctor(iTextSharp.text.pdf.PdfReader,System.Int32)">
             Constructs a <CODE>PdfIndirectReference</CODE>.
            
             @param        reader            a <CODE>PdfReader</CODE>
             @param        number            the object number.
        </member>
        <member name="M:iTextSharp.text.pdf.PRStream.#ctor(iTextSharp.text.pdf.PdfReader,System.Byte[],System.Int32)">
            Creates a new PDF stream object that will replace a stream
            in a existing PDF file.
            @param   reader  the reader that holds the existing PDF
            @param   conts   the new content
            @param   compressionLevel    the compression level for the content
            @since   2.1.3 (replacing the existing constructor without param compressionLevel)
        </member>
        <member name="M:iTextSharp.text.pdf.PRStream.SetData(System.Byte[],System.Boolean)">
            Sets the data associated with the stream, either compressed or
            uncompressed. Note that the data will never be compressed if
            Document.compress is set to false.
            
            @param data raw data, decrypted and uncompressed.
            @param compress true if you want the stream to be compresssed.
            @since   iText 2.1.1
        </member>
        <member name="M:iTextSharp.text.pdf.PRStream.SetData(System.Byte[],System.Boolean,System.Int32)">
            Sets the data associated with the stream, either compressed or
            uncompressed. Note that the data will never be compressed if
            Document.compress is set to false.
            
            @param data raw data, decrypted and uncompressed.
            @param compress true if you want the stream to be compresssed.
            @param compressionLevel  a value between -1 and 9 (ignored if compress == false)
            @since   iText 2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.PRStream.SetDataRaw(System.Byte[])">
             Sets the data associated with the stream, as-is.  This method will not
             remove or change any existing filter: the data has to match an existing
             filter or an appropriate filter has to be set.
            
             @param data data, possibly encrypted and/or compressed
             @since 5.5.0
        </member>
        <member name="M:iTextSharp.text.pdf.PRStream.SetData(System.Byte[])">
            Sets the data associated with the stream
            @param data raw data, decrypted and uncompressed.
        </member>
        <member name="T:iTextSharp.text.pdf.PRTokeniser">
            
             @author  Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.PRTokeniser.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Creates a PRTokeniser for the specified {@link RandomAccessSource}.
            The beginning of the file is read to determine the location of the header, and the data source is adjusted
            as necessary to account for any junk that occurs in the byte source before the header
            @param file the source
        </member>
        <member name="M:iTextSharp.text.pdf.PRTokeniser.IsWhitespace(System.Int32)">
            Is a certain character a whitespace? Currently checks on the following: '0', '9', '10', '12', '13', '32'.
            <br />The same as calling {@link #isWhitespace(int, boolean) isWhiteSpace(ch, true)}.
            @param ch int
            @return boolean
            @since 5.5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PRTokeniser.IsWhitespace(System.Int32,System.Boolean)">
            Checks whether a character is a whitespace. Currently checks on the following: '0', '9', '10', '12', '13', '32'.
            @param ch int
            @param isWhitespace boolean
            @return boolean
            @since 5.5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PRTokeniser.ReadLineSegment(System.Byte[])">
             Reads data into the provided byte[]. Checks on leading whitespace.
             See {@link #isWhitespace(int) isWhiteSpace(int)} or {@link #isWhitespace(int, boolean) isWhiteSpace(int, boolean)}
             for a list of whitespace characters.
             <br />The same as calling {@link #readLineSegment(byte[], boolean) readLineSegment(input, true)}.
            
             @param input byte[]
             @return boolean
             @throws IOException
             @since 5.5.1
        </member>
        <member name="M:iTextSharp.text.pdf.PRTokeniser.ReadLineSegment(System.Byte[],System.Boolean)">
             Reads data into the provided byte[]. Checks on leading whitespace.
             See {@link #isWhitespace(int) isWhiteSpace(int)} or {@link #isWhitespace(int, boolean) isWhiteSpace(int, boolean)}
             for a list of whitespace characters.
            
             @param input byte[]
             @param isNullWhitespace boolean to indicate whether '0' is whitespace or not.
                                     If in doubt, use true or overloaded method {@link #readLineSegment(byte[]) readLineSegment(input)}
             @return boolean
             @throws IOException
             @since 5.5.1
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.PushbuttonField" -->
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_LABEL_ONLY">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_ICON_ONLY">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_ICON_TOP_LABEL_BOTTOM">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_LABEL_TOP_ICON_BOTTOM">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_ICON_LEFT_LABEL_RIGHT">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_LABEL_LEFT_ICON_RIGHT">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.LAYOUT_LABEL_OVER_ICON">
            A layout option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.SCALE_ICON_ALWAYS">
            An icon scaling option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.SCALE_ICON_NEVER">
            An icon scaling option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.SCALE_ICON_IS_TOO_BIG">
            An icon scaling option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.SCALE_ICON_IS_TOO_SMALL">
            An icon scaling option 
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.layout">
            Holds value of property layout.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.image">
            Holds value of property image.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.template">
            Holds value of property template.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.scaleIcon">
            Holds value of property scaleIcon.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.proportionalIcon">
            Holds value of property proportionalIcon.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.iconVerticalAdjustment">
            Holds value of property iconVerticalAdjustment.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.iconHorizontalAdjustment">
            Holds value of property iconHorizontalAdjustment.
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.iconFitToBounds">
            Holds value of property iconFitToBounds.
        </member>
        <member name="M:iTextSharp.text.pdf.PushbuttonField.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String)">
            Creates a new instance of PushbuttonField
            @param writer the document <CODE>PdfWriter</CODE>
            @param box the field location and dimensions
            @param fieldName the field name. If <CODE>null</CODE> only the widget keys
            will be included in the field allowing it to be used as a kid field.
        </member>
        <member name="M:iTextSharp.text.pdf.PushbuttonField.GetAppearance">
            Gets the button appearance.
            @throws IOException on error
            @throws DocumentException on error
            @return the button appearance
        </member>
        <member name="F:iTextSharp.text.pdf.PushbuttonField.iconReference">
            Holds value of property iconReference.
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.Layout">
            Sets the icon and label layout. Possible values are <CODE>LAYOUT_LABEL_ONLY</CODE>,
            <CODE>LAYOUT_ICON_ONLY</CODE>, <CODE>LAYOUT_ICON_TOP_LABEL_BOTTOM</CODE>,
            <CODE>LAYOUT_LABEL_TOP_ICON_BOTTOM</CODE>, <CODE>LAYOUT_ICON_LEFT_LABEL_RIGHT</CODE>,
            <CODE>LAYOUT_LABEL_LEFT_ICON_RIGHT</CODE> and <CODE>LAYOUT_LABEL_OVER_ICON</CODE>.
            The default is <CODE>LAYOUT_LABEL_ONLY</CODE>.
            @param layout New value of property layout.
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.Image">
            Sets the icon as an image.
            @param image the image
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.Template">
            Sets the icon as a template.
            @param template the template
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.ScaleIcon">
            Sets the way the icon will be scaled. Possible values are
            <CODE>SCALE_ICON_ALWAYS</CODE>, <CODE>SCALE_ICON_NEVER</CODE>,
            <CODE>SCALE_ICON_IS_TOO_BIG</CODE> and <CODE>SCALE_ICON_IS_TOO_SMALL</CODE>.
            The default is <CODE>SCALE_ICON_ALWAYS</CODE>.
            @param scaleIcon the way the icon will be scaled
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.ProportionalIcon">
            Sets the way the icon is scaled. If <CODE>true</CODE> the icon is scaled proportionally,
            if <CODE>false</CODE> the scaling is done anamorphicaly.
            @param proportionalIcon the way the icon is scaled
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.IconVerticalAdjustment">
            A number between 0 and 1 indicating the fraction of leftover space to allocate at the bottom of the icon.
            A value of 0 positions the icon at the bottom of the annotation rectangle.
            A value of 0.5 centers it within the rectangle. The default is 0.5.
            @param iconVerticalAdjustment a number between 0 and 1 indicating the fraction of leftover space to allocate at the bottom of the icon
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.IconHorizontalAdjustment">
            A number between 0 and 1 indicating the fraction of leftover space to allocate at the left of the icon.
            A value of 0 positions the icon at the left of the annotation rectangle.
            A value of 0.5 centers it within the rectangle. The default is 0.5.
            @param iconHorizontalAdjustment a number between 0 and 1 indicating the fraction of leftover space to allocate at the left of the icon
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.Field">
            Gets the pushbutton field.
            @throws IOException on error
            @throws DocumentException on error
            @return the pushbutton field
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.IconFitToBounds">
            If <CODE>true</CODE> the icon will be scaled to fit fully within the bounds of the annotation,
            if <CODE>false</CODE> the border width will be taken into account. The default
            is <CODE>false</CODE>.
            @param iconFitToBounds if <CODE>true</CODE> the icon will be scaled to fit fully within the bounds of the annotation,
            if <CODE>false</CODE> the border width will be taken into account
        </member>
        <member name="P:iTextSharp.text.pdf.PushbuttonField.IconReference">
            Sets the reference to an existing icon.
            @param iconReference the reference to an existing icon
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.BitArray">
             <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>
            
             @author Sean Owen
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.Get(System.Int32)">
            @param i bit to get
            @return true iff bit i is set
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.Set(System.Int32)">
             Sets bit i.
            
             @param i bit to set
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.Flip(System.Int32)">
             Flips bit i.
            
             @param i bit to set
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.SetBulk(System.Int32,System.Int32)">
             Sets a block of 32 bits, starting at bit i.
            
             @param i first bit to set
             @param newBits the new value of the next 32 bits. Note again that the least-significant bit
             corresponds to bit i, the next-least-significant to i+1, and so on.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.Clear">
            Clears all bits (sets to false).
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.IsRange(System.Int32,System.Int32,System.Boolean)">
             Efficient method to check if a range of bits is set, or not set.
            
             @param start start of range, inclusive.
             @param end end of range, exclusive
             @param value if true, checks that bits in range are set, otherwise checks that they are not set
             @return true iff all bits are set or not set in range, according to value argument
             @throws IllegalArgumentException if end is less than or equal to start
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.GetBitArray">
            @return underlying array of ints. The first element holds the first 32 bits, and the least
                    significant bit is bit 0.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitArray.Reverse">
            Reverses all bits in the array.
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.BitMatrix">
             <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
             module, x is the column position, and y is the row position. The ordering is always x, y.
             The origin is at the top-left.</p>
            
             <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
             with a new int. This is done intentionally so that we can copy out a row into a BitArray very
             efficiently.</p>
            
             <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
             meaning they represent lower x values. This is compatible with BitArray's implementation.</p>
            
             @author Sean Owen
             @author dswitkin@google.com (Daniel Switkin)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.Get(System.Int32,System.Int32)">
             <p>Gets the requested bit, where true means black.</p>
            
             @param x The horizontal component (i.e. which column)
             @param y The vertical component (i.e. which row)
             @return value of given bit in matrix
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.Set(System.Int32,System.Int32)">
             <p>Sets the given bit to true.</p>
            
             @param x The horizontal component (i.e. which column)
             @param y The vertical component (i.e. which row)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.Flip(System.Int32,System.Int32)">
             <p>Flips the given bit.</p>
            
             @param x The horizontal component (i.e. which column)
             @param y The vertical component (i.e. which row)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.Clear">
            Clears all bits (sets to false).
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.SetRegion(System.Int32,System.Int32,System.Int32,System.Int32)">
             <p>Sets a square region of the bit matrix to true.</p>
            
             @param left The horizontal position to begin at (inclusive)
             @param top The vertical position to begin at (inclusive)
             @param width The width of the region
             @param height The height of the region
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.GetRow(System.Int32,iTextSharp.text.pdf.qrcode.BitArray)">
             A fast method to retrieve one row of data from the matrix as a BitArray.
            
             @param y The row to retrieve
             @param row An optional caller-allocated BitArray, will be allocated if null or too small
             @return The resulting BitArray - this reference should always be used even when passing
                     your own row
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.GetWidth">
            @return The width of the matrix
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.GetHeight">
            @return The height of the matrix
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.BitMatrix.GetDimension">
             This method is for compatibility with older code. It's only logical to call if the matrix
             is square, so I'm throwing if that's not the case.
            
             @return row/column dimension of this matrix
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.BitVector">
             JAVAPORT: This should be combined with BitArray in the future, although that class is not yet
             dynamically resizeable. This implementation is reasonable but there is a lot of function calling
             in loops I'd like to get rid of.
            
             @author satorux@google.com (Satoru Takabayashi) - creator
             @author dswitkin@google.com (Daniel Switkin) - ported from C++
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.ByteArray">
             This class implements an array of unsigned bytes.
            
             @author dswitkin@google.com (Daniel Switkin)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.ByteArray.At(System.Int32)">
            Access an unsigned byte at location index.
            @param index The index in the array to access.
            @return The unsigned value of the byte as an int.
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.qrcode.ByteMatrix" -->
        <member name="T:iTextSharp.text.pdf.qrcode.CharacterSetECI">
             Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
             of ISO 18004.
            
             @author Sean Owen
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.CharacterSetECI.GetCharacterSetECIByName(System.String)">
            @param name character set ECI encoding name
            @return {@link CharacterSetECI} representing ECI for character encoding, or null if it is legal
              but unsupported
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.EncodeHintType">
             These are a set of hints that you may pass to Writers to specify their behavior.
            
             @author dswitkin@google.com (Daniel Switkin)
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.EncodeHintType.ERROR_CORRECTION">
            Specifies what degree of error correction to use, for example in QR Codes (type Integer).
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.EncodeHintType.CHARACTER_SET">
            Specifies what character encoding to use where applicable (type String)
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.Encoder">
            @author satorux@google.com (Satoru Takabayashi) - creator
            @author dswitkin@google.com (Daniel Switkin) - ported from C++
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.Encode(System.String,iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel,iTextSharp.text.pdf.qrcode.QRCode)">
              Encode "bytes" with the error correction level "ecLevel". The encoding mode will be chosen
             internally by ChooseMode(). On success, store the result in "qrCode".
            
             We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for
             "getECLevel" since our primary use is to show QR code on desktop screens. We don't need very
             strong error correction for this purpose.
            
             Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()
             with which clients can specify the encoding mode. For now, we don't need the functionality.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.GetAlphanumericCode(System.Int32)">
            @return the code point of the table used in alphanumeric mode or
             -1 if there is no corresponding code in the table.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.ChooseMode(System.String,System.String)">
            Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
            if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.InitQRCode(System.Int32,iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel,iTextSharp.text.pdf.qrcode.Mode,iTextSharp.text.pdf.qrcode.QRCode)">
            Initialize "qrCode" according to "numInputBytes", "ecLevel", and "mode". On success,
            modify "qrCode".
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.TerminateBits(System.Int32,iTextSharp.text.pdf.qrcode.BitVector)">
            Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.GetNumDataBytesAndNumECBytesForBlockID(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            Get number of data bytes and number of error correction bytes for block id "blockID". Store
            the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
            JISX0510:2004 (p.30)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.InterleaveWithECBytes(iTextSharp.text.pdf.qrcode.BitVector,System.Int32,System.Int32,System.Int32,iTextSharp.text.pdf.qrcode.BitVector)">
            Interleave "bits" with corresponding error correction bytes. On success, store the result in
            "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.AppendModeInfo(iTextSharp.text.pdf.qrcode.Mode,iTextSharp.text.pdf.qrcode.BitVector)">
            Append mode info. On success, store the result in "bits".
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.AppendLengthInfo(System.Int32,System.Int32,iTextSharp.text.pdf.qrcode.Mode,iTextSharp.text.pdf.qrcode.BitVector)">
            Append length info. On success, store the result in "bits".
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Encoder.AppendBytes(System.String,iTextSharp.text.pdf.qrcode.Mode,iTextSharp.text.pdf.qrcode.BitVector,System.String)">
            Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel">
             <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
             defined by the QR code standard.</p>
            
             @author Sean Owen
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel.L">
            L = ~7% correction
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel.M">
            M = ~15% correction
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel.Q">
            Q = ~25% correction
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel.H">
            H = ~30% correction
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.ErrorCorrectionLevel.ForBits(System.Int32)">
            @param bits int containing the two bits encoding a QR Code's error correction level
            @return {@link ErrorCorrectionLevel} representing the encoded error correction level
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.FormatInformation">
             <p>Encapsulates a QR Code's format information, including the data mask used and
             error correction level.</p>
            
             @author Sean Owen
             @see ErrorCorrectionLevel
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.FormatInformation.FORMAT_INFO_DECODE_LOOKUP">
            See ISO 18004:2006, Annex C, Table C.1
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.FormatInformation.BITS_SET_IN_HALF_BYTE">
            Offset i holds the number of 1 bits in the binary representation of i
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.FormatInformation.DecodeFormatInformation(System.Int32,System.Int32)">
            @param maskedFormatInfo1 format info indicator, with mask still applied
            @param maskedFormatInfo2 second copy of same info; both are checked at the same time
             to establish best match
            @return information about the format it specifies, or <code>null</code>
             if doesn't seem to match any known pattern
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.GF256">
             <p>This class contains utility methods for performing mathematical operations over
             the Galois Field GF(256). Operations use a given primitive polynomial in calculations.</p>
            
             <p>Throughout this package, elements of GF(256) are represented as an <code>int</code>
             for convenience and speed (but at the cost of memory).
             Only the bottom 8 bits are really used.</p>
            
             @author Sean Owen
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.#ctor(System.Int32)">
             Create a representation of GF(256) using the given primitive polynomial.
            
             @param primitive irreducible polynomial whose coefficients are represented by
              the bits of an int, where the least-significant bit represents the constant
              coefficient
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.BuildMonomial(System.Int32,System.Int32)">
            @return the monomial representing coefficient * x^degree
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.AddOrSubtract(System.Int32,System.Int32)">
             Implements both addition and subtraction -- they are the same in GF(256).
            
             @return sum/difference of a and b
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.Exp(System.Int32)">
            @return 2 to the power of a in GF(256)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.Log(System.Int32)">
            @return base 2 log of a in GF(256)
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.Inverse(System.Int32)">
            @return multiplicative inverse of a
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256.Multiply(System.Int32,System.Int32)">
            @param a
            @param b
            @return product of a and b in GF(256)
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.GF256Poly">
             <p>Represents a polynomial whose coefficients are elements of GF(256).
             Instances of this class are immutable.</p>
            
             <p>Much credit is due to William Rucklidge since portions of this code are an indirect
             port of his C++ Reed-Solomon implementation.</p>
            
             @author Sean Owen
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256Poly.#ctor(iTextSharp.text.pdf.qrcode.GF256,System.Int32[])">
            @param field the {@link GF256} instance representing the field to use
            to perform computations
            @param coefficients coefficients as ints representing elements of GF(256), arranged
            from most significant (highest-power term) coefficient to least significant
            @throws IllegalArgumentException if argument is null or empty,
            or if leading coefficient is 0 and this is not a
            constant polynomial (that is, it is not the monomial "0")
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256Poly.GetDegree">
            @return degree of this polynomial
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256Poly.IsZero">
            @return true iff this polynomial is the monomial "0"
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256Poly.GetCoefficient(System.Int32)">
            @return coefficient of x^degree term in this polynomial
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.GF256Poly.EvaluateAt(System.Int32)">
            @return evaluation of this polynomial at a given point
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.MaskUtil">
            @author satorux@google.com (Satoru Takabayashi) - creator
            @author dswitkin@google.com (Daniel Switkin) - ported from C++
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.MatrixUtil">
            @author satorux@google.com (Satoru Takabayashi) - creator
            @author dswitkin@google.com (Daniel Switkin) - ported from C++
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.Mode">
             <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
             data can be encoded to bits in the QR code standard.</p>
            
             @author Sean Owen
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Mode.ForBits(System.Int32)">
            @param bits four bits encoding a QR Code data mode
            @return {@link Mode} encoded by these bits
            @throws IllegalArgumentException if bits do not correspond to a known mode
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Mode.GetCharacterCountBits(iTextSharp.text.pdf.qrcode.Version)">
            @param version version in question
            @return number of bits used, in this QR Code symbol {@link Version}, to encode the
                    count of characters that will follow encoded in this {@link Mode}
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.QRCode">
            @author satorux@google.com (Satoru Takabayashi) - creator
            @author dswitkin@google.com (Daniel Switkin) - ported from C++
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.QRCodeWriter">
             This object renders a QR Code as a ByteMatrix 2D array of greyscale values.
            
             @author dswitkin@google.com (Daniel Switkin)
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.ReedSolomonEncoder">
             <p>Implements Reed-Solomon enbcoding, as the name implies.</p>
            
             @author Sean Owen
             @author William Rucklidge
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.ReedSolomonException">
             <p>Thrown when an exception occurs during Reed-Solomon decoding, such as when
             there are too many errors to correct.</p>
            
             @author Sean Owen
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.Version">
             See ISO 18004:2006 Annex D
            
             @author Sean Owen
        </member>
        <member name="F:iTextSharp.text.pdf.qrcode.Version.VERSION_DECODE_INFO">
            See ISO 18004:2006 Annex D.
            Element i represents the raw version bits that specify version i + 7
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Version.GetProvisionalVersionForDimension(System.Int32)">
             <p>Deduces version information purely from QR Code dimensions.</p>
            
             @param dimension dimension in modules
             @return {@link Version} for a QR Code of that dimension
             @throws FormatException if dimension is not 1 mod 4
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Version.BuildFunctionPattern">
            See ISO 18004:2006 Annex E
        </member>
        <member name="M:iTextSharp.text.pdf.qrcode.Version.BuildVersions">
            See ISO 18004:2006 6.5.1 Table 9
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.Version.ECBlocks">
            <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
            use blocks of differing sizes within one version, so, this encapsulates the parameters for
            each set of blocks. It also holds the number of error-correction codewords per block since it
            will be the same across all blocks within one version.</p>
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.Version.ECB">
            <p>Encapsualtes the parameters for one error-correction block in one symbol version.
            This includes the number of data codewords, and the number of times a block with these
            parameters is used consecutively in the QR code version's format.</p>
        </member>
        <member name="T:iTextSharp.text.pdf.qrcode.WriterException">
             A base class which covers the range of exceptions which may occur when encoding a barcode using
             the Writer framework.
            
             @author dswitkin@google.com (Daniel Switkin)
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.RadioCheckField" -->
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_CHECK">
            A field with the symbol check 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_CIRCLE">
            A field with the symbol circle 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_CROSS">
            A field with the symbol cross 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_DIAMOND">
            A field with the symbol diamond 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_SQUARE">
            A field with the symbol square 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.TYPE_STAR">
            A field with the symbol star 
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.checkType">
            Holds value of property checkType.
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.onValue">
            Holds value of property onValue.
        </member>
        <member name="F:iTextSharp.text.pdf.RadioCheckField.vchecked">
            Holds value of property checked.
        </member>
        <member name="M:iTextSharp.text.pdf.RadioCheckField.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String,System.String)">
            Creates a new instance of RadioCheckField
            @param writer the document <CODE>PdfWriter</CODE>
            @param box the field location and dimensions
            @param fieldName the field name. It must not be <CODE>null</CODE>
            @param onValue the value when the field is checked
        </member>
        <member name="M:iTextSharp.text.pdf.RadioCheckField.GetAppearance(System.Boolean,System.Boolean)">
            Gets the field appearance.
            @param isRadio <CODE>true</CODE> for a radio field and <CODE>false</CODE>
            for a check field
            @param on <CODE>true</CODE> for the checked state, <CODE>false</CODE>
            otherwise
            @throws IOException on error
            @throws DocumentException on error
            @return the appearance
        </member>
        <member name="M:iTextSharp.text.pdf.RadioCheckField.GetAppearanceRadioCircle(System.Boolean)">
            Gets the special field appearance for the radio circle.
            @param on <CODE>true</CODE> for the checked state, <CODE>false</CODE>
            otherwise
            @return the appearance
        </member>
        <member name="M:iTextSharp.text.pdf.RadioCheckField.GetRadioGroup(System.Boolean,System.Boolean)">
            Gets a radio group. It's composed of the field specific keys, without the widget
            ones. This field is to be used as a field aggregator with {@link PdfFormField#addKid(PdfFormField) AddKid()}.
            @param noToggleToOff if <CODE>true</CODE>, exactly one radio button must be selected at all
            times; clicking the currently selected button has no effect.
            If <CODE>false</CODE>, clicking
            the selected button deselects it, leaving no button selected.
            @param radiosInUnison if <CODE>true</CODE>, a group of radio buttons within a radio button field that
            use the same value for the on state will turn on and off in unison; that is if
            one is checked, they are all checked. If <CODE>false</CODE>, the buttons are mutually exclusive
            (the same behavior as HTML radio buttons)
            @return the radio group
        </member>
        <member name="M:iTextSharp.text.pdf.RadioCheckField.GetField(System.Boolean)">
            Gets a radio or check field.
            @param isRadio <CODE>true</CODE> to get a radio field, <CODE>false</CODE> to get
            a check field
            @throws IOException on error
            @throws DocumentException on error
            @return the field
        </member>
        <member name="P:iTextSharp.text.pdf.RadioCheckField.CheckType">
            Sets the checked symbol. It can be
            <CODE>TYPE_CHECK</CODE>,
            <CODE>TYPE_CIRCLE</CODE>,
            <CODE>TYPE_CROSS</CODE>,
            <CODE>TYPE_DIAMOND</CODE>,
            <CODE>TYPE_SQUARE</CODE> and
            <CODE>TYPE_STAR</CODE>.
            @param checkType the checked symbol
        </member>
        <member name="P:iTextSharp.text.pdf.RadioCheckField.OnValue">
            Sets the value when the field is checked.
            @param onValue the value when the field is checked
        </member>
        <member name="P:iTextSharp.text.pdf.RadioCheckField.Checked">
            Sets the state of the field to checked or unchecked.
            @param checked the state of the field, <CODE>true</CODE> for checked
            and <CODE>false</CODE> for unchecked
        </member>
        <member name="P:iTextSharp.text.pdf.RadioCheckField.RadioField">
            Gets the radio field. It's only composed of the widget keys and must be used
            with {@link #getRadioGroup(bool,bool)}.
            @return the radio field
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="P:iTextSharp.text.pdf.RadioCheckField.CheckField">
            Gets the check field.
            @return the check field
            @throws IOException on error
            @throws DocumentException on error
        </member>
        <member name="T:iTextSharp.text.pdf.RandomAccessFileOrArray">
            Intended to be layered on top of a low level RandomAccessSource object.  Provides
            functionality useful during parsing:
            <ul>
            	<li>tracks current position in the file</li>
            	<li>allows single byte pushback</li>
            	<li>allows reading of multi-byte data structures (int, long, String) for both Big and Little Endian representations</li>
            	<li>allows creation of independent 'views' of the underlying data source</li>
            </ul> 
            
            @author Paulo Soares, Kevin Day
        </member>
        <member name="F:iTextSharp.text.pdf.RandomAccessFileOrArray.byteSource">
            The source that backs this object
        </member>
        <member name="F:iTextSharp.text.pdf.RandomAccessFileOrArray.byteSourcePosition">
            The physical location in the underlying byte source.
        </member>
        <member name="F:iTextSharp.text.pdf.RandomAccessFileOrArray.back">
            the pushed  back byte, if any
        </member>
        <member name="F:iTextSharp.text.pdf.RandomAccessFileOrArray.isBack">
            Whether there is a pushed back byte
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(System.String)">
            @deprecated use {@link RandomAccessFileOrArray#RandomAccessFileOrArray(RandomAccessSource)} instead
            @param filename
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Creates an independent view of the specified source.  Closing the new object will not close the source.
            Closing the source will have adverse effect on the behavior of the new view.
            @deprecated use {@link RandomAccessFileOrArray#createView()} instead
            @param source the source for the new independent view
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.CreateView">
            Creates an independent view of this object (with it's own file pointer and pushback queue).  Closing the new object will not close this object.
            Closing this object will have adverse effect on the view.
            @return the new view
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(iTextSharp.text.io.IRandomAccessSource)">
            Creates a RandomAccessFileOrArray that wraps the specified byte source.  The byte source will be closed when
            this RandomAccessFileOrArray is closed.
            @param byteSource the byte source to wrap
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(System.String,System.Boolean)">
            Constructs a new RandomAccessFileOrArrayObject
            @param filename the file to open (can be a file system file or one of the following url strings: file://, http://, https://, jar:, wsjar:, vfszip:
            @param forceRead if true, the entire file will be read into memory
            @param plainRandomAccess if true, a regular RandomAccessFile is used to access the file contents.  If false, a memory mapped file will be used, unless the file cannot be mapped into memory, in which case regular RandomAccessFile will be used
            @throws IOException if there is a failure opening or reading the file
            @deprecated use {@link RandomAccessSourceFactory#createBestSource(String)} and {@link RandomAccessFileOrArray#RandomAccessFileOrArray(RandomAccessSource)} instead
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(System.Uri)">
            @param url
            @throws IOException
            @deprecated use {@link RandomAccessSourceFactory#createSource(URL)} and {@link RandomAccessFileOrArray#RandomAccessFileOrArray(RandomAccessSource)} instead
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(System.IO.Stream)">
            @param is
            @throws IOException
            @deprecated use {@link RandomAccessSourceFactory#createSource(InputStream)} and {@link RandomAccessFileOrArray#RandomAccessFileOrArray(RandomAccessSource)} instead
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.#ctor(System.Byte[])">
            @param arrayIn
            @throws IOException
            @deprecated use {@link RandomAccessSourceFactory#createSource(byte[])} and {@link RandomAccessFileOrArray#RandomAccessFileOrArray(RandomAccessSource)} instead
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.PushBack(System.Byte)">
            Pushes a byte back.  The next get() will return this byte instead of the value from the underlying data source
            @param b the byte to push
        </member>
        <member name="M:iTextSharp.text.pdf.RandomAccessFileOrArray.Read">
            Reads a single byte
            @return the byte, or -1 if EOF is reached
            @throws IOException
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.RandomAccessFileOrArray.ReadShortLE" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.RandomAccessFileOrArray.ReadUnsignedShortLE" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.RandomAccessFileOrArray.ReadCharLE" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.RandomAccessFileOrArray.ReadIntLE" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.RandomAccessFileOrArray.ReadUnsignedInt" -->
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.SequenceList" -->
        <member name="M:iTextSharp.text.pdf.SequenceList.Expand(System.String,System.Int32)">
            Generates a list of numbers from a string.
            @param ranges the comma separated ranges
            @param maxNumber the maximum number in the range
            @return a list with the numbers as <CODE>Integer</CODE>
        </member>
        <member name="T:iTextSharp.text.pdf.ShadingColor">
            Implements a shading pattern as a <code>Color</code>.
            
             @author Paulo Soares
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.SimpleBookmark" -->
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.#ctor">
            Creates a new instance of SimpleBookmark 
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.GetNumber(iTextSharp.text.pdf.PdfIndirectReference)">
            Gets number of indirect. If type of directed indirect is PAGES, it refers PAGE object through KIDS.
            (Contributed by Kazuya Ujihara)
            @param indirect 
            2004-06-13
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.GetBookmark(iTextSharp.text.pdf.PdfReader)">
            Gets a <CODE>List</CODE> with the bookmarks. It returns <CODE>null</CODE> if
            the document doesn't have any bookmarks.
            @param reader the document
            @return a <CODE>List</CODE> with the bookmarks or <CODE>null</CODE> if the
            document doesn't have any
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.GetBookmark(iTextSharp.text.pdf.PdfReader,iTextSharp.text.pdf.PdfDictionary,System.Boolean)">
            Gets a <CODE>List</CODE> with the bookmarks that are children of <CODE>outline</CODE>. It returns <CODE>null</CODE> if
            the document doesn't have any bookmarks.
            @param reader the document
            @param outline the outline dictionary to get bookmarks from
            @param includeRoot indicates if to include <CODE>outline</CODE> parameter itself into returned list of bookmarks
            @return a <CODE>List</CODE> with the bookmarks or <CODE>null</CODE> if the
            document doesn't have any
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.EliminatePages(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Int32[])">
            Removes the bookmark entries for a number of page ranges. The page ranges
            consists of a number of pairs with the start/end page range. The page numbers
            are inclusive.
            @param list the bookmarks
            @param pageRange the page ranges, always in pairs.
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.ShiftPageNumbers(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Int32,System.Int32[])">
            For the pages in range add the <CODE>pageShift</CODE> to the page number.
            The page ranges
            consists of a number of pairs with the start/end page range. The page numbers
            are inclusive.
            @param list the bookmarks
            @param pageShift the number to add to the pages in range
            @param pageRange the page ranges, always in pairs. It can be <CODE>null</CODE>
            to include all the pages
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.ExportToXMLNode(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},System.IO.TextWriter,System.Int32,System.Boolean)">
            Exports the bookmarks to XML. Only of use if the generation is to be include in
            some other XML document.
            @param list the bookmarks
            @param out the export destination. The writer is not closed
            @param indent the indentation level. Pretty printing significant only. Use <CODE>-1</CODE> for no indents.
            @param onlyASCII codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE>,
            whatever the encoding
            @throws IOException on error
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.SimpleBookmark.ExportToXML(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},System.IO.Stream,System.String,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.ExportToXML(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},System.IO.TextWriter,System.String,System.Boolean)">
            Exports the bookmarks to XML.
            @param list the bookmarks
            @param wrt the export destination. The writer is not closed
            @param encoding the encoding according to IANA conventions
            @param onlyASCII codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE>,
            whatever the encoding
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.ImportFromXML(System.IO.Stream)">
            Import the bookmarks from XML.
            @param in the XML source. The stream is not closed
            @throws IOException on error
            @return the bookmarks
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleBookmark.ImportFromXML(System.IO.TextReader)">
            Import the bookmarks from XML.
            @param in the XML source. The reader is not closed
            @throws IOException on error
            @return the bookmarks
        </member>
        <member name="T:iTextSharp.text.pdf.SimpleNamedDestination">
            
             @author Paulo Soares
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.SimpleNamedDestination.ExportToXML(System.Collections.Generic.Dictionary{System.String,System.String},System.IO.Stream,System.String,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.SimpleNamedDestination.ExportToXML(System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextWriter,System.String,System.Boolean)">
            Exports the bookmarks to XML.
            @param names the names
            @param wrt the export destination. The writer is not closed
            @param encoding the encoding according to IANA conventions
            @param onlyASCII codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE>,
            whatever the encoding
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleNamedDestination.ImportFromXML(System.IO.Stream)">
            Import the names from XML.
            @param inp the XML source. The stream is not closed
            @throws IOException on error
            @return the names
        </member>
        <member name="M:iTextSharp.text.pdf.SimpleNamedDestination.ImportFromXML(System.IO.TextReader)">
            Import the names from XML.
            @param inp the XML source. The reader is not closed
            @throws IOException on error
            @return the names
        </member>
        <member name="T:iTextSharp.text.pdf.SpotColor">
            
             @author  psoares
        </member>
        <member name="M:iTextSharp.text.pdf.StampContent.#ctor(iTextSharp.text.pdf.PdfStamperImp,iTextSharp.text.pdf.PdfStamperImp.PageStamp)">
            Creates a new instance of StampContent 
        </member>
        <member name="P:iTextSharp.text.pdf.StampContent.Duplicate">
             Gets a duplicate of this <CODE>PdfContentByte</CODE>. All
             the members are copied by reference but the buffer stays different.
            
             @return a copy of this <CODE>PdfContentByte</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.StandardDecryption.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
            Creates a new instance of StandardDecryption 
        </member>
        <member name="M:iTextSharp.text.pdf.StringUtils.EscapeString(System.Byte[])">
             Escapes a <CODE>byte</CODE> array according to the PDF conventions.
            
             @param b the <CODE>byte</CODE> array to escape
             @return an escaped <CODE>byte</CODE> array
        </member>
        <member name="M:iTextSharp.text.pdf.StringUtils.EscapeString(System.Byte[],iTextSharp.text.pdf.ByteBuffer)">
             Escapes a <CODE>byte</CODE> array according to the PDF conventions.
            
             @param b the <CODE>byte</CODE> array to escape
        </member>
        <member name="M:iTextSharp.text.pdf.StringUtils.ConvertCharsToBytes(System.Char[])">
            Converts an array of unsigned 16bit numbers to an array of bytes.
            The input values are presented as chars for convenience.
            
            @param chars the array of 16bit numbers that should be converted
            @return the resulting byte array, twice as large as the input
        </member>
        <member name="T:iTextSharp.text.pdf.TextField">
            Supports text, combo and list fields generating the correct appearances.
            All the option in the Acrobat GUI are supported in an easy to use API.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.defaultText">
            Holds value of property defaultText. 
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.choices">
            Holds value of property choices. 
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.choiceExports">
            Holds value of property choiceExports. 
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.choiceSelections">
            Holds value of property choiceSelection. 
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.visibleTopChoice">
            Represents the /TI value 
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.#ctor(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Rectangle,System.String)">
            Creates a new <CODE>TextField</CODE>.
            @param writer the document <CODE>PdfWriter</CODE>
            @param box the field location and dimensions
            @param fieldName the field name. If <CODE>null</CODE> only the widget keys
            will be included in the field allowing it to be used as a kid field.
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.ObfuscatePassword(System.String)">
            Obfuscates a password <code>String</code>.
            Every character is replaced by an asterisk (*).
            
            @param text 
            @return String
            @since   2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.GetAppearance">
            Get the <code>PdfAppearance</code> of a text or combo field
            @throws IOException on error
            @throws DocumentException on error
            @return A <code>PdfAppearance</code>
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.GetListAppearance">
            Get the <code>PdfAppearance</code> of a list field
            @throws IOException on error
            @throws DocumentException on error
            @return A <code>PdfAppearance</code>
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.GetTextField">
            Gets a new text field.
            @throws IOException on error
            @throws DocumentException on error
            @return a new text field
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.GetComboField">
            Gets a new combo field.
            @throws IOException on error
            @throws DocumentException on error
            @return a new combo field
        </member>
        <member name="M:iTextSharp.text.pdf.TextField.GetListField">
            Gets a new list field.
            @throws IOException on error
            @throws DocumentException on error
            @return a new list field
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.TextField.AddChoiceSelection(System.Int32)" -->
        <member name="M:iTextSharp.text.pdf.TextField.SetExtraMargin(System.Single,System.Single)">
            Sets extra margins in text fields to better mimic the Acrobat layout.
            @param extraMarginLeft the extra marging left
            @param extraMarginTop the extra margin top
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.substitutionFonts">
            Holds value of property substitutionFonts.
        </member>
        <member name="F:iTextSharp.text.pdf.TextField.extensionFont">
            Holds value of property extensionFont.
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.DefaultText">
            Sets the default text. It is only meaningful for text fields.
            @param defaultText the default text
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.Choices">
            Sets the choices to be presented to the user in list/combo
            fields.
            @param choices the choices to be presented to the user
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.ChoiceExports">
            Sets the export values in list/combo fields. If this array
            is <CODE>null</CODE> then the choice values will also be used
            as the export values.
            @param choiceExports the export values in list/combo fields
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.ChoiceSelection">
            Sets the zero based index of the selected item.
            @param choiceSelection the zero based index of the selected item
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.VisibleTopChoice">
             Sets the top visible choice for lists;
            
             @since 5.5.3
             @param visibleTopChoice index of the first visible item (zero-based array)
            Returns the index of the top visible choice of a list. Default is -1.
            @return the index of the top visible choice
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.SubstitutionFonts">
            Sets a list of substitution fonts. The list is composed of <CODE>BaseFont</CODE> and can also be <CODE>null</CODE>. The fonts in this list will be used if the original
            font doesn't contain the needed glyphs.
            @param substitutionFonts the list
        </member>
        <member name="P:iTextSharp.text.pdf.TextField.ExtensionFont">
            Sets the extensionFont. This font will be searched before the
            substitution fonts. It may be <code>null</code>.
            @param extensionFont New value of property extensionFont.
        </member>
        <member name="T:iTextSharp.text.pdf.TrueTypeFontSubSet">
            Subsets a True Type font by removing the unneeded glyphs from
             the font.
            
             @author  Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFontSubSet.tableDirectory">
            Contains the location of the several tables. The key is the name of
            the table and the value is an <CODE>int[3]</CODE> where position 0
            is the checksum, position 1 is the offset from the start of the file
            and position 2 is the length of the table.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFontSubSet.rf">
            The file in use.
        </member>
        <member name="F:iTextSharp.text.pdf.TrueTypeFontSubSet.fileName">
            The file name.
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontSubSet.#ctor(System.String,iTextSharp.text.pdf.RandomAccessFileOrArray,System.util.collections.HashSet2{System.Int32},System.Int32,System.Boolean,System.Boolean)">
            Creates a new TrueTypeFontSubSet
            @param directoryOffset The offset from the start of the file to the table directory
            @param fileName the file name of the font
            @param glyphsUsed the glyphs used
            @param includeCmap <CODE>true</CODE> if the table cmap is to be included in the generated font
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontSubSet.Process">
            Does the actual work of subsetting the font.
            @throws IOException on error
            @throws DocumentException on error
            @return the subset font
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontSubSet.ReadStandardString(System.Int32)">
            Reads a <CODE>string</CODE> from the font file as bytes using the Cp1252
             encoding.
            @param length the length of bytes to read
            @return the <CODE>string</CODE> read
            @throws IOException the font file could not be read
        </member>
        <member name="T:iTextSharp.text.pdf.TrueTypeFontUnicode">
            Represents a True Type font with Unicode encoding. All the character
            in the font can be used directly by using the encoding Identity-H or
            Identity-V. This is the only way to represent some character sets such
            as Thai.
            @author  Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.#ctor(System.String,System.String,System.Boolean,System.Byte[],System.Boolean)">
            Creates a new TrueType font addressed by Unicode characters. The font
            will always be embedded.
            @param ttFile the location of the font on file. The file must end in '.ttf'.
            The modifiers after the name are ignored.
            @param enc the encoding to be applied to this font
            @param emb true if the font is to be embedded in the PDF
            @param ttfAfm the font as a <CODE>byte</CODE> array
            @throws DocumentException the font is invalid
            @throws IOException the font file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetWidth(System.Int32)">
            Gets the width of a <CODE>char</CODE> in normalized 1000 units.
            @param char1 the unicode <CODE>char</CODE> to get the width of
            @return the width in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetWidth(System.String)">
            Gets the width of a <CODE>string</CODE> in normalized 1000 units.
            @param text the <CODE>string</CODE> to get the witdth of
            @return the width in normalized 1000 units
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetToUnicode(System.Object[])">
            Creates a ToUnicode CMap to allow copy and paste from Acrobat.
            @param metrics metrics[0] contains the glyph index and metrics[2]
            contains the Unicode code
            @throws DocumentException on error
            @return the stream representing this CMap or <CODE>null</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.ToHex(System.Int32)">
            Gets an hex string in the format "&lt;HHHH&gt;".
            @param n the number
            @return the hex string
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetCIDFontType2(iTextSharp.text.pdf.PdfIndirectReference,System.String,System.Object[])">
            Generates the CIDFontTyte2 dictionary.
            @param fontDescriptor the indirect reference to the font descriptor
            @param subsetPrefix the subset prefix
            @param metrics the horizontal width metrics
            @return a stream
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetFontBaseType(iTextSharp.text.pdf.PdfIndirectReference,System.String,iTextSharp.text.pdf.PdfIndirectReference)">
            Generates the font dictionary.
            @param descendant the descendant dictionary
            @param subsetPrefix the subset prefix
            @param toUnicode the ToUnicode stream
            @return the stream
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.Compare(System.Int32[],System.Int32[])">
            The method used to sort the metrics array.
            @param o1 the first element
            @param o2 the second element
            @return the comparisation
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.WriteFont(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfIndirectReference,System.Object[])">
            Outputs to the writer the font dictionaries and streams.
            @param writer the writer for this document
            @param ref the font indirect reference
            @param parms several parameters that depend on the font type
            @throws IOException on error
            @throws DocumentException error in generating the object
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetFullFontStream">
            Returns a PdfStream object with the full font program.
            @return  a PdfStream with the font program
            @since   2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.ConvertToBytes(System.String)">
            A forbidden operation. Will throw a null pointer exception.
            @param text the text
            @return always <CODE>null</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.GetMetricsTT(System.Int32)">
            Gets the glyph index and metrics for a character.
            @param c the character
            @return an <CODE>int</CODE> array with {glyph index, width}
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.CharExists(System.Int32)">
            Checks if a character exists in this font.
            @param c the character to check
            @return <CODE>true</CODE> if the character has a glyph,
            <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.TrueTypeFontUnicode.SetCharAdvance(System.Int32,System.Int32)">
            Sets the character advance.
            @param c the character
            @param advance the character advance normalized to 1000 units
            @return <CODE>true</CODE> if the advance was set,
            <CODE>false</CODE> otherwise
        </member>
        <member name="T:iTextSharp.text.pdf.Type1Font">
            Reads a Type1 font
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.pfb">
            The PFB file if the input was made with a <CODE>byte</CODE> array.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.FontName">
            The Postscript font name.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.FullName">
            The full name of the font.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.FamilyName">
            The family name of the font.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.Weight">
            The weight of the font: normal, bold, etc.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.ItalicAngle">
            The italic angle of the font, usually 0.0 or negative.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.IsFixedPitch">
            <CODE>true</CODE> if all the characters have the same
            width.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.CharacterSet">
            The character set of the font.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.llx">
            The llx of the FontBox.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.lly">
            The lly of the FontBox.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.urx">
            The lurx of the FontBox.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.ury">
            The ury of the FontBox.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.UnderlinePosition">
            The underline position.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.UnderlineThickness">
            The underline thickness.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.EncodingScheme">
            The font's encoding name. This encoding is 'StandardEncoding' or
            'AdobeStandardEncoding' for a font that can be totally encoded
            according to the characters names. For all other names the
            font is treated as symbolic.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.CapHeight">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.XHeight">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.Ascender">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.Descender">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.StdHW">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.StdVW">
            A variable.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.CharMetrics">
            Represents the section CharMetrics in the AFM file. Each
            value of this array contains a <CODE>Object[4]</CODE> with an
            Integer, Integer, String and int[]. This is the code, width, name and char bbox.
            The key is the name of the char and also an Integer with the char number.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.KernPairs">
            Represents the section KernPairs in the AFM file. The key is
            the name of the first character and the value is a <CODE>Object[]</CODE>
            with 2 elements for each kern pair. Position 0 is the name of
            the second character and position 1 is the kerning distance. This is
            repeated for all the pairs.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.fileName">
            The file in use.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.builtinFont">
            <CODE>true</CODE> if this font is one of the 14 built in fonts.
        </member>
        <member name="F:iTextSharp.text.pdf.Type1Font.PFB_TYPES">
            Types of records in a PFB file. ASCII is 1 and BINARY is 2.
            They have to appear in the PFB file in this sequence.
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.#ctor(System.String,System.String,System.Boolean,System.Byte[],System.Byte[],System.Boolean)">
            Creates a new Type1 font.
            @param ttfAfm the AFM file if the input is made with a <CODE>byte</CODE> array
            @param pfb the PFB file if the input is made with a <CODE>byte</CODE> array
            @param afmFile the name of one of the 14 built-in fonts or the location of an AFM file. The file must end in '.afm'
            @param enc the encoding to be applied to this font
            @param emb true if the font is to be embedded in the PDF
            @throws DocumentException the AFM file is invalid
            @throws IOException the AFM file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetRawWidth(System.Int32,System.String)">
            Gets the width from the font according to the <CODE>name</CODE> or,
            if the <CODE>name</CODE> is null, meaning it is a symbolic font,
            the char <CODE>c</CODE>.
            @param c the char if the font is symbolic
            @param name the glyph name
            @return the width of the char
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetKerning(System.Int32,System.Int32)">
            Gets the kerning between two Unicode characters. The characters
            are converted to names and this names are used to find the kerning
            pairs in the <CODE>Hashtable</CODE> <CODE>KernPairs</CODE>.
            @param char1 the first char
            @param char2 the second char
            @return the kerning to be applied
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.Process(iTextSharp.text.pdf.RandomAccessFileOrArray)">
            Reads the font metrics
            @param rf the AFM file
            @throws DocumentException the AFM file is invalid
            @throws IOException the AFM file could not be read
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetFullFontStream">
            If the embedded flag is <CODE>false</CODE> or if the font is
             one of the 14 built in types, it returns <CODE>null</CODE>,
            otherwise the font is read and output in a PdfStream object.
            @return the PdfStream containing the font or <CODE>null</CODE>
            @throws DocumentException if there is an error reading the font
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetFontDescriptor(iTextSharp.text.pdf.PdfIndirectReference)">
            Generates the font descriptor for this font or <CODE>null</CODE> if it is
            one of the 14 built in fonts.
            @param fontStream the indirect reference to a PdfStream containing the font or <CODE>null</CODE>
            @return the PdfDictionary containing the font descriptor or <CODE>null</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetFontBaseType(iTextSharp.text.pdf.PdfIndirectReference,System.Int32,System.Int32,System.Byte[])">
            Generates the font dictionary for this font.
            @return the PdfDictionary containing the font dictionary
            @param firstChar the first valid character
            @param lastChar the last valid character
            @param shortTag a 256 bytes long <CODE>byte</CODE> array where each unused byte is represented by 0
            @param fontDescriptor the indirect reference to a PdfDictionary containing the font descriptor or <CODE>null</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.WriteFont(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.pdf.PdfIndirectReference,System.Object[])">
            Outputs to the writer the font dictionaries and streams.
            @param writer the writer for this document
            @param ref the font indirect reference
            @param parms several parameters that depend on the font type
            @throws IOException on error
            @throws DocumentException error in generating the object
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.GetFontDescriptor(System.Int32,System.Single)">
            Gets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>,
            <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
            and <CODE>BBOXURY</CODE>.
            @param key the parameter to be extracted
            @param fontSize the font size in points
            @return the parameter in points
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.SetFontDescriptor(System.Int32,System.Single)">
            Sets the font parameter identified by <CODE>key</CODE>. Valid values
            for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>,
            <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
            and <CODE>BBOXURY</CODE>.
            @param key the parameter to be updated
            @param value the parameter value
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.HasKernPairs">
            Checks if the font has any kerning pairs.
            @return <CODE>true</CODE> if the font has any kerning pairs
        </member>
        <member name="M:iTextSharp.text.pdf.Type1Font.SetKerning(System.Int32,System.Int32,System.Int32)">
            Sets the kerning between two Unicode chars.
            @param char1 the first char
            @param char2 the second char
            @param kern the kerning to apply in normalized 1000 units
            @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
        </member>
        <member name="P:iTextSharp.text.pdf.Type1Font.PostscriptFontName">
            Gets the postscript font name.
            @return the postscript font name
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.Type1Font.FullFontName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.Type1Font.AllNameEntries" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.text.pdf.Type1Font.FamilyFontName" -->
        <member name="T:iTextSharp.text.pdf.Type3Font">
            A class to support Type3 fonts.
        </member>
        <member name="M:iTextSharp.text.pdf.Type3Font.#ctor(iTextSharp.text.pdf.PdfWriter,System.Char[],System.Boolean)">
            Creates a Type3 font.
            @param writer the writer
            @param chars an array of chars corresponding to the glyphs used (not used, prisent for compability only)
            @param colorized if <CODE>true</CODE> the font may specify color, if <CODE>false</CODE> no color commands are allowed
            and only images as masks can be used
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.Type3Font.#ctor(iTextSharp.text.pdf.PdfWriter,System.Boolean)" -->
        <member name="M:iTextSharp.text.pdf.Type3Font.DefineGlyph(System.Char,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Defines a glyph. If the character was already defined it will return the same content
            @param c the character to match this glyph.
            @param wx the advance this character will have
            @param llx the X lower left corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            @param lly the Y lower left corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            @param urx the X upper right corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            @param ury the Y upper right corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            @return a content where the glyph can be defined
        </member>
        <member name="M:iTextSharp.text.pdf.Type3Font.GetFullFontStream">
            Always returns null, because you can't get the FontStream of a Type3 font.
            @return  null
            @since   2.1.3
        </member>
        <member name="T:iTextSharp.text.pdf.Type3Glyph">
            The content where Type3 glyphs are written to.
        </member>
        <member name="T:iTextSharp.text.pdf.VerticalText">
            Writes text vertically. Note that the naming is done according
            to horizontal text although it referrs to vertical text.
            A line with the alignment Element.LEFT_ALIGN will actually
            be top aligned.
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.NO_MORE_TEXT">
            Signals that there are no more text available. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.NO_MORE_COLUMN">
            Signals that there is no more column. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.chunks">
            The chunks that form the text. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.text">
            The <CODE>PdfContent</CODE> where the text will be written to. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.alignment">
            The column Element. Default is left Element. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.currentChunkMarker">
            Marks the chunks to be eliminated when the line is written. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.currentStandbyChunk">
            The chunk created by the splitting. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.splittedChunkText">
            The chunk created by the splitting. 
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.leading">
            The leading
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.startX">
            The X coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.startY">
            The Y coordinate.
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.maxLines">
            The maximum number of vertical lines.
        </member>
        <member name="F:iTextSharp.text.pdf.VerticalText.height">
            The height of the text.
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.#ctor(iTextSharp.text.pdf.PdfContentByte)">
            Creates new VerticalText
            @param text the place where the text will be written to. Can
            be a template.
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.AddText(iTextSharp.text.Phrase)">
            Adds a <CODE>Phrase</CODE> to the current text array.
            @param phrase the text
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.AddText(iTextSharp.text.Chunk)">
            Adds a <CODE>Chunk</CODE> to the current text array.
            @param chunk the text
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.SetVerticalLayout(System.Single,System.Single,System.Single,System.Int32,System.Single)">
            Sets the layout.
            @param startX the top right X line position
            @param startY the top right Y line position
            @param height the height of the lines
            @param maxLines the maximum number of lines
            @param leading the separation between the lines
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.CreateLine(System.Single)">
            Creates a line from the chunk array.
            @param width the width of the line
            @return the line or null if no more chunks
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.ShortenChunkArray">
            Normalizes the list of chunks when the line is accepted.
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.Go">
            Outputs the lines to the document. It is equivalent to <CODE>go(false)</CODE>.
            @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
            and/or <CODE>NO_MORE_COLUMN</CODE>
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.Go(System.Boolean)">
            Outputs the lines to the document. The output can be simulated.
            @param simulate <CODE>true</CODE> to simulate the writting to the document
            @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
            and/or <CODE>NO_MORE_COLUMN</CODE>
            @throws DocumentException on error
        </member>
        <member name="M:iTextSharp.text.pdf.VerticalText.SetOrigin(System.Single,System.Single)">
            Sets the new text origin.
            @param startX the X coordinate
            @param startY the Y coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.Leading">
            Gets the separation between the vertical lines.
            @return the vertical line separation
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.OriginX">
            Gets the X coordinate where the next line will be writen. This value will change
            after each call to <code>go()</code>.
            @return  the X coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.OriginY">
            Gets the Y coordinate where the next line will be writen.
            @return  the Y coordinate
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.MaxLines">
            Gets the maximum number of available lines. This value will change
            after each call to <code>go()</code>.
            @return Value of property maxLines.
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.Height">
            Gets the height of the line
            @return the height
        </member>
        <member name="P:iTextSharp.text.pdf.VerticalText.Alignment">
            Gets the Element.
            @return the alignment
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm">
            Processes XFA forms.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.#ctor">
            An empty constructor to build on.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.GetXfaObject(iTextSharp.text.pdf.PdfReader)">
            Return the XFA Object, could be an array, could be a Stream.
            Returns null f no XFA Object is present.
            @param    reader  a PdfReader instance
            @return   the XFA object
            @since    2.1.3
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.#ctor(iTextSharp.text.pdf.PdfReader)">
            A constructor from a <CODE>PdfReader</CODE>. It basically does everything
            from finding the XFA stream to the XML parsing.
            @param reader the reader
            @throws java.io.IOException on error
            @throws javax.xml.parsers.ParserConfigurationException on error
            @throws org.xml.sax.SAXException on error
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.ExtractNodes">
            Extracts the nodes from the domDocument.
            @since    2.1.5
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.CreateDatasetsNode(System.Xml.XmlNode)">
            Some XFA forms don't have a datasets node.
            If this is the case, we have to add one.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.SetXfa(iTextSharp.text.pdf.XfaForm,iTextSharp.text.pdf.PdfReader,iTextSharp.text.pdf.PdfWriter)">
            Sets the XFA key from a byte array. The old XFA is erased.
            @param form the data
            @param reader the reader
            @param writer the writer
            @throws java.io.IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.SetXfa(iTextSharp.text.pdf.PdfWriter)">
            Sets the XFA key from the instance data. The old XFA is erased.
            @param writer the writer
            @throws java.io.IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.SerializeDoc(System.Xml.XmlNode)">
            Serializes a XML document to a byte array.
            @param n the XML document
            @throws java.io.IOException on error
            @return the serialized XML document
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.FindFieldName(System.String,iTextSharp.text.pdf.AcroFields)">
            Finds the complete field name contained in the "classic" forms from a partial
            name.
            @param name the complete or partial name
            @param af the fields
            @return the complete name or <CODE>null</CODE> if not found
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.FindDatasetsName(System.String)">
            Finds the complete SOM name contained in the datasets section from a 
            possibly partial name.
            @param name the complete or partial name
            @return the complete name or <CODE>null</CODE> if not found
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.FindDatasetsNode(System.String)">
            Finds the <CODE>Node</CODE> contained in the datasets section from a 
            possibly partial name.
            @param name the complete or partial name
            @return the <CODE>Node</CODE> or <CODE>null</CODE> if not found
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.GetNodeText(System.Xml.XmlNode)">
            Gets all the text contained in the child nodes of this node.
            @param n the <CODE>Node</CODE>
            @return the text found or "" if no text was found
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.SetNodeText(System.Xml.XmlNode,System.String)">
            Sets the text of this node. All the child's node are deleted and a new
            child text node is created.
            @param n the <CODE>Node</CODE> to add the text to
            @param text the text to add
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.FillXfaForm(System.Xml.XmlNode,System.Boolean)">
            Replaces the data under datasets/data.
            @since	iText 5.0.0
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.XfaPresent">
            Returns <CODE>true</CODE> if it is a XFA form.
            @return <CODE>true</CODE> if it is a XFA form
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.DomDocument">
            Gets the top level DOM document.
            @return the top level DOM document
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Reader">
            Sets the <CODE>PdfReader</CODE> to be used by this instance.
            @param reader the <CODE>PdfReader</CODE> to be used by this instance
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Changed">
            Checks if this XFA form was changed.
            @return <CODE>true</CODE> if this XFA form was changed
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.TemplateSom">
            Gets the class that contains the template processing section of the XFA.
            @return the class that contains the template processing section of the XFA
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.DatasetsSom">
            Gets the class that contains the datasets processing section of the XFA.
            @return the class that contains the datasets processing section of the XFA
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.AcroFieldsSom">
            Gets the class that contains the "classic" fields processing.
            @return the class that contains the "classic" fields processing
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.DatasetsNode">
            Gets the <CODE>Node</CODE> that corresponds to the datasets part.
            @return the <CODE>Node</CODE> that corresponds to the datasets part
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.InverseStore">
            A structure to store each part of a SOM name and link it to the next part
            beginning from the lower hierarchie.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.InverseStore.IsSimilar(System.String)">
            Search the current node for a similar name. A similar name starts
            with the same name but has a differnt index. For example, "detail[3]" 
            is similar to "detail[9]". The main use is to discard names that
            correspond to out of bounds records.
            @param name the name to search
            @return <CODE>true</CODE> if a similitude was found
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.InverseStore.DefaultName">
            Gets the full name by traversing the hiearchie using only the
            index 0.
            @return the full name
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.Stack2`1">
            Another stack implementation. The main use is to facilitate
            the porting to other languages.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Stack2`1.Peek">
            Looks at the object at the top of this stack without removing it from the stack.
            @return the object at the top of this stack
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Stack2`1.Pop">
            Removes the object at the top of this stack and returns that object as the value of this function.
            @return the object at the top of this stack 
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Stack2`1.Push(`0)">
            Pushes an item onto the top of this stack.
            @param item the item to be pushed onto this stack
            @return the <CODE>item</CODE> argument
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Stack2`1.Empty">
            Tests if this stack is empty.
            @return <CODE>true</CODE> if and only if this stack contains no items; <CODE>false</CODE> otherwise
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.Xml2Som">
            A class for some basic SOM processing.
        </member>
        <member name="F:iTextSharp.text.pdf.XfaForm.Xml2Som.order">
            The order the names appear in the XML, depth first.
        </member>
        <member name="F:iTextSharp.text.pdf.XfaForm.Xml2Som.name2Node">
            The mapping of full names to nodes.
        </member>
        <member name="F:iTextSharp.text.pdf.XfaForm.Xml2Som.inverseSearch">
            The data to do a search from the bottom hierarchie.
        </member>
        <member name="F:iTextSharp.text.pdf.XfaForm.Xml2Som.stack">
            A stack to be used when parsing.
        </member>
        <member name="F:iTextSharp.text.pdf.XfaForm.Xml2Som.anform">
            A temporary store for the repetition count.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.EscapeSom(System.String)">
            Escapes a SOM string fragment replacing "." with "\.".
            @param s the unescaped string
            @return the escaped string
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.UnescapeSom(System.String)">
            Unescapes a SOM string fragment replacing "\." with ".".
            @param s the escaped string
            @return the unescaped string
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.PrintStack">
            Outputs the stack as the sequence of elements separated
            by '.'.
            @return the stack as the sequence of elements separated by '.'
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.GetShortName(System.String)">
            Gets the name with the <CODE>#subform</CODE> removed.
            @param s the long name
            @return the short name
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.InverseSearchAdd(System.String)">
            Adds a SOM name to the search node chain.
            @param unstack the SOM name
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.InverseSearchAdd(System.Collections.Generic.Dictionary{System.String,iTextSharp.text.pdf.XfaForm.InverseStore},iTextSharp.text.pdf.XfaForm.Stack2{System.String},System.String)">
            Adds a SOM name to the search node chain.
            @param inverseSearch the start point
            @param stack the stack with the separeted SOM parts
            @param unstack the full name
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.InverseSearchGlobal(System.Collections.Generic.List{System.String})">
            Searchs the SOM hiearchie from the bottom.
            @param parts the SOM parts
            @return the full name or <CODE>null</CODE> if not found
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2Som.SplitParts(System.String)">
            Splits a SOM name in the individual parts.
            @param name the full SOM name
            @return the split name
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Xml2Som.Order">
            Gets the order the names appear in the XML, depth first.
            @return the order the names appear in the XML, depth first
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Xml2Som.Name2Node">
            Gets the mapping of full names to nodes.
            @return the mapping of full names to nodes
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Xml2Som.InverseSearch">
            Gets the data to do a search from the bottom hierarchie.
            @return the data to do a search from the bottom hierarchie
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.Xml2SomDatasets">
            Processes the datasets section in the XFA form.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2SomDatasets.#ctor(System.Xml.XmlNode)">
            Creates a new instance from the datasets node. This expects
            not the datasets but the data node that comes below.
            @param n the datasets node
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2SomDatasets.InsertNode(System.Xml.XmlNode,System.String)">
            Inserts a new <CODE>Node</CODE> that will match the short name.
            @param n the datasets top <CODE>Node</CODE>
            @param shortName the short name
            @return the new <CODE>Node</CODE> of the inserted name
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.AcroFieldsSearch">
            A class to process "classic" fields.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.AcroFieldsSearch.#ctor(System.Collections.Generic.ICollection{System.String})">
            Creates a new instance from a Collection with the full names.
            @param items the Collection
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.AcroFieldsSearch.AcroShort2LongName">
            Gets the mapping from short names to long names. A long 
            name may contain the #subform name part.
            @return the mapping from short names to long names
        </member>
        <member name="T:iTextSharp.text.pdf.XfaForm.Xml2SomTemplate">
            Processes the template section in the XFA form.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2SomTemplate.#ctor(System.Xml.XmlNode)">
            Creates a new instance from the datasets node.
            @param n the template node
        </member>
        <member name="M:iTextSharp.text.pdf.XfaForm.Xml2SomTemplate.GetFieldType(System.String)">
            Gets the field type as described in the <CODE>template</CODE> section of the XFA.
            @param s the exact template name
            @return the field type or <CODE>null</CODE> if not found
        </member>
        <member name="P:iTextSharp.text.pdf.XfaForm.Xml2SomTemplate.DynamicForm">
            <CODE>true</CODE> if it's a dynamic form; <CODE>false</CODE>
            if it's a static form.
            @return <CODE>true</CODE> if it's a dynamic form; <CODE>false</CODE>
            if it's a static form
        </member>
        <member name="T:iTextSharp.text.pdf.XfdfReader">
            Reads a XFDF.
            @author Leonard Rosenthol (leonardr@pdfsages.com)
        </member>
        <member name="F:iTextSharp.text.pdf.XfdfReader.listFields">
            Storage for field values if there's more than one value for a field.
            @since    2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.#ctor(System.String)">
            Reads an XFDF form.
            @param filename the file name of the form
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.#ctor(System.Byte[])">
            Reads an XFDF form.
            @param xfdfIn the byte array with the form
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.#ctor(System.IO.Stream)">
            Reads an XFDF form.
            @param is an InputStream to read the form
            @throws IOException on error
            @since 5.0.1
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.GetField(System.String)">
            Gets the field value.
            @param name the fully qualified field name
            @return the field's value
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.GetFieldValue(System.String)">
            Gets the field value or <CODE>null</CODE> if the field does not
            exist or has no value defined.
            @param name the fully qualified field name
            @return the field value or <CODE>null</CODE>
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.GetListValues(System.String)">
            Gets the field values for a list or <CODE>null</CODE> if the field does not
            exist or has no value defined.
            @param name the fully qualified field name
            @return the field values or <CODE>null</CODE>
            @since   2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.StartElement(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Called when a start tag is found.
            @param tag the tag name
            @param h the tag's attributes
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.EndElement(System.String)">
            Called when an end tag is found.
            @param tag the tag name
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.StartDocument">
            Called when the document starts to be parsed.
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.EndDocument">
            Called after the document is parsed.
        </member>
        <member name="M:iTextSharp.text.pdf.XfdfReader.Text(System.String)">
            Called when a text element is found.
            @param str the text element, probably a fragment.
        </member>
        <member name="P:iTextSharp.text.pdf.XfdfReader.Fields">
            Gets all the fields. The map is keyed by the fully qualified
            field name and the value is a merged <CODE>PdfDictionary</CODE>
            with the field content.
            @return all the fields
        </member>
        <member name="P:iTextSharp.text.pdf.XfdfReader.FileSpec">
            Gets the PDF file specification contained in the FDF.
            @return the PDF file specification contained in the FDF
        </member>
        <member name="T:iTextSharp.text.RectangleReadOnly">
            <summary>
            A RectangleReadOnly is the representation of a geometric figure.
            It's the same as a Rectangle but immutable.
            </summary>
            <seealso cref="T:iTextSharp.text.Element"/>
            <seealso cref="T:iTextSharp.text.Table"/>
            <seealso cref="T:iTextSharp.text.Cell"/>
            <seealso cref="T:iTextSharp.text.HeaderFooter"/>
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a RectangleReadOnly-object.
            </summary>
            <param name="llx">lower left x</param>
            <param name="lly">lower left y</param>
            <param name="urx">upper right x</param>
            <param name="ury">upper right y</param>
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Constructs a <CODE>RectangleReadOnly</CODE> -object.
            
            @param llx	lower left x
            @param lly	lower left y
            @param urx	upper right x
            @param ury	upper right y
            @param rotation	the rotation of the Rectangle (0, 90, 180, 270)
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.#ctor(System.Single,System.Single)">
            <summary>
            Constructs a RectangleReadOnly-object starting from the origin (0, 0).
            </summary>
            <param name="urx">upper right x</param>
            <param name="ury">upper right y</param>
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.#ctor(System.Single,System.Single,System.Int32)">
            Constructs a <CODE>RectangleReadOnly</CODE>-object starting from the origin
            (0, 0) and with a specific rotation (valid values are 0, 90, 180, 270).
            
            @param urx   upper right x
            @param ury   upper right y
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.#ctor(iTextSharp.text.Rectangle)">
            <summary>
            Constructs a RectangleReadOnly-object.
            </summary>
            <param name="rect">another Rectangle</param>
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.CloneNonPositionParameters(iTextSharp.text.Rectangle)">
            Copies all of the parameters from a <CODE>Rectangle</CODE> object
            except the position.
            
            @param rect
                       <CODE>Rectangle</CODE> to copy from
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.SoftCloneNonPositionParameters(iTextSharp.text.Rectangle)">
            Copies all of the parameters from a <CODE>Rectangle</CODE> object
            except the position.
            
            @param rect
                       <CODE>Rectangle</CODE> to copy from
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.Normalize">
            Switches lowerleft with upperright
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.EnableBorderSide(System.Int32)">
            Enables the border on the specified side.
            
            @param side
                       the side to enable. One of <CODE>LEFT, RIGHT, TOP, BOTTOM
                       </CODE>
        </member>
        <member name="M:iTextSharp.text.RectangleReadOnly.DisableBorderSide(System.Int32)">
            Disables the border on the specified side.
            
            @param side
                       the side to disable. One of <CODE>LEFT, RIGHT, TOP, BOTTOM
                       </CODE>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Top">
            <summary>
            Get/set the upper right y-coordinate. 
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Border">
            <summary>
            Get/set the border
            </summary>
            <value>a int</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.GrayFill">
            <summary>
            Get/set the grayscale of the rectangle.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Left">
            <summary>
            Get/set the lower left x-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Right">
            <summary>
            Get/set the upper right x-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Bottom">
            <summary>
            Get/set the lower left y-coordinate.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.BorderWidth">
            <summary>
            Get/set the borderwidth.
            </summary>
            <value>a float</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.BorderColor">
             Gets the color of the border.
            
             @return    a value
            <summary>
            Get/set the color of the border.
            </summary>
            <value>a BaseColor</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.BackgroundColor">
             Gets the backgroundcolor.
            
             @return    a value
            <summary>
            Get/set the backgroundcolor.
            </summary>
            <value>a BaseColor</value>
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.Rotation">
            <summary>
            Set/gets the rotation
            </summary>
            <value>a int</value>    
        </member>
        <member name="P:iTextSharp.text.RectangleReadOnly.UseVariableBorders">
            Sets a parameter indicating if the rectangle has variable borders
            
            @param useVariableBorders
                       indication if the rectangle has variable borders
        </member>
        <member name="T:iTextSharp.text.RomanList">
            
            A special-version of <CODE>LIST</CODE> which use roman-letters.
            
            @see com.lowagie.text.List
            @version 2003-06-22
            @author Michael Niedermair
        </member>
        <member name="M:iTextSharp.text.RomanList.#ctor">
            Initialization
        </member>
        <member name="M:iTextSharp.text.RomanList.#ctor(System.Int32)">
            Initialization
            
            @param symbolIndent    indent
        </member>
        <member name="M:iTextSharp.text.RomanList.#ctor(System.Boolean,System.Int32)">
            Initialization 
            @param    romanlower        roman-char in lowercase   
            @param     symbolIndent    indent
        </member>
        <member name="M:iTextSharp.text.RomanList.Add(iTextSharp.text.IElement)">
             Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
            
             @param    o    the object to add.
             @return true if adding the object succeeded
        </member>
        <member name="M:iTextSharp.text.SpecialSymbol.Index(System.String)">
             Returns the first occurrence of a special symbol in a <CODE>String</CODE>.
            
             @param    string        a <CODE>String</CODE>
             @return    an index of -1 if no special symbol was found
        </member>
        <member name="M:iTextSharp.text.SpecialSymbol.Get(System.Char,iTextSharp.text.Font)">
            Gets a chunk with a symbol character.
            @param c a character that has to be changed into a symbol
            @param font Font if there is no SYMBOL character corresponding with c
            @return a SYMBOL version of a character
        </member>
        <member name="M:iTextSharp.text.SpecialSymbol.GetCorrespondingSymbol(System.Char)">
             Looks for the corresponding symbol in the font Symbol.
            
             @param    c    the original ASCII-char
             @return    the corresponding symbol in font Symbol
        </member>
        <member name="T:iTextSharp.text.Utilities">
            A collection of convenience methods that were present in many different iText
            classes.
        </member>
        <member name="M:iTextSharp.text.Utilities.GetKeySet``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:iTextSharp.text.Utilities.AddToArray(System.Object[][],System.Object[])">
            Utility method to extend an array.
            @param original the original array or <CODE>null</CODE>
            @param item the item to be added to the array
            @return a new array with the item appended
        </member>
        <member name="M:iTextSharp.text.Utilities.CheckTrueOrFalse(System.util.Properties,System.String)">
            Checks for a true/false value of a key in a Properties object.
            @param attributes
            @param key
            @return
        </member>
        <member name="M:iTextSharp.text.Utilities.ToURL(System.String)">
            <summary>
            This method makes a valid URL from a given filename.
            </summary>
            <remarks>
            
            </remarks>
            <param name="filename">a given filename</param>
            <returns>a valid URL</returns>
        </member>
        <member name="M:iTextSharp.text.Utilities.UnEscapeURL(System.String)">
            Unescapes an URL. All the "%xx" are replaced by the 'xx' hex char value.
            @param src the url to unescape
            @return the eunescaped value
        </member>
        <member name="M:iTextSharp.text.Utilities.Skip(System.IO.Stream,System.Int32)">
            <summary>
            This method is an alternative for the Stream.Skip()-method
            that doesn't seem to work properly for big values of size.
            </summary>
            <param name="istr">the stream</param>
            <param name="size">the number of bytes to skip</param>
        </member>
        <member name="M:iTextSharp.text.Utilities.MillimetersToPoints(System.Single)">
            Measurement conversion from millimeters to points.
            @param    value   a value in millimeters
            @return   a value in points
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.MillimetersToInches(System.Single)">
            Measurement conversion from millimeters to inches.
            @param    value   a value in millimeters
            @return   a value in inches
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.PointsToMillimeters(System.Single)">
            Measurement conversion from points to millimeters.
            @param    value   a value in points
            @return   a value in millimeters
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.PointsToInches(System.Single)">
            Measurement conversion from points to inches.
            @param    value   a value in points
            @return   a value in inches
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.InchesToMillimeters(System.Single)">
            Measurement conversion from inches to millimeters.
            @param    value   a value in inches
            @return   a value in millimeters
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.InchesToPoints(System.Single)">
            Measurement conversion from inches to points.
            @param    value   a value in inches
            @return   a value in points
            @since    2.1.2
        </member>
        <member name="M:iTextSharp.text.Utilities.ReadFileToString(System.String)">
            Reads the contents of a file to a String.
            @param	path	the path to the file
            @return	a String with the contents of the file
            @since	iText 5.0.0
        </member>
        <member name="M:iTextSharp.text.Utilities.ConvertToHex(System.Byte[])">
            Converts an array of bytes to a String of hexadecimal values
            @param bytes	a byte array
            @return	the same bytes expressed as hexadecimal values
        </member>
        <member name="T:iTextSharp.text.xml.ParserBase">
            <summary>
            The <CODE>ParserBase</CODE>-class provides XML document parsing.
            </summary>
        </member>
        <member name="M:iTextSharp.text.xml.ParserBase.Parse(System.String)">
            <summary>
            Begins the process of processing an XML document
            </summary>
            <param name="url">the XML document to parse</param>
        </member>
        <member name="M:iTextSharp.text.xml.ParserBase.StartElement(System.String,System.String,System.String,System.Collections.Hashtable)">
            <summary>
            This method gets called when a start tag is encountered.
            </summary>
            <param name="uri"></param>
            <param name="lname"></param>
            <param name="name">the name of the tag that is encountered</param>
            <param name="attrs">the list of attributes</param>
        </member>
        <member name="M:iTextSharp.text.xml.ParserBase.EndElement(System.String,System.String,System.String)">
            <summary>
            This method gets called when an end tag is encountered.
            </summary>
            <param name="uri"></param>
            <param name="lname"></param>
            <param name="name">the name of the tag that ends</param>
        </member>
        <member name="M:iTextSharp.text.xml.ParserBase.Characters(System.String,System.Int32,System.Int32)">
            <summary>
            This method gets called when characters are encountered.
            </summary>
            <param name="content">an array of characters</param>
            <param name="start">the start position in the array</param>
            <param name="length">the number of characters to read from the array</param>
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.EntitiesToSymbol">
            This class contains entities that can be used in an entity tag.
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.EntitiesToSymbol.map">
            This is a map that contains all possible id values of the entity tag
            that can be translated to a character in font Symbol.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.EntitiesToSymbol.Get(System.String,iTextSharp.text.Font)">
            Gets a chunk with a symbol character.
            @param e a symbol value (see Entities class: alfa is greek alfa,...)
            @param font the font if the symbol isn't found (otherwise Font.SYMBOL)
            @return a Chunk
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.EntitiesToSymbol.GetCorrespondingSymbol(System.String)">
             Looks for the corresponding symbol in the font Symbol.
            
             @param    name    the name of the entity
             @return   the corresponding character in font Symbol
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.EntitiesToUnicode">
            This class contains entities that can be used in an entity tag.
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.EntitiesToUnicode.map">
            This is a map that contains the names of entities and their unicode value.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.EntitiesToUnicode.DecodeEntity(System.String)">
             Translates an entity to a unicode character.
            
             @param   name    the name of the entity
             @return  the corresponding unicode character
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.xml.simpleparser.EntitiesToUnicode.DecodeString(System.String)" -->
        <member name="T:iTextSharp.text.xml.simpleparser.IanaEncodings">
            Translates a IANA encoding name to a Java encoding.
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.IanaEncodings.map">
            The object that maps IANA to Java encodings. 
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment">
            The handler for the events fired by <CODE>SimpleXMLParser</CODE>.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment.Comment(System.String)">
            Called when a comment is found.
            @param text the comment text
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.xml.simpleparser.SimpleXMLParser" -->
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.UNKNOWN">
            possible states 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.stack">
            the state stack 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.character">
            The current character. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.previousCharacter">
            The previous character. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.lines">
            the line we are currently reading 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.columns">
            the column where the current character occurs 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.eol">
            was the last character equivalent to a newline? 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.nowhite">
            A boolean indicating if the next character should be taken into account
            if it's a space character. When nospace is false, the previous character
            wasn't whitespace.
            @since 2.1.5
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.state">
            the current state 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.html">
            Are we parsing HTML? 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.text">
            current text (whatever is encountered between tags) 
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.entity" -->
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.tag">
            current tagname 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.attributes">
            current attributes 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.doc">
            The handler to which we are going to forward document content 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.comment">
            The handler to which we are going to forward comments. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.nested">
            Keeps track of the number of tags that are open. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.quoteCharacter">
            the quote character that was used to open the quote. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.attributekey">
            the attribute key. 
        </member>
        <member name="F:iTextSharp.text.xml.simpleparser.SimpleXMLParser.attributevalue">
            the attribute value. 
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.#ctor(iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler,iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment,System.Boolean)">
            Creates a Simple XML parser object.
            Call Go(BufferedReader) immediately after creation.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.Go(System.IO.TextReader)">
            Does the actual parsing. Perform this immediately
            after creating the parser object.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.RestoreState">
            Gets a state from the stack
            @return the previous state
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.SaveState(System.Int32)">
            Adds a state to the stack.
            @param   s   a state to add to the stack
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.Flush">
            Flushes the text that is currently in the buffer.
            The text can be ignored, added to the document
            as content or as comment,... depending on the current state.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.InitTag">
            Initialized the tag name and attributes.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.DoTag">
            Sets the name of the tag. 
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.ProcessTag(System.Boolean)">
            processes the tag.
            @param start if true we are dealing with a tag that has just been opened; if false we are closing a tag.
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.ThrowException(System.String)">
            Throws an exception 
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.Parse(iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler,iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandlerComment,System.IO.TextReader,System.Boolean)">
            Parses the XML document firing the events to the handler.
            @param doc the document handler
            @param r the document. The encoding is already resolved. The reader is not closed
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.Parse(iTextSharp.text.xml.simpleparser.ISimpleXMLDocHandler,System.IO.Stream)">
            Parses the XML document firing the events to the handler.
            @param doc the document handler
            @param in the document. The encoding is deduced from the stream. The stream is not closed
            @throws IOException on error
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.SimpleXMLParser.EscapeXML(System.String,System.Boolean)">
            Escapes a string with the appropriated XML codes.
            @param s the string to be escaped
            @param onlyASCII codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE>
            @return the escaped string
        </member>
        <member name="T:iTextSharp.text.xml.xmp.DublinCoreSchema">
            An implementation of an XmpSchema.
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpSchema">
            Abstract superclass of the XmpSchemas supported by iText.
        </member>
        <member name="T:System.util.Properties">
            <summary>
            Summary description for Properties.
            </summary>
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpSchema.xmlns">
            the namesspace 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.#ctor(System.String)">
            Constructs an XMP schema. 
            @param xmlns
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.ToString">
            The String representation of the contents.
            @return a String representation.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.Process(System.Text.StringBuilder,System.Object)">
            Processes a property
            @param buf
            @param p
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.AddProperty(System.String,System.String)">
            @param key
            @param value
            @return the previous property (null if there wasn't one)
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.SetProperty(System.String,iTextSharp.text.xml.xmp.LangAlt)">
            @see java.util.Properties#setProperty(java.lang.String, java.lang.String)
            
            @param key
            @param value
            @return the previous property (null if there wasn't one)
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpSchema.Escape(System.String)">
            @param content
            @return
        </member>
        <member name="P:iTextSharp.text.xml.xmp.XmpSchema.Xmlns">
            @return Returns the xmlns.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.DEFAULT_XPATH_ID">
            default namespace identifier
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.DEFAULT_XPATH_URI">
            default namespace uri
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.CONTRIBUTOR">
            External Contributors to the resource (other than the authors). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.COVERAGE">
            The extent or scope of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.CREATOR">
            The authors of the resource (listed in order of precedence, if significant). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.DATE">
            Date(s) that something interesting happened to the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.DESCRIPTION">
            A textual description of the content of the resource. Multiple values may be present for different languages. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.FORMAT">
            The file format used when saving the resource. Tools and applications should set this property to the save format of the data. It may include appropriate qualifiers. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.IDENTIFIER">
            Unique identifier of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.LANGUAGE">
            An unordered array specifying the languages used in the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.PUBLISHER">
            Publishers. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.RELATION">
            Relationships to other documents. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.RIGHTS">
            Informal rights statement, selected by language. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.SOURCE">
            Unique identifier of the work from which this resource was derived. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.SUBJECT">
            An unordered array of descriptive phrases or keywords that specify the topic of the content of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.TITLE">
            The title of the document, or the name given to the resource. Typically, it will be a name by which the resource is formally known. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreSchema.TYPE">
            A document type; for example, novel, poem, or working paper. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.#ctor">
            @param shorthand
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddTitle(System.String)">
            Adds a title.
            @param title
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddTitle(iTextSharp.text.xml.xmp.LangAlt)">
            Adds a title.
            @param title
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddDescription(System.String)">
            Adds a description.
            @param desc
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddDescription(iTextSharp.text.xml.xmp.LangAlt)">
            Adds a description.
            @param desc
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddSubject(System.String)">
            Adds a subject.
            @param subject
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddSubject(System.String[])">
            Adds a subject.
            @param subject array of subjects
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddAuthor(System.String)">
            Adds a single author.
            @param author
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddAuthor(System.String[])">
            Adds an array of authors.
            @param author
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddPublisher(System.String)">
            Adds a single publisher.
            @param publisher
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreSchema.AddPublisher(System.String[])">
            Adds an array of publishers.
            @param publisher
        </member>
        <member name="T:iTextSharp.text.xml.xmp.EncodingNoPreamble">
            <summary>
            A wrapper for an Encoding to suppress the preamble.
            </summary>
        </member>
        <member name="F:iTextSharp.text.xml.xmp.LangAlt.DEFAULT">
            Key for the default language. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.LangAlt.#ctor(System.String)">
            Creates a Properties object that stores languages for use in an XmpSchema 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.LangAlt.#ctor">
            Creates a Properties object that stores languages for use in an XmpSchema 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.LangAlt.AddLanguage(System.String,System.String)">
            Add a language.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.LangAlt.Process(System.Text.StringBuilder,System.String)">
            Process a property.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.LangAlt.ToString">
            Creates a String that can be used in an XmpSchema.
        </member>
        <member name="T:iTextSharp.text.xml.xmp.PdfSchema">
            An implementation of an XmpSchema.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfSchema.DEFAULT_XPATH_ID">
            default namespace identifier
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfSchema.DEFAULT_XPATH_URI">
            default namespace uri
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfSchema.KEYWORDS">
            Keywords. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfSchema.VERSION">
            The PDF file version (for example: 1.0, 1.3, and so on). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfSchema.PRODUCER">
            The Producer. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfSchema.#ctor">
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfSchema.AddKeywords(System.String)">
            Adds keywords.
            @param keywords
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfSchema.AddProducer(System.String)">
            Adds the producer.
            @param producer
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfSchema.AddVersion(System.String)">
            Adds the version.
            @param version
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpArray">
            StringBuilder to construct an XMP array.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpArray.UNORDERED">
            An array that is unordered. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpArray.ORDERED">
            An array that is ordered. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpArray.ALTERNATIVE">
            An array with alternatives. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpArray.type">
            the type of array. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpArray.#ctor(System.String)">
            Creates an XmpArray.
            @param type the type of array: UNORDERED, ORDERED or ALTERNATIVE.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpArray.ToString">
            Returns the String representation of the XmpArray.
            @return a String representation
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpBasicSchema">
            An implementation of an XmpSchema.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.DEFAULT_XPATH_ID">
            default namespace identifier
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.DEFAULT_XPATH_URI">
            default namespace uri
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.ADVISORY">
            An unordered array specifying properties that were edited outside the authoring application. Each item should contain a single namespace and XPath separated by one ASCII space (U+0020). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.BASEURL">
            The base URL for relative URLs in the document content. If this document contains Internet links, and those links are relative, they are relative to this base URL. This property provides a standard way for embedded relative URLs to be interpreted by tools. Web authoring tools should set the value based on their notion of where URLs will be interpreted. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.CREATEDATE">
            The date and time the resource was originally created. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.CREATORTOOL">
            The name of the first known tool used to create the resource. If history is present in the metadata, this value should be equivalent to that of xmpMM:History�s softwareAgent property. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.IDENTIFIER">
            An unordered array of text strings that unambiguously identify the resource within a given context. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.METADATADATE">
            The date and time that any metadata for this resource was last changed. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.MODIFYDATE">
            The date and time the resource was last modified. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.NICKNAME">
            A short informal name for the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicSchema.THUMBNAILS">
            An alternative array of thumbnail images for a file, which can differ in characteristics such as size or image encoding. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.#ctor">
            @param shorthand
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddCreatorTool(System.String)">
            Adds the creatortool.
            @param creator
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddCreateDate(System.String)">
            Adds the creation date.
            @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddModDate(System.String)">
            Adds the modification date.
            @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddMetaDataDate(System.String)">
            Adds the meta data date.
            @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddIdentifiers(System.String[])">
            Adds the identifier.
            @param id
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicSchema.AddNickname(System.String)">
            Adds the nickname.
            @param name
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpMMSchema">
            An implementation of an XmpSchema.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.DEFAULT_XPATH_ID">
            default namespace identifier
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.DEFAULT_XPATH_URI">
            default namespace uri
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.DERIVEDFROM">
            A reference to the original document from which this one is derived. It is a minimal reference; missing components can be assumed to be unchanged. For example, a new version might only need to specify the instance ID and version number of the previous version, or a rendition might only need to specify the instance ID and rendition class of the original. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.DOCUMENTID">
            The common identifier for all versions and renditions of a document. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.HISTORY">
            An ordered array of high-level user actions that resulted in this resource. It is intended to give human readers a general indication of the steps taken to make the changes from the previous version to this one. The list should be at an abstract level; it is not intended to be an exhaustive keystroke or other detailed history. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.MANAGEDFROM">
            A reference to the document as it was prior to becoming managed. It is set when a managed document is introduced to an asset management system that does not currently own it. It may or may not include references to different management systems. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.MANAGER">
            The name of the asset management system that manages this resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.MANAGETO">
            A URI identifying the managed resource to the asset management system; the presence of this property is the formal indication that this resource is managed. The form and content of this URI is private to the asset management system. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.MANAGEUI">
            A URI that can be used to access information about the managed resource through a web browser. It might require a custom browser plugin. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.MANAGERVARIANT">
            Specifies a particular variant of the asset management system. The format of this property is private to the specific asset management system. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.RENDITIONCLASS">
            The rendition class name for this resource.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.RENDITIONPARAMS">
             Can be used to provide additional rendition parameters that are too complex or verbose to encode in xmpMM: RenditionClass. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.VERSIONID">
            The document version identifier for this resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMSchema.VERSIONS">
            The version history associated with this resource.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpMMSchema.#ctor">
            @throws IOException
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpReader">
            Reads an XMP stream into an org.w3c.dom.Document objects.
            Allows you to replace the contents of a specific tag.
            @since 2.1.3
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpReader.EXTRASPACE">
            String used to fill the extra space. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpReader.XPACKET_PI_BEGIN">
            Processing Instruction required at the start of an XMP stream
            @since iText 2.1.6
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpReader.XPACKET_PI_END_W">
            Processing Instruction required at the end of an XMP stream for XMP streams that can be updated
            @since iText 2.1.6
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.#ctor(System.Byte[])">
            Constructs an XMP reader
            @param	bytes	the XMP content
            @throws ExceptionConverter 
            @throws IOException 
            @throws SAXException 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.ReplaceNode(System.String,System.String,System.String)">
            Replaces the content of a tag.
            @param	namespaceURI	the URI of the namespace
            @param	localName		the tag name
            @param	value			the new content for the tag
            @return	true if the content was successfully replaced
            @since	2.1.6 the return type has changed from void to boolean
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.ReplaceDescriptionAttribute(System.String,System.String,System.String)">
            Replaces the content of an attribute in the description tag.
            @param    namespaceURI    the URI of the namespace
            @param    localName       the tag name
            @param    value           the new content for the tag
            @return   true if the content was successfully replaced
            @since    5.0.0 the return type has changed from void to boolean
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.Add(System.String,System.String,System.String,System.String)">
            Adds a tag.
            @param	namespaceURI	the URI of the namespace
            @param	parent			the tag name of the parent
            @param	localName		the name of the tag to add
            @param	value			the new content for the tag
            @return	true if the content was successfully added
            @since	2.1.6
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.SetNodeText(System.Xml.XmlDocument,System.Xml.XmlNode,System.String)">
            Sets the text of this node. All the child's node are deleted and a new
            child text node is created.
            @param domDocument the <CODE>Document</CODE> that contains the node
            @param n the <CODE>Node</CODE> to add the text to
            @param value the text to add
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpReader.SerializeDoc">
            Writes the document to a byte array.
        </member>
        <member name="T:iTextSharp.text.xml.xmp.XmpWriter">
            With this class you can create an Xmp Stream that can be used for adding
            Metadata to a PDF Dictionary. Remark that this class doesn't cover the
            complete XMP specification.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpWriter.UTF8">
            A possible charset for the XMP. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpWriter.UTF16">
            A possible charset for the XMP. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpWriter.UTF16BE">
            A possible charset for the XMP. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpWriter.UTF16LE">
            A possible charset for the XMP. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.#ctor(System.IO.Stream,System.String,System.Int32)">
            Creates an XmpWriter.
            @param os
            @param utfEncoding
            @param extraSpace
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.#ctor(System.IO.Stream)">
            Creates an XmpWriter.
            @param os
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.#ctor(System.IO.Stream,iTextSharp.text.pdf.PdfDictionary)">
            @param os
            @param info
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.#ctor(System.IO.Stream,System.Collections.Generic.IDictionary{System.String,System.String})">
            @param os
            @param info
            @throws IOException
            @since 5.0.1 (generic type in signature)
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.AddRdfDescription(System.String,System.String)">
            Adds an rdf:Description.
            @param xmlns
            @param content
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.AddRdfDescription(iTextSharp.text.xml.xmp.XmpSchema)">
            Adds an rdf:Description.
            @param s
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.SetProperty(System.String,System.String,System.Object)">
            @param schemaNS The namespace URI for the property. Has the same usage as in getProperty.
            @param propName The name of the property.
                            Has the same usage as in <code>getProperty()</code>.
            @param value    the value for the property (only leaf properties have a value).
                            Arrays and non-leaf levels of structs do not have values.
                            Must be <code>null</code> if the value is not relevant.<br/>
                            The value is automatically detected: Boolean, Integer, Long, Double, XMPDateTime and
                            byte[] are handled, on all other <code>toString()</code> is called.
            @throws XMPException Wraps all errors and exceptions that may occur.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.AppendArrayItem(System.String,System.String,System.String)">
             Simplifies the construction of an array by not requiring that you pre-create an empty array.
             The array that is assigned is created automatically if it does not yet exist. Each call to
             AppendArrayItem() appends an item to the array.
            
             @param schemaNS  The namespace URI for the array.
             @param arrayName The name of the array. May be a general path expression, must not be null or
                              the empty string.
             @param value     the value of the array item.
             @throws XMPException Wraps all errors and exceptions that may occur.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.AppendOrderedArrayItem(System.String,System.String,System.String)">
             Simplifies the construction of an ordered array by not requiring that you pre-create an empty array.
             The array that is assigned is created automatically if it does not yet exist. Each call to
             AppendArrayItem() appends an item to the array.
            
             @param schemaNS  The namespace URI for the array.
             @param arrayName The name of the array. May be a general path expression, must not be null or
                              the empty string.
             @param value     the value of the array item.
             @throws XMPException Wraps all errors and exceptions that may occur.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.AppendAlternateArrayItem(System.String,System.String,System.String)">
             Simplifies the construction of an alternate array by not requiring that you pre-create an empty array.
             The array that is assigned is created automatically if it does not yet exist. Each call to
             AppendArrayItem() appends an item to the array.
            
             @param schemaNS  The namespace URI for the array.
             @param arrayName The name of the array. May be a general path expression, must not be null or
                              the empty string.
             @param value     the value of the array item.
             @throws XMPException Wraps all errors and exceptions that may occur.
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.Serialize(System.IO.Stream)">
            Flushes and closes the XmpWriter.
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpWriter.Close">
            Flushes and closes the XmpWriter.
            @throws IOException
        </member>
        <member name="P:iTextSharp.text.xml.xmp.XmpWriter.ReadOnly">
            Sets the XMP to read-only 
        </member>
        <member name="P:iTextSharp.text.xml.xmp.XmpWriter.About">
            @param about The about to set.
        </member>
        <member name="T:iTextSharp.text.ZapfDingbatsList">
            
            A special-version of <CODE>LIST</CODE> whitch use zapfdingbats-letters.
            
            @see com.lowagie.text.List
            @author Michael Niedermair and Bruno Lowagie
        </member>
        <member name="F:iTextSharp.text.ZapfDingbatsList.zn">
            char-number in zapfdingbats
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsList.#ctor(System.Int32)">
            Creates a ZapfDingbatsList
            
            @param zn a char-number
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsList.#ctor(System.Int32,System.Int32)">
            Creates a ZapfDingbatsList
            
            @param zn a char-number
            @param symbolIndent    indent
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsList.setDingbatColor(iTextSharp.text.BaseColor)">
             Sets the dingbat's color.
            
             @param zapfDingbatColor color for the ZapfDingbat
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsList.Add(iTextSharp.text.IElement)">
             Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
            
             @param    o    the object to add.
             @return true if adding the object succeeded
        </member>
        <member name="P:iTextSharp.text.ZapfDingbatsList.CharNumber">
            set the char-number 
            @param zn a char-number
        </member>
        <member name="T:iTextSharp.text.ZapfDingbatsNumberList">
            
            A special-version of <CODE>LIST</CODE> whitch use zapfdingbats-numbers (1..10).
            
            @see com.lowagie.text.List
            @version 2003-06-22
            @author Michael Niedermair
        </member>
        <member name="F:iTextSharp.text.ZapfDingbatsNumberList.type">
            which type
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsNumberList.#ctor(System.Int32)">
            Creates a ZapdDingbatsNumberList
            @param type the type of list
            @param symbolIndent  indent
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsNumberList.#ctor(System.Int32,System.Int32)">
            Creates a ZapdDingbatsNumberList
            @param type the type of list
            @param symbolIndent    indent
        </member>
        <member name="M:iTextSharp.text.ZapfDingbatsNumberList.Add(iTextSharp.text.IElement)">
             Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
            
             @param    o    the object to add.
             @return true if adding the object succeeded
        </member>
        <member name="P:iTextSharp.text.ZapfDingbatsNumberList.NumberType">
             get the type
            
             @return    char-number
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Octet string from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged,
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.LessThanOrEqual(System.Byte[],System.Byte[])">
            return true if a &lt;= b (arrays are assumed padded with zeros).
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObjectParser(System.Int32,System.Boolean)">
            Return the object held in this tagged object as a parser assuming it has
            the type of the passed in tag. If the object doesn't have a parser
            associated with it, the base object is returned.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerApplicationSpecific">
            Base class for an application specific object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject">
             Return the enclosed object assuming explicit tagging.
            
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject(System.Int32)">
             Return the enclosed object assuming implicit tagging.
            
             @param derTagNo the type tag that should be applied to the object's contents.
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerNull">
            A BER Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.ToBytes(System.Collections.IEnumerable)">
            convert a vector of octet strings into a single byte string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.GetEnumerator">
            return the DER octets that make up this string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo">
            <pre>
            PKIFailureInfo ::= BIT STRING {
            badAlg               (0),
              -- unrecognized or unsupported Algorithm Identifier
            badMessageCheck      (1), -- integrity check failed (e.g., signature did not verify)
            badRequest           (2),
              -- transaction not permitted or supported
            badTime              (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
            badCertId            (4), -- no certificate could be found matching the provided criteria
            badDataFormat        (5),
              -- the data submitted has the wrong format
            wrongAuthority       (6), -- the authority indicated in the request is different from the one creating the response token
            incorrectData        (7), -- the requester's data is incorrect (for notary services)
            missingTimeStamp     (8), -- when the timestamp is missing but should be there (by policy)
            badPOP               (9)  -- the proof-of-possession failed
            timeNotAvailable    (14),
              -- the TSA's time source is not available
            unacceptedPolicy    (15),
              -- the requested TSA policy is not supported by the TSA
            unacceptedExtension (16),
              -- the requested extension is not supported by the TSA
             addInfoNotAvailable (17)
               -- the additional information requested could not be understood
               -- or is not available
             systemFailure       (25)
               -- the request cannot be handled due to system failure
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetPadBits(System.Int32)">
            return the correct number of pad bits for a bit string defined in
            a 32 bit constant
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetBytes(System.Int32)">
            return the correct number of bytes for a bit string defined in
            a 32 bit constant
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo.#ctor(System.Int32)">
            Basic constructor.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.ToAsn1Object">
            <pre>
            PkiFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Size">
             Return the number of string elements present.
            
             @return number of elements present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Item(System.Int32)">
             Return the UTF8STRING at index.
            
             @param index index of the string of interest
             @return the string at index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32)">
            @param status
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32,Org.BouncyCastle.Asn1.Cmp.PkiFreeText)">
            @param status
            @param statusString
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.ToAsn1Object">
             <pre>
             PkiStatusInfo ::= SEQUENCE {
                 status        PKIStatus,                (INTEGER)
                 statusString  PkiFreeText     OPTIONAL,
                 failInfo      PkiFailureInfo  OPTIONAL  (BIT STRING)
             }
            
             PKIStatus:
               granted                (0), -- you got exactly what you asked for
               grantedWithMods        (1), -- you got something like what you asked for
               rejection              (2), -- you don't get it, more information elsewhere in the message
               waiting                (3), -- the request body part has not yet been processed, expect to hear more later
               revocationWarning      (4), -- this message contains a warning that a revocation is imminent
               revocationNotification (5), -- notification that a revocation has occurred
               keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg
            
             PkiFailureInfo:
               badAlg           (0), -- unrecognized or unsupported Algorithm Identifier
               badMessageCheck  (1), -- integrity check failed (e.g., signature did not verify)
               badRequest       (2), -- transaction not permitted or supported
               badTime          (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
               badCertId        (4), -- no certificate could be found matching the provided criteria
               badDataFormat    (5), -- the data submitted has the wrong format
               wrongAuthority   (6), -- the authority indicated in the request is different from the one creating the response token
               incorrectData    (7), -- the requester's data is incorrect (for notary services)
               missingTimeStamp (8), -- when the timestamp is missing but should be there (by policy)
               badPOP           (9)  -- the proof-of-possession failed
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attribute ::= SEQUENCE {
                attrType OBJECT IDENTIFIER,
                attrValues SET OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.GetAll(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return all the attributes matching the OBJECT IDENTIFIER oid. The vector will be
             empty if there are no attributes of the required type present.
            
             @param oid type of attribute required.
             @return a vector of all the attributes found of type oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.Add(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Return a new table with the passed in attribute added.
            
             @param attrType
             @param attrValue
             @return
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cms.AttributeTable.Item(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Return the first attribute matching the given OBJECT IDENTIFIER</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthenticatedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(System.Object)">
             return an AuthenticatedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers.id_ri">
            The other Revocation Info arc
            id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
                                              dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedData">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= Sequence {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a CompressedData object from a tagged object.
            
             @param ato the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(System.Object)">
             return a CompressedData object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedDataParser">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= SEQUENCE {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.ContentInfoParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= SEQUENCE {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            MQVuserKeyingMaterial ::= SEQUENCE {
              ephemeralPublicKey OriginatorPublicKey,
              addedukm [0] EXPLICIT UserKeyingMaterial OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.GetInstance(System.Object)">
             return an EncryptedContentInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EncryptedContentInfo ::= Sequence {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser">
            <pre>
            EncryptedContentInfo ::= SEQUENCE {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedData.ToAsn1Object">
            <pre>
                  EncryptedData ::= SEQUENCE {
                                version CMSVersion,
                                encryptedContentInfo EncryptedContentInfo,
                                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an EnvelopedData object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(System.Object)">
             return an EnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= Sequence {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= SEQUENCE {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(System.Object)">
             return a KekIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekIdentifier ::= Sequence {
                keyIdentifier OCTET STRING,
                date GeneralizedTime OPTIONAL,
                other OtherKeyAttribute OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(System.Object)">
             return a KekRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 4
                kekID KekIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an KeyAgreeRecipientIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(System.Object)">
             return an KeyAgreeRecipientIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyAgreeRecipientIdentifier ::= CHOICE {
                issuerAndSerialNumber IssuerAndSerialNumber,
                rKeyId [0] IMPLICIT RecipientKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KeyAgreeRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(System.Object)">
             return a KeyAgreeRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.ToAsn1Object">
                     * Produce an object suitable for an Asn1OutputStream.
                     * <pre>
                     * KeyAgreeRecipientInfo ::= Sequence {
                     *     version CMSVersion,  -- always set to 3
                     *     originator [0] EXPLICIT OriginatorIdentifierOrKey,
                     *     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                     *     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                     *     recipientEncryptedKeys RecipientEncryptedKeys
                     * }
            		 *
            		 * UserKeyingMaterial ::= OCTET STRING
                     * </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.GetInstance(System.Object)">
             return a KeyTransRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyTransRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 0 or 2
                rid RecipientIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorIdentifierOrKey object from a tagged object.
            
             @param o the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(System.Object)">
             return an OriginatorIdentifierOrKey object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             OriginatorIdentifierOrKey ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier,
                 originatorKey [1] OriginatorPublicKey
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(System.Object)">
             return an OriginatorInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorInfo ::= Sequence {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorPublicKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(System.Object)">
             return an OriginatorPublicKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorPublicKey ::= Sequence {
                algorithm AlgorithmIdentifier,
                publicKey BIT STRING
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.GetInstance(System.Object)">
             return an OtherKeyAttribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherKeyAttribute ::= Sequence {
                keyAttrId OBJECT IDENTIFIER,
                keyAttr ANY DEFINED BY keyAttrId OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(System.Object)">
             return a OtherRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherRecipientInfo ::= Sequence {
               oriType OBJECT IDENTIFIER,
               oriValue ANY DEFINED BY oriType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a PasswordRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(System.Object)">
             return a PasswordRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            PasswordRecipientInfo ::= Sequence {
              version CMSVersion,   -- Always set to 0
              keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier
                                        OPTIONAL,
             keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
             encryptedKey EncryptedKey }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an RecipientEncryptedKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(System.Object)">
             return a RecipientEncryptedKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientEncryptedKey ::= SEQUENCE {
                rid KeyAgreeRecipientIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.GetInstance(System.Object)">
             return a RecipientIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientInfo ::= CHOICE {
                ktri KeyTransRecipientInfo,
                kari [1] KeyAgreeRecipientInfo,
                kekri [2] KekRecipientInfo,
                pwri [3] PasswordRecipientInfo,
                ori [4] OtherRecipientInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a RecipientKeyIdentifier object from a tagged object.
            
             @param _ato the tagged object holding the object we want.
             @param _explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(System.Object)">
             return a RecipientKeyIdentifier object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientKeyIdentifier ::= Sequence {
                 subjectKeyIdentifier SubjectKeyIdentifier,
                 date GeneralizedTime OPTIONAL,
                 other OtherKeyAttribute OPTIONAL
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedData">
            a signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SignedData ::= Sequence {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedDataParser">
            <pre>
            SignedData ::= SEQUENCE {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.GetInstance(System.Object)">
             return a SignerIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             SignerIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  SignerIdentifier sid,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            table of the available named parameters for GOST 3410-2001.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the ECDomainParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters.ToAsn1Object">
             <pre>
             Gost28147-89-Parameters ::=
                           SEQUENCE {
                                   iv                   Gost28147-89-IV,
                                   encryptionParamSet   OBJECT IDENTIFIER
                            }
            
               Gost28147-89-IV ::= OCTET STRING (SIZE (8))
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            table of the available named parameters for GOST 3410-94.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the GOST3410ParamSetParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            returns an enumeration containing the name strings for parameters
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Boolean)">
            return a DerBoolean from the passed in bool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerGeneralizedTime">
            Generalized time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(System.Object)">
             return a generalized time from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Generalized Time object from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.String)">
             The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
             for local time, or Z+-HHMM on the end, for difference between local
             time and UTC time. The fractional second amount f must consist of at
             least one number with trailing zeroes removed.
            
             @param time the time string.
             @exception ArgumentException if string is an illegal format.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.DateTime)">
            base constructor from a local time object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetTime">
            return the time - always in the form of
             YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerGeneralizedTime.TimeString">
            Return the time.
            @return The time string as it appeared in the encoded object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            Der IA5String object - this is an ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return a IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String)">
            basic constructor - without validation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a Numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Numeric string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String)">
            basic constructor -  without validation..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an Oid from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an object Identifier from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Printable string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String)">
            basic constructor - this does not validate the string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an T61 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.String)">
            basic constructor - with string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            Der UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a Universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Universal string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUnknownTag">
            We insert one of these when we find a tag we don't recognise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUnknownTag.#ctor(System.Int32,System.Byte[])">
            @param tag the tag value.
            @param data the contents octets.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtcTime">
            UTC time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(System.Object)">
             return an UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTC Time from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.String)">
            The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
            never encoded. When you're creating one of these objects from scratch, that's
            what you want to use, otherwise we'll try to deal with whatever Gets read from
            the input stream... (this is why the input format is different from the GetTime()
            method output).
            <p>
            @param time the time string.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.DateTime)">
            base constructor from a DateTime object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToDateTime">
             return the time as a date based on whatever a 2 digit year will return. For
             standardised processing use ToAdjustedDateTime().
            
             @return the resulting date
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToAdjustedDateTime">
             return the time as an adjusted date
             in the range of 1950 - 2049.
            
             @return a date in the range of 1950 to 2049.
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.TimeString">
            return the time - always in the form of
             YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
            <p>
            <b>Note:</b> In some cases, due to the local date processing, this
            may lead to unexpected results. If you want to stick the normal
            convention of 1950 to 2049 use the GetAdjustedTime() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.AdjustedTimeString">
            <summary>
            Return a time string as an adjusted date with a 4 digit year.
            This goes in the range of 1950 - 2049.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTF8 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            Der VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a Visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Visible string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CertificateValues">
            <remarks>
            RFC 3126: 4.3.1 Certificate Values Attribute Definition
            <code>
            CertificateValues ::= SEQUENCE OF Certificate
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication.ToAsn1Object">
            <pre>
            CommitmentTypeIndication ::= SEQUENCE {
                 commitmentTypeId   CommitmentTypeIdentifier,
                 commitmentTypeQualifier   SEQUENCE SIZE (1..MAX) OF
                         CommitmentTypeQualifier OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier">
             Commitment type qualifiers, used in the Commitment-Type-Indication attribute (RFC3126).
            
             <pre>
               CommitmentTypeQualifier ::= SEQUENCE {
                   commitmentTypeIdentifier  CommitmentTypeIdentifier,
                   qualifier          ANY DEFINED BY commitmentTypeIdentifier OPTIONAL }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param as <code>CommitmentTypeQualifier</code> structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.ToAsn1Object">
             Returns a DER-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs">
            <remarks>
            RFC 3126: 4.2.1 Complete Certificate Refs Attribute Definition
            <code>
            CompleteCertificateRefs ::= SEQUENCE OF OtherCertID
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CompleteRevocationRefs ::= SEQUENCE OF CrlOcspRef
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlIdentifier ::= SEQUENCE 
            {
            	crlissuer		Name,
            	crlIssuedTime	UTCTime,
            	crlNumber		INTEGER OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CRLListID ::= SEQUENCE 
            {
            	crls	SEQUENCE OF CrlValidatedID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlOcspRef">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlOcspRef ::= SEQUENCE {
            	crlids		[0] CRLListID		OPTIONAL,
            	ocspids		[1] OcspListID		OPTIONAL,
            	otherRev	[2] OtherRevRefs	OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlValidatedID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlValidatedID ::= SEQUENCE {
            	crlHash			OtherHash,
            	crlIdentifier	CrlIdentifier OPTIONAL}
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspIdentifier ::= SEQUENCE {
            	ocspResponderID		ResponderID,
            		-- As in OCSP response data
            	producedAt			GeneralizedTime
            		-- As in OCSP response data
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspListID ::=  SEQUENCE {
            	ocspResponses	SEQUENCE OF OcspResponsesID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspResponsesID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspResponsesID ::= SEQUENCE {
            	ocspIdentifier	OcspIdentifier,
            	ocspRepHash		OtherHash OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherCertID">
            <remarks>
            <code>
            OtherCertID ::= SEQUENCE {
            	otherCertHash	OtherHash,
            	issuerSerial	IssuerSerial OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHash">
            <remarks>
            <code>
            OtherHash ::= CHOICE {
            	sha1Hash	OtherHashValue, -- This contains a SHA-1 hash
            	otherHash	OtherHashAlgAndValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue">
            <summary>
            Summary description for OtherHashAlgAndValue.
            </summary>
            <remarks>
            <code>
            OtherHashAlgAndValue ::= SEQUENCE {
            	hashAlgorithm	AlgorithmIdentifier,
            	hashValue		OtherHashValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevRefs">
             <remarks>
             RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
             <code>
             OtherRevRefs ::= SEQUENCE 
             {
            		otherRevRefType      OtherRevRefType,
            		otherRevRefs         ANY DEFINED BY otherRevRefType
             }
            
             OtherRevRefType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevVals">
             <remarks>
             RFC 3126: 4.3.2 Revocation Values Attribute Definition
             <code>
             OtherRevVals ::= SEQUENCE 
             {
            		otherRevValType      OtherRevValType,
            		otherRevVals         ANY DEFINED BY otherRevValType
             }
            
             OtherRevValType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate">
            <remarks>
            <code>
            OtherSigningCertificate ::= SEQUENCE {
            	certs		SEQUENCE OF OtherCertID,
            	policies	SEQUENCE OF PolicyInformation OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.RevocationValues">
            <remarks>
            RFC 5126: 6.3.4.  revocation-values Attribute Definition
            <code>
            RevocationValues ::=  SEQUENCE {
            	crlVals			[0] SEQUENCE OF CertificateList     OPTIONAL,
            	ocspVals		[1] SEQUENCE OF BasicOCSPResponse   OPTIONAL,
            	otherRevVals	[2] OtherRevVals OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyId">
            <remarks>
            <code>
            SignaturePolicyId ::= SEQUENCE {
            	sigPolicyIdentifier		SigPolicyId,
            	sigPolicyHash			SigPolicyHash,
            	sigPolicyQualifiers		SEQUENCE SIZE (1..MAX) OF SigPolicyQualifierInfo OPTIONAL
            }
            
            SigPolicyId ::= OBJECT IDENTIFIER
            
            SigPolicyHash ::= OtherHashAlgAndValue
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier">
            <remarks>
            <code>
            SignaturePolicyIdentifier ::= CHOICE {
            	SignaturePolicyId		SignaturePolicyId,
            	SignaturePolicyImplied	SignaturePolicyImplied
            }
            
            SignaturePolicyImplied ::= NULL
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerAttribute.ToAsn1Object">
            
             <pre>
              SignerAttribute ::= SEQUENCE OF CHOICE {
                  claimedAttributes   [0] ClaimedAttributes,
                  certifiedAttributes [1] CertifiedAttributes }
            
              ClaimedAttributes ::= SEQUENCE OF Attribute
              CertifiedAttributes ::= AttributeCertificate -- as defined in RFC 3281: see clause 4.1.
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignerLocation">
             Signer-Location attribute (RFC3126).
            
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerLocation.ToAsn1Object">
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
            
               DirectoryString ::= CHOICE {
                     teletexString           TeletexString (SIZE (1..MAX)),
                     printableString         PrintableString (SIZE (1..MAX)),
                     universalString         UniversalString (SIZE (1..MAX)),
                     utf8String              UTF8String (SIZE (1.. MAX)),
                     bmpString               BMPString (SIZE (1..MAX)) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo">
            <remarks>
            <code>
            SigPolicyQualifierInfo ::= SEQUENCE {
            	sigPolicyQualifierId  SigPolicyQualifierId,
            	sigQualifier          ANY DEFINED BY sigPolicyQualifierId
            }
            
            SigPolicyQualifierId ::= OBJECT IDENTIFIER
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.ToAsn1Object">
            <pre>
            ContentHints ::= SEQUENCE {
              contentDescription UTF8String (SIZE (1..MAX)) OPTIONAL,
              contentType ContentType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            Create from OCTET STRING whose octets represent the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(System.Byte[])">
            Create from byte array representing the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.ToAsn1Object">
            The definition of ContentIdentifier is
            <pre>
            ContentIdentifier ::=  OCTET STRING
            </pre>
            id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 7 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.ToAsn1Object">
            <pre>
            EssCertID ::= SEQUENCE {
                certHash Hash,
                issuerSerial IssuerSerial OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertIDv2.ToAsn1Object">
             <pre>
             EssCertIDv2 ::=  SEQUENCE {
                 hashAlgorithm     AlgorithmIdentifier
                          DEFAULT {algorithm id-sha256},
                 certHash          Hash,
                 issuerSerial      IssuerSerial OPTIONAL
             }
            
             Hash ::= OCTET STRING
            
             IssuerSerial ::= SEQUENCE {
                 issuer         GeneralNames,
                 serialNumber   CertificateSerialNumber
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherCertID.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherCertID.ToAsn1Object">
             <pre>
             OtherCertID ::= SEQUENCE {
                 otherCertHash    OtherHash,
                 issuerSerial     IssuerSerial OPTIONAL }
            
             OtherHash ::= CHOICE {
                 sha1Hash     OCTET STRING,
                 otherHash    OtherHashAlgAndValue }
            
             OtherHashAlgAndValue ::= SEQUENCE {
                 hashAlgorithm    AlgorithmIdentifier,
                 hashValue        OCTET STRING }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate.ToAsn1Object">
            The definition of OtherSigningCertificate is
            <pre>
            OtherSigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF OtherCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-ets-otherSigCert OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 19 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.ToAsn1Object">
            The definition of SigningCertificate is
            <pre>
            SigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificate OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 12 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificateV2.ToAsn1Object">
            The definition of SigningCertificateV2 is
            <pre>
            SigningCertificateV2 ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertIDv2,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificateV2 OBJECT IDENTIFIER ::= { iso(1)
               member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) id-aa(2) 47 }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.DataGroupHash">
             The DataGroupHash object.
             <pre>
             DataGroupHash  ::=  SEQUENCE {
                  dataGroupNumber         DataGroupNumber,
                  dataGroupHashValue     OCTET STRING }
            
             DataGroupNumber ::= INTEGER {
                     dataGroup1    (1),
                     dataGroup1    (2),
                     dataGroup1    (3),
                     dataGroup1    (4),
                     dataGroup1    (5),
                     dataGroup1    (6),
                     dataGroup1    (7),
                     dataGroup1    (8),
                     dataGroup1    (9),
                     dataGroup1    (10),
                     dataGroup1    (11),
                     dataGroup1    (12),
                     dataGroup1    (13),
                     dataGroup1    (14),
                     dataGroup1    (15),
                     dataGroup1    (16) }
            
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.LdsSecurityObject">
             The LDSSecurityObject object (V1.8).
             <pre>
             LDSSecurityObject ::= SEQUENCE {
               version                LDSSecurityObjectVersion,
               hashAlgorithm          DigestAlgorithmIdentifier,
               dataGroupHashValues    SEQUENCE SIZE (2..ub-DataGroups) OF DataHashGroup,
               ldsVersionInfo         LDSVersionInfo OPTIONAL
                 -- if present, version MUST be v1 }
            
             DigestAlgorithmIdentifier ::= AlgorithmIdentifier,
            
             LDSSecurityObjectVersion :: INTEGER {V0(0)}
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttCPAccredited">
            The id-isismtt-cp-accredited OID indicates that the certificate is a
            qualified certificate according to Directive 1999/93/EC of the European
            Parliament and of the Council of 13 December 1999 on a Community
            Framework for Electronic Signatures, which additionally conforms the
            special requirements of the SigG and has been issued by an accredited CA.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDateOfCertGen">
             Certificate extensionDate of certificate generation
             
             <pre>
            		DateOfCertGenSyntax ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATProcuration">
            Attribute to indicate that the certificate holder may sign in the name of
            a third person. May also be used as extension in a certificate.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdmission">
            Attribute to indicate admissions to certain professions. May be used as
            attribute in attribute certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATMonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST
            be used in new certificates in place of the extension/attribute
            MonetaryLimit since January 1, 2004. For the sake of backward
            compatibility with certificates already in use, SigG conforming
            components MUST support MonetaryLimit (as well as QcEuLimitValue).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDeclarationOfMajority">
            A declaration of majority. May be used as attribute in attribute
            certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATIccsn">
             
             Serial number of the smart card containing the corresponding private key
             
             <pre>
            		ICCSNSyntax ::= OCTET STRING (SIZE(8..20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATPKReference">
             
             Reference for a file of a smartcard that stores the public key of this
             certificate and that is used as �security anchor�.
             
             <pre>
            		PKReferenceSyntax ::= OCTET STRING (SIZE(20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRestriction">
             Some other restriction regarding the usage of this certificate. May be
             used as attribute in attribute certificate or as extension in a
             certificate.
             
             <pre>
            		RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
             
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRetrieveIfAllowed">
             
             (Single)Request extension: Clients may include this extension in a
             (single) Request to request the responder to send the certificate in the
             response message along with the status information. Besides the LDAP
             service, this extension provides another mechanism for the distribution
             of certificates, which MAY optionally be provided by certificate
             repositories.
             
             <pre>
            		RetrieveIfAllowed ::= BOOLEAN
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRequestedCertificate">
            SingleOCSPResponse extension: The certificate requested by the client by
            inserting the RetrieveIfAllowed extension in the request, will be
            returned in this extension.
            
            @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNamingAuthorities">
            Base ObjectIdentifier for naming authorities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertInDirSince">
             SingleOCSPResponse extension: Date, when certificate has been published
             in the directory and status information has become available. Currently,
             accrediting authorities enforce that SigG-conforming OCSP servers include
             this extension in the responses.
             
             <pre>
            		CertInDirSince ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertHash">
             Hash of a certificate in OCSP.
            
             @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNameAtBirth">
             <pre>
            		NameAtBirth ::= DirectoryString(SIZE(1..64)
             </pre>
             
             Used in
             {@link Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes SubjectDirectoryAttributes}
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdditionalInformation">
            Some other information of non-restrictive nature regarding the usage of
            this certificate. May be used as attribute in atribute certificate or as
            extension in a certificate.
            
            <pre>
                          AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATLiabilityLimitationFlag">
             Indicates that an attribute certificate exists, which limits the
             usability of this public key certificate. Whenever verifying a signature
             with the help of this certificate, the content of the corresponding
             attribute certificate should be concerned. This extension MUST be
             included in a PKC, if a corresponding attribute certificate (having the
             PKC as base certificate) contains some attribute that restricts the
             usability of the PKC too. Attribute certificates with restricting content
             MUST always be included in the signed document.
             
             <pre>
            		LiabilityLimitationFlagSyntax ::= BOOLEAN
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash">
            ISIS-MTT PROFILE: The responder may include this extension in a response to
            send the hash of the requested certificate to the responder. This hash is
            cryptographically bound to the certificate and serves as evidence that the
            certificate is known to the responder (i.e. it has been issued and is present
            in the directory). Hence, this extension is a means to provide a positive
            statement of availability as described in T8.[8]. As explained in T13.[1],
            clients may rely on this information to be able to validate signatures after
            the expiry of the corresponding certificate. Hence, clients MUST support this
            extension. If a positive statement of availability is to be delivered, this
            extension syntax and OID MUST be used.
            <p/>
            <p/>
            <pre>
                CertHash ::= SEQUENCE {
                  hashAlgorithm AlgorithmIdentifier,
                  certificateHash OCTET STRING
                }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertHash:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
             Constructor from a given details.
            
             @param hashAlgorithm   The hash algorithm identifier.
             @param certificateHash The hash of the whole DER encoding of the certificate.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate">
            ISIS-MTT-Optional: The certificate requested by the client by inserting the
            RetrieveIfAllowed extension in the request, will be returned in this
            extension.
            <p/>
            ISIS-MTT-SigG: The signature act allows publishing certificates only then,
            when the certificate owner gives his isExplicit permission. Accordingly, there
            may be �nondownloadable� certificates, about which the responder must provide
            status information, but MUST NOT include them in the response. Clients may
            get therefore the following three kind of answers on a single request
            including the RetrieveIfAllowed extension:
            <ul>
            <li> a) the responder supports the extension and is allowed to publish the
            certificate: RequestedCertificate returned including the requested
            certificate</li>
            <li>b) the responder supports the extension but is NOT allowed to publish
            the certificate: RequestedCertificate returned including an empty OCTET
            STRING</li>
            <li>c) the responder does not support the extension: RequestedCertificate is
            not included in the response</li>
            </ul>
            Clients requesting RetrieveIfAllowed MUST be able to handle these cases. If
            any of the OCTET STRING options is used, it MUST contain the DER encoding of
            the requested certificate.
            <p/>
            <pre>
                       RequestedCertificate ::= CHOICE {
                         Certificate Certificate,
                         publicKeyCertificate [0] EXPLICIT OCTET STRING,
                         attributeCertificate [1] EXPLICIT OCTET STRING
                       }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
             <p/>
             Only one parameter can be given. All other must be <code>null</code>.
            
             @param certificate Given as Certificate
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                        RequestedCertificate ::= CHOICE {
                          Certificate Certificate,
                          publicKeyCertificate [0] EXPLICIT OCTET STRING,
                          attributeCertificate [1] EXPLICIT OCTET STRING
                        }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax">
            Some other information of non-restrictive nature regarding the usage of this
            certificate.
            
            <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.#ctor(System.String)">
             Constructor from a given details.
            
             @param information The describtion of the information.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions">
             An Admissions structure.
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             <p/>
             </pre>
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo[])">
             Constructor from a given details.
             <p/>
             Parameter <code>professionInfos</code> is mandatory.
            
             @param admissionAuthority The admission authority.
             @param namingAuthority    The naming authority.
             @param professionInfos    The profession infos.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   Admissions ::= SEQUENCE
                   {
                     admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                     namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                     professionInfos SEQUENCE OF ProfessionInfo
                   }
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax">
             Attribute to indicate admissions to certain professions.
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
             <p/>
             <p/>
             ISIS-MTT PROFILE: The relatively complex structure of AdmissionSyntax
             supports the following concepts and requirements:
             <ul>
             <li> External institutions (e.g. professional associations, chambers, unions,
             administrative bodies, companies, etc.), which are responsible for granting
             and verifying professional admissions, are indicated by means of the data
             field admissionAuthority. An admission authority is indicated by a
             GeneralName object. Here an X.501 directory name (distinguished name) can be
             indicated in the field directoryName, a URL address can be indicated in the
             field uniformResourceIdentifier, and an object identifier can be indicated in
             the field registeredId.</li>
             <li> The names of authorities which are responsible for the administration of
             title registers are indicated in the data field namingAuthority. The name of
             the authority can be identified by an object identifier in the field
             namingAuthorityId, by means of a text string in the field
             namingAuthorityText, by means of a URL address in the field
             namingAuthorityUrl, or by a combination of them. For example, the text string
             can contain the name of the authority, the country and the name of the title
             register. The URL-option refers to a web page which contains lists with
             �officially� registered professions (text and possibly OID) as well as
             further information on these professions. Object identifiers for the
             component namingAuthorityId are grouped under the OID-branch
             id-isis-at-namingAuthorities and must be applied for.</li>
             <li>See http://www.teletrust.de/anwend.asp?Id=30200&amp;Sprache=E_&amp;HomePG=0
             for an application form and http://www.teletrust.de/links.asp?id=30220,11
             for an overview of registered naming authorities.</li>
             <li> By means of the data type ProfessionInfo certain professions,
             specializations, disciplines, fields of activity, etc. are identified. A
             profession is represented by one or more text strings, resp. profession OIDs
             in the fields professionItems and professionOIDs and by a registration number
             in the field registrationNumber. An indication in text form must always be
             present, whereas the other indications are optional. The component
             addProfessionInfo may contain additional applicationspecific information in
             DER-encoded form.</li>
             </ul>
             <p/>
             By means of different namingAuthority-OIDs or profession OIDs hierarchies of
             professions, specializations, disciplines, fields of activity, etc. can be
             expressed. The issuing admission authority should always be indicated (field
             admissionAuthority), whenever a registration number is presented. Still,
             information on admissions can be given without indicating an admission or a
             naming authority by the exclusive use of the component professionItems. In
             this case the certification authority is responsible for the verification of
             the admission information.
             <p/>
             <p/>
             <p/>
             This attribute is single-valued. Still, several admissions can be captured in
             the sequence structure of the component contentsOfAdmissions of
             AdmissionSyntax or in the component professionInfos of Admissions. The
             component admissionAuthority of AdmissionSyntax serves as default value for
             the component admissionAuthority of Admissions. Within the latter component
             the default value can be overwritten, in case that another authority is
             responsible. The component namingAuthority of Admissions serves as a default
             value for the component namingAuthority of ProfessionInfo. Within the latter
             component the default value can be overwritten, in case that another naming
             authority needs to be recorded.
             <p/>
             The length of the string objects is limited to 128 characters. It is
             recommended to indicate a namingAuthorityURL in all issued attribute
             certificates. If a namingAuthorityURL is indicated, the field professionItems
             of ProfessionInfo should contain only registered titles. If the field
             professionOIDs exists, it has to contain the OIDs of the professions listed
             in professionItems in the same order. In general, the field professionInfos
             should contain only one entry, unless the admissions that are to be listed
             are logically connected (e.g. they have been issued under the same admission
             number).
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from given details.
            
             @param admissionAuthority   The admission authority.
             @param contentsOfAdmissions The admissions.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.GetContentsOfAdmissions">
            @return Returns the contentsOfAdmissions.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.AdmissionAuthority">
            @return Returns the admissionAuthority if present, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority">
            A declaration of majority.
            <p/>
            <pre>
                      DeclarationOfMajoritySyntax ::= CHOICE
                      {
                        notYoungerThan [0] IMPLICIT INTEGER,
                        fullAgeAtCountry [1] IMPLICIT SEQUENCE
                        {
                          fullAge BOOLEAN DEFAULT TRUE,
                          country PrintableString (SIZE(2))
                        }
                        dateOfBirth [2] IMPLICIT GeneralizedTime
                      }
            </pre>
            <p/>
            fullAgeAtCountry indicates the majority of the owner with respect to the laws
            of a specific country.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                       DeclarationOfMajoritySyntax ::= CHOICE
                       {
                         notYoungerThan [0] IMPLICIT INTEGER,
                         fullAgeAtCountry [1] IMPLICIT SEQUENCE
                         {
                           fullAge BOOLEAN DEFAULT TRUE,
                           country PrintableString (SIZE(2))
                         }
                         dateOfBirth [2] IMPLICIT GeneralizedTime
                       }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.NotYoungerThan">
            @return notYoungerThan if that's what we are, -1 otherwise
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST be
            used in new certificates in place of the extension/attribute MonetaryLimit
            since January 1, 2004. For the sake of backward compatibility with
            certificates already in use, components SHOULD support MonetaryLimit (as well
            as QcEuLimitValue).
            <p/>
            Indicates a monetary limit within which the certificate holder is authorized
            to act. (This value DOES NOT express a limit on the liability of the
            certification authority).
            <p/>
            <pre>
               MonetaryLimitSyntax ::= SEQUENCE
               {
                 currency PrintableString (SIZE(3)),
                 amount INTEGER,
                 exponent INTEGER
               }
            </pre>
            <p/>
            currency must be the ISO code.
            <p/>
            value = amount�10*exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.#ctor(System.String,System.Int32,System.Int32)">
             Constructor from a given details.
             <p/>
             <p/>
             value = amount�10^exponent
            
             @param currency The currency. Must be the ISO code.
             @param amount   The amount
             @param exponent The exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                MonetaryLimitSyntax ::= SEQUENCE
                {
                  currency PrintableString (SIZE(3)),
                  amount INTEGER,
                  exponent INTEGER
                }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority">
            Names of authorities which are responsible for the administration of title
            registers.
            
            <pre>
                        NamingAuthority ::= SEQUENCE 
                        {
                          namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                          namingAuthorityUrl IA5String OPTIONAL,
                          namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                        }
            </pre>
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern">
            Profession OIDs should always be defined under the OID branch of the
            responsible naming authority. At the time of this writing, the work group
            �Recht, Wirtschaft, Steuern� (�Law, Economy, Taxes�) is registered as the
            first naming authority under the OID id-isismtt-at-namingAuthorities.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from given details.
             <p/>
             All parameters can be combined.
            
             @param namingAuthorityID   ObjectIdentifier for naming authority.
             @param namingAuthorityUrl  URL for naming authority.
             @param namingAuthorityText Textual representation of naming authority.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityID">
            @return Returns the namingAuthorityID.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityText">
            @return Returns the namingAuthorityText.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityUrl">
            @return Returns the namingAuthorityUrl.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax">
            Attribute to indicate that the certificate holder may sign in the name of a
            third person.
            <p>
            ISIS-MTT PROFILE: The corresponding ProcurationSyntax contains either the
            name of the person who is represented (subcomponent thirdPerson) or a
            reference to his/her base certificate (in the component signingFor,
            subcomponent certRef), furthermore the optional components country and
            typeSubstitution to indicate the country whose laws apply, and respectively
            the type of procuration (e.g. manager, procuration, custody).
            </p>
            <p>
            ISIS-MTT PROFILE: The GeneralName MUST be of type directoryName and MAY only
            contain: - RFC3039 attributes, except pseudonym (countryName, commonName,
            surname, givenName, serialNumber, organizationName, organizationalUnitName,
            stateOrProvincename, localityName, postalAddress) and - SubjectDirectoryName
            attributes (title, dateOfBirth, placeOfBirth, gender, countryOfCitizenship,
            countryOfResidence and NameAtBirth).
            </p>
            <pre>
                          ProcurationSyntax ::= SEQUENCE {
                            country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                            typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                            signingFor [3] EXPLICIT SigningFor 
                          }
                          
                          SigningFor ::= CHOICE 
                          { 
                            thirdPerson GeneralName,
                            certRef IssuerSerial 
                          }
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.IssuerSerial)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param certRef            Reference to certificate of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param thirdPerson        The GeneralName of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo">
            Professions, specializations, disciplines, fields of activity, etc.
            
            <pre>
                          ProfessionInfo ::= SEQUENCE 
                          {
                            namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                            professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                            professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                            registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                            addProfessionInfo OCTET STRING OPTIONAL 
                          }
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwltin">
            Rechtsanw�ltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwalt">
            Rechtsanwalt
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsbeistand">
            Rechtsbeistand
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberaterin">
            Steuerberaterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberater">
            Steuerberater
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigte">
            Steuerbevollm�chtigte
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigter">
            Steuerbevollm�chtigter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarin">
            Notarin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notar">
            Notar
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreterin">
            Notarvertreterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreter">
            Notarvertreter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalterin">
            Notariatsverwalterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalter">
            Notariatsverwalter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprferin">
            Wirtschaftspr�ferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprfer">
            Wirtschaftspr�fer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigteBuchprferin">
            Vereidigte Buchpr�ferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigterBuchprfer">
            Vereidigter Buchpr�fer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwltin">
            Patentanw�ltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwalt">
            Patentanwalt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.X500.DirectoryString[],Org.BouncyCastle.Asn1.DerObjectIdentifier[],System.String,Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor from given details.
             <p/>
             <code>professionItems</code> is mandatory, all other parameters are
             optional.
            
             @param namingAuthority    The naming authority.
             @param professionItems    Directory strings of the profession.
             @param professionOids     DERObjectIdentfier objects for the
                                       profession.
             @param registrationNumber Registration number.
             @param addProfessionInfo  Additional infos in encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionItems">
            @return Returns the professionItems.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionOids">
            @return Returns the professionOids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.AddProfessionInfo">
            @return Returns the addProfessionInfo.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.NamingAuthority">
            @return Returns the namingAuthority.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.RegistrationNumber">
            @return Returns the registrationNumber.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction">
            Some other restriction regarding the usage of this certificate.
            <p/>
            <pre>
             RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from DirectoryString.
             <p/>
             The DirectoryString is of type RestrictionSyntax:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
            
             @param restriction A IAsn1String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(System.String)">
             Constructor from a given details.
            
             @param restriction The description of the restriction.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            cast5CBCParameters ::= Sequence {
                                      iv         OCTET STRING DEFAULT 0,
                                             -- Initialization vector
                                      keyLength  Integer
                                             -- Key length, in bits
                                 }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.IdeaCbcPar.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            IDEA-CBCPar ::= Sequence {
                                 iv    OCTET STRING OPTIONAL -- exactly 8 octets
                             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge">
             This is designed to parse
             the PublicKeyAndChallenge created by the KEYGEN tag included by
             Mozilla based browsers.
              <pre>
              PublicKeyAndChallenge ::= SEQUENCE {
                spki SubjectPublicKeyInfo,
                challenge IA5STRING
              }
            
              </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-3
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers">
            <summary>From RFC 3657</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicOcspResponse       ::= Sequence {
                 tbsResponseData      ResponseData,
                 signatureAlgorithm   AlgorithmIdentifier,
                 signature            BIT STRING,
                 certs                [0] EXPLICIT Sequence OF Certificate OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CertID          ::=     Sequence {
                hashAlgorithm       AlgorithmIdentifier,
                issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                serialNumber        CertificateSerialNumber }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.#ctor">
            create a CertStatus object with a tag of zero.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             CertStatus ::= CHOICE {
                             good        [0]     IMPLICIT Null,
                             revoked     [1]     IMPLICIT RevokedInfo,
                             unknown     [2]     IMPLICIT UnknownInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CrlID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlID ::= Sequence {
                crlUrl               [0]     EXPLICIT IA5String OPTIONAL,
                crlNum               [1]     EXPLICIT Integer OPTIONAL,
                crlTime              [2]     EXPLICIT GeneralizedTime OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspRequest     ::=     Sequence {
                tbsRequest                  TBSRequest,
                optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspResponse ::= Sequence {
                responseStatus         OcspResponseStatus,
                responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus.#ctor(System.Int32)">
            The OcspResponseStatus enumeration.
            <pre>
            OcspResponseStatus ::= Enumerated {
                successful            (0),  --Response has valid confirmations
                malformedRequest      (1),  --Illegal confirmation request
                internalError         (2),  --Internal error in issuer
                tryLater              (3),  --Try again later
                                            --(4) is not used
                sigRequired           (5),  --Must sign the request
                unauthorized          (6)   --Request unauthorized
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Request.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Request         ::=     Sequence {
                reqCert                     CertID,
                singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponderID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponderID ::= CHOICE {
                 byName          [1] Name,
                 byKey           [2] KeyHash }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseBytes.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseBytes ::=       Sequence {
                responseType   OBJECT IDENTIFIER,
                response       OCTET STRING }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseData ::= Sequence {
                version              [0] EXPLICIT Version DEFAULT v1,
                responderID              ResponderID,
                producedAt               GeneralizedTime,
                responses                Sequence OF SingleResponse,
                responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.RevokedInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RevokedInfo ::= Sequence {
                 revocationTime              GeneralizedTime,
                 revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ServiceLocator.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ServiceLocator ::= Sequence {
                issuer    Name,
                locator   AuthorityInfoAccessSyntax OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Signature.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Signature       ::=     Sequence {
                signatureAlgorithm      AlgorithmIdentifier,
                signature               BIT STRING,
                certs               [0] EXPLICIT Sequence OF Certificate OPTIONAL}
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.SingleResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SingleResponse ::= Sequence {
                     certID                       CertID,
                     certStatus                   CertStatus,
                     thisUpdate                   GeneralizedTime,
                     nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
                     singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.TbsRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            TBSRequest      ::=     Sequence {
                version             [0]     EXPLICIT Version DEFAULT v1,
                requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                requestList                 Sequence OF Request,
                requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequest">
            Pkcs10 Certfication request object.
            <pre>
            CertificationRequest ::= Sequence {
              certificationRequestInfo  CertificationRequestInfo,
              signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
              signature                 BIT STRING
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo">
             Pkcs10 CertificationRequestInfo object.
             <pre>
              CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.EncryptedData">
             The EncryptedData object.
             <pre>
                  EncryptedData ::= Sequence {
                       version Version,
                       encryptedContentInfo EncryptedContentInfo
                  }
            
            
                  EncryptedContentInfo ::= Sequence {
                      contentType ContentType,
                      contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
                      encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
                }
            
                EncryptedContent ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.MacData.ToAsn1Object">
            <pre>
            MacData ::= SEQUENCE {
                mac      DigestInfo,
                macSalt  OCTET STRING,
                iterations INTEGER DEFAULT 1
                -- Note: The default is for historic reasons and its use is deprecated. A
                -- higher value, like 1024 is recommended.
            </pre>
            @return the basic DERObject construction.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.Pfx">
            the infamous Pfx from Pkcs12
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ToAsn1Object">
             write out an RSA private key with its associated information
             as described in Pkcs8.
             <pre>
                  PrivateKeyInfo ::= Sequence {
                                          version Version,
                                          privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
                                          privateKey PrivateKey,
                                          attributes [0] IMPLICIT Attributes OPTIONAL
                                      }
                  Version ::= Integer {v1(0)} (v1,...)
            
                  PrivateKey ::= OCTET STRING
            
                  Attributes ::= Set OF Attr
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.ToAsn1Object">
             <pre>
              RSAES-OAEP-params ::= SEQUENCE {
                 hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1,
                 maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                 pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
               }
            
               OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-sha1 PARAMETERS NULL   }|
                 { OID id-sha256 PARAMETERS NULL }|
                 { OID id-sha384 PARAMETERS NULL }|
                 { OID id-sha512 PARAMETERS NULL },
                 ...  -- Allows for future expansion --
               }
               PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
               }
               PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-pSpecified PARAMETERS OCTET STRING },
                 ...  -- Allows for future expansion --
              }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignedData">
            a Pkcs#7 signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SignedData ::= Sequence {
                 version Version,
                 digestAlgorithms DigestAlgorithmIdentifiers,
                 contentInfo ContentInfo,
                 certificates
                     [0] IMPLICIT ExtendedCertificatesAndCertificates
                              OPTIONAL,
                 crls
                     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                 signerInfos SignerInfos }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignerInfo">
            a Pkcs#7 signer info object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  issuerAndSerialNumber IssuerAndSerialNumber,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure">
            the elliptic curve private key object from SEC 1
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure.ToAsn1Object">
            ECPrivateKey ::= SEQUENCE {
                version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
                privateKey OCTET STRING,
                parameters [0] Parameters OPTIONAL,
                publicKey [1] BIT STRING OPTIONAL }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities">
            Handler class for dealing with S/MIME Capabilities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.DesCbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetCapabilitiesForOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            returns an ArrayList with 0 or more objects of all the capabilities
            matching the passed in capability Oid. If the Oid passed is null the
            entire set is returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapabilities ::= Sequence OF SMIMECapability
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.DesCbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapability.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapability ::= Sequence {
                capabilityID OBJECT IDENTIFIER,
                parameters ANY DEFINED BY capabilityID OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector">
            Handler for creating a vector S/MIME Capabilities
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute">
            The SmimeEncryptionKeyPreference object.
            <pre>
            SmimeEncryptionKeyPreference ::= CHOICE {
                issuerAndSerialNumber   [0] IssuerAndSerialNumber,
                receipentKeyId          [1] RecipientKeyIdentifier,
                subjectAltKeyIdentifier [2] SubjectKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            @param sKeyId the subjectKeyIdentifier value (normally the X.509 one)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            elliptic curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.Accuracy.ToAsn1Object">
            <pre>
            Accuracy ::= SEQUENCE {
                        seconds        INTEGER              OPTIONAL,
                        millis     [0] INTEGER  (1..999)    OPTIONAL,
                        micros     [1] INTEGER  (1..999)    OPTIONAL
                        }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.GetInstance(System.Object)">
            @param o
            @return a MessageImprint object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.ToAsn1Object">
            <pre>
               MessageImprint ::= SEQUENCE  {
                  hashAlgorithm                AlgorithmIdentifier,
                  hashedMessage                OCTET STRING  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampReq.ToAsn1Object">
            <pre>
            TimeStampReq ::= SEQUENCE  {
             version                      INTEGER  { v1(1) },
             messageImprint               MessageImprint,
               --a hash algorithm OID and the hash value of the data to be
               --time-stamped
             reqPolicy             TSAPolicyId              OPTIONAL,
             nonce                 INTEGER                  OPTIONAL,
             certReq               BOOLEAN                  DEFAULT FALSE,
             extensions            [0] IMPLICIT Extensions  OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampResp.ToAsn1Object">
            <pre>
            TimeStampResp ::= SEQUENCE  {
              status                  PkiStatusInfo,
              timeStampToken          TimeStampToken     OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TstInfo.ToAsn1Object">
             <pre>
            
                 TstInfo ::= SEQUENCE  {
                    version                      INTEGER  { v1(1) },
                    policy                       TSAPolicyId,
                    messageImprint               MessageImprint,
                      -- MUST have the same value as the similar field in
                      -- TimeStampReq
                    serialNumber                 INTEGER,
                     -- Time-Stamping users MUST be ready to accommodate integers
                     -- up to 160 bits.
                    genTime                      GeneralizedTime,
                    accuracy                     Accuracy                 OPTIONAL,
                    ordering                     BOOLEAN             DEFAULT FALSE,
                    nonce                        INTEGER                  OPTIONAL,
                      -- MUST be present if the similar field was present
                      -- in TimeStampReq.  In that case it MUST have the same value.
                    tsa                          [0] GeneralName          OPTIONAL,
                    extensions                   [1] IMPLICIT Extensions   OPTIONAL  }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.DirectoryString.ToAsn1Object">
            <pre>
             DirectoryString ::= CHOICE {
               teletexString               TeletexString (SIZE (1..MAX)),
               printableString             PrintableString (SIZE (1..MAX)),
               universalString             UniversalString (SIZE (1..MAX)),
               utf8String                  UTF8String (SIZE (1..MAX)),
               bmpString                   BMPString (SIZE (1..MAX))  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AccessDescription">
            The AccessDescription object.
            <pre>
            AccessDescription  ::=  SEQUENCE {
                  accessMethod          OBJECT IDENTIFIER,
                  accessLocation        GeneralName  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AccessDescription.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AccessDescription with the oid and location provided.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessMethod">
            
             @return the access method.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessLocation">
            
             @return the access location
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            <summary>
            Don't use this one if you are trying to be RFC 3281 compliant.
            Use it for v1 attribute certificates only.
            </summary>
            <param name="names">Our GeneralNames structure</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertIssuer ::= CHOICE {
                  v1Form   GeneralNames,  -- MUST NOT be used in this
                                          -- profile
                  v2Form   [0] V2Form     -- v2 only
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertValidityPeriod  ::= Sequence {
                  notBeforeTime  GeneralizedTime,
                  notAfterTime   GeneralizedTime
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.GetInstance(System.Object)">
            @param obj
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttributeCertificate ::= Sequence {
                  acinfo               AttributeCertificateInfo,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
              }
            
              AttCertVersion ::= Integer { v2(1) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess">
             The AuthorityInformationAccess object.
             <pre>
             id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
            
             AuthorityInfoAccessSyntax  ::=
                  Sequence SIZE (1..MAX) OF AccessDescription
             AccessDescription  ::=  Sequence {
                   accessMethod          OBJECT IDENTIFIER,
                   accessLocation        GeneralName  }
            
             id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
             id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
             id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AuthorityInformationAccess with the oid and location provided.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier">
             The AuthorityKeyIdentifier object.
             <pre>
             id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
            
               AuthorityKeyIdentifier ::= Sequence {
                  keyIdentifier             [0] IMPLICIT KeyIdentifier           OPTIONAL,
                  authorityCertIssuer       [1] IMPLICIT GeneralNames            OPTIONAL,
                  authorityCertSerialNumber [2] IMPLICIT CertificateSerialNumber OPTIONAL  }
            
               KeyIdentifier ::= OCTET STRING
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
                     *
                     * Calulates the keyidentifier using a SHA1 hash over the BIT STRING
                     * from SubjectPublicKeyInfo as defined in RFC2459.
                     *
                     * Example of making a AuthorityKeyIdentifier:
                     * <pre>
            	     *   SubjectPublicKeyInfo apki = new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(
            		 *       publicKey.getEncoded()).readObject());
                     *   AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(apki);
                     * </pre>
                     *
                     *
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[])">
            create an AuthorityKeyIdentifier with a precomputed key identifier
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[],Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with a precomupted key identifier
            and the GeneralNames tag and the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificatePair">
             This class helps to support crossCerfificatePairs in a LDAP directory
             according RFC 2587
            
             <pre>
                 crossCertificatePairATTRIBUTE::={
                   WITH SYNTAX   CertificatePair
                   EQUALITY MATCHING RULE certificatePairExactMatch
                   ID joint-iso-ccitt(2) ds(5) attributeType(4) crossCertificatePair(40)}
             </pre>
            
             <blockquote> The forward elements of the crossCertificatePair attribute of a
             CA's directory entry shall be used to store all, except self-issued
             certificates issued to this CA. Optionally, the reverse elements of the
             crossCertificatePair attribute, of a CA's directory entry may contain a
             subset of certificates issued by this CA to other CAs. When both the forward
             and the reverse elements are present in a single attribute value, issuer name
             in one certificate shall match the subject name in the other and vice versa,
             and the subject public key in one certificate shall be capable of verifying
             the digital signature on the other certificate and vice versa.
            
             When a reverse element is present, the forward element value and the reverse
             element value need not be stored in the same attribute value; in other words,
             they can be stored in either a single attribute value or two attribute
             values. </blockquote>
            
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertificatePair:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure,Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
            
             @param forward Certificates issued to this CA.
             @param reverse Certificates issued by this CA to other CAs.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Forward">
            @return Returns the forward.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Reverse">
            @return Returns the reverse.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertPolicyID">
             CertPolicyId, used in the CertificatePolicies and PolicyMappings
             X509V3 Extensions.
            
             <pre>
                 CertPolicyId ::= OBJECT IDENTIFIER
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DisplayText">
             <code>DisplayText</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions (in policy qualifiers).
            
             <p>It stores a string in a chosen encoding.
             <pre>
             DisplayText ::= CHOICE {
                  ia5String        IA5String      (SIZE (1..200)),
                  visibleString    VisibleString  (SIZE (1..200)),
                  bmpString        BMPString      (SIZE (1..200)),
                  utf8String       UTF8String     (SIZE (1..200)) }
             </pre></p>
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeIA5String">
             Constant corresponding to ia5String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeBmpString">
             Constant corresponding to bmpString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeUtf8String">
             Constant corresponding to utf8String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeVisibleString">
             Constant corresponding to visibleString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.DisplayTextMaximumSize">
             Describe constant <code>DisplayTextMaximumSize</code> here.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.Int32,System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param type the desired encoding type for the text.
             @param text the text to store. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param text the text to encapsulate. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(Org.BouncyCastle.Asn1.IAsn1String)">
             Creates a new <code>DisplayText</code> instance.
             <p>Useful when reading back a <code>DisplayText</code> class
             from it's Asn1Encodable form.</p>
            
             @param contents an <code>Asn1Encodable</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.GetString">
             Returns the stored <code>string</code> object.
            
             @return the stored text as a <code>string</code>.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage">
            The extendedKeyUsage object.
            <pre>
                 extendedKeyUsage ::= Sequence SIZE (1..MAX) OF KeyPurposeId
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage.GetAllUsages">
            Returns all extended key usages.
            The returned ArrayList contains DerObjectIdentifier instances.
            @return An ArrayList with all key purposes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralSubtree">
             Class for containing a restriction object subtrees in NameConstraints. See
             RFC 3280.
            
             <pre>
            
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.NameConstraints
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             Constructor from a given details.
            
             According RFC 3280, the minimum and maximum fields are not used with any
             name forms, thus minimum MUST be zero, and maximum MUST be absent.
             <p>
             If minimum is <code>null</code>, zero is assumed, if
             maximum is <code>null</code>, maximum is absent.</p>
            
             @param baseName
                        A restriction.
             @param minimum
                        Minimum
            
             @param maximum
                        Maximum
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @return a DERObject
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Holder">
            The Holder object.
            <p>
            For an v2 attribute certificate this is:
            
            <pre>
                       Holder ::= SEQUENCE {
                             baseCertificateID   [0] IssuerSerial OPTIONAL,
                                      -- the issuer and serial number of
                                      -- the holder's Public Key Certificate
                             entityName          [1] GeneralNames OPTIONAL,
                                      -- the name of the claimant or role
                             objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                                      -- used to directly authenticate the holder,
                                      -- for example, an executable
                       }
            </pre>
            </p>
            <p>
            For an v1 attribute certificate this is:
            
            <pre>
                    subject CHOICE {
                     baseCertificateID [0] IssuerSerial,
                     -- associated with a Public Key Certificate
                     subjectName [1] GeneralNames },
                     -- associated with a name
            </pre>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor for a holder for an v1 attribute certificate.
            
            @param tagObj The ASN.1 tagged holder object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor for a holder for an v2 attribute certificate. *
            
            @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.IssuerSerial,System.Int32)">
            Constructs a holder from a IssuerSerial.
            @param baseCertificateID The IssuerSerial.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,System.Int32)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.ObjectDigestInfo)">
            Constructs a holder from an object digest info.
            
            @param objectDigestInfo The object digest info object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.ToAsn1Object">
            The Holder object.
            <pre>
             Holder ::= Sequence {
                   baseCertificateID   [0] IssuerSerial OPTIONAL,
                            -- the issuer and serial number of
                            -- the holder's Public Key Certificate
                   entityName          [1] GeneralNames OPTIONAL,
                            -- the name of the claimant or role
                   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                            -- used to directly authenticate the holder,
                            -- for example, an executable
             }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.Version">
            Returns 1 for v2 attribute certificates or 0 for v1 attribute
            certificates. 
            @return The version of the attribute certificate.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.EntityName">
            Returns the entityName for an v2 attribute certificate or the subjectName
            for an v1 attribute certificate.
            
            @return The entityname or subjectname.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax">
            Implementation of <code>IetfAttrSyntax</code> as specified by RFC3281.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.ToAsn1Object">
            
             <pre>
            
              IetfAttrSyntax ::= Sequence {
                policyAuthority [0] GeneralNames OPTIONAL,
                values Sequence OF CHOICE {
                  octets OCTET STRING,
                  oid OBJECT IDENTIFIER,
                  string UTF8String
                }
              }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuerSerial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             IssuerSerial  ::=  Sequence {
                  issuer         GeneralNames,
                  serial         CertificateSerialNumber,
                  issuerUid      UniqueIdentifier OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyPurposeID">
            The KeyPurposeID object.
            <pre>
                KeyPurposeID ::= OBJECT IDENTIFIER
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NameConstraints.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from a given details.
            
             <p>permitted and excluded are Vectors of GeneralSubtree objects.</p>
            
             @param permitted Permitted subtrees
             @param excluded Excluded subtrees
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.NoticeReference">
             <code>NoticeReference</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions
             (in policy qualifiers).
            
             <pre>
              NoticeReference ::= Sequence {
                  organization     DisplayText,
                  noticeNumbers    Sequence OF Integer }
            
             </pre>
            
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,System.Collections.IList)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param orgName a <code>string</code> value
             @param numbers a <code>ArrayList</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param orgName a <code>string</code> value
             @param numbers an <code>Asn1Sequence</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.Int32,System.String,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param displayTextType an <code>int</code> value
             @param orgName a <code>string</code> value
             @param numbers an <code>Asn1Sequence</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
             <p>Useful for reconstructing a <code>NoticeReference</code>
             instance from its encodable/encoded form.</p>
            
             @param as an <code>Asn1Sequence</code> value obtained from either
             calling @{link ToAsn1Object()} for a <code>NoticeReference</code>
             instance or from parsing it from a Der-encoded stream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.ToAsn1Object">
             Describe <code>ToAsn1Object</code> method here.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo">
            ObjectDigestInfo ASN.1 structure used in v2 attribute certificates.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKey">
            The public key is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKeyCert">
            The public key certificate is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.OtherObjectDigest">
            An other object is hashed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.#ctor(System.Int32,System.String,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
            Constructor from given details.
            <p>
            If <code>digestedObjectType</code> is not {@link #publicKeyCert} or
            {@link #publicKey} <code>otherObjectTypeID</code> must be given,
            otherwise it is ignored.</p>
            
            @param digestedObjectType The digest object type.
            @param otherObjectTypeID The object type ID for
                       <code>otherObjectDigest</code>.
            @param digestAlgorithm The algorithm identifier for the hash.
            @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyMappings">
             PolicyMappings V3 extension, described in RFC3280.
             <pre>
                PolicyMappings ::= Sequence SIZE (1..MAX) OF Sequence {
                  issuerDomainPolicy      CertPolicyId,
                  subjectDomainPolicy     CertPolicyId }
             </pre>
            
             @see <a href="http://www.faqs.org/rfc/rfc3280.txt">RFC 3280, section 4.2.1.6</a>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param seq an <code>Asn1Sequence</code> constructed as specified
             in RFC 3280
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(System.Collections.IDictionary)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param mappings a <code>HashMap</code> value that maps
             <code>string</code> oids
             to other <code>string</code> oids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierID">
             PolicyQualifierId, used in the CertificatePolicies
             X509V3 extension.
            
             <pre>
                id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
                id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
                id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
              PolicyQualifierId ::=
                   OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo">
             Policy qualifiers, used in the X509V3 CertificatePolicies
             extension.
            
             <pre>
               PolicyQualifierInfo ::= Sequence {
                   policyQualifierId  PolicyQualifierId,
                   qualifier          ANY DEFINED BY policyQualifierId }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param policyQualifierId a <code>PolicyQualifierId</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(System.String)">
             Creates a new <code>PolicyQualifierInfo</code> containing a
             cPSuri qualifier.
            
             @param cps the CPS (certification practice statement) uri as a
             <code>string</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param as <code>PolicyQualifierInfo</code> X509 structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.ToAsn1Object">
             Returns a Der-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod">
            <remarks>
            <pre>
            PrivateKeyUsagePeriod ::= SEQUENCE
            {
            notBefore       [0]     GeneralizedTime OPTIONAL,
            notAfter        [1]     GeneralizedTime OPTIONAL }
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.BiometricData">
            The BiometricData object.
            <pre>
            BiometricData  ::=  SEQUENCE {
                  typeOfBiometricData  TypeOfBiometricData,
                  hashAlgorithm        AlgorithmIdentifier,
                  biometricDataHash    OCTET STRING,
                  sourceDataUri        IA5String OPTIONAL  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode">
            The Iso4217CurrencyCode object.
            <pre>
            Iso4217CurrencyCode  ::=  CHOICE {
                  alphabetic              PrintableString (SIZE 3), --Recommended
                  numeric              INTEGER (1..999) }
            -- Alphabetic or numeric currency code as defined in ISO 4217
            -- It is recommended that the Alphabetic form is used
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue">
            The MonetaryValue object.
            <pre>
            MonetaryValue  ::=  SEQUENCE {
                  currency              Iso4217CurrencyCode,
                  amount               INTEGER,
                  exponent             INTEGER }
            -- value = amount * 10^exponent
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.QCStatement">
            The QCStatement object.
            <pre>
            QCStatement ::= SEQUENCE {
              statementId        OBJECT IDENTIFIER,
              statementInfo      ANY DEFINED BY statementId OPTIONAL}
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation">
             The SemanticsInformation object.
             <pre>
                   SemanticsInformation ::= SEQUENCE {
                     semanticsIdentifier        OBJECT IDENTIFIER   OPTIONAL,
                     nameRegistrationAuthorities NameRegistrationAuthorities
                                                                     OPTIONAL }
                     (WITH COMPONENTS {..., semanticsIdentifier PRESENT}|
                      WITH COMPONENTS {..., nameRegistrationAuthorities PRESENT})
            
                 NameRegistrationAuthorities ::=  SEQUENCE SIZE (1..MAX) OF
                     GeneralName
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData">
             The TypeOfBiometricData object.
             <pre>
             TypeOfBiometricData ::= CHOICE {
               predefinedBiometricType   PredefinedBiometricType,
               biometricDataOid          OBJECT IDENTIFIER }
            
             PredefinedBiometricType ::= INTEGER {
               picture(0),handwritten-signature(1)}
               (picture|handwritten-signature)
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.RoleSyntax">
             Implementation of the RoleSyntax object as specified by the RFC3281.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetInstance(System.Object)">
            RoleSyntax factory method.
            @param obj the object used to construct an instance of <code>
            RoleSyntax</code>. It must be an instance of <code>RoleSyntax
            </code> or <code>Asn1Sequence</code>.
            @return the instance of <code>RoleSyntax</code> built from the
            supplied object.
            @throws java.lang.ArgumentException if the object passed
            to the factory is not an instance of <code>RoleSyntax</code> or
            <code>Asn1Sequence</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor.
            @param roleAuthority the role authority of this RoleSyntax.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor. Invoking this constructor is the same as invoking
            <code>new RoleSyntax(null, roleName)</code>.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(System.String)">
            Utility constructor. Takes a <code>string</code> argument representing
            the role name, builds a <code>GeneralName</code> to hold the role name
            and calls the constructor that takes a <code>GeneralName</code>.
            @param roleName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor that builds an instance of <code>RoleSyntax</code> by
            extracting the encoded elements from the <code>Asn1Sequence</code>
            object supplied.
            @param seq    an instance of <code>Asn1Sequence</code> that holds
            the encoded elements used to build this <code>RoleSyntax</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleNameAsString">
            Gets the role name as a <code>java.lang.string</code> object.
            @return    the role name of this RoleSyntax represented as a
            <code>string</code> object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleAuthorityAsString">
            Gets the role authority as a <code>string[]</code> object.
            @return the role authority of this RoleSyntax represented as a
            <code>string[]</code> array.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.ToAsn1Object">
             Implementation of the method <code>ToAsn1Object</code> as
             required by the superclass <code>ASN1Encodable</code>.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleAuthority">
            Gets the role authority of this RoleSyntax.
            @return    an instance of <code>GeneralNames</code> holding the
            role authority of this RoleSyntax.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleName">
            Gets the role name of this RoleSyntax.
            @return    an instance of <code>GeneralName</code> holding the
            role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym">
            Structure for a name or pseudonym.
            
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString 
                    },
                	   pseudonym DirectoryString 
                  }
            </pre>
            
            @see org.bouncycastle.asn1.x509.sigi.PersonalData
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
            Constructor from DERString.
            <p/>
            The sequence is of type NameOrPseudonym:
            <p/>
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString
                    },
                	   pseudonym DirectoryString
                  }
            </pre>
            @param pseudonym pseudonym value to use.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(System.String)">
             Constructor from a given details.
            
             @param pseudonym The pseudonym.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from a given details.
            
             @param surname   The surname.
             @param givenName A sequence of directory strings making up the givenName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.PersonalData">
             Contains personal data for the otherName field in the subjectAltNames
             extension.
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.sigi.NameOrPseudonym
             @see org.bouncycastle.asn1.x509.sigi.SigIObjectIdentifiers
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Asn1.DerGeneralizedTime,Org.BouncyCastle.Asn1.X500.DirectoryString,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from a given details.
            
             @param nameOrPseudonym  Name or pseudonym.
             @param nameDistinguisher Name distinguisher.
             @param dateOfBirth      Date of birth.
             @param placeOfBirth     Place of birth.
             @param gender           Gender.
             @param postalAddress    Postal Address.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers">
            Object Identifiers of SigI specifciation (German Signature Law
            Interoperability specification).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKP">
            Key purpose IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICP">
            Certificate policy IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigION">
            Other Name IDs for German SigI (Signature Interoperability Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKPDirectoryService">
            To be used for for the generation of directory service certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIONPersonalData">
            ID for PersonalData
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICPSigConform">
            Certificate is conform to german signature law.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes">
             This extension may contain further X.500 attributes of the subject. See also
             RFC 3039.
            
             <pre>
                 SubjectDirectoryAttributes ::= Attributes
                 Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                 Attribute ::= SEQUENCE
                 {
                   type AttributeType
                   values SET OF AttributeValue
                 }
            
                 AttributeType ::= OBJECT IDENTIFIER
                 AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @see org.bouncycastle.asn1.x509.X509Name for AttributeType ObjectIdentifiers.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             The sequence is of type SubjectDirectoryAttributes:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @param seq
                        The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(System.Collections.IList)">
             Constructor from an ArrayList of attributes.
            
             The ArrayList consists of attributes of type {@link Attribute Attribute}
            
             @param attributes The attributes.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.Attributes">
            @return Returns the attributes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier">
            The SubjectKeyIdentifier object.
            <pre>
            SubjectKeyIdentifier::= OCTET STRING
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
             Calculates the keyIdentifier using a SHA1 hash over the BIT STRING
             from SubjectPublicKeyInfo as defined in RFC3280.
            
             @param spki the subject public key info.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 1 key identifier. As in:
            <pre>
            (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey (excluding the tag,
            length, and number of unused bits).
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateTruncatedSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 2 key identifier. As in:
            <pre>
            (2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the
            SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.GetPublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Target">
            Target structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            <p>
            The targetCert field is currently not supported and must not be used
            according to RFC 3281.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.GetInstance(System.Object)">
            Creates an instance of a Target from the given object.
            <p>
            <code>obj</code> can be a Target or a {@link Asn1TaggedObject}</p>
            
            @param obj The object.
            @return A Target instance.
            @throws ArgumentException if the given object cannot be
                        interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor from Asn1TaggedObject.
            
            @param tagObj The tagged object.
            @throws ArgumentException if the encoding is wrong.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.X509.Target.Choice,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from given details.
             <p>
             Exactly one of the parameters must be not <code>null</code>.</p>
            
             @param type the choice type to apply to the name.
             @param name the general name.
             @throws ArgumentException if type is invalid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetGroup">
            @return Returns the targetGroup.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetName">
            @return Returns the targetName.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TargetInformation">
            Target information extension for attributes certificates according to RFC
            3281.
            
            <pre>
                      SEQUENCE OF Targets
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetInstance(System.Object)">
            Creates an instance of a TargetInformation from the given object.
            <p>
            <code>obj</code> can be a TargetInformation or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A TargetInformation instance.
            @throws ArgumentException if the given object cannot be interpreted as TargetInformation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from a Asn1Sequence.
            
            @param seq The Asn1Sequence.
            @throws ArgumentException if the sequence does not contain
                        correctly encoded Targets elements.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetTargetsObjects">
            Returns the targets in this target information extension.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Targets)">
            Constructs a target information from a single targets element. 
            According to RFC 3281 only one targets element must be produced.
            
            @param targets A Targets instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
             According to RFC 3281 only one targets element must be produced. If
             multiple targets are given they must be merged in
             into one targets element.
            
             @param targets An array with {@link Targets}.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                     SEQUENCE OF Targets
            </pre>
            
            <p>
            According to RFC 3281 only one targets element must be produced. If
            multiple targets are given in the constructor they are merged into one
            targets element. If this was produced from a
            {@link Org.BouncyCastle.Asn1.Asn1Sequence} the encoding is kept.</p>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Targets">
            Targets structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                       Targets ::= SEQUENCE OF Target
                      
                       Target  ::= CHOICE {
                         targetName          [0] GeneralName,
                         targetGroup         [1] GeneralName,
                         targetCert          [2] TargetCert
                       }
                      
                       TargetCert  ::= SEQUENCE {
                         targetCertificate    IssuerSerial,
                         targetName           GeneralName OPTIONAL,
                         certDigestInfo       ObjectDigestInfo OPTIONAL
                       }
            </pre>
            
            @see org.bouncycastle.asn1.x509.Target
            @see org.bouncycastle.asn1.x509.TargetInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetInstance(System.Object)">
            Creates an instance of a Targets from the given object.
            <p>
            <code>obj</code> can be a Targets or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A Targets instance.
            @throws ArgumentException if the given object cannot be interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence.
            
            @param targets The ASN.1 SEQUENCE.
            @throws ArgumentException if the contents of the sequence are
                        invalid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
            Constructor from given targets.
            <p>
            The ArrayList is copied.</p>
            
            @param targets An <code>ArrayList</code> of {@link Target}s.
            @see Target
            @throws ArgumentException if the ArrayList contains not only Targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetTargets">
            Returns the targets in an <code>ArrayList</code>.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                       Targets ::= SEQUENCE OF Target
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.UserNotice">
             <code>UserNotice</code> class, used in
             <code>CertificatePolicies</code> X509 extensions (in policy
             qualifiers).
             <pre>
             UserNotice ::= Sequence {
                  noticeRef        NoticeReference OPTIONAL,
                  explicitText     DisplayText OPTIONAL}
            
             </pre>
            
             @see PolicyQualifierId
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,Org.BouncyCastle.Asn1.X509.DisplayText)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param explicitText a <code>DisplayText</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,System.String)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param str the explicitText field as a string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>UserNotice</code> instance.
             <p>Useful from reconstructing a <code>UserNotice</code> instance
             from its encodable/encoded form.
            
             @param as an <code>ASN1Sequence</code> value obtained from either
             calling @{link toASN1Object()} for a <code>UserNotice</code>
             instance or from parsing it from a DER-encoded stream.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator">
             Generator for Version 1 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator">
             Generator for Version 2 AttributeCertificateInfo
             <pre>
             AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
             }
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator.AddAttribute(Org.BouncyCastle.Asn1.X509.AttributeX509)">
            @param attribute
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2Form.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             V2Form ::= Sequence {
                  issuerName            GeneralNames  OPTIONAL,
                  baseCertificateID     [0] IssuerSerial  OPTIONAL,
                  objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
                    -- issuerName MUST be present in this profile
                    -- baseCertificateID and objectDigestInfo MUST NOT
                    -- be present in this profile
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator">
             Generator for Version 2 TbsCertList structures.
             <pre>
              TbsCertList  ::=  Sequence  {
                   version                 Version OPTIONAL,
                                                -- if present, shall be v2
                   signature               AlgorithmIdentifier,
                   issuer                  Name,
                   thisUpdate              Time,
                   nextUpdate              Time OPTIONAL,
                   revokedCertificates     Sequence OF Sequence  {
                        userCertificate         CertificateSerialNumber,
                        revocationDate          Time,
                        crlEntryExtensions      Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }  OPTIONAL,
                   crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }
             </pre>
            
             <b>Note: This class may be subject to change</b>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator">
             Generator for Version 3 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  extensions        [ 3 ] Extensions OPTIONAL
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * public class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IDictionary)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Hashtable)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.ArrayList,System.Collections.Hashtable)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.ArrayList,System.Collections.ArrayList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator">
            <remarks>Generator for X.509 extensions</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension with the given oid and the passed in value to be included
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The ASN.1 object to be included in the extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension with the given oid and the passed in byte array to be wrapped
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The byte array to be wrapped.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Generate">
            <summary>Generate an X509Extensions object based on the current state of the generator.</summary>
            <returns>An <c>X509Extensions</c> object</returns>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.IsEmpty">
            <summary>Return true if there are no extension present in this generator.</summary>
            <returns>True if empty, false otherwise</returns>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC2253Symbols">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC1779Symbols">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookup">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList)">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOids">
            return an ArrayList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValues">
            return an ArrayList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValues(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an ArrayList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.IDictionary)">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.KeySpecificInfo">
            ASN.1 def for Diffie-Hellman key exchange KeySpecificInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.KeySpecificInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             KeySpecificInfo ::= Sequence {
                 algorithm OBJECT IDENTIFIER,
                 counter OCTET STRING SIZE (4..4)
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.OtherInfo">
            ANS.1 def for Diffie-Hellman key exchange OtherInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.OtherInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             OtherInfo ::= Sequence {
                 keyInfo KeySpecificInfo,
                 partyAInfo [0] OCTET STRING OPTIONAL,
                 suppPubInfo [2] OCTET STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            table of the current named curves defined in X.962 EC-DSA.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredInputStream">
            reader for Base64 armored objects - read the headers and then start returning
            bytes when the data is reached. An IOException is thrown if the CRC check
            fails.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.Decode(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
             decode the base 64 encoded input data.
            
             @return the offset the data starts in out.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream)">
             Create a stream for reading a PGP armoured message, parsing up to a header
             and then reading the data that follows.
            
             @param input
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream,System.Boolean)">
             Create an armoured input stream which will assume the data starts
             straight away, or parse for headers first depending on the value of
             hasHeaders.
            
             @param input
             @param hasHeaders true if headers are to be looked for, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsClearText">
            @return true if we are inside the clear text section of a PGP
            signed message.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsEndOfStream">
            @return true if the stream is actually at end of file.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaderLine">
            Return the armor header line (if there is one)
            @return the armor header line, null if none present.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaders">
            Return the armor headers (the lines after the armor header line),
            @return an array of armor headers, null if there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredOutputStream">
            Basic output stream.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Encode(System.IO.Stream,System.Int32[],System.Int32)">
            encode the input data producing a base 64 encoded byte array.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.SetHeader(System.String,System.String)">
             Set an additional header entry.
            
             @param name the name of the header entry.
             @param v the value of the header entry.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.ResetHeaders">
            Reset the headers to only contain a Version string.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.BeginClearText(Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            Start a clear text signed message.
            @param hashAlgorithm
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Close">
            <b>Note</b>: close does nor close the underlying stream. So it is possible to write
            multiple objects using armoring to a single stream.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Attr.ImageAttrib">
            <remarks>Basic type for a image attribute packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacket">
            Basic type for a user attribute sub-packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.UserAttributeSubpacket.GetData">
            return the generic data making up the packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream">
            <remarks>Reader for PGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgInputStream.NextPacketTag">
            <summary>Returns the next packet tag in the stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream.PartialInputStream">
            <summary>
            A stream that overlays our input stream, allowing the user to only read a segment of it.
            NB: dataLength will be negative if the segment length is in the upper range above 2**31.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgObject">
            <remarks>Base class for a PGP object.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgOutputStream">
            <remarks>Basic output stream.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag)">
            <summary>Create a stream representing an old style partial object.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">The packet tag for the object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64,System.Boolean)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
            <param name="oldFormat">If true, the header is written out in old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64)">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Byte[])">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="buffer">Buffer to use for collecting chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Flush">
            <summary>Flush the underlying stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Finish">
            <summary>Finish writing out the current packet without closing the underlying stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressedDataPacket">
            <remarks>Generic compressed data object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.InputStreamPacket.GetInputStream">
            <summary>Note: you can only read from this once...</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.CompressedDataPacket.Algorithm">
            <summary>The algorithm tag value.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressionAlgorithmTag">
            <remarks>Basic tags for compression algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ContainedPacket">
            <remarks>Basic type for a PGP packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey">
            <remarks>Base class for a DSA public key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.IBcpgKey">
            <remarks>Base interface for a PGP key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.IBcpgKey.Format">
            <summary>
            The base format for this key - in the case of the symmetric keys it will generally
            be raw indicating that the key is just a straight byte representation, for an asymmetric
            key the format will be PGP, indicating the key is a string of MPIs encoded in PGP format.
            </summary>
            <returns>"RAW" or "PGP".</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey">
            <remarks>Base class for a DSA secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.X">
            @return x
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey">
            <remarks>Base class for an ElGamal public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey">
            <remarks>Base class for an ElGamal secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger)">
            @param x
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ExperimentalPacket">
            <remarks>Basic packet for an experimental packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.HashAlgorithmTag">
            <remarks>Basic tags for hash algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.LiteralDataPacket">
            <remarks>Generic literal data packet.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.Format">
            <summary>The format tag value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.ModificationTime">
            <summary>The modification time of the file in milli-seconds (since Jan 1, 1970 UTC)</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MarkerPacket">
            <remarks>Basic type for a marker packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ModDetectionCodePacket">
            <remarks>Basic packet for a modification detection code packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MPInteger">
            <remarks>A multiple precision integer</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OnePassSignaturePacket">
            <remarks>Generic signature object</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.KeyAlgorithm">
            <summary>The encryption algorithm tag.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.HashAlgorithm">
            <summary>The hash algorithm tag.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PacketTag">
            <remarks>Basic PGP packet tag types.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag">
            <remarks>Public Key Algorithm tag numbers.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicKeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public key packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicSubkeyPacket">
            <remarks>Basic packet for a PGP public subkey</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicSubkeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public subkey packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey">
            <remarks>Base class for an RSA public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <summary>Construct an RSA public key from the passed in stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <param name="n">The modulus.</param>
            <param name="e">The public exponent.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey">
            <remarks>Base class for an RSA secret (or priate) key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.S2k">
            <remarks>The string to key specifier class.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.S2k.GetIV">
            <summary>The IV for the key generation algorithm.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.HashAlgorithm">
            <summary>The hash algorithm.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.IterationCount">
            <summary>The iteration count</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.ProtectionMode">
            <summary>The protection mode - only if GnuDummyS2K</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretKeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretSubkeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignaturePacket">
            <remarks>Generic signature packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,Org.BouncyCastle.Bcpg.SignatureSubpacket[],Org.BouncyCastle.Bcpg.SignatureSubpacket[],System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 4 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param hashedData
             @param unhashedData
             @param fingerprint
             @param signature
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Int64,System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 2/3 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param fingerprint
             @param signature
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureTrailer">
             return the signature trailer that must be included with the data
             to reconstruct the signature
            
             @return byte[]
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignature">
            		* return the signature as a set of integers - note this is normalised to be the
                    * ASN.1 encoding of what appears in the signature packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureBytes">
            Return the byte encoding of the signature section.
            @return uninterpreted signature bytes.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.KeyId">
            return the keyId
            @return the keyId that created the signature.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.CreationTime">
            <summary>Return the creation time in milliseconds since 1 Jan., 1970 UTC.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacket">
            <remarks>Basic type for a PGP Signature sub-packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignatureSubpacket.GetData">
            <summary>Return the generic data making up the packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketsParser">
            reader for signature sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketTag">
            Basic PGP signature sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature">
            Packet embedded signature
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Exportable">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.IssuerKeyId">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime">
            packet giving time after creation at which the key expires.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime.Time">
             Return the number of seconds after creation time a key is valid for.
            
             @return second count for key validity.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyFlags">
            Packet holding the key flag values.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyFlags.Flags">
            <summary>
            Return the flag values contained in the first 4 octets (note: at the moment
            the standard only uses the first one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.NotationData">
            Class provided a NotationData object according to
            RFC2440, Chapter 5.2.3.15. Notation Data
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PrimaryUserId">
            packet giving whether or not the signature is signed using the primary user ID for the key.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Revocable">
            packet giving whether or not is revocable.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime">
            packet giving signature expiration time.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime.Time">
            return time in seconds before signature expires after creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignerUserId">
            packet giving the User ID of the signer.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.TrustSignature">
            packet giving trust.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricEncDataPacket">
            <remarks>Basic type for a symmetric key encrypted packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag">
            Basic tags for symmetric key algorithms
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket">
            Basic type for a symmetric encrypted session key packet
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.GetSecKeyData">
            @return byte[]
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.EncAlgorithm">
            @return int
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.S2k">
            @return S2k
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.Version">
            @return int
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.TrustPacket">
            <summary>Basic type for a trust packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributePacket">
            Basic type for a user attribute packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser">
            reader for user attribute sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag">
            Basic PGP user attribute sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserIdPacket">
            Basic type for a user ID packet.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAttributeTableParameter">
            <remarks>
            The 'Signature' parameter is only available when generating unsigned attributes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedData">
            containing class for an CMS Authenticated Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetAuthAttrs">
            return a table of the digested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetUnauthAttrs">
            return a table of the undigested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedData.MacAlgOid">
            return the object identifier for the content MAC algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator">
             General class for generating a CMS authenticated-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSAuthenticatedDataGenerator  fact = new CMSAuthenticatedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSAuthenticatedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedGenerator">
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSEnvelopedDataGenerator  fact = new CMSEnvelopedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSEnvelopedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.X509.X509Certificate)">
             add a recipient.
            
             @param cert recipient's public key certificate
             @exception ArgumentException if there is a problem with the certificate
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
             add a recipient
            
             @param key the public key used by the recipient
             @param subKeyId the identifier for the recipient's public key
             @exception ArgumentException if there is a problem with the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Byte[])">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Asn1.Cms.KekIdentifier)">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipient(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
             Add a key agreement based recipient.
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCert recipient's public key certificate.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipients(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.ICollection,System.String)">
             Add multiple key agreement based recipients (sharing a single KeyAgreeRecipientInfo structure).
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCerts recipients' public key certificates.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
             constructor allowing specific source of randomness
            
             @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            constructor allowing specific source of randomness
            @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            generate an authenticated object that contains an CMS Authenticated Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser">
             Parsing class for an CMS Authenticated Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CMSAuthenticatedDataParser     ad = new CMSAuthenticatedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ad.getRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey, "BC");
            
                      processDataStream(recData.getContentStream());
            
                      if (!Arrays.equals(ad.getMac(), recipient.getMac())
                      {
                          System.err.println("Data corrupted!!!!");
                      }
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CMSAuthenticatedDataParser     ep = new CMSAuthenticatedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsContentInfoParser.Close">
            Close the underlying data stream.
            @throws IOException if the close fails.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetAuthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetUnauthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgOid">
            return the object identifier for the mac algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator">
             General class for generating a CMS authenticated-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CMSAuthenticatedDataStreamGenerator edGen = new CMSAuthenticatedDataStreamGenerator();
            
                  edGen.addKeyTransRecipient(cert);
            
                  ByteArrayOutputStream  bOut = new ByteArrayOutputStream();
            
                  OutputStream out = edGen.open(
                                          bOut, CMSAuthenticatedDataGenerator.AES128_CBC, "BC");*
                  out.write(data);
            
                  out.close();
             </pre>
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            constructor allowing specific source of randomness
            @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            Use a BER Set to store the recipient information
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
            @throws java.io.IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthEnvelopedData">
            containing class for an CMS AuthEnveloped Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedData">
            containing class for an CMS Compressed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetContent">
             Return the uncompressed content.
            
             @return the uncompressed content
             @throws CmsException if there is an exception uncompressing the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetContent(System.Int32)">
             Return the uncompressed content, throwing an exception if the data size
             is greater than the passed in limit. If the content is exceeded getCause()
             on the CMSException will contain a StreamOverflowException
            
             @param limit maximum number of bytes to read
             @return the content read
             @throws CMSException if there is an exception uncompressing the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsCompressedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataGenerator">
                * General class for generating a compressed CMS message.
                * <p>
                * A simple example of usage.</p>
                * <p>
                * <pre>
                *      CMSCompressedDataGenerator fact = new CMSCompressedDataGenerator();
                *      CMSCompressedData data = fact.Generate(content, algorithm);
                * </pre>
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            Generate an object that contains an CMS Compressed Data
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataParser">
             Class for reading a CMS Compressed Data stream.
             <pre>
                 CMSCompressedDataParser cp = new CMSCompressedDataParser(inputStream);
            
                 process(cp.GetContent().GetContentStream());
             </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                  CMSCompressedDataParser     ep = new CMSCompressedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator">
             General class for generating a compressed CMS message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  CMSCompressedDataStreamGenerator gen = new CMSCompressedDataStreamGenerator();
            
                  Stream cOut = gen.Open(outputStream, CMSCompressedDataStreamGenerator.ZLIB);
            
                  cOut.Write(data);
            
                  cOut.Close();
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedData">
            containing class for an CMS Enveloped Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedData.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator">
             <remarks>
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CmsEnvelopedDataGenerator  fact = new CmsEnvelopedDataGenerator();
            
                  fact.AddKeyTransRecipient(cert);
            
                  CmsEnvelopedData         data = fact.Generate(content, algorithm);
             </pre>
             </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains a CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,System.Int32)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataParser">
             Parsing class for an CMS Enveloped Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ep.GetRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey);
            
                      processDataStream(recData.getContentStream());
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator">
             General class for generating a CMS enveloped-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CmsEnvelopedDataStreamGenerator edGen = new CmsEnvelopedDataStreamGenerator();
            
                  edGen.AddKeyTransRecipient(cert);
            
                  MemoryStream  bOut = new MemoryStream();
            
                  Stream out = edGen.Open(
                                          bOut, CMSEnvelopedDataGenerator.AES128_CBC);*
                  out.Write(data);
            
                  out.Close();
             </pre>
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBufferSize(System.Int32)">
            <summary>Set the underlying string size for encapsulated data.</summary>
            <param name="bufferSize">Length of octet strings to buffer the data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            <summary>Use a BER Set to store the recipient information.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains an CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessable.Write(System.IO.Stream)">
            <summary>
            Generic routine to copy out the data we want processed.
            </summary>
            <remarks>
            This routine may be called multiple times.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsProcessableByteArray">
            a holding class for a byte array of data to be processed.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessableByteArray.GetContent">
            <returns>A clone of the byte array</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsProcessableFile">
            a holding class for a file of data to be processed.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessableFile.GetContent">
            <returns>The file handle</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedData">
             general class for handling a pkcs7-signature message.
            
             A simple example of usage - note, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer...
            
             <pre>
              IX509Store              certs = s.GetCertificates();
              SignerInformationStore  signers = s.GetSignerInfos();
            
              foreach (SignerInformation signer in signers.GetSigners())
              {
                  ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                  X509Certificate cert = (X509Certificate) certList[0];
            
                  if (signer.Verify(cert.GetPublicKey()))
                  {
                      verified++;
                  }
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Collections.IDictionary,System.Byte[])">
             Content with detached signature, digests precomputed
            
             @param hashes a map of precomputed digests for content indexed by name of hash.
             @param sigBlock the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Cms.CmsProcessable,System.IO.Stream)">
             base constructor - content with detached signature.
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetAttributeCertificates(System.String)">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCertificates(System.String)">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCrls(System.String)">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceSigners(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.Cms.SignerInformationStore)">
             Replace the signerinformation store associated with this
             CmsSignedData object with the new one passed in. You would
             probably only want to do this if you wanted to change the unsigned
             attributes associated with a signer, or perhaps delete one.
            
             @param signedData the signed data object to be used as a base.
             @param signerInformationStore the new signer information store to use.
             @return a new signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceCertificatesAndCrls(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store)">
             Replace the certificate and CRL information associated with this
             CmsSignedData object with the new one passed in.
            
             @param signedData the signed data object to be used as a base.
             @param x509Certs the new certificates to be used.
             @param x509Crls the new CRLs to be used.
             @return a new signed data object.
             @exception CmsException if there is an error processing the stores
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.Version">
            <summary>Return the version number for this object.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.ContentInfo">
            return the ContentInfo
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataGenerator">
                 * general class for generating a pkcs7-signature message.
                 * <p>
                 * A simple example of usage.
                 *
                 * <pre>
                 *      IX509Store certs...
                 *      IX509Store crls...
                 *      CmsSignedDataGenerator gen = new CmsSignedDataGenerator();
                 *
                 *      gen.AddSigner(privKey, cert, CmsSignedGenerator.DigestSha1);
                 *      gen.AddCertificates(certs);
                 *      gen.AddCrls(crls);
                 *
                 *      CmsSignedData data = gen.Generate(content);
                 * </pre>
            	 * </p>
        </member>
        <member name="F:Org.BouncyCastle.Cms.CmsSignedGenerator.Data">
            Default type for the signed data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddAttributeCertificates(Org.BouncyCastle.X509.Store.IX509Store)">
             Add the attribute certificates contained in the passed in store to the
             generator.
            
             @param store a store of Version 2 attribute certificates
             @throws CmsException if an error occurse processing the store.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddSigners(Org.BouncyCastle.Cms.SignerInformationStore)">
             Add a store of precalculated signers to the generator.
            
             @param signerStore store of signers
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.GetGeneratedDigests">
             Return a map of oids and byte arrays representing the digests calculated on the content during
             the last generate.
            
             @return a map of oids (as String objects) and byte[] representing digests.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
                    * add a signer - no attributes other than the default ones will be
                    * provided here.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
             add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
             provided here.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
                    * add a signer with extra signed/unsigned attributes.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
            		* @param signedAttr table of attributes to be included in signature
            		* @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            	     * add a signer with extra signed/unsigned attributes.
            		 *
            		 * @param key signing key to use
            		 * @param subjectKeyID subjectKeyID of corresponding public key
            		 * @param digestOID digest algorithm OID
            		 * @param signedAttr table of attributes to be included in signature
            		 * @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param subjectKeyID subjectKeyID of corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, including digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(System.String,Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object  - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.GenerateCounterSigners(Org.BouncyCastle.Cms.SignerInformation)">
             generate a set of one or more SignerInformation objects representing counter signatures on
             the passed in SignerInformation object.
            
             @param signer the signer to be countersigned
             @param sigProvider the provider to be used for counter signing.
             @return a store containing the signers.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataParser">
             Parsing class for an CMS Signed Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one signer can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             A simple example of usage for an encapsulated signature.
             </p>
             <p>
             Two notes: first, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer, and, second, because we are in a streaming
             mode the order of the operations is important.
             </p>
             <pre>
                  CmsSignedDataParser     sp = new CmsSignedDataParser(encapSigData);
            
                  sp.GetSignedContent().Drain();
            
                  IX509Store              certs = sp.GetCertificates();
                  SignerInformationStore  signers = sp.GetSignerInfos();
            
                  foreach (SignerInformation signer in signers.GetSigners())
                  {
                      ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                      X509Certificate cert = (X509Certificate) certList[0];
            
                      Console.WriteLine("verify returns: " + signer.Verify(cert));
                  }
             </pre>
              Note also: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsSignedDataParser     ep = new CmsSignedDataParser(new BufferedInputStream(encapSigData, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(Org.BouncyCastle.Cms.CmsTypedStream,System.IO.Stream)">
             base constructor
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
            @throws CmsException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetAttributeCertificates(System.String)">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception org.bouncycastle.x509.NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCertificates(System.String)">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCrls(System.String)">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceSigners(System.IO.Stream,Org.BouncyCastle.Cms.SignerInformationStore,System.IO.Stream)">
            Replace the signerinformation store associated with the passed
            in message contained in the stream original with the new one passed in.
            You would probably only want to do this if you wanted to change the unsigned
            attributes associated with a signer, or perhaps delete one.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param signerInformationStore the new signer information store to use.
            @param out the stream to Write the new signed data object to.
            @return out.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceCertificatesAndCrls(System.IO.Stream,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,System.IO.Stream)">
            Replace the certificate and CRL information associated with this
            CMSSignedData object with the new one passed in.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param certsAndCrls the new certificates and CRLs to be used.
            @param out the stream to Write the new signed data object to.
            @return out.
            @exception CmsException if there is an error processing the CertStore
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.Version">
             Return the version number for the SignedData object
            
             @return the version number
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator">
             General class for generating a pkcs7-signature message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  IX509Store                   certs...
                  CmsSignedDataStreamGenerator gen = new CmsSignedDataStreamGenerator();
            
                  gen.AddSigner(privateKey, cert, CmsSignedDataStreamGenerator.DIGEST_SHA1);
            
                  gen.AddCertificates(certs);
            
                  Stream sigOut = gen.Open(bOut);
            
                  sigOut.Write(Encoding.UTF8.GetBytes("Hello World!"));
            
                  sigOut.Close();
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            add a signer, specifying the digest encryption algorithm - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes - specifying digest
            encryption algorithm.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data". If dataOutputStream is non null the data
            being signed will be written to the stream as it is processed.
            @param out stream the CMS object is to be written to.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
            @param out stream the CMS object is to be written to.
            @param signedContentType OID for data to be signed.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetDigestAlgName(System.String)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetEncryptionAlgName(System.String)">
            Return the digest encryption algorithm using one of the standard
            JCA string representations rather than the algorithm identifier (if
            possible).
        </member>
        <member name="T:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator">
            Default signed attributes generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor(Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.createStandardAttributeTable(System.Collections.IDictionary)">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType, signingTime, and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType, signingTime, and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in Hashtable of attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.GetAttributes(System.Collections.IDictionary)">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInfoGenerator.Generate(Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a RecipientInfo object for the given key.
            </summary>
            <param name="contentEncryptionKey">
            A <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/>
            </param>
            <param name="random">
            A <see cref="T:Org.BouncyCastle.Security.SecureRandom"/>
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Asn1.Cms.RecipientInfo"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Cms.KekRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a secret key known to the other side.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetMac">
             Return the MAC calculated for the content stream. Note: this call is only meaningful once all
             the content has been read.
            
             @return  byte array containing the mac.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgOid">
                    * return the object identifier for the key encryption algorithm.
                    * 
            		* @return OID for key encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgParams">
                    * return the ASN.1 encoded key encryption algorithm parameters, or null if
                    * there aren't any.
                    * 
            		* @return ASN.1 encoding of key encryption algorithm parameters.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KekRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using key agreement.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyTransRecipientInformation">
            the KeyTransRecipientInformation class for a recipient who has been sent a secret
            key encrypted using their public key that needs to be used to
            extract the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return it as a byte array.
        </member>
        <member name="T:Org.BouncyCastle.Cms.OriginatorID">
            a basic index for an originator.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertStoreSelector.Policy">
            <summary>
            An <code>ISet</code> of <code>DerObjectIdentifier</code> objects.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.PasswordRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a password.
        </member>
        <member name="M:Org.BouncyCastle.Cms.PasswordRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="P:Org.BouncyCastle.Cms.PasswordRecipientInformation.KeyDerivationAlgorithm">
             return the object identifier for the key derivation algorithm, or null
             if there is none present.
            
             @return OID for key derivation algorithm, if present.
        </member>
        <member name="T:Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey">
            <summary>
            PKCS5 scheme-2 - password converted to bytes assuming ASCII.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey">
            PKCS5 scheme-2 - password converted to bytes using UTF-8.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetFirstRecipient(Org.BouncyCastle.Cms.RecipientID)">
             Return the first RecipientInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a recipient
             @return a single RecipientInformation object. Null if none matches.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients">
             Return all recipients in the collection
            
             @return a collection of recipients.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients(Org.BouncyCastle.Cms.RecipientID)">
             Return possible empty collection with recipients matching the passed in RecipientID
            
             @param selector a recipient id to select against.
             @return a collection of RecipientInformation objects.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformationStore.Count">
             Return the number of recipients in the collection.
            
             @return number of recipients identified.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerID">
            a basic index for a signer.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerInformation">
            an expanded SignerInfo block from a CMS Signed message
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetContentDigest">
            return the content digest that was calculated during verification.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetSignature">
            return the encoded signature
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetCounterSignatures">
            Return a SignerInformationStore containing the counter signatures attached to this
            signer. If no counter signatures are present an empty store is returned.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetEncodedSignedAttributes">
            return the DER encoding of the signed attributes.
            @throws IOException if an encoding error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            verify that the given public key successfully handles and confirms the
            signature associated with this signer.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.X509.X509Certificate)">
            verify that the given certificate successfully handles and confirms
            the signature associated with this signer and, if a signingTime
            attribute is available, that the certificate was valid at the time the
            signature was generated.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ToSignerInfo">
             Return the base ASN.1 CMS structure that this object contains.
            
             @return an object containing a CMS SignerInfo structure.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ReplaceUnsignedAttributes(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Return a signer information object with the passed in unsigned
             attributes replacing the ones that are current associated with
             the object passed in.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param unsignedAttributes the unsigned attributes to add.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.AddCounterSigners(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Cms.SignerInformationStore)">
             Return a signer information object with passed in SignerInformationStore representing counter
             signatures attached as an unsigned attribute.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param counterSigners signer info objects carrying counter signature.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.Version">
            return the version number for this objects underlying SignerInfo structure.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgParams">
            return the signature parameters, or null if there aren't any.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgParams">
            return the signature/encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.SignedAttributes">
            return a table of the signed attributes - indexed by
            the OID of the attribute.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.UnsignedAttributes">
            return a table of the unsigned attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetFirstSigner(Org.BouncyCastle.Cms.SignerID)">
             Return the first SignerInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a signer
             @return a single SignerInformation object. Null if none matches.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners">
            <returns>An ICollection of all signers in the collection</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners(Org.BouncyCastle.Cms.SignerID)">
             Return possible empty collection with signers matching the passed in SignerID
            
             @param selector a signer id to select against.
             @return a collection of SignerInformation objects.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformationStore.Count">
            <summary>The number of signers in the collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.SimpleAttributeTableGenerator">
            Basic generator that just returns a preconstructed attribute table
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHAgreement">
            a Diffie-Hellman key exchange engine.
            <p>
            note: This uses MTI/A0 key agreement in order to make the key agreement
            secure against passive attacks. If you're doing Diffie-Hellman and both
            parties have long term public keys you should look at using this. For
            further information have a look at RFC 2631.</p>
            <p>
            It's possible to extend this to more than two parties as well, for the moment
            that is left as an exercise for the reader.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateMessage">
            calculate our initial message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters,Org.BouncyCastle.Math.BigInteger)">
            given a message from a given party and the corresponding public key
            calculate the next message in the agreement sequence. In this case
            this will represent the shared secret.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement">
            a Diffie-Hellman key agreement class.
            <p>
            note: This is only the basic algorithm, it doesn't take advantage of
            long term public keys if they are available. See the DHAgreement class
            for a "better" implementation.</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a short term public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement">
             P1363 7.2.1 ECSVDP-DH
            
             ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
             and [Kob87]. This primitive derives a shared secret value from one
             party's private key and another party's public key, where both have
             the same set of EC domain parameters. If two parties correctly
             execute this primitive, they will produce the same output. This
             primitive can be invoked by a scheme to derive a shared secret key;
             specifically, it may be used with the schemes ECKAS-DH1 and
             DL/ECKAS-DH2. It assumes that the input keys are valid (see also
             Section 7.2.2).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement">
             P1363 7.2.2 ECSVDP-DHC
            
             ECSVDP-DHC is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version with cofactor multiplication. It is based on
             the work of [DH76], [Mil86], [Kob87], [LMQ98] and [Kal98a]. This
             primitive derives a shared secret value from one party's private key
             and another party's public key, where both have the same set of EC
             domain parameters. If two parties correctly execute this primitive,
             they will produce the same output. This primitive can be invoked by a
             scheme to derive a shared secret key; specifically, it may be used
             with the schemes ECKAS-DH1 and DL/ECKAS-DH2. It does not assume the
             validity of the input public key (see also Section 7.2.1).
             <p>
             Note: As stated P1363 compatibility mode with ECDH can be preset, and
             in this case the implementation doesn't have a ECDH compatibility mode
             (if you want that just use ECDHBasicAgreement and note they both implement
             BasicAgreement!).</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator">
            RFC 2631 Diffie-hellman KEK derivation function.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator">
            X9.63 based key derivation function for ECDH CMS.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client">
            Implements the client side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
            Initialises the client to begin new authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.GenerateClientCredentials(System.Byte[],System.Byte[],System.Byte[])">
            Generates client's credentials given the client's salt, identity and password
            @param salt The salt used in the client's verifier.
            @param identity The user's identity (eg. username)
            @param password The user's password
            @return Client's public value to send to server
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSecret(Org.BouncyCastle.Math.BigInteger)">
            Generates client's verification message given the server's credentials
            @param serverB The server's credentials
            @return Client's verification message for the server
            @throws CryptoException If server's credentials are invalid
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server">
            Implements the server side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
            Initialises the server to accept a new client authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param v The client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.GenerateServerCredentials">
            Generates the server's credentials that are to be sent to the client.
            @return The server's public value to the client
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSecret(Org.BouncyCastle.Math.BigInteger)">
            Processes the client's credentials. If valid the shared secret is generated and returned.
            @param clientA The client's credentials
            @return A shared secret BigInteger
            @throws CryptoException If client's credentials are invalid
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator">
            Generates new SRP verifier for user
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest)">
            Initialises generator to create new verifiers
            @param N The safe prime to use (see DHParametersGenerator)
            @param g The group parameter to use (see DHParametersGenerator)
            @param digest The digest to use. The same digest type will need to be used later for the actual authentication
            attempt. Also note that the final session key size is dependent on the chosen digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.GenerateVerifier(System.Byte[],System.Byte[],System.Byte[])">
            Creates a new SRP verifier
            @param salt The salt to use, generally should be large and random
            @param identity The user's identifying information (eg. username)
            @param password The user's password
            @return A new verifier for use in future SRP authentication
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if neccessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher">
            a buffer wrapper for an asymmetric block cipher, allowing input
            to be accumulated in a piecemeal fashion until final processing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             base constructor.
            
             @param cipher the cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.GetBufferPosition">
             return the amount of data sitting in the buffer.
            
             @return the amount of data sitting in the buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the buffer and the underlying cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.DoFinal">
             process the contents of the buffer using the underlying
             cipher.
            
             @return the result of the encryption/decryption process on the
             buffer.
             @exception InvalidCipherTextException if we are given a garbage block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Reset">
            <summary>Reset the buffer</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if neccessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Gost3411Digest">
            implementation of GOST R 34.11-94
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(System.Byte[])">
            Constructor to allow use of a particular sbox with GOST28147
            @see GOST28147Engine#getSBox(String)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Gost3411Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.C2">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD2Digest">
            implementation of MD2
            as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param out the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param in the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.MD2Digest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD4Digest">
            implementation of MD4 as RFC 1320 by R. Rivest, MIT Laboratory for
            Computer Science and RSA Data Security, Inc.
            <p>
            <b>NOTE</b>: This algorithm is only included for backwards compatibility
            with legacy applications, it's not secure, don't use it for anything new!</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD4Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest">
            implementation of RipeMD128
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD128Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest">
            <remarks>
            <p>Implementation of RipeMD256.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD128.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD256Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest">
            <remarks>
            <p>Implementation of RipeMD 320.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD160.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD320Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.ShortenedDigest">
            Wrapper class that reduces the output length of a particular digest to
            only the first n bytes of the digest function.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.ShortenedDigest.#ctor(Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             Base constructor.
            
             @param baseDigest underlying digest to use.
             @param length length in bytes of the output of doFinal.
             @exception ArgumentException if baseDigest is null, or length is greater than baseDigest.GetDigestSize().
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.TigerDigest">
            implementation of Tiger based on:
            <a href="http://www.cs.technion.ac.il/~biham/Reports/Tiger">
             http://www.cs.technion.ac.il/~biham/Reports/Tiger</a>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor(Org.BouncyCastle.Crypto.Digests.TigerDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest">
             Implementation of WhirlpoolDigest, based on Java source published by Barreto
             and Rijmen.
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.#ctor(Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest)">
            Copy constructor. This will copy the state of the provided message
            digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.Reset">
            Reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding">
            ISO 9796-1 padding. Note in the light of recent results you should
            only use this with RSA (rather than the "simpler" Rabin keys) and you
            should never use it with anything other than a hash (ie. even if the
            message is small don't sign the message, sign it's hash) or some "random"
            value. See your favorite search engine for details.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetInputBlockSize">
            return the input block size. The largest message we can process
            is (key_size_in_bits + 3)/16, which in our world comes to
            key_size_in_bytes / 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetOutputBlockSize">
            return the maximum possible size for the output.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.SetPadBits(System.Int32)">
            set the number of bits in the next message to be treated as
            pad bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetPadBits">
            retrieve the number of pad bits in the last decoded message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not a valid ISO 9796 bit string
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.maskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
            Basic constructor.
            @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesLightEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values
             in each round.
             </p>
             <p>
             This file contains the slowest performance version with no static tables
             for round precomputation, but it has the smallest foot print.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesWrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap Specification.
            <p/>
            For further details see: <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.BlowfishEngine">
            A class that provides Blowfish key encryption operations,
            such as encoding data and generating keys.
            All the algorithms herein are from Applied Cryptography
            and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Blowfish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.ProcessTable(System.UInt32,System.UInt32,System.UInt32[])">
            apply the encryption cycle to each value pair in the table.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Encrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine">
            Camellia - based on RFC 3713, smaller implementation, about half the size of CamelliaEngine.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine">
            <remarks>
            An implementation of the Camellia key wrapper based on RFC 3657/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3657.txt">http://www.ietf.org/rfc/rfc3657.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast5Engine">
             A class that provides CAST key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC's
            
             RFC2144 - Cast5 (64bit block, 40-128bit key)
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a CAST cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F1(System.UInt32,System.UInt32,System.Int32)">
             The first of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F2(System.UInt32,System.UInt32,System.Int32)">
             The second of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F3(System.UInt32,System.UInt32,System.Int32)">
             The third of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32[])">
             Does the 16 rounds to encrypt the block.
            
             @param L0    the LH-32bits of the plaintext block
             @param R0    the RH-32bits of the plaintext block
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast6Engine">
             A class that provides CAST6 key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC
            
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to encrypt the block.
            
             @param A    the 00-31  bits of the plaintext block
             @param B    the 32-63  bits of the plaintext block
             @param C    the 64-95  bits of the plaintext block
             @param D    the 96-127 bits of the plaintext block
             @param result the resulting ciphertext
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Decipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to decrypt the block.
            
             @param A    the 00-31  bits of the ciphertext block
             @param B    the 32-63  bits of the ciphertext block
             @param C    the 64-95  bits of the ciphertext block
             @param D    the 96-127 bits of the ciphertext block
             @param result the resulting plaintext
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.DesFunc(System.Int32[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            the DES engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine">
                * Wrap keys according to
                * <a href="http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt">
                * draft-ietf-smime-key-wrap-01.txt</a>.
                * <p>
                * Note:
                * <ul>
                * <li>this is based on a draft, and as such is subject to change - don't use this class for anything requiring long term storage.</li>
                * <li>if you are using this to wrap triple-des keys you need to set the
                * parity bits on the key and, if it's a two-key triple-des key, pad it
                * yourself.</li>
                * </ul>
            	* </p>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.param">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Gost28147Engine">
            implementation of GOST 28147-89
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an Gost28147 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.GetSBox(System.String)">
            Return the S-Box associated with SBoxName
            @param sBoxName name of the S-Box
            @return byte array representing the S-Box
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC128Engine">
             HC-128 is a software-efficient stream cipher created by Hongjun Wu. It
             generates keystream from a 128-bit secret key and a 128-bit initialization
             vector.
             <p>
             http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf
             </p><p>
             It is a third phase candidate in the eStream contest, and is patent-free.
             No attacks are known as of today (April 2007). See
            
             http://www.ecrypt.eu.org/stream/hcp3.html
             </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <c>input</c> putting the result into <c>output</c>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC128Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-128 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 128 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC256Engine">
            HC-256 is a software-efficient stream cipher created by Hongjun Wu. It 
            generates keystream from a 256-bit secret key and a 256-bit initialization 
            vector.
            <p>
            http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc256_p3.pdf
            </p><p>
            Its brother, HC-128, is a third phase candidate in the eStream contest.
            The algorithm is patent-free. No attacks are known as of today (April 2007). 
            See
            
            http://www.ecrypt.eu.org/stream/hcp3.html
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC256Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-256 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 256 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IesEngine">
            support class for constructing intergrated encryption ciphers
            for doing basic message exchanges on top of key agreement ciphers
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac)">
             set up for use with stream mode, where the key derivation function
             is used to provide a stream of bytes to xor with the message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac,Org.BouncyCastle.Crypto.BufferedBlockCipher)">
             set up for use in conjunction with a block cipher to handle the
             message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
             @param cipher the cipher to used for encrypting the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the encryptor.
            
             @param forEncryption whether or not this is encryption/decryption.
             @param privParam our private key parameters
             @param pubParam the recipient's/sender's public key parameters
             @param param encoding and derivation parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IsaacEngine">
            Implementation of Bob Jenkin's ISAAC (Indirection Shift Accumulate Add and Count).
            see: http://www.burtleburtle.net/bob/rand/isaacafa.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IsaacEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an ISAAC cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine">
            NaccacheStern Engine. For details on this cipher, please see
            http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initializes this algorithm. Must be called before all other Functions.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#init(bool,
                  org.bouncycastle.crypto.CipherParameters)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetInputBlockSize">
             Returns the input block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetInputBlockSize()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetOutputBlockSize">
             Returns the output block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetOutputBlockSize()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single Block using the Naccache-Stern algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#ProcessBlock(byte[],
                  int, int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Encrypt(Org.BouncyCastle.Math.BigInteger)">
             Encrypts a BigInteger aka Plaintext with the public key.
            
             @param plain
                        The BigInteger to encrypt
             @return The byte[] representation of the encrypted BigInteger (i.e.
                     crypted.toByteArray())
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.AddCryptedBlocks(System.Byte[],System.Byte[])">
             Adds the contents of two encrypted blocks mod sigma
            
             @param block1
                        the first encrypted block
             @param block2
                        the second encrypted block
             @return encrypt((block1 + block2) mod sigma)
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessData(System.Byte[])">
             Convenience Method for data exchange with the cipher.
            
             Determines blocksize and splits data to blocksize.
            
             @param data the data to be processed
             @return the data after it went through the NaccacheSternEngine.
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.chineseRemainder(System.Collections.IList,System.Collections.IList)">
             Computes the integer x that is expressed through the given primes and the
             congruences with the chinese remainder theorem (CRT).
            
             @param congruences
                        the congruences c_i
             @param primes
                        the primes p_i
             @return an integer x for that x % p_i == c_i
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NoekeonEngine">
            A Noekeon engine, using direct-key mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.#ctor">
            Create an instance of the Noekeon encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NullEngine">
            The no-op engine that just copies bytes through, irrespective of whether encrypting and decrypting.
            Provided for the sake of completeness.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2Engine">
            an implementation of RC2 as described in RFC 2268
                 "A Description of the RC2(r) Encryption Algorithm" R. Rivest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC2 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.RotateWordLeft(System.Int32,System.Int32)">
            return the result rotating the 16 bit number in x left by y
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine">
            Wrap keys according to RFC 3217 - RC2 mechanism
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.parameters">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC4Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC532Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation has a word size of 32 bits.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in     in byte buffer containing data to encrypt
             @param  inOff  offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC564Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation is set to work with a 64 bit word size.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-64 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in      in byte buffer containing data to encrypt
             @param  inOff   offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateLeft(System.Int64,System.Int64)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateRight(System.Int64,System.Int64)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC6Engine">
            An RC6 engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.#ctor">
            Create an instance of the RC6 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param inKey the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine">
            an implementation of the RFC 3211 Key Wrap
            Specification.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine">
            This does your basic RSA Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475. You need to use this if you are
            trying to get another party to generate signatures without them being aware
            of the message they are signing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the blinding engine.
            
             @param forEncryption true if we are encrypting (blinding), false otherwise.
             @param param         the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the RSA blinding algorithm.
            
             @param in    the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @throws DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Salsa20Engine">
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Salsa20 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedWrapEngine">
            <remarks>
            An implementation of the SEED key wrapper based on RFC 4010/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc4010.txt">http://www.ietf.org/rfc/rfc4010.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SerpentEngine">
                * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                * including 128, 192 and 256 bit keys conjectured to be at least as
                * secure as three-key triple-DES.
                * <p>
                * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                * candidate algorithm for the NIST AES Quest.>
            	* </p>
                * <p>
                * For full details see the <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt one block of plaintext.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt one block of ciphertext.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb0(System.Int32,System.Int32,System.Int32,System.Int32)">
            S0 - { 3, 8,15, 1,10, 6, 5,11,14,13, 4, 2, 7, 0, 9,12 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SkipjackEngine">
            a class that provides a basic SKIPJACK engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a SKIPJACK cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.G(System.Int32,System.Int32)">
            The G permutation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.H(System.Int32,System.Int32)">
            the inverse of the G permutation.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TeaEngine">
            An TEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TwofishEngine">
             A class that provides Twofish encryption operations.
            
             This Java implementation is based on the Java reference
             implementation provided by Bruce Schneier and developed
             by Raif S. Naffah.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.P_00">
            Define the fixed p0/p1 permutations used in keyed S-box lookup.
            By changing the following constant definitions, the S-boxes will
            automatically Get changed in the Twofish engine.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.gSubKeys">
            gSubKeys[] and gSBox[] are eventually used in the
            encryption and decryption methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Twofish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
             The input will be an exact multiple of our blocksize.
            
             encryptBlock uses the pre-calculated gSBox[] and subKey[]
             arrays.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_MDS_Encode(System.Int32,System.Int32)">
             Use (12, 8) Reed-Solomon code over GF(256) to produce
             a key S-box 32-bit entity from 2 key material 32-bit
             entities.
            
             @param    k0 first 32-bit entity
             @param    k1 second 32-bit entity
             @return     Remainder polynomial Generated using RS code
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_rem(System.Int32)">
                    * Reed-Solomon code parameters: (12,8) reversible code:
            		* <p>
                    * <pre>
                    * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
                    * </pre>
                    * where a = primitive root of field generator 0x14D
            		* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.VmpcEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise a VMPC cipher.
            
            @param forEncryption
               whether or not we are for encryption.
            @param params
               the parameters required to set up the cipher.
            @exception ArgumentException
               if the params argument is inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.XteaEngine">
            An XTEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator">
            Basic KDF generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on ISO 18033/P1363a.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.#ctor(System.Int32,Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF Parameters generator.
            
             @param counterStart value of counter.
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws ArgumentException if the size of the request will cause an overflow.
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesKeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key generated will be 64 bits in size, otherwise
             strength can be 64 or 56 bits (if you don't count the parity bits).
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key Generated will be 192 bits in size, otherwise
             strength can be 128 or 192 (or 112 or 168 if you don't count
             parity bits), depending on whether you wish to do 2-key or 3-key
             triple DES.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator">
             a basic Diffie-Hellman key pair generator.
            
             This generates keys consistent for use with the basic algorithm for
             Diffie-Hellman.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DHParametersGenerator.GenerateParameters">
            which Generates the p and g values from the given parameters,
            returning the DHParameters object.
            <p>
            Note: can take a while...</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator">
                 * a DSA key pair generator.
                 *
                 * This Generates DSA keys in line with the method described
            	 * in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator">
            Generate suitable parameters for DSA, in line with FIPS 186-2, or FIPS 186-3.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             initialise the key generator.
            
             @param size size of the key (range 2^512 -> 2^1024 - 64 bit increments)
             @param certainty measure of robustness of prime (for FIPS 186-2 compliance this should be at least 80).
             @param random random byte source.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters)">
             Initialise the key generator for DSA 2.
             <p>
                 Use this init method if you need to generate parameters for DSA 2 keys.
             </p>
            
             @param params  DSA 2 key generation parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters">
            which Generates the p and g values from the given parameters,
            returning the DsaParameters object.
            <p>
            Note: can take a while...</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters_FIPS186_3">
            generate suitable parameters for DSA, in line with
            <i>FIPS 186-3 A.1 Generation of the FFC Primes p and q</i>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine Generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator">
            a ElGamal key pair generator.
            <p>
            This Generates keys consistent for use with ElGamal as described in
            page 164 of "Handbook of Applied Cryptography".</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator.GenerateParameters">
                     * which Generates the p and g values from the given parameters,
                     * returning the ElGamalParameters object.
                     * <p>
                     * Note: can take a while...
            		 * </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator">
            a GOST3410 key pair generator.
            This generates GOST3410 keys in line with the method described
            in GOST R 34.10-94.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator">
            generate suitable parameters for GOST3410.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.Init(System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             initialise the key generator.
            
             @param size size of the key
             @param typeProcedure type procedure A,B = 1;  A',B' - else
             @param random random byte source.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.procedure_C(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Procedure C
            procedure generates the a value from the given p,q,
            returning the a value.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.GenerateParameters">
            which generates the p , q and a values from the given parameters,
            returning the Gost3410Parameters object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator">
            KFD2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF1 byte generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator">
            KDF2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF2 bytes generator. Generates key material
             according to IEEE P1363 or ISO 18033 depending on the initialisation.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator">
            Generator for MGF1 as defined in Pkcs 1v2
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            @param digest the digest to be used as the source of Generated bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes Generated from
             the derivation function.
            
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator">
             Key generation parameters for NaccacheStern cipher. For details on this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.permuteList(System.Collections.IList,Org.BouncyCastle.Security.SecureRandom)">
             Generates a permuted ArrayList from the original one. The original List
             is not modified
            
             @param arr
                        the ArrayList to be permuted
             @param rand
                        the source of Randomness for permutation
             @return a new IList with the permuted elements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.findFirstPrimes(System.Int32)">
             Finds the first 'count' primes starting with 3
            
             @param count
                        the number of primes to find
             @return a vector containing the found primes as Integer
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator">
            Generator for PBE derived keys and ivs as usd by OpenSSL.
            <p>
            The scheme is a simple extension of PKCS 5 V2.0 Scheme 1 using MD5 with an
            iteration count of 1.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetPassword">
             return the password byte array.
            
             @return the password byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetSalt">
             return the salt byte array.
            
             @return the salt byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate derived parameters for a key of length keySize.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate derived parameters for a key of length keySize, and
             an initialisation vector (IV) of length ivSize.
            
             @param keySize the length, in bits, of the key required.
             @param ivSize the length, in bits, of the iv required.
             @return a parameters object representing a key and an IV.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor">
            Construct a OpenSSL Parameters generator. 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.Init(System.Byte[],System.Byte[])">
            Initialise - note the iteration count for this algorithm is fixed at 1.
            
            @param password password to use.
            @param salt salt to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedKey(System.Int32)">
            the derived key function, the ith hash of the password and the salt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
             @exception ArgumentException if keySize + ivSize is larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 12 V1.0.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/index.html">
            RSA's Pkcs12 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 12 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
             @exception ArgumentException if an unknown digest is passed in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.Adjust(System.Byte[],System.Int32,System.Byte[])">
            add a + b + 1, returning the result in a. The a value is treated
            as a BigInteger of length (b.Length * 8) bits. The result is
            modulo 2^b.Length in case of overflow.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedKey(System.Int32,System.Int32)">
            generation of a derived key ala Pkcs12 V1.0.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 1.
            Note this generator is limited to the size of the hash produced by the
            digest used to drive it.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 5 Scheme 1 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedKey">
            the derived key function, the ith hash of the mPassword and the mSalt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the mPassword, mSalt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the mPassword, mSalt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
             @exception ArgumentException if keySize + ivSize is larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the mPassword,
             mSalt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 2.
            This generator uses a SHA-1 HMac as the calculation function.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a></p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.#ctor">
            construct a Pkcs5 Scheme 2 Parameters generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator">
            Generate a random factor suitable for use with RSA blind signatures
            as outlined in Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the factor generator
            
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.GenerateBlindingFactor">
             Generate a suitable blind factor for the public key the generator was initialised with.
            
             @return a random blind factor
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignerWithRecovery">
            Signer with message recovery.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage">
             Returns true if the signer has recovered the full message as
             part of signature verification.
            
             @return true if full message recovered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage">
             Returns a reference to what message was recovered (if any).
            
             @return full/partial message, null if nothing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.UpdateWithRecoveredMessage(System.Byte[])">
             Perform an update with the recovered message before adding any other data. This must
             be the first update method called, and calling it will result in the signer assuming
             that further calls to update will include message content past what is recoverable.
            
             @param signature the signature that we are in the process of verifying.
             @throws IllegalStateException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.KeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding a padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Gost28147Mac">
            implementation of GOST 28147-89 MAC
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac">
             DES based CBC Block Cipher MAC according to ISO9797, algorithm 3 (ANSI X9.19 Retail MAC)
            
             This could as well be derived from CBCBlockCipherMac, but then the property mac in the base
             class must be changed to protected
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation. This must
             be DESEngine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a Retail-MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation. The final block is decrypted and then encrypted using the
            middle and right part of the key.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.MaxBytesExceededException">
            <summary>
            This exception is thrown whenever a cipher requires a change of key, iv
            or similar after x amount of bytes enciphered
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>
            A block cipher mode that includes authenticated encryption with a streaming mode
            and optional associated data.</summary>
            <see cref="T:Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same outLength as the plain text.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher that uses Cipher Text Stealing
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update of 'length' bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of length bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update and doFinal
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if neccessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param length the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never Get thrown).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in
            NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher">
            implements the GOST 28147 OFB counter mode (GCTR).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             counter mode (must have a 64 bit block size).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param encrypting if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/GCTR"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/PGPCFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            A padder that adds ISO10126-2 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PaddingName">
             Return the name of the algorithm the padder implements.
            
             @return the name of the algorithm the padder implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if neccessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary> A padder that adds Trailing-Bit-Compliment padding to a block.
            <p>
            This padding pads the block out compliment of the last bit
            of the plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
            <summary> Initialise the padder.</summary>
            <param name="random">- a SecureRandom if available.
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            <p>
            Note: this assumes that the last block of plain text is always
            passed to it inside in. i.e. if inOff is zero, indicating the
            entire block is to be overwritten with padding the value of in
            should be the same as the last block of plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PaddingName">
            <summary> Return the name of the algorithm the cipher implements.</summary>
            <returns> the name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.X923Padding">
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if one is available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.X923Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding">
            <summary> A padder that adds Null byte padding to a block.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             <summary> Initialise the padder.
            
             </summary>
             <param name="random">- a SecureRandom if available.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PaddingName">
             <summary> Return the name of the algorithm the cipher implements.
            
             </summary>
             <returns> the name of the algorithm the cipher implements.
             </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.CcmParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
            Base constructor.
            
            @param key key to be used by underlying cipher
            @param macSize macSize in bits
            @param nonce nonce to be used
            @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.G">
            return the generator - g
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.L">
            return private value limit - l
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.IesParameters">
            parameters for using an integrated cipher in stream mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
            @param cipherKeySize the size of the associated Cipher key (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.MgfParameters">
            <remarks>Parameters for mask derivation functions.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters">
             Parameters for NaccacheStern public private key generation. For details on
             this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32,System.Int32,System.Int32)">
             Parameters for generating a NaccacheStern KeyPair.
            
             @param random
                        The source of randomness
             @param strength
                        The desired strength of the Key in Bits
             @param certainty
                        the probability that the generated primes are not really prime
                        as integer: 2^(-certainty) is then the probability
             @param countSmallPrimes
                        How many small key factors are desired
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32,System.Int32,System.Int32,System.Boolean)">
             Parameters for a NaccacheStern KeyPair.
            
             @param random
                        The source of randomness
             @param strength
                        The desired strength of the Key in Bits
             @param certainty
                        the probability that the generated primes are not really prime
                        as integer: 2^(-certainty) is then the probability
             @param cntSmallPrimes
                        How many small key factors are desired
             @param debug
                        Turn debugging on or off (reveals secret information, use with
                        caution)
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.Certainty">
            @return Returns the certainty.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.CountSmallPrimes">
            @return Returns the countSmallPrimes.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters">
             Public key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.#ctor(System.Boolean,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32)">
            @param privateKey
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.G">
            @return Returns the g.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.LowerSigmaBound">
            @return Returns the lowerSigmaBound.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.Modulus">
            @return Returns the n.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters">
             Private key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32,System.Collections.IList,Org.BouncyCastle.Math.BigInteger)">
             Constructs a NaccacheSternPrivateKey
            
             @param g
                        the public enryption parameter g
             @param n
                        the public modulus n = p*q
             @param lowerSigmaBound
                        the public lower sigma bound up to which data can be encrypted
             @param smallPrimes
                        the small primes, of which sigma is constructed in the right
                        order
             @param phi_n
                        the private modulus phi(n) = (p-1)(q-1)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt">
            <summary> Cipher parameters with a fixed salt value associated with them.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses Microsoft's RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator">
            <remarks>
            Takes bytes generated by an underling RandomGenerator and reverses the order in
            each small window (of configurable size).
            <p>
            Access to internals is synchronized so a single one of these can be shared.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator">
            A thread based seed generator - one source of randomness.
            <p>
            Based on an idea from Marcus Lippert.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator.GenerateSeed(System.Int32,System.Boolean)">
            Generate seed bytes. Set fast to false for best quality.
            <p>
            If fast is set to true, the code should be round about 8 times faster when
            generating a long sequence of random bytes. 20 bytes of random values using
            the fast mode take less than half a second on a Nokia e70. If fast is set to false,
            it takes round about 2500 ms.
            </p>
            @param numBytes the number of bytes to generate
            @param fast true if fast mode should be used
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.P">
            <remarks>
            Permutation generated by code:
            <code>
            // First 1850 fractional digit of Pi number. 
            byte[] key = new BigInteger("14159265358979323846...5068006422512520511").ToByteArray();
            s = 0;
            P = new byte[256];
            for (int i = 0; i &lt; 256; i++) 
            {
                P[i] = (byte) i;
            }
            for (int m = 0; m &lt; 768; m++) 
            {
                s = P[(s + P[m &amp; 0xff] + key[m % key.length]) &amp; 0xff];
                byte temp = P[m &amp; 0xff];
                P[m &amp; 0xff] = P[s &amp; 0xff];
                P[s &amp; 0xff] = temp;
            } </code>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.s">
            <remarks>Value generated in the same way as <c>P</c>.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer">
            GOST R 34.10-2001 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional GOST3410 the message should be a GOST3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a GOST3410 signature for
            the passed in message (for standard GOST3410 the message should be
            a GOST3411 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECNRSigner">
            EC-NR as described in IEEE 1363-2000
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with.  Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR it *must* be at least as long.
            
             @param digest  the digest to be signed.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             return true if the value r and s represent a signature for the
             message passed in. Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR, it *must* be at least as long.  But just in case the signer
             applied mod(n) to the longer digest, this implementation will
             apply mod(n) during verification.
            
             @param digest  the digest to be verified.
             @param r       the r value of the signature.
             @param s       the s value of the signature.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signing or verification.
            
             @param forSigning
                        true if for signing, false otherwise
             @param parameters
                        necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using the key
            we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described in
            the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Gost3410Signer">
            Gost R 34.10-94 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional Gost3410 the message should be a Gost3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a Gost3410 signature for
            the passed in message for standard Gost3410 the message should be a
            Gost3411 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 2 and 3).
            <p>
            Note: the usual length for the salt is the length of the hash
            function used in bytes.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Boolean)">
            <summary>
            Generate a signer for the with either implicit or explicit trailers
            for ISO9796-2, scheme 2 or 3.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="saltLength">length of salt in bytes.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
             <param name="saltLength">length of salt in bytes.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer.</summary>
            <param name="forSigning">true if for signing, false if for verification.</param>
            <param name="parameters">parameters for signature generation/verification. If the
            parameters are for generation they should be a ParametersWithRandom,
            a ParametersWithSalt, or just an RsaKeyParameters object. If RsaKeyParameters
            are passed in a SecureRandom will be created.
            </param>
            <exception cref="T:System.ArgumentException">if wrong parameter type or a fixed
            salt is passed in which is the wrong length.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns>true on full message recovery, false otherwise, or if not sure.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.LtoOSP(System.Int64,System.Byte[])">
            <summary> long to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 1)</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
            <summary>
            Generate a signer for the with either implicit or explicit trailers
            for ISO9796-2.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns> true on full message recovery, false otherwise.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.GenerateSignature">
            <summary> Generate a signature for the message we've been loaded with using
            the key we were initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the internal state represents the signature described
            in the passed in array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.StreamBlockCipher">
            a wrapper for block ciphers with a single byte block size, so that they
            can be treated like stream ciphers.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             basic constructor.
            
             @param cipher the block cipher to be wrapped.
             @exception ArgumentException if the cipher has a block size other than
             one.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the underlying cipher.
            
             @param forEncryption true if we are setting up for encryption, false otherwise.
             @param param the necessary parameters for the underlying cipher to be initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.ReturnByte(System.Byte)">
             encrypt/decrypt a single byte returning the result.
            
             @param in the byte to be processed.
             @return the result of processing the input byte.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process a block of bytes from in putting the result into out.
            
             @param in the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param out the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data stars at.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.Reset">
            reset the underlying cipher. This leaves it in the same state
            it was at after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.StreamBlockCipher.AlgorithmName">
             return the name of the algorithm we are wrapping.
            
             @return the name of the algorithm we are wrapping.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer">
            <remarks>
            A certificate verifyer, that will always return true.
            <pre>
            DO NOT USE THIS FILE UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING.
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer">
            <remarks>
            This should be implemented by any class which can find out, if a given
            certificate chain is being accepted by an client.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer.IsValid(Org.BouncyCastle.Asn1.X509.X509CertificateStructure[])">
            <param name="certs">The certs, which are part of the chain.</param>
            <returns>True, if the chain is accepted, false otherwise</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer.IsValid(Org.BouncyCastle.Asn1.X509.X509CertificateStructure[])">
            <summary>Return true.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ByteQueue">
            <remarks>
            A queue for bytes.
            <p>
            This file could be more optimized.
            </p>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.DefaultCapacity">
            The initial size for our buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.NextTwoPow(System.Int32)">
            <returns>The smallest number which can be written as 2^x which is bigger than i.</returns>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.databuf">
            The buffer where we store our data.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.skipped">
            How many bytes at the beginning of the buffer are skipped.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.available">
            How many bytes in the buffer are valid data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.Read(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Read data from the buffer.</summary>
            <param name="buf">The buffer where the read data will be copied to.</param>
            <param name="offset">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.AddData(System.Byte[],System.Int32,System.Int32)">
            <summary>Add some data to our buffer.</summary>
            <param name="data">A byte-array to read data from.</param>
            <param name="offset">How many bytes to skip at the beginning of the array.</param>
            <param name="len">How many bytes to read from the array.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.RemoveData(System.Int32)">
            <summary>Remove some bytes from our data from the beginning.</summary>
            <param name="i">How many bytes to remove.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.ByteQueue.Available">
            <summary>The number of bytes which are available in this buffer.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Certificate">
            A representation for a certificate chain.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.Certificate.certs">
            The certificates.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Parse(System.IO.Stream)">
             Parse the ServerCertificate message.
            
             @param inStr The stream where to parse from.
             @return A Certificate object with the certs, the server has sended.
             @throws IOException If something goes wrong during parsing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Encode(System.IO.Stream)">
             Encodes version of the ClientCertificate message
            
             @param outStr stream to write the message to
             @throws IOException If something goes wrong
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure[])">
             Private constructor from a cert array.
            
             @param certs The certs the chain should contain.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.GetCerts">
            <returns>An array which contains the certs, this chain contains.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CombinedHash">
            <remarks>A combined hash, which implements md5(m) || sha1(m).</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.GetByteLength">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.GetDigestSize">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.Update(System.Byte)">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.DoFinal(System.Byte[],System.Int32)">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.Reset">
            <seealso cref="M:Org.BouncyCastle.Crypto.IDigest.Reset"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CombinedHash.AlgorithmName">
            <seealso cref="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.Init(Org.BouncyCastle.Crypto.Tls.TlsClientContext)">
            <summary>
            Called at the start of a new TLS session, before any other methods.
            </summary>
            <param name="context">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites">
            <summary>
            Get the list of cipher suites that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/>, each specifying a supported cipher suite.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods">
            <summary>
            Get the list of compression methods that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/>, each specifying a supported compression method.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions">
            <summary>
            Get the (optional) table of client extensions to be included in (extended) client hello.
            </summary>
            <returns>
            A <see cref="T:System.Collections.IDictionary"/> (<see cref="T:Org.BouncyCastle.Crypto.Tls.ExtensionType"/> -&gt; byte[]). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])">
            <summary>
            Reports the session ID once it has been determined.
            </summary>
            <param name="sessionID">
            A <see cref="T:System.Byte"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCipherSuite(Org.BouncyCastle.Crypto.Tls.CipherSuite)">
            <summary>
            Report the cipher suite that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered cipher suites
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites"/>
            </remarks>
            <param name="selectedCipherSuite">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCompressionMethod(Org.BouncyCastle.Crypto.Tls.CompressionMethod)">
            <summary>
            Report the compression method that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered compression methods
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods"/>
            </remarks>
            <param name="selectedCompressionMethod">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySecureRenegotiation(System.Boolean)">
            <summary>
            Report whether the server supports secure renegotiation
            </summary>
            <remarks>
            The protocol handler automatically processes the relevant extensions
            </remarks>
            <param name="secureRenegotiation">
            A <see cref="T:System.Boolean"/>, true if the server supports secure renegotiation
            </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.ProcessServerExtensions(System.Collections.IDictionary)">
            <summary>
            Report the extensions from an extended server hello.
            </summary>
            <remarks>
            Will only be called if we returned a non-null result from <see cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions"/>.
            </remarks>
            <param name="serverExtensions">
            A <see cref="T:System.Collections.IDictionary"/>  (<see cref="T:Org.BouncyCastle.Crypto.Tls.ExtensionType"/> -&gt; byte[])
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetKeyExchange">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/> to negotiate the key exchange
            part of the protocol.
            </summary>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetAuthentication">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsAuthentication"/> to handle authentication
            part of the protocol.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompression">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCompression"/> to handle record compression.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipher">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/> to use for encryption/decryption.
            </summary>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.RecordStream">
            <remarks>An implementation of the TLS 1.0 record layer.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher">
            <summary>
            A generic TLS 1.0 block cipher. This can be used for AES or 3DES for example.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.EncodePlaintext(Org.BouncyCastle.Crypto.Tls.ContentType,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.DecodeCiphertext(Org.BouncyCastle.Crypto.Tls.ContentType,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsDHKeyExchange">
            <summary>
            TLS 1.0 DH key exchange.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange">
            <summary>
            A generic interface for key exchange implementations in TLS 1.0.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ValidateCertificateRequest(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipClientCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientCredentials(Org.BouncyCastle.Crypto.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GenerateClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GeneratePremasterSecret">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsMac">
            <remarks>
            A generic TLS MAC implementation, which can be used with any kind of
            IDigest to act as an HMAC.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.#ctor(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Int32,System.Int32)">
             Generate a new instance of an TlsMac.
            
             @param digest    The digest to use.
             @param key_block A byte-array where the key for this mac is located.
             @param offset    The number of bytes to skip, before the key starts in the buffer.
             @param len       The length of the key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.GetMacSecret">
            @return the MAC write secret
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.IncSequenceNumber">
            Increment the current write sequence number
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.CalculateMac(Org.BouncyCastle.Crypto.Tls.ContentType,System.Byte[],System.Int32,System.Int32)">
             Calculate the mac for some given data.
             <p/>
             TlsMac will keep track of the sequence number internally.
            
             @param type    The message type of the message.
             @param message A byte-buffer containing the message.
             @param offset  The number of bytes to skip, before the message starts.
             @param len     The length of the message.
             @return A new byte-buffer containing the mac value.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.SequenceNumber">
            @return the current write sequence number
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.Size">
            @return The Keysize of the mac.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsNullCipher">
            <summary>
            A NULL cipher suite, for use during handshake.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler">
            <remarks>An implementation of all high level protocols in TLS 1.0.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.#ctor(System.IO.Stream,System.IO.Stream)">
            <remarks>Both streams can be the same object</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.#ctor(System.IO.Stream,System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>Both streams can be the same object</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.ProcessChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
             This method is called, when a change cipher spec message is received.
            
             @throws IOException If the message has an invalid content or the
                                 handshake is not in the correct state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.Connect(Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer)">
            <summary>Connects to the remote system.</summary>
            <param name="verifyer">Will be used when a certificate is received to verify
            that this certificate is accepted by the client.</param>
            <exception cref="T:System.IO.IOException">If handshake was not successful</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.ReadApplicationData(System.Byte[],System.Int32,System.Int32)">
             Read data from the network. The method will return immediately, if there is
             still some data left in the buffer, or block until some application
             data has been read from the network.
            
             @param buf    The buffer where the data will be copied to.
             @param offset The position where the data will be placed in the buffer.
             @param len    The maximum number of bytes to read.
             @return The number of bytes read.
             @throws IOException If something goes wrong during reading data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.WriteData(System.Byte[],System.Int32,System.Int32)">
             Send some application data to the remote system.
             <p/>
             The method will handle fragmentation internally.
            
             @param buf    The buffer with the data.
             @param offset The position in the buffer where the data is placed.
             @param len    The length of the data.
             @throws IOException If something goes wrong during sending.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.FailWithError(Org.BouncyCastle.Crypto.Tls.AlertLevel,Org.BouncyCastle.Crypto.Tls.AlertDescription)">
             Terminate this connection with an alert.
             <p/>
             Can be used for normal closure too.
            
             @param alertLevel       The level of the alert, an be AlertLevel.fatal or AL_warning.
             @param alertDescription The exact alert message.
             @throws IOException If alert was fatal.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.Close">
            <summary>Closes this connection</summary>
            <exception cref="T:System.IO.IOException">If something goes wrong during closing.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.AssertEmpty(System.IO.MemoryStream)">
             Make sure the Stream is now empty. Fail otherwise.
            
             @param is The Stream to check.
             @throws IOException If is is not empty.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.OutputStream">
            <summary>A Stream which can be used to send data.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.InputStream">
            <summary>A Stream which can be used to read data.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.Stream">
            <summary>The secure bidirectional stream for this connection</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsRsaKeyExchange">
            <summary>
            TLS 1.0 RSA key exchange.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsSrpKeyExchange">
            <summary>
            TLS 1.1 SRP key exchange.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsUtilities">
            <remarks>Some helper functions for MicroTLS.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @param u2Out      the return object for the u2 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Org.BouncyCastle.Math.EC.F2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>F2mPoint</code>. 
            @param p The F2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Org.BouncyCastle.Math.EC.F2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Org.BouncyCastle.Math.EC.F2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Org.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,Org.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Org.BouncyCastle.Math.EC.F2mPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The F2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Org.BouncyCastle.Math.EC.F2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The F2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Org.BouncyCastle.Math.EC.F2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The F2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Org.BouncyCastle.Math.EC.F2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.n">
            The order of the base point of the curve.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.h">
            The cofactor of the curve.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.infinity">
            The point at infinity on this curve.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.mu">
            The parameter <code>&#956;</code> of the elliptic curve if this is
            a Koblitz curve.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param n The order of the main subgroup of the elliptic curve.
            @param h The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param n The order of the main subgroup of the elliptic curve.
            @param h The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.GetMu">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a
            Koblitz curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.solveQuadradicEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.k1">
            Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.k2">
            Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.k3">
            Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>IntArray</code> holding the bits.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.t">
            The number of <code>int</code>s required to hold <code>m</code> bits.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.SetPreCompInfo(Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Sets the <code>PreCompInfo</code>. Used by <code>ECMultiplier</code>s
            to save the precomputation for this <code>ECPoint</code> to store the
            precomputation result for use by subsequent multiplication.
            @param preCompInfo The values precomputed by the
            <code>ECMultiplier</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.AssertECMultiplier">
            Sets the appropriate <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes with point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compresion.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.AssertECMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.CheckPoints(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.EC.ECPoint)">
            Check, if two <code>ECPoint</code>s can be added or subtracted.
            @param a The first <code>ECPoint</code> to check.
            @param b The second <code>ECPoint</code> to check.
            @throws IllegalArgumentException if <code>a</code> and <code>b</code>
            cannot be added.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.AddSimple(Org.BouncyCastle.Math.EC.F2mPoint)">
            Adds another <code>ECPoints.F2m</code> to <code>this</code> without
            checking if both points are on the same curve. Used by multiplication
            algorithms, because there all points are a multiple of the same point
            and hence the checks can be omitted.
            @param b The other <code>ECPoints.F2m</code> to add to
            <code>this</code>.
            @return <code>this + b</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.SubtractSimple(Org.BouncyCastle.Math.EC.F2mPoint)">
            Subtracts another <code>ECPoints.F2m</code> from <code>this</code>
            without checking if both points are on the same curve. Used by
            multiplication algorithms, because there all points are a multiple
            of the same point and hence the checks can be omitted.
            @param b The other <code>ECPoints.F2m</code> to subtract from
            <code>this</code>.
            @return <code>this - b</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.AssertECMultiplier">
            Sets the appropriate <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> i multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.FpNafMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.FpNafMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            D.3.2 pg 101
            @see org.bouncycastle.math.ec.multiplier.ECMultiplier#multiply(org.bouncycastle.math.ec.ECPoint, java.math.BigInteger)
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ReferenceMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations in
            {@link org.bouncycastle.math.ec.ECPoint ECPoint}.
            
            @param p The point to multiply.
            @param k The factor by which to multiply.
            @return The result of the point multiplication <code>k * p</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafMultiplier.WindowNaf(System.SByte,Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &#8722;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>sbyte[]</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.preComp">
            Array holding the precomputed <code>ECPoint</code>s used for the Window
            NAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
            WNafMultiplier.multiply()}</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.twiceP">
            Holds an <code>ECPoint</code> representing twice(this). Used for the
            Window NAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
            WNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The F2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Org.BouncyCastle.Math.EC.F2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The F2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Org.BouncyCastle.Math.EC.F2mPoint,System.SByte[],Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link org.bouncycastle.math.ec.F2mPoint F2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The F2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.preComp">
            Array holding the precomputed <code>F2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.#ctor(Org.BouncyCastle.Math.EC.F2mPoint[])">
            Constructor for <code>WTauNafPreCompInfo</code>
            @param preComp Array holding the precomputed <code>F2mPoint</code>s
            used for the WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.GetPreComp">
            @return the array holding the precomputed <code>F2mPoint</code>s
            used for the WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspResp">
            <remarks>
            <code>
            BasicOcspResponse ::= SEQUENCE {
            	tbsResponseData		ResponseData,
            	signatureAlgorithm	AlgorithmIdentifier,
            	signature			BIT STRING,
            	certs				[0] EXPLICIT SEQUENCE OF Certificate OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetExtensionValue(System.String)">
            <summary>
            Get the value of a given extension.
            </summary>
            <param name="oid">The object ID of the extension. </param>
            <returns>An Asn1OctetString object if that extension is found or null if not.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetTbsResponseData">
            <returns>The DER encoding of the tbsResponseData field.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetCertificates(System.String)">
            <returns>The certificates, if any, associated with the response.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the signature against the tbsResponseData object we contain.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetEncoded">
            <returns>The ASN.1 encoded representation of this object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator">
            Generator for basic OCSP response objects.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Ocsp.RespID)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            construct with the responderID to be the SHA-1 keyHash of the passed in public key.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param thisUpdate date this response was valid on
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SetResponseExtensions(Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Set the extensions for the response.
            
             @param responseExtensions the extension object to carry.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.#ctor(System.String,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Math.BigInteger)">
            create from an issuer certificate and the serial number of the
            certificate it signed.
            @exception OcspException if any problems occur creating the id fields.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.DeriveCertificateID(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Math.BigInteger)">
             Create a new CertificateID for a new serial number derived from a previous one
             calculated for the same CA certificate.
            
             @param original the previously calculated CertificateID for the CA.
             @param newSerialNumber the serial number for the new certificate of interest.
            
             @return a new CertificateID for newSerialNumber
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.CertificateID.SerialNumber">
            return the serial number for the certificate associated
            with this request.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OcspReq">
             <pre>
             OcspRequest     ::=     SEQUENCE {
                   tbsRequest                  TBSRequest,
                   optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            
               TBSRequest      ::=     SEQUENCE {
                   version             [0]     EXPLICIT Version DEFAULT v1,
                   requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                   requestList                 SEQUENCE OF Request,
                   requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            
               Signature       ::=     SEQUENCE {
                   signatureAlgorithm      AlgorithmIdentifier,
                   signature               BIT STRING,
                   certs               [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL}
            
               Version         ::=             INTEGER  {  v1(0) }
            
               Request         ::=     SEQUENCE {
                   reqCert                     CertID,
                   singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            
               CertID          ::=     SEQUENCE {
                   hashAlgorithm       AlgorithmIdentifier,
                   issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                   issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                   serialNumber        CertificateSerialNumber }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetTbsRequest">
            Return the DER encoding of the tbsRequest field.
            @return DER encoding of tbsRequest
            @throws OcspException in the event of an encoding error.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetCertificates(System.String)">
             If the request is signed return a possibly empty CertStore containing the certificates in the
             request. If the request is not signed the method returns null.
            
             @return null if not signed, a CertStore otherwise
             @throws OcspException
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            Verify the signature against the TBSRequest object we contain.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.SignatureAlgOid">
            return the object identifier representing the signature algorithm
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.IsSigned">
             Return whether or not this request is signed.
            
             @return true if signed false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID)">
             Add a request for the given CertificateID.
            
             @param certId certificate ID of interest
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a request with extensions
            
             @param certId certificate ID of interest
             @param singleRequestExtensions the extensions to attach to the request
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.SetRequestorName(Org.BouncyCastle.Asn1.X509.X509Name)">
             Set the requestor name to the passed in X509Principal
            
             @param requestorName a X509Principal representing the requestor name.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.Generate">
             Generate an unsigned request
            
             @return the OcspReq
             @throws OcspException
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReqGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspResp.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OCSPRespGenerator">
            base generator for an OCSP response - at the moment this only supports the
            generation of responses containing BasicOCSP responses.
        </member>
        <member name="F:Org.BouncyCastle.Ocsp.OcspRespStatus.Successful">
            note 4 is not used.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RespID">
            Carrier for a ResponderID.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RevokedStatus">
            wrapper for the RevokedInfo object
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.RevokedStatus.RevocationReason">
            return the revocation reason. Note: this field is optional, test for it
            with hasRevocationReason() first.
            @exception InvalidOperationException if a reason is asked for and none is avaliable
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.SingleResp.GetCertStatus">
             Return the status object for the response - null indicates good.
            
             @return the status object for the response, null if it is good.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.SingleResp.NextUpdate">
             return the NextUpdate value - note: this is an optional field so may
             be returned as null.
            
             @return nextUpdate, or null if not present.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.UnknownStatus">
            wrapper for the UnknownInfo object
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData">
            <remarks>Compressed data objects</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetInputStream">
            <summary>Get the raw input stream contained in the object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetDataStream">
            <summary>Return an uncompressed input stream which allows reading of the compressed data.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.Algorithm">
            <summary>The algorithm used for compression</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator">
            <remarks>Class for producing compressed data packets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream)">
            <summary>
            <p>
            Return an output stream which will save the data being written to
            the compressed object.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will compress the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            <p>
            <b>Note</b>: using this may break compatibility with RFC 1991 compliant tools.
            Only recent OpenPGP implementations are capable of accepting these streams.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <param name="buffer">The buffer to use.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Close">
            <summary>Close the compressed object.</summary>summary>
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream">
             An output stream that compresses into the BZip2 format (with the file
             header chars) into another stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             TODO:    Update to BZip2 1.0.1
             <b>NB:</b> note this class has been modified to add a leading BZ to the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="M:Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream.WriteByte(System.Byte)">
            
             modified by Oliver Merkel, 010128
            
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException">
            <remarks>
            Thrown if the IV at the start of a data stream indicates the wrong key is being used.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">
            <remarks>Generic exception class for PGP encoding/decoding problems.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.IsIntegrityProtected">
            <summary>Return true if the message is integrity protected.</summary>
            <returns>True, if there is a modification detection code namespace associated
            with this stream.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.Verify">
            <summary>Note: This can only be called after the message has been read.</summary>
            <returns>True, if the message verifies, false otherwise</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator">
            <remarks>Generator for encrypted objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Existing SecureRandom constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Creates a cipher stream which will have an integrity packet associated with it.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>Base constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="rand">Source of randomness.</param>
            <param name="oldFormat">PGP 2.6.x compatibility required.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(System.Char[])">
            <summary>
            Add a PBE encryption method to the encrypted object using the default algorithm (S2K_SHA1).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(System.Char[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Add a public key encrypted session key to the encrypted object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64,System.Byte[])">
            <summary>
            <p>
            If buffer is non null stream assumed to be partial, otherwise the length will be used
            to output a fixed length packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64)">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Close">
            <summary>
            <p>
            Close off the encrypted object - this is equivalent to calling Close() on the stream
            returned by the Open() method.
            </p>
            <p>
            <b>Note</b>: This does not close the underlying output stream, only the stream on top of
            it created by the Open() method.
            </p>
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList">
            <remarks>A holder for a list of PGP encryption method packets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags">
            <remarks>Key flag values for the KeyFlags subpacket.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair">
            <remarks>
            General class to handle JCA key pairs and convert them into OpenPGP ones.
            <p>
            A word for the unwary, the KeyId for an OpenPGP public key is calculated from
            a hash that includes the time of creation, if you pass a different date to the
            constructor below with the same public private key pair the KeyIs will not be the
            same as for previous generations of the key, so ideally you only want to do
            this once.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Create a key pair from a PgpPrivateKey and a PgpPublicKey.</summary>
            <param name="pub">The public key.</param>
            <param name="priv">The private key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.KeyId">
            <summary>The keyId associated with this key pair.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator">
            <remarks>
            Generator for a PGP master and subkey ring.
            This class will generate both the secret and public key rings
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator using old style checksumming. It is recommended to use
            SHA1 checksumming where possible.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair)">
            <summary>Add a subkey to the key ring to be generated with default certification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector)">
            <summary>
            Add a subkey with specific hashed and unhashed packets associated with it and
            default certification.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GenerateSecretKeyRing">
            <summary>Return the secret key ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GeneratePublicKeyRing">
            <summary>Return the public key ring that corresponds to the secret key ring.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException">
            <remarks>
            Thrown if the key checksum is invalid.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData">
            <summary>Class for processing literal data objects.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetRawFileName">
            Return the file name as an unintrepreted byte array.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetInputStream">
            <summary>The raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetDataStream">
            <summary>The input stream representing the data stream.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Format">
            <summary>The format of the data stream - Binary or Text</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.FileName">
            <summary>The file name that's associated with the data stream.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.ModificationTime">
            <summary>The modification time for the file.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator">
            <remarks>Class for producing literal data packets.</remarks>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.#ctor(System.Boolean)">
            <summary>
            Generates literal data objects in the old format.
            This is important if you need compatibility with PGP 2.6.x.
            </summary>
            <param name="oldFormat">If true, uses old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.Int64,System.DateTime)">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="length">The length of the data we will write.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.DateTime,System.Byte[])">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet,
            as an indefinite length stream. The stream is written out as a series of partial
            packets with a chunk size determined by the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.</p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
            <param name="buffer">The buffer to use for collecting data to put into chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>
            <p>
            Open a literal data packet for the passed in <c>FileInfo</c> object, returning
            an output stream for saving the file contents.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="file">The <c>FileInfo</c> object containg the packet details.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Close">
            <summary>
            Close the literal data packet - this is equivalent to calling Close()
            on the stream returned by the Open() method.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker">
            <remarks>
            A PGP marker packet - in general these should be ignored other than where
            the idea is to preserve the original input stream.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory">
            <remarks>
            General class for reading a PGP object stream.
            <p>
            Note: if this class finds a PgpPublicKey or a PgpSecretKey it
            will create a PgpPublicKeyRing, or a PgpSecretKeyRing for each
            key found. If all you are trying to do is read a key ring file use
            either PgpPublicKeyRingBundle or PgpSecretKeyRingBundle.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.NextPgpObject">
            <summary>Return the next object in the stream, or null if the end is reached.</summary>
            <exception cref="T:System.IO.IOException">On a parse error</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.AllPgpObjects">
            <summary>
            Return all available objects in a list.
            </summary>
            <returns>An <c>IList</c> containing all objects from this factory, in order.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature">
            <remarks>A one pass signature object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.InitVerify(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Initialise the signature object for verification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.Verify(Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Verify the calculated signature against the passed in PgpSignature.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList">
            <remarks>Holder for a list of PgpOnePassSignature objects.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData">
            <remarks>A password based encryption object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStream(System.Char[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey">
            <remarks>General class to contain a private key for use with other OpenPGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Int64)">
            <summary>
            Create a PgpPrivateKey from a regular private key and the ID of its
            associated public key.
            </summary>
            <param name="privateKey">Private key to use.</param>
            <param name="keyId">ID of the corresponding public key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.KeyId">
            <summary>The keyId associated with the contained private key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.Key">
            <summary>The contained private key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey">
            <remarks>General class to handle a PGP public key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.DateTime)">
            <summary>
            Create a PgpPublicKey from the passed in lightweight one.
            </summary>
            <remarks>
            Note: the time passed in affects the value of the key's keyId, so you probably only want
            to do this once for a lightweight key, or make sure you keep track of the time you used.
            </remarks>
            <param name="algorithm">Asymmetric algorithm type representing the public key.</param>
            <param name="pubKey">Actual public key to associate.</param>
            <param name="time">Date of creation.</param>
            <exception cref="T:System.ArgumentException">If <c>pubKey</c> is not public.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">On key creation problem.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyPacket,Org.BouncyCastle.Bcpg.TrustPacket,System.Collections.IList)">
            <summary>Constructor for a sub-key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Copy constructor.</summary>
            <param name="pubKey">The public key to copy.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetTrustData">
            <summary>Return the trust data associated with the public key, if present.</summary>
            <returns>A byte array with trust data, null otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetValidSeconds">
            <summary>The number of valid seconds from creation time - zero means no expiry.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetFingerprint">
            <summary>The fingerprint of the key</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetKey">
            <summary>The public key contained in the object.</summary>
            <returns>A lightweight public key.</returns>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If the key algorithm is not recognised.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpUserAttributeSubpacketVector</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForId(System.String)">
            <summary>Allows enumeration of any signatures associated with the passed in id.</summary>
            <param name="id">The ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForUserAttribute(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>Allows enumeration of signatures associated with the passed in user attributes.</summary>
            <param name="userAttributes">The vector of user attributes to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesOfType(System.Int32)">
            <summary>Allows enumeration of signatures of the passed in type that are on this key.</summary>
            <param name="signatureType">The type of the signature to be returned.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignatures">
            <summary>Allows enumeration of all signatures/certifications associated with this key.</summary>
            <returns>An <c>IEnumerable</c> with all signatures/certifications.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsRevoked">
            <summary>Check whether this (sub)key has a revocation signature on it.</summary>
            <returns>True, if this (sub)key has been revoked.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for an id to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="id">The ID the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for the given UserAttributeSubpackets to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="userAttributes">The attributes the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>
            Remove any certifications associated with a user attribute subpacket on a key.
            </summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The attributes to be removed.</param>
            <returns>
            The re-certified key, or null if the user attribute subpacket was not found on the key.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String)">
            <summary>Remove any certifications associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that is to be removed.</param>
            <returns>The re-certified key, or null if the ID was not found on the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that the certfication is to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given user attributes on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The user attributes that the certfication is to be removed from.</param>
            <param name="certification">The certification to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a revocation or some other key certification to a key.</summary>
            <param name="key">The key the revocation is to be added to.</param>
            <param name="certification">The key signature to be added.</param>
            <returns>The new changed public key object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification from the key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The modified key, null if the certification was not found.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Version">
            <summary>The version of this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.CreationTime">
            <summary>The creation time of this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.ValidDays">
            <summary>The number of valid days from creation time - zero means no expiry.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.KeyId">
            <summary>The keyId associated with the public key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsEncryptionKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for encryption.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for encryption.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsMasterKey">
            <summary>True, if this is a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Algorithm">
            <summary>The algorithm code associated with the public key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.BitStrength">
            <summary>The strength of the key in bits.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData">
            <remarks>A public key encrypted data object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetSymmetricAlgorithm(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>
            Return the algorithm code for the symmetric algorithm used to encrypt the data.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetDataStream(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Return the decrypted data stream for the packet.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.KeyId">
            <summary>The key ID for the key used to encrypt the data.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing">
            <remarks>
            Class to hold a single master public key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpPublicKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey">
            <summary>Return the first public key in the ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey(System.Int64)">
            <summary>Return the public key referred to by the passed in key ID if it is present.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKeys">
            <summary>Allows enumeration of all the public keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpPublicKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.InsertPublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Returns a new key ring with the public key passed in either added or
            replacing an existing one.
            </summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be inserted.</param>
            <returns>A new <c>PgpPublicKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.RemovePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Returns a new key ring with the public key passed in removed from the key ring.</summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be removed.</param>
            <returns>A new <c>PgpPublicKeyRing</c>, or null if pubKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire public key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpPublicKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpPublicKeyRing.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the public key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKey(System.Int64)">
            <summary>Return the PGP public key associated with the given key id.</summary>
            <param name="keyId">The ID of the public key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKeyRing(System.Int64)">
            <summary>Return the public key ring which contains the key referred to by keyId</summary>
            <param name="keyId">key ID to match against</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.AddPublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in public key ring.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="publicKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.RemovePublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in public key ring removed.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="publicKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Count">
            <summary>Return the number of key rings in this collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey">
            <remarks>General class to handle a PGP secret key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKey(System.Char[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="oldPassPhrase">The current password for the key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ReplacePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Replace the passed the public key on the passed in secret key.</summary>
            <param name="secretKey">Secret key to change.</param>
            <param name="publicKey">New public key.</param>
            <returns>A new secret key.</returns>
            <exception cref="T:System.ArgumentException">If KeyId's do not match.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsSigningKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for signing.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for use with signing.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsMasterKey">
            <summary>True, if this is a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyEncryptionAlgorithm">
            <summary>The algorithm the key is encrypted with.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyId">
            <summary>The key ID of the public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.PublicKey">
            <summary>The public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing">
            <remarks>
            Class to hold a single master secret key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpSecretKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetPublicKey">
            <summary>Return the public key for the master key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKey">
            <summary>Return the master private key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKeys">
            <summary>Allows enumeration of the secret keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpSecretKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetExtraPublicKeys">
            <summary>
            Return an iterator of the public keys in the secret key ring that
            have no matching private key. At the moment only personal certificate data
            appears in this fashion.
            </summary>
            <returns>An <c>IEnumerable</c> of unattached, or extra, public keys.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.ReplacePublicKeys(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Replace the public key set on the secret ring with the corresponding key off the public ring.
            </summary>
            <param name="secretRing">Secret ring to be changed.</param>
            <param name="publicRing">Public ring containing the new public key set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key ring, with the master key and sub keys encrypted
            using a new password and the passed in algorithm.
            </summary>
            <param name="ring">The <c>PgpSecretKeyRing</c> to be copied.</param>
            <param name="oldPassPhrase">The current password for key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.InsertSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>
            Returns a new key ring with the secret key passed in either added or
            replacing an existing one with the same key ID.
            </summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be inserted.</param>
            <returns>A new <c>PgpSecretKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.RemoveSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>Returns a new key ring with the secret key passed in removed from the key ring.</summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be removed.</param>
            <returns>A new <c>PgpSecretKeyRing</c>, or null if secKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire secret key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpSecretKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpSecretKeyRing.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the secret key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKey(System.Int64)">
            <summary>Return the PGP secret key associated with the given key id.</summary>
            <param name="keyId">The ID of the secret key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKeyRing(System.Int64)">
            <summary>Return the secret key ring which contains the key referred to by keyId</summary>
            <param name="keyId">The ID of the secret key</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.AddSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in secret key ring.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="secretKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.RemoveSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in secret key ring removed.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="secretKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Count">
            <summary>Return the number of rings in this collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature">
            <remarks>A PGP signature object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in user attributes.
            </summary>
            <param name="userAttributes">User attributes the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in ID.
            </summary>
            <param name="id">ID the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are verifying against.</param>
            <param name="pubKey">The key we are verifying.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a key certification, such as revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are checking.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.Version">
            <summary>The OpenPGP version number for this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyAlgorithm">
            <summary>The key algorithm associated with this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HashAlgorithm">
            <summary>The hash algorithm associated with this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyId">
            <summary>The ID of the key that created the signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.CreationTime">
            <summary>The creation time of this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HasSubpackets">
            <summary>
            Return true if the signature has either hashed or unhashed subpackets.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator">
            <remarks>Generator for PGP signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.Generate">
            <summary>Return a signature object containing the current signature state.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in ID and key.</summary>
            <param name="id">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in userAttributes.</summary>
            <param name="userAttributes">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are certifying against.</param>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification, such as a revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList">
            <remarks>A list of PGP signatures - normally in the signature block after literal data.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator">
            <remarks>Generator for signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetTrust(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Add a TrustSignature packet to the signature. The values for depth and trust are largely
            installation dependent but there are some guidelines in RFC 4880 - 5.2.3.13.
            </summary>
            <param name="isCritical">true if the packet is critical.</param>
            <param name="depth">depth level.</param>
            <param name="trustAmount">trust amount.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetKeyExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a key is valid for after the time of its creation.
            A value of zero means the key never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the key is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a signature is valid for after the time of its creation.
            A value of zero means the signature never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the signature is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureCreationTime(System.Boolean,System.DateTime)">
            <summary>
            Set the creation time for the signature.
            <p>
            Note: this overrides the generation of a creation time when the signature
            is generated.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationReason(System.Boolean,Org.BouncyCastle.Bcpg.RevocationReasonTag,System.String)">
            <summary>
            Sets revocation reason sub packet
            </summary>	    
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationKey(System.Boolean,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.Byte[])">
            <summary>
            Sets revocation key sub packet
            </summary>	
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetIssuerKeyID(System.Boolean,System.Int64)">
            <summary>
            Sets issuer key sub packet
            </summary>	
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector">
            <remarks>Container for a list of signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.HasSubpacket(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
             Return true if a particular subpacket type exists.
            
             @param type type to look for.
             @return true if present, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSubpackets(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
            Return all signature subpackets of the passed in type.
            @param type subpacket type code
            @return an array of zero or more matching subpackets.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSignatureExpirationTime">
            <summary>
            Return the number of seconds a signature is valid for after its creation date.
            A value of zero means the signature never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetKeyExpirationTime">
            <summary>
            Return the number of seconds a key is valid for after its creation date.
            A value of zero means the key never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.Count">
            <summary>Return the number of packets this vector contains.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector">
            <remarks>Container for a list of user attribute subpackets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities">
            <remarks>Basic utility class.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>Write out the passed in file as a literal data packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo,System.Byte[])">
            <summary>Write out the passed in file as a literal data packet in partial packet format.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.GetDecoderStream(System.IO.Stream)">
            <summary>
            Return either an ArmoredInputStream or a BcpgInputStream based on whether
            the initial characters of the stream are binary PGP encodings or not.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator">
            <remarks>Generator for old style PGP V3 Signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.Generate">
            <summary>Return a V3 signature object containing the current signature state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.PemReader">
            Class for reading OpenSSL PEM encoded streams containing 
            X509 certificates, PKCS8 encoded keys and PKCS7 objects.
            <p>
            In the case of PKCS7 objects the reader will return a CMS ContentInfo object. Keys and
            Certificates will be returned using the appropriate java.security type.</p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemReader.ReadPemObject">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader)">
             Create a new PemReader
            
             @param reader the Reader
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader,Org.BouncyCastle.OpenSsl.IPasswordFinder)">
             Create a new PemReader with a password finder
            
             @param reader the Reader
             @param pFinder the password finder
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCertificate(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509Certificate.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCrl(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509CRL.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCertificateRequest(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS10 certification request.
            
             @return the certificate request.
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadAttributeCertificate(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509 Attribute Certificate.
            
             @return the X509 Attribute Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadPkcs7(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS7 object. This returns a ContentInfo object suitable for use with the CMS
             API.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadPrivateKey(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            Read a Key Pair
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.PemWriter">
            <remarks>General purpose writer for OpenSSL PEM objects.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IO.Pem.PemWriter">
            A generic PEM writer, based on RFC 1421
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.#ctor(System.IO.TextWriter)">
             Base constructor.
            
             @param out output stream to use.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.GetOutputSize(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Return the number of bytes or characters required to contain the
             passed in object if it is PEM encoded.
            
             @param obj pem object to be output
             @return an estimate of the number of bytes
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemWriter.#ctor(System.IO.TextWriter)">
            <param name="writer">The TextWriter object to write the output to.</param>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest">
             <remarks>
             A class for verifying and creating Pkcs10 Certification requests.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             <summary>
             Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
             </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
             <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
             <param name="publicKey">Public Key to be included in cert reqest.</param>
             <param name="attributes">ASN1Set of Attributes.</param>
             <param name="signingKey">Matching Private key for nominated (above) public key to be used to sign the request.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetPublicKey">
            <summary>
            Get the public key.
            </summary>
            <returns>The public key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.Verify">
            <summary>
            Verify Pkcs10 Cert Request is valid.
            </summary>
            <returns>true = valid.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned">
             <remarks>
             A class for creating and verifying Pkcs10 Certification requests (this is an extension on <see cref="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest"/>).
             The requests are made using delay signing. This is useful for situations where
             the private key is in another environment and not directly accessible (e.g. HSM)
             So the first step creates the request, then the signing is done outside this
             object and the signature is then used to complete the request.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set)">
            <summary>
            Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
            </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
            <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
            <param name="publicKey">Public Key to be included in cert reqest.</param>
            <param name="attributes">ASN1Set of Attributes.</param>
            <remarks>
            After the object is constructed use the <see cref="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.GetDataToSign"/> and finally the
            SignRequest methods to finalize the request.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Store.GetCertificate(System.String)">
            simply return the cert entry for the private key
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs12Utilities">
            Utility class for reencoding PKCS#12 files to definite length.
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[])">
             Just re-encode the outer layer of the PKCS#12 file to definite length encoding.
            
             @param berPKCS12File - original PKCS#12 file
             @return a byte array representing the DER encoding of the PFX structure
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[],System.Char[])">
             Re-encode the PKCS#12 structure to definite length encoding at the inner layer
             as well, recomputing the MAC accordingly.
            
             @param berPKCS12File - original PKCS12 file.
             @param provider - provider to use for MAC calculation.
             @return a byte array representing the DER encoding of the PFX structure.
             @throws IOException on parsing, encoding errors.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.RevocationDate">
            <summary>
            Returns the revocationDate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.Status">
            <summary>
            Returns the certStatus.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.GetSupportedExtensions">
            Returns an immutable <code>Set</code> of X.509 attribute certificate
            extensions that this <code>PkixAttrCertChecker</code> supports or
            <code>null</code> if no extensions are supported.
            <p>
            Each element of the set is a <code>String</code> representing the
            Object Identifier (OID) of the X.509 extension that is supported.
            </p>
            <p>
            All X.509 attribute certificate extensions that a
            <code>PkixAttrCertChecker</code> might possibly be able to process
            should be included in the set.
            </p>
            
            @return an immutable <code>Set</code> of X.509 extension OIDs (in
                    <code>String</code> format) supported by this
                    <code>PkixAttrCertChecker</code>, or <code>null</code> if no
                    extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Check(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixCertPath,Org.BouncyCastle.Pkix.PkixCertPath,System.Collections.ICollection)">
            Performs checks on the specified attribute certificate. Every handled
            extension is rmeoved from the <code>unresolvedCritExts</code>
            collection.
            
            @param attrCert The attribute certificate to be checked.
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param holderCertPath The certificate path which belongs to the holder
                       certificate.
            @param unresolvedCritExts a <code>Collection</code> of OID strings
                       representing the current set of unresolved critical extensions
            @throws CertPathValidatorException if the specified attribute certificate
                        does not pass the check.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Clone">
            Returns a clone of this object.
            
            @return a copy of this <code>PkixAttrCertChecker</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder.Build(Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixAttrCertPathValidator">
            CertPathValidatorSpi implementation for X.509 Attribute Certificates la RFC 3281.
            
            @see org.bouncycastle.x509.ExtendedPkixParameters
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertPathValidator.Validate(Org.BouncyCastle.Pkix.PkixCertPath,Org.BouncyCastle.Pkix.PkixParameters)">
            Validates an attribute certificate with the given certificate path.
            
            <p>
            <code>params</code> must be an instance of
            <code>ExtendedPkixParameters</code>.
            </p><p>
            The target constraints in the <code>params</code> must be an
            <code>X509AttrCertStoreSelector</code> with at least the attribute
            certificate criterion set. Obey that also target informations may be
            necessary to correctly validate this attribute certificate.
            </p><p>
            The attribute certificate issuer must be added to the trusted attribute
            issuers with {@link ExtendedPkixParameters#setTrustedACIssuers(Set)}.
            </p>
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param params The PKIX parameters.
            @return A <code>PKIXCertPathValidatorResult</code> of the result of
                    validating the <code>certPath</code>.
            @throws InvalidAlgorithmParameterException if <code>params</code> is
                        inappropriate for this validator.
            @throws CertPathValidatorException if the verification fails.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixBuilderParameters">
            <summary>
            Summary description for PkixBuilderParameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixParameters">
            <summary>
            Summary description for PkixParameters.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.PkixValidityModel">
            This is the default PKIX validity model. Actually there are two variants
            of this: The PKIX model and the modified PKIX model. The PKIX model
            verifies that all involved certificates must have been valid at the
            current time. The modified PKIX model verifies that all involved
            certificates were valid at the signing time. Both are indirectly choosen
            with the {@link PKIXParameters#setDate(java.util.Date)} method, so this
            methods sets the Date when <em>all</em> certificates must have been
            valid.
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.ChainValidityModel">
            This model uses the following validity model. Each certificate must have
            been valid at the moment where is was used. That means the end
            certificate must have been valid at the time the signature was done. The
            CA certificate which signed the end certificate must have been valid,
            when the end certificate was signed. The CA (or Root CA) certificate must
            have been valid, when the CA certificate was signed and so on. So the
            {@link PKIXParameters#setDate(java.util.Date)} method sets the time, when
            the <em>end certificate</em> must have been valid. <p/> It is used e.g.
            in the German signature law.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.#ctor(Org.BouncyCastle.Utilities.Collections.ISet)">
             Creates an instance of PKIXParameters with the specified Set of
             most-trusted CAs. Each element of the set is a TrustAnchor.<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.
            
             @param trustAnchors
                        a Set of TrustAnchors
            
             @exception InvalidAlgorithmParameterException
                            if the specified Set is empty
                            <code>(trustAnchors.isEmpty() == true)</code>
             @exception NullPointerException
                            if the specified Set is <code>null</code>
             @exception ClassCastException
                            if any of the elements in the Set are not of type
                            <code>java.security.cert.TrustAnchor</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetCertConstraints">
             Returns the required constraints on the target certificate. The
             constraints are returned as an instance of CertSelector. If
             <code>null</code>, no constraints are defined.<br />
             <br />
             Note that the CertSelector returned is cloned to protect against
             subsequent modifications.
            
             @return a CertSelector specifying the constraints on the target
                     certificate (or <code>null</code>)
            
             @see #setTargetCertConstraints(CertSelector)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetCertConstraints(Org.BouncyCastle.X509.Store.IX509Selector)">
             Sets the required constraints on the target certificate. The constraints
             are specified as an instance of CertSelector. If null, no constraints are
             defined.<br />
             <br />
             Note that the CertSelector specified is cloned to protect against
             subsequent modifications.
            
             @param selector
                        a CertSelector specifying the constraints on the target
                        certificate (or <code>null</code>)
            
             @see #getTargetCertConstraints()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetInitialPolicies">
             Returns an immutable Set of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. The
             default return value is an empty <code>Set</code>, which is
             interpreted as meaning that any policy would be acceptable.
            
             @return an immutable <code>Set</code> of initial policy OIDs in String
                     format, or an empty <code>Set</code> (implying any policy is
                     acceptable). Never returns <code>null</code>.
            
             @see #setInitialPolicies(java.util.Set)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetInitialPolicies(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the <code>Set</code> of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. By
             default, any policy is acceptable (i.e. all policies), so a user that
             wants to allow any policy as acceptable does not need to call this
             method, or can call it with an empty <code>Set</code> (or
             <code>null</code>).<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.<br />
             <br />
            
             @param initialPolicies
                        a Set of initial policy OIDs in String format (or
                        <code>null</code>)
            
             @exception ClassCastException
                            if any of the elements in the set are not of type String
            
             @see #getInitialPolicies()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetCertPathCheckers(System.Collections.IList)">
             Sets a <code>List</code> of additional certification path checkers. If
             the specified List contains an object that is not a PKIXCertPathChecker,
             it is ignored.<br />
             <br />
             Each <code>PKIXCertPathChecker</code> specified implements additional
             checks on a certificate. Typically, these are checks to process and
             verify private extensions contained in certificates. Each
             <code>PKIXCertPathChecker</code> should be instantiated with any
             initialization parameters needed to execute the check.<br />
             <br />
             This method allows sophisticated applications to extend a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code>. Each
             of the specified PKIXCertPathCheckers will be called, in turn, by a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code> for
             each certificate processed or validated.<br />
             <br />
             Regardless of whether these additional PKIXCertPathCheckers are set, a
             PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code>
             must perform all of the required PKIX checks on each certificate. The one
             exception to this rule is if the RevocationEnabled flag is set to false
             (see the {@link #setRevocationEnabled(boolean) setRevocationEnabled}
             method).<br />
             <br />
             Note that the List supplied here is copied and each PKIXCertPathChecker
             in the list is cloned to protect against subsequent modifications.
            
             @param checkers
                        a List of PKIXCertPathCheckers. May be null, in which case no
                        additional checkers will be used.
             @exception ClassCastException
                            if any of the elements in the list are not of type
                            <code>java.security.cert.PKIXCertPathChecker</code>
             @see #getCertPathCheckers()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetCertPathCheckers">
             Returns the List of certification path checkers. Each PKIXCertPathChecker
             in the returned IList is cloned to protect against subsequent modifications.
            
             @return an immutable List of PKIXCertPathCheckers (may be empty, but not
                     <code>null</code>)
            
             @see #setCertPathCheckers(java.util.List)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddCertPathChecker(Org.BouncyCastle.Pkix.PkixCertPathChecker)">
             Adds a <code>PKIXCertPathChecker</code> to the list of certification
             path checkers. See the {@link #setCertPathCheckers setCertPathCheckers}
             method for more details.
             <p>
             Note that the <code>PKIXCertPathChecker</code> is cloned to protect
             against subsequent modifications.</p>
            
             @param checker a <code>PKIXCertPathChecker</code> to add to the list of
             checks. If <code>null</code>, the checker is ignored (not added to list).
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
             Method to support <code>Clone()</code> under J2ME.
             <code>super.Clone()</code> does not exist and fields are not copied.
            
             @param params Parameters to set. If this are
                        <code>ExtendedPkixParameters</code> they are copied to.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetStores(System.Collections.IList)">
             Sets the Bouncy Castle Stores for finding CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             The <code>IList</code> is cloned.
             </p>
            
             @param stores A list of stores to use.
             @see #getStores
             @throws ClassCastException if an element of <code>stores</code> is not
                         a {@link Store}.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddStore(Org.BouncyCastle.X509.Store.IX509Store)">
             Adds a Bouncy Castle {@link Store} to find CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             This method should be used to add local stores, like collection based
             X.509 stores, if available. Local stores should be considered first,
             before trying to use additional (remote) locations, because they do not
             need possible additional network traffic.
             </p><p>
             If <code>store</code> is <code>null</code> it is ignored.
             </p>
            
             @param store The store to add.
             @see #getStores
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddAdditionalStore(Org.BouncyCastle.X509.Store.IX509Store)">
             Adds an additional Bouncy Castle {@link Store} to find CRLs, certificates,
             attribute certificates or cross certificates.
             <p>
             You should not use this method. This method is used for adding additional
             X.509 stores, which are used to add (remote) locations, e.g. LDAP, found
             during X.509 object processing, e.g. in certificates or CRLs. This method
             is used in PKIX certification path processing.
             </p><p>
             If <code>store</code> is <code>null</code> it is ignored.
             </p>
            
             @param store The store to add.
             @see #getStores()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetAdditionalStores">
             Returns an <code>IList</code> of additional Bouncy Castle
             <code>Store</code>s used for finding CRLs, certificates, attribute
             certificates or cross certificates.
            
             @return an immutable <code>IList</code> of additional Bouncy Castle
                     <code>Store</code>s. Never <code>null</code>.
            
             @see #addAddionalStore(Store)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetStores">
             Returns an <code>IList</code> of Bouncy Castle
             <code>Store</code>s used for finding CRLs, certificates, attribute
             certificates or cross certificates.
            
             @return an immutable <code>IList</code> of Bouncy Castle
                     <code>Store</code>s. Never <code>null</code>.
            
             @see #setStores(IList)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAdditionalLocationsEnabled(System.Boolean)">
             Sets if additional {@link X509Store}s for locations like LDAP found in
             certificates or CRLs should be used.
            
             @param enabled <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetConstraints">
             Returns the required constraints on the target certificate or attribute
             certificate. The constraints are returned as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
            
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> returned is cloned to protect
             against subsequent modifications.
             </p>
             @return a <code>IX509Selector</code> specifying the constraints on the
                     target certificate or attribute certificate (or <code>null</code>)
             @see #setTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetConstraints(Org.BouncyCastle.X509.Store.IX509Selector)">
             Sets the required constraints on the target certificate or attribute
             certificate. The constraints are specified as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> specified is cloned to protect
             against subsequent modifications.
             </p>
            
             @param selector a <code>IX509Selector</code> specifying the constraints on
                        the target certificate or attribute certificate (or
                        <code>null</code>)
             @see #getTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTrustedACIssuers">
             Returns the trusted attribute certificate issuers. If attribute
             certificates is verified the trusted AC issuers must be set.
             <p>
             The returned <code>ISet</code> consists of <code>TrustAnchor</code>s.
             </p><p>
             The returned <code>ISet</code> is immutable. Never <code>null</code>
             </p>
            
             @return Returns an immutable set of the trusted AC issuers.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTrustedACIssuers(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the trusted attribute certificate issuers. If attribute certificates
             is verified the trusted AC issuers must be set.
             <p>
             The <code>trustedACIssuers</code> must be a <code>ISet</code> of
             <code>TrustAnchor</code>
             </p><p>
             The given set is cloned.
             </p>
            
             @param trustedACIssuers The trusted AC issuers to set. Is never
                        <code>null</code>.
             @throws ClassCastException if an element of <code>stores</code> is not
                         a <code>TrustAnchor</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetNecessaryACAttributes">
             Returns the neccessary attributes which must be contained in an attribute
             certificate.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the necessary AC attributes.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetNecessaryACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the neccessary which must be contained in an attribute certificate.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param necessaryACAttributes The necessary AC attributes to set.
             @throws ClassCastException if an element of
                         <code>necessaryACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetProhibitedACAttributes">
             Returns the attribute certificates which are not allowed.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the prohibited AC attributes. Is never <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetProhibitedACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificates which are not allowed.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param prohibitedACAttributes The prohibited AC attributes to set.
             @throws ClassCastException if an element of
                         <code>prohibitedACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetAttrCertCheckers">
             Returns the attribute certificate checker. The returned set contains
             {@link PKIXAttrCertChecker}s and is immutable.
            
             @return Returns the attribute certificate checker. Is never
                     <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAttrCertCheckers(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificate checkers.
             <p>
             All elements in the <code>ISet</code> must a {@link PKIXAttrCertChecker}.
             </p>
             <p>
             The given set is cloned.
             </p>
            
             @param attrCertCheckers The attribute certificate checkers to set. Is
                        never <code>null</code>.
             @throws ClassCastException if an element of <code>attrCertCheckers</code>
                         is not a <code>PKIXAttrCertChecker</code>.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsUseDeltasEnabled">
            Whether delta CRLs should be used for checking the revocation status.
            Defaults to <code>false</code>.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.ValidityModel">
            The validity model.
            @see #CHAIN_VALIDITY_MODEL
            @see #PKIX_VALIDITY_MODEL
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsAdditionalLocationsEnabled">
             Returns if additional {@link X509Store}s for locations like LDAP found
             in certificates or CRLs should be used.
            
             @return Returns <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetInstance(Org.BouncyCastle.Pkix.PkixParameters)">
             Returns an instance of <code>PkixBuilderParameters</code>.
             <p>
             This method can be used to get a copy from other
             <code>PKIXBuilderParameters</code>, <code>PKIXParameters</code>,
             and <code>ExtendedPKIXParameters</code> instances.
             </p>
            
             @param pkixParams The PKIX parameters to create a copy of.
             @return An <code>PkixBuilderParameters</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetExcludedCerts">
            <summary>
            Excluded certificates are not used for building a certification path.
            </summary>
            <returns>the excluded certificates.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetExcludedCerts(Org.BouncyCastle.Utilities.Collections.ISet)">
            <summary>
            Sets the excluded certificates which are not used for building a
            certification path. If the <code>ISet</code> is <code>null</code> an
            empty set is assumed.
            </summary>
            <remarks>
            The given set is cloned to protect it against subsequent modifications.
            </remarks>
            <param name="excludedCerts">The excluded certificates to set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
            Can alse handle <code>ExtendedPKIXBuilderParameters</code> and
            <code>PKIXBuilderParameters</code>.
            
            @param params Parameters to set.
            @see org.bouncycastle.x509.ExtendedPKIXParameters#setParams(java.security.cert.PKIXParameters)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.Clone">
             Makes a copy of this <code>PKIXParameters</code> object. Changes to the
             copy will not affect the original and vice versa.
            
             @return a copy of this <code>PKIXParameters</code> object
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPath">
             An immutable sequence of certificates (a certification path).<br />
             <br />
             This is an abstract class that defines the methods common to all CertPaths.
             Subclasses can handle different kinds of certificates (X.509, PGP, etc.).<br />
             <br />
             All CertPath objects have a type, a list of Certificates, and one or more
             supported encodings. Because the CertPath class is immutable, a CertPath
             cannot change in any externally visible way after being constructed. This
             stipulation applies to all public fields and methods of this class and any
             added or overridden by subclasses.<br />
             <br />
             The type is a string that identifies the type of Certificates in the
             certification path. For each certificate cert in a certification path
             certPath, cert.getType().equals(certPath.getType()) must be true.<br />
             <br />
             The list of Certificates is an ordered List of zero or more Certificates.
             This List and all of the Certificates contained in it must be immutable.<br />
             <br />
             Each CertPath object must support one or more encodings so that the object
             can be translated into a byte array for storage or transmission to other
             parties. Preferably, these encodings should be well-documented standards
             (such as PKCS#7). One of the encodings supported by a CertPath is considered
             the default encoding. This encoding is used if no encoding is explicitly
             requested (for the {@link #getEncoded()} method, for instance).<br />
             <br />
             All CertPath objects are also Serializable. CertPath objects are resolved
             into an alternate {@link CertPathRep} object during serialization. This
             allows a CertPath object to be serialized into an equivalent representation
             regardless of its underlying implementation.<br />
             <br />
             CertPath objects can be created with a CertificateFactory or they can be
             returned by other classes, such as a CertPathBuilder.<br />
             <br />
             By convention, X.509 CertPaths (consisting of X509Certificates), are ordered
             starting with the target certificate and ending with a certificate issued by
             the trust anchor. That is, the issuer of one certificate is the subject of
             the following one. The certificate representing the
             {@link TrustAnchor TrustAnchor} should not be included in the certification
             path. Unvalidated X.509 CertPaths may not follow these conventions. PKIX
             CertPathValidators will detect any departure from these conventions that
             cause the certification path to be invalid and throw a
             CertPathValidatorException.<br />
             <br />
             <strong>Concurrent Access</strong><br />
             <br />
             All CertPath objects must be thread-safe. That is, multiple threads may
             concurrently invoke the methods defined in this class on a single CertPath
             object (or more than one) with no ill effects. This is also true for the List
             returned by CertPath.getCertificates.<br />
             <br />
             Requiring CertPath objects to be immutable and thread-safe allows them to be
             passed around to various pieces of code without worrying about coordinating
             access. Providing this thread-safety is generally not difficult, since the
             CertPath and List objects in question are immutable.
            
             @see CertificateFactory
             @see CertPathBuilder
            <summary>
            CertPath implementation for X.509 certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.SortCerts(System.Collections.IList)">
            @param certs
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.Collections.ICollection)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.IO.Stream,System.String)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
            
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.Equals(System.Object)">
             Compares this certification path for equality with the specified object.
             Two CertPaths are equal if and only if their types are equal and their
             certificate Lists (and by implication the Certificates in those Lists)
             are equal. A CertPath is never equal to an object that is not a CertPath.<br />
             <br />
             This algorithm is implemented by this method. If it is overridden, the
             behavior specified here must be maintained.
            
             @param other
                        the object to test for equality with this certification path
            
             @return true if the specified object is equal to this certification path,
                     false otherwise
            
             @see Object#hashCode() Object.hashCode()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded">
             Returns the encoded form of this certification path, using
             the default encoding.
            
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error occurs
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded(System.String)">
             Returns the encoded form of this certification path, using
             the specified encoding.
            
             @param encoding the name of the encoding to use
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error
             occurs or the encoding requested is not supported
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.ToAsn1Object(Org.BouncyCastle.X509.X509Certificate)">
             Return a DERObject containing the encoded certificate.
            
             @param cert the X509Certificate object to be encoded
            
             @return the DERObject
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Encodings">
             Returns an iteration of the encodings supported by this
             certification path, with the default encoding
             first. Attempts to modify the returned Iterator via its
             remove method result in an UnsupportedOperationException.
            
             @return an Iterator over the names of the supported encodings (as Strings)
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Certificates">
            <summary>
            Returns the list of certificates in this certification
            path.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilder">
             Implements the PKIX CertPathBuilding algorithm for BouncyCastle.
            
             @see CertPathBuilderSpi
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathBuilder.Build(Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilderException">
            <summary>
            Summary description for PkixCertPathBuilderException.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilderResult">
            <summary>
            Summary description for PkixCertPathBuilderResult.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorResult">
            <summary>
            Summary description for PkixCertPathValidatorResult.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Init(System.Boolean)">
                     * Initializes the internal state of this <code>PKIXCertPathChecker</code>.
                     * <p>
                     * The <code>forward</code> flag specifies the order that certificates
                     * will be passed to the {@link #check check} method (forward or reverse). A
                     * <code>PKIXCertPathChecker</code> <b>must</b> support reverse checking
                     * and <b>may</b> support forward checking.
            		 * </p>
                     * 
                     * @param forward
                     *            the order that certificates are presented to the
                     *            <code>check</code> method. If <code>true</code>,
                     *            certificates are presented from target to most-trusted CA
                     *            (forward); if <code>false</code>, from most-trusted CA to
                     *            target (reverse).
                     * @exception CertPathValidatorException
                     *                if this <code>PKIXCertPathChecker</code> is unable to
                     *                check certificates in the specified order; it should never
                     *                be thrown if the forward flag is false since reverse
                     *                checking must be supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.IsForwardCheckingSupported">
            Indicates if forward checking is supported. Forward checking refers to
            the ability of the <code>PKIXCertPathChecker</code> to perform its
            checks when certificates are presented to the <code>check</code> method
            in the forward direction (from target to most-trusted CA).
            
            @return <code>true</code> if forward checking is supported,
                    <code>false</code> otherwise
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.GetSupportedExtensions">
                     * Returns an immutable <code>Set</code> of X.509 certificate extensions
                     * that this <code>PKIXCertPathChecker</code> supports (i.e. recognizes,
                     * is able to process), or <code>null</code> if no extensions are
                     * supported.
                     * <p>
                     * Each element of the set is a <code>String</code> representing the
                     * Object Identifier (OID) of the X.509 extension that is supported. The OID
                     * is represented by a set of nonnegative integers separated by periods.
                     * </p><p>
                     * All X.509 certificate extensions that a <code>PKIXCertPathChecker</code>
                     * might possibly be able to process should be included in the set.
            		 * </p>
                     * 
                     * @return an immutable <code>Set</code> of X.509 extension OIDs (in
                     *         <code>String</code> format) supported by this
                     *         <code>PKIXCertPathChecker</code>, or <code>null</code> if no
                     *         extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Check(Org.BouncyCastle.X509.X509Certificate,System.Collections.ICollection)">
            Performs the check(s) on the specified certificate using its internal
            state and removes any critical extensions that it processes from the
            specified collection of OID strings that represent the unresolved
            critical extensions. The certificates are presented in the order
            specified by the <code>init</code> method.
            
            @param cert
                       the <code>Certificate</code> to be checked
            @param unresolvedCritExts
                       a <code>Collection</code> of OID strings representing the
                       current set of unresolved critical extensions
            @exception CertPathValidatorException
                           if the specified certificate does not pass the check
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Clone">
            Returns a clone of this object. Calls the <code>Object.clone()</code>
            method. All subclasses which maintain state must support and override
            this method, if necessary.
            
            @return a copy of this <code>PKIXCertPathChecker</code>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidator">
            The <i>Service Provider Interface</i> (<b>SPI</b>)
            for the {@link CertPathValidator CertPathValidator} class. All
            <code>CertPathValidator</code> implementations must include a class (the
            SPI class) that extends this class (<code>CertPathValidatorSpi</code>)
            and implements all of its methods. In general, instances of this class
            should only be accessed through the <code>CertPathValidator</code> class.
            For details, see the Java Cryptography Architecture.<br />
            <br />
            <b>Concurrent Access</b><br />
            <br />
            Instances of this class need not be protected against concurrent
            access from multiple threads. Threads that need to access a single
            <code>CertPathValidatorSpi</code> instance concurrently should synchronize
            amongst themselves and provide the necessary locking before calling the
            wrapping <code>CertPathValidator</code> object.<br />
            <br />
            However, implementations of <code>CertPathValidatorSpi</code> may still
            encounter concurrency issues, since multiple threads each
            manipulating a different <code>CertPathValidatorSpi</code> instance need not
            synchronize.
            <summary>
            CertPathValidatorSpi implementation for X.509 Certificate validation a la RFC
            3280.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorException">
             An exception indicating one of a variety of problems encountered when 
             validating a certification path. <br />
             <br />
             A <code>CertPathValidatorException</code> provides support for wrapping
             exceptions. The {@link #getCause getCause} method returns the throwable, 
             if any, that caused this exception to be thrown. <br />
             <br />
             A <code>CertPathValidatorException</code> may also include the 
             certification path that was being validated when the exception was thrown 
             and the index of the certificate in the certification path that caused the 
             exception to be thrown. Use the {@link #getCertPath getCertPath} and
             {@link #getIndex getIndex} methods to retrieve this information.<br />
             <br />
             <b>Concurrent Access</b><br />
             <br />
             Unless otherwise specified, the methods defined in this class are not
             thread-safe. Multiple threads that need to access a single
             object concurrently should synchronize amongst themselves and
             provide the necessary locking. Multiple threads each manipulating
             separate objects need not synchronize.
            
             @see CertPathValidator
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the given detail
            message. A detail message is a <code>String</code> that describes this
            particular exception. 
            </summary>
            <param name="message">the detail message</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message and cause.
            </summary>
            <param name="message">the detail message</param>
            <param name="cause">the cause (which is saved for later retrieval by the
            {@link #getCause getCause()} method). (A <code>null</code>
            value is permitted, and indicates that the cause is
            nonexistent or unknown.)</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception,Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message, cause, certification path, and index.
            </summary>
            <param name="message">the detail message (or <code>null</code> if none)</param>
            <param name="cause">the cause (or <code>null</code> if none)</param>
            <param name="certPath">the certification path that was in the process of being
            validated when the error was encountered</param>
            <param name="index">the index of the certificate in the certification path that</param>																																																																																   * 
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Message">
            <summary>
            Returns the detail message for this <code>CertPathValidatorException</code>.
            </summary>
            <returns>the detail message, or <code>null</code> if neither the message nor cause were specified</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.CertPath">
            Returns the certification path that was being validated when the
            exception was thrown.
            
            @return the <code>CertPath</code> that was being validated when the
                    exception was thrown (or <code>null</code> if not specified)
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Index">
            Returns the index of the certificate in the certification path that
            caused the exception to be thrown. Note that the list of certificates in
            a <code>CertPath</code> is zero based. If no index has been set, -1 is
            returned.
            
            @return the index that has been set, or -1 if none has been set
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities">
            <summary>
            Summary description for PkixCertPathValidatorUtilities.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.KEY_CERT_SIGN">
            <summary>
            key usage bits
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindTrustAnchor(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Utilities.Collections.ISet)">
            <summary>
            Search the given Set of TrustAnchor's for one that is the
            issuer of the given X509 certificate.
            </summary>
            <param name="cert">the X509 certificate</param>
            <param name="trustAnchors">a Set of TrustAnchor's</param>
            <returns>the <code>TrustAnchor</code> object if found or
            <code>null</code> if not.
            </returns>
            @exception
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetIssuerPrincipal(System.Object)">
            <summary>
            Returns the issuer of an attribute certificate or certificate.
            </summary>
            <param name="cert">The attribute certificate or certificate.</param>
            <returns>The issuer as <code>X500Principal</code>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetNextWorkingKey(System.Collections.IList,System.Int32)">
             Return the next working key inheriting DSA parameters if necessary.
             <p>
             This methods inherits DSA parameters from the indexed certificate or
             previous certificates in the certificate chain to the returned
             <code>PublicKey</code>. The list is searched upwards, meaning the end
             certificate is at position 0 and previous certificates are following.
             </p>
             <p>
             If the indexed certificate does not contain a DSA key this method simply
             returns the public key. If the DSA key already contains DSA parameters
             the key is also only returned.
             </p>
            
             @param certs The certification path.
             @param index The index of the certificate which contains the public key
                        which should be extended with DSA parameters.
             @return The public key of the certificate in list position
                     <code>index</code> extended with DSA parameters if applicable.
             @throws Exception if DSA parameters cannot be inherited.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindCertificates(Org.BouncyCastle.X509.Store.X509CertStoreSelector,System.Collections.IList)">
            <summary>
            Return a Collection of all certificates or attribute certificates found
            in the X509Store's that are matching the certSelect criteriums.
            </summary>
            <param name="certSelect">a {@link Selector} object that will be used to select
            the certificates</param>
            <param name="certStores">a List containing only X509Store objects. These
            are used to search for certificates.</param>
            <returns>a Collection of all found <see cref="T:Org.BouncyCastle.X509.X509Certificate"/> or
            org.bouncycastle.x509.X509AttributeCertificate objects.
            May be empty but never <code>null</code>.</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCrlIssuersFromDistributionPoint(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Collections.ICollection,Org.BouncyCastle.X509.Store.X509CrlStoreSelector,Org.BouncyCastle.Pkix.PkixParameters)">
             Add the CRL issuers from the cRLIssuer field of the distribution point or
             from the certificate if not given to the issuer criterion of the
             <code>selector</code>.
             <p>
             The <code>issuerPrincipals</code> are a collection with a single
             <code>X500Principal</code> for <code>X509Certificate</code>s. For
             {@link X509AttributeCertificate}s the issuer may contain more than one
             <code>X500Principal</code>.
             </p>
            
             @param dp The distribution point.
             @param issuerPrincipals The issuers of the certificate or attribute
                        certificate which contains the distribution point.
             @param selector The CRL selector.
             @param pkixParams The PKIX parameters containing the cert stores.
             @throws Exception if an exception occurs while processing.
             @throws ClassCastException if <code>issuerPrincipals</code> does not
             contain only <code>X500Principal</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCompleteCrls(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,System.DateTime,Org.BouncyCastle.Pkix.PkixParameters)">
             Fetches complete CRLs according to RFC 3280.
            
             @param dp The distribution point for which the complete CRL
             @param cert The <code>X509Certificate</code> or
                        {@link org.bouncycastle.x509.X509AttributeCertificate} for
                        which the CRL should be searched.
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @return A <code>Set</code> of <code>X509CRL</code>s with complete
                     CRLs.
             @throws Exception if an exception occurs while picking the CRLs
                         or no CRLs are found.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetDeltaCrls(System.DateTime,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Crl)">
             Fetches delta CRLs according to RFC 3280 section 5.2.4.
            
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @param completeCRL The complete CRL the delta CRL is for.
             @return A <code>Set</code> of <code>X509CRL</code>s with delta CRLs.
             @throws Exception if an exception occurs while picking the delta
                         CRLs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindIssuerCerts(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Find the issuer certificates of a given certificate.
            
             @param cert
                        The certificate for which an issuer should be found.
             @param pkixParams
             @return A <code>Collection</code> object containing the issuer
                     <code>X509Certificate</code>s. Never <code>null</code>.
            
             @exception Exception
                            if an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetExtensionValue(Org.BouncyCastle.X509.IX509Extension,Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Extract the value of the given extension, if it exists.
            </summary>
            <param name="ext">The extension object.</param>
            <param name="oid">The object identifier to obtain.</param>
            <returns>Asn1Object</returns>
            <exception cref="T:System.Exception">if the extension cannot be read.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIP(Org.BouncyCastle.Utilities.Collections.ISet,Org.BouncyCastle.Utilities.Collections.ISet)">
             Returns the intersection of the permitted IP ranges in
             <code>permitted</code> with <code>ip</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ips       The IP address with its subnet mask.
             @return The <code>Set</code> of permitted IP ranges intersected with
                     <code>ip</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Returns the union of the excluded IP ranges in <code>excluded</code>
             with <code>ip</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address with its subnet mask.
             @return The <code>Set</code> of excluded IP ranges unified with
                     <code>ip</code> as byte arrays.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIPRange(System.Byte[],System.Byte[])">
             Calculates the union if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the union of both addresses.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIPRange(System.Byte[],System.Byte[])">
             Calculates the interesction if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the single IP address with its subnet
                     mask as a byte array or an empty <code>Set</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IpWithSubnetMask(System.Byte[],System.Byte[])">
             Concatenates the IP address with its subnet mask.
            
             @param ip         The IP address.
             @param subnetMask Its subnet mask.
             @return The concatenated IP address with its subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.ExtractIPsAndSubnetMasks(System.Byte[],System.Byte[])">
             Splits the IP addresses and their subnet mask.
            
             @param ipWithSubmask1 The first IP address with the subnet mask.
             @param ipWithSubmask2 The second IP address with the subnet mask.
             @return An array with two elements. Each element contains the IP address
                     and the subnet mask in this order.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.MinMaxIPs(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
             Based on the two IP addresses and their subnet masks the IP range is
             computed for each IP address - subnet mask pair and returned as the
             minimum IP address and the maximum address of the range.
            
             @param ip1         The first IP address.
             @param subnetmask1 The subnet mask of the first IP address.
             @param ip2         The second IP address.
             @param subnetmask2 The subnet mask of the second IP address.
             @return A array with two elements. The first/second element contains the
                     min and max IP address of the first/second IP address and its
                     subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CheckPermittedIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Checks if the IP <code>ip</code> is included in the permitted ISet
             <code>permitted</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ip        The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is not permitted.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcludedIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Checks if the IP <code>ip</code> is included in the excluded ISet
             <code>excluded</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IsIPConstrained(System.Byte[],System.Byte[])">
             Checks if the IP address <code>ip</code> is constrained by
             <code>constraint</code>.
            
             @param ip         The IP address.
             @param constraint The constraint. This is an IP address concatenated with
                               its subnetmask.
             @return <code>true</code> if constrained, <code>false</code>
                     otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.unionEmail(System.String,System.String,Org.BouncyCastle.Utilities.Collections.ISet)">
             The common part of <code>email1</code> and <code>email2</code> is
             added to the union <code>union</code>. If <code>email1</code> and
             <code>email2</code> have nothing in common they are added both.
            
             @param email1 Email address constraint 1.
             @param email2 Email address constraint 2.
             @param union  The union.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.intersectEmail(System.String,System.String,Org.BouncyCastle.Utilities.Collections.ISet)">
             The most restricting part from <code>email1</code> and
             <code>email2</code> is added to the intersection <code>intersect</code>.
            
             @param email1    Email address constraint 1.
             @param email2    Email address constraint 2.
             @param intersect The intersection.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkPermitted(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Checks if the given GeneralName is in the permitted ISet.
            
             @param name The GeneralName
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcluded(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Check if the given GeneralName is contained in the excluded ISet.
            
             @param name The GeneralName.
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code> is
                      excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectPermittedSubtree(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Updates the permitted ISet of these name constraints with the intersection
             with the given subtree.
            
             @param permitted The permitted subtrees
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.AddExcludedSubtree(Org.BouncyCastle.Asn1.X509.GeneralSubtree)">
             Adds a subtree to the excluded ISet of these name constraints.
            
             @param subtree A subtree with an excluded GeneralName.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Max(System.Byte[],System.Byte[])">
             Returns the maximum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The maximum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Min(System.Byte[],System.Byte[])">
             Returns the minimum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The minimum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CompareTo(System.Byte[],System.Byte[])">
             Compares IP address <code>ip1</code> with <code>ip2</code>. If ip1
             is equal to ip2 0 is returned. If ip1 is bigger 1 is returned, -1
             otherwise.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return 0 if ip1 is equal to ip2, 1 if ip1 is bigger, -1 otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Or(System.Byte[],System.Byte[])">
             Returns the logical OR of the IP addresses <code>ip1</code> and
             <code>ip2</code>.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The OR of <code>ip1</code> and <code>ip2</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.StringifyIP(System.Byte[])">
             Stringifies an IPv4 or v6 address with subnet mask.
            
             @param ip The IP with subnet mask.
             @return The stringified IP address.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixPolicyNode">
            <summary>
            Summary description for PkixPolicyNode.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixPolicyNode.#ctor(System.Collections.IList,System.Int32,Org.BouncyCastle.Utilities.Collections.ISet,Org.BouncyCastle.Pkix.PkixPolicyNode,Org.BouncyCastle.Utilities.Collections.ISet,System.String,System.Boolean)">
            Constructors
        </member>
        <member name="T:Org.BouncyCastle.Pkix.ReasonsMask">
            <summary>
            This class helps to handle CRL revocation reasons mask. Each CRL handles a
            certain set of revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor(System.Int32)">
            <summary>
            Constructs are reason mask with the reasons.
            </summary>
            <param name="reasons">The reasons.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor">
            <summary>
            A reason mask with no reason.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.ReasonsMask.AllReasons">
            <summary>
            A mask with all revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.AddReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
             Adds all reasons from the reasons mask to this mask.
            
             @param mask The reasons mask to add.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.Intersect(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Intersects this mask with the given reasons mask.
            </summary>
            <param name="mask">mask The mask to intersect with.</param>
            <returns>The intersection of this and teh given mask.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.HasNewReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Returns <c>true</c> if the passed reasons mask has new reasons.
            </summary>
            <param name="mask">The reasons mask which should be tested for new reasons.</param>
            <returns><c>true</c> if the passed reasons mask has new reasons.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.IsAllReasons">
            <summary>
            Returns <code>true</code> if this reasons mask contains all possible
            reasons.
            </summary>
            <returns>true if this reasons mask contains all possible reasons.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.Reasons">
            <summary>
            Returns the reasons in this mask.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB2(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.X509.X509Crl)">
             If the complete CRL includes an issuing distribution point (IDP) CRL
             extension check the following:
             <p>
             (i) If the distribution point name is present in the IDP CRL extension
             and the distribution field is present in the DP, then verify that one of
             the names in the IDP matches one of the names in the DP. If the
             distribution point name is present in the IDP CRL extension and the
             distribution field is omitted from the DP, then verify that one of the
             names in the IDP matches one of the names in the cRLIssuer field of the
             DP.
             </p>
             <p>
             (ii) If the onlyContainsUserCerts boolean is asserted in the IDP CRL
             extension, verify that the certificate does not include the basic
             constraints extension with the cA boolean asserted.
             </p>
             <p>
             (iii) If the onlyContainsCACerts boolean is asserted in the IDP CRL
             extension, verify that the certificate includes the basic constraints
             extension with the cA boolean asserted.
             </p>
             <p>
             (iv) Verify that the onlyContainsAttributeCerts boolean is not asserted.
             </p>
            
             @param dp   The distribution point.
             @param cert The certificate.
             @param crl  The CRL.
             @throws AnnotatedException if one of the conditions is not met or an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB1(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.X509.X509Crl)">
             If the DP includes cRLIssuer, then verify that the issuer field in the
             complete CRL matches cRLIssuer in the DP and that the complete CRL
             contains an
                  g distribution point extension with the indirectCRL
             boolean asserted. Otherwise, verify that the CRL issuer matches the
             certificate issuer.
            
             @param dp   The distribution point.
             @param cert The certificate ot attribute certificate.
             @param crl  The CRL for <code>cert</code>.
             @throws AnnotatedException if one of the above conditions does not apply or an error
                                        occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlF(Org.BouncyCastle.X509.X509Crl,System.Object,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Pkix.PkixParameters,System.Collections.IList)">
             Obtain and validate the certification path for the complete CRL issuer.
             If a key usage extension is present in the CRL issuer's certificate,
             verify that the cRLSign bit is set.
            
             @param crl                CRL which contains revocation information for the certificate
                                       <code>cert</code>.
             @param cert               The attribute certificate or certificate to check if it is
                                       revoked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param paramsPKIX         paramsPKIX PKIX parameters.
             @param certPathCerts      The certificates on the certification path.
             @return A <code>Set</code> with all keys of possible CRL issuer
                     certificates.
             @throws AnnotatedException if the CRL is not valid or the status cannot be checked or
                                        some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.IList)">
             Checks a distribution point for revocation information for the
             certificate <code>cert</code>.
            
             @param dp                 The distribution point to consider.
             @param paramsPKIX         PKIX parameters.
             @param cert               Certificate to check if it is revoked.
             @param validDate          The date when the certificate revocation status should be
                                       checked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param certStatus         The current certificate revocation status.
             @param reasonMask         The reasons mask which is already checked.
             @param certPathCerts      The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrls(Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.IList)">
             Checks a certificate if it is revoked.
            
             @param paramsPKIX       PKIX parameters.
             @param cert             Certificate to check if it is revoked.
             @param validDate        The date when the certificate revocation status should be
                                     checked.
             @param sign             The issuer certificate of the certificate <code>cert</code>.
             @param workingPublicKey The public key of the issuer certificate <code>sign</code>.
             @param certPathCerts    The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlC(Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.Pkix.PkixParameters)">
             If use-deltas is set, verify the issuer and scope of the delta CRL.
            
             @param deltaCRL    The delta CRL.
             @param completeCRL The complete CRL.
             @param pkixParams  The PKIX paramaters.
             @throws AnnotatedException if an exception occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrls(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,System.Collections.IList)">
            Checks if an attribute certificate is revoked.
            
            @param attrCert Attribute certificate to check if it is revoked.
            @param paramsPKIX PKIX parameters.
            @param issuerCert The issuer certificate of the attribute certificate
                       <code>attrCert</code>.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            
            @throws CertPathValidatorException if the certificate is revoked or the
                        status cannot be checked or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.ProcessAttrCert1(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters)">
            Searches for a holder public key certificate and verifies its
            certification path.
            
            @param attrCert the attribute certificate.
            @param pkixParams The PKIX parameters.
            @return The certificate path of the holder certificate.
            @throws Exception if
                        <ul>
                        <li>no public key certificate can be found although holder
                        information is given by an entity name or a base certificate
                        ID</li>
                        <li>support classes cannot be created</li>
                        <li>no certification path for the public key certificate can
                        be built</li>
                        </ul>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.IList)">
            
            Checks a distribution point for revocation information for the
            certificate <code>attrCert</code>.
            
            @param dp The distribution point to consider.
            @param attrCert The attribute certificate which should be checked.
            @param paramsPKIX PKIX parameters.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param issuerCert Certificate to check if it is revoked.
            @param reasonMask The reasons mask which is already checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            @throws Exception if the certificate is revoked or the status
                        cannot be checked or some error occurs.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.TrustAnchor">
            <summary>
            A trust anchor or most-trusted Certification Authority (CA).
            
            This class represents a "most-trusted CA", which is used as a trust anchor
            for validating X.509 certification paths. A most-trusted CA includes the
            public key of the CA, the CA's name, and any constraints upon the set of
            paths which may be validated using this key. These parameters can be
            specified in the form of a trusted X509Certificate or as individual
            parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.X509.X509Certificate,System.Byte[])">
             <summary>
             Creates an instance of TrustAnchor with the specified X509Certificate and
             optional name constraints, which are intended to be used as additional
             constraints when validating an X.509 certification path.
            	The name constraints are specified as a byte array. This byte array
            	should contain the DER encoded form of the name constraints, as they
            	would appear in the NameConstraints structure defined in RFC 2459 and
            	X.509. The ASN.1 definition of this structure appears below.
            	
            	<pre>
            	NameConstraints ::= SEQUENCE {
            		permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
            		excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
            	   
             GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
             
            		GeneralSubtree ::= SEQUENCE {
            		base                    GeneralName,
            		minimum         [0]     BaseDistance DEFAULT 0,
            		maximum         [1]     BaseDistance OPTIONAL }
            		
            		BaseDistance ::= INTEGER (0..MAX)
            
            		GeneralName ::= CHOICE {
            		otherName                       [0]     OtherName,
            		rfc822Name                      [1]     IA5String,
            		dNSName                         [2]     IA5String,
            		x400Address                     [3]     ORAddress,
            		directoryName                   [4]     Name,
            		ediPartyName                    [5]     EDIPartyName,
            		uniformResourceIdentifier       [6]     IA5String,
            		iPAddress                       [7]     OCTET STRING,
            		registeredID                    [8]     OBJECT IDENTIFIER}
            	</pre>
            	
            	Note that the name constraints byte array supplied is cloned to protect
            	against subsequent modifications.
             </summary>
             <param name="trustedCert">a trusted X509Certificate</param>
             <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
             NameConstraints extension to be used for checking name
             constraints. Only the value of the extension is included, not
             the OID or criticality flag. Specify null to omit the
             parameter.</param>
             <exception cref="T:System.ArgumentNullException">if the specified X509Certificate is null</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <c>TrustAnchor</c> where the
            most-trusted CA is specified as an X500Principal and public key.
            </summary>
            <remarks>
            <p>
            Name constraints are an optional parameter, and are intended to be used
            as additional constraints when validating an X.509 certification path.
            </p><p>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they
            would appear in the NameConstraints structure defined in RFC 2459
            and X.509. The ASN.1 notation for this structure is supplied in the
            documentation for the other constructors.
            </p><p>
            Note that the name constraints byte array supplied here is cloned to
            protect against subsequent modifications.
            </p>
            </remarks>
            <param name="caPrincipal">the name of the most-trusted CA as X509Name</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">
            a byte array containing the ASN.1 DER encoding of a NameConstraints extension to
            be used for checking name constraints. Only the value of the extension is included,
            not the OID or criticality flag. Specify <c>null</c> to omit the parameter.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if <c>caPrincipal</c> or <c>pubKey</c> is null
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <code>TrustAnchor</code> where the most-trusted
            CA is specified as a distinguished name and public key. Name constraints
            are an optional parameter, and are intended to be used as additional
            constraints when validating an X.509 certification path.
            <br/>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they would
            appear in the NameConstraints structure defined in RFC 2459 and X.509.
            </summary>
            <param name="caName">the X.500 distinguished name of the most-trusted CA in RFC
            2253 string format</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
            NameConstraints extension to be used for checking name
            constraints. Only the value of the extension is included, not 
            the OID or criticality flag. Specify null to omit the 
            parameter.</param>
            throws NullPointerException, IllegalArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.setNameConstraints(System.Byte[])">
            <summary>
            Decode the name constraints and clone them if not null.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.ToString">
            <summary>
            Returns a formatted string describing the <code>TrustAnchor</code>.
            </summary>
            <returns>a formatted string describing the <code>TrustAnchor</code></returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.TrustedCert">
            <summary>
            Returns the most-trusted CA certificate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CA">
            <summary>
            Returns the name of the most-trusted CA as an X509Name.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAName">
            <summary>
            Returns the name of the most-trusted CA in RFC 2253 string format.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAPublicKey">
            <summary>
            Returns the public key of the most-trusted CA.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Security.AgreementUtilities">
            <remarks>
             Utility class for creating IBasicAgreement objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.CipherUtilities">
            <remarks>
             Cipher Utility class contains methods that can not be specifically grouped into other classes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.CipherUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.DotNetUtilities">
            <summary>
            A class containing methods to interface the BouncyCastle world to the .NET Crypto world.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.DotNetUtilities.ToX509Certificate(Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
            <summary>
            Create an System.Security.Cryptography.X509Certificate from an X509Certificate Structure.
            </summary>
            <param name="x509Struct"></param>
            <returns>A System.Security.Cryptography.X509Certificate.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.MacUtilities">
            <remarks>
             Utility class for creating HMac object from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.PbeUtilities">
             <summary>
            
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.PbeUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor(System.String)">
             create a SecurityUtilityException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.WrapperUtilities">
            <remarks>
             Utility class for creating IWrapper objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampRequest">
            Base class for an RFC 3161 Time Stamp Request.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.Byte[])">
             Create a TimeStampRequest from the past in byte array.
            
             @param req byte array containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.IO.Stream)">
             Create a TimeStampRequest from the past in input stream.
            
             @param in input stream containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.Validate(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
             Validate the timestamp request, checking the digest to see if it is of an
             accepted type and whether it is of the correct length for the algorithm specified.
            
             @param algorithms a set of string OIDS giving accepted algorithms.
             @param policies if non-null a set of policies we are willing to sign under.
             @param extensions if non-null a set of extensions we are willing to accept.
             @throws TspException if the request is invalid, or processing fails.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampRequestGenerator">
            Generator for RFC 3161 Time Stamp Request objects.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 3)
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag
            The value parameter becomes the contents of the octet string associated
            with the extension.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 3)
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag
            The value parameter becomes the contents of the octet string associated
            with the extension.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampResponse">
            Base class for an RFC 3161 Time Stamp Response object.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.Byte[])">
             Create a TimeStampResponse from a byte array containing an ASN.1 encoding.
            
             @param resp the byte array containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the byte array doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.IO.Stream)">
             Create a TimeStampResponse from an input stream containing an ASN.1 encoding.
            
             @param input the input stream containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the stream doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.Validate(Org.BouncyCastle.Tsp.TimeStampRequest)">
             Check this response against to see if it a well formed response for
             the passed in request. Validation will include checking the time stamp
             token if the response status is GRANTED or GRANTED_WITH_MODS.
            
             @param request the request to be checked against
             @throws TspException if the request can not match this response.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampResponseGenerator">
            Generator for RFC 3161 Time Stamp Responses.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponseGenerator.Generate(Org.BouncyCastle.Tsp.TimeStampRequest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Utilities.Date.DateTimeObject)">
             Return an appropriate TimeStampResponse.
             <p>
             If genTime is null a timeNotAvailable error response will be returned.
            
             @param request the request this response is for.
             @param serialNumber serial number for the response token.
             @param genTime generation time for the response token.
             @param provider provider to use for signature calculation.
             @return
             @throws NoSuchAlgorithmException
             @throws NoSuchProviderException
             @throws TSPException
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponseGenerator.GenerateFailResponse(Org.BouncyCastle.Asn1.Cmp.PkiStatus,System.Int32,System.String)">
             Generate a TimeStampResponse with chosen status and FailInfoField.
            
             @param status the PKIStatus to set.
             @param failInfoField the FailInfoField to set.
             @param statusString an optional string describing the failure.
             @return a TimeStampResponse with a failInfoField and optional statusString
             @throws TSPException in case the response could not be created
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.Validate(Org.BouncyCastle.X509.X509Certificate)">
            Validate the time stamp token.
            <p>
            To be valid the token must be signed by the passed in certificate and
            the certificate must be the one referred to by the SigningCertificate
            attribute included in the hashed attributes of the token. The
            certificate must also have the ExtendedKeyUsageExtension with only
            KeyPurposeID.IdKPTimeStamping and have been valid at the time the
            timestamp was created.
            </p>
            <p>
            A successful call to validate means all the above are true.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.ToCmsSignedData">
             Return the underlying CmsSignedData object.
            
             @return the underlying CMS structure.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.GetEncoded">
             Return a ASN.1 encoded byte stream representing the encoded object.
            
             @throws IOException if encoding fails.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            basic creation - only the default attributes will be included here.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            create with a signer with extra signed/unsigned attributes.
        </member>
        <member name="P:Org.BouncyCastle.Tsp.TimeStampTokenInfo.Nonce">
            @return the nonce value, null if there isn't one.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TspAlgorithms">
            Recognised hash algorithms for the time stamp protocol.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.GetSignatureTimestamps(Org.BouncyCastle.Cms.SignerInformation)">
             Fetches the signature time-stamp attributes from a SignerInformation object.
             Checks that the MessageImprint for each time-stamp matches the signature field.
             (see RFC 3161 Appendix A).
            
             @param signerInfo a SignerInformation to search for time-stamps
             @return a collection of TimeStampToken objects
             @throws TSPValidationException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.ValidateCertificate(Org.BouncyCastle.X509.X509Certificate)">
             Validate the passed in certificate as being of the correct type to be used
             for time stamping. To be valid it must have an ExtendedKeyUsage extension
             which has a key purpose identifier of id-kp-timeStamping.
            
             @param cert the certificate of interest.
             @throws TspValidationException if the certicate fails on one of the check points.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.GetDigestAlgName(System.String)">
            <summary>
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TspValidationException">
            Exception thrown if a TSP request or response fails to validate.
            <p>
            If a failure code is associated with the exception it can be retrieved using
            the getFailureCode() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Tsp.TspValidationException.FailureCode">
             Return the failure code associated with this exception - if one is set.
            
             @return the failure code if set, -1 otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.BZip2Constants">
             Base class for both the compress and decompress classes.
             Holds common arrays, and static data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CBZip2InputStream">
             An input stream that decompresses from the BZip2 format (with the file
             header chars) to be read as any other stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             <b>NB:</b> note this class has been modified to read the leading BZ from the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CRC">
             A simple class the hold and calculate the CRC for sanity checking
             of the data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <param name="dateTime">A UTC DateTime value not before epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentException">'dateTime' is before epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a base 64 output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.DecodeString(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder">
            <summary>
             A buffering class to allow translation from one format to another to
                be done in discrete chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create a buffered Decoder.
            </summary>
            <param name="translator">The translater to use.</param>
            <param name="bufferSize">The size of the buffer.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">Data in.</param>
            <param name="output">Byte array for the output.</param>
            <param name="outOff">The offset in the output byte array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">The input data.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of data to process from input data array.</param>
            <param name="outBytes">Array to store output.</param>
            <param name="outOff">Position in output array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder">
            <summary>
            A class that allows encoding of data using a specific encoder to be processed in chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create.
            </summary>
            <param name="translator">The translator to use.</param>
            <param name="bufferSize">Size of the chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">The byte.</param>
            <param name="outBytes">An array to store output in.</param>
            <param name="outOff">Offset within output array to start writing from.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">Input data Byte array containing data to be processed.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of input data to be processed.</param>
            <param name="outBytes">Output data array.</param>
            <param name="outOff">Offset within output data array to start writing to.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.HexTranslator">
            <summary>
            A hex translator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.ITranslator">
            <summary>
            Translator interface.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetEncodedBlockSize">
            <summary>
            Return encoded block size.
            </summary>
            <returns>2</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Encode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode some data.
            </summary>
            <param name="input">Input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amount of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The offset within the output data array to start writing from.</param>
            <returns>Amount of data encoded.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetDecodedBlockSize">
            <summary>
            Returns the decoded block size.
            </summary>
            <returns>1</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Decode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decode data from a byte array.
            </summary>
            <param name="input">The input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amounty of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The position within the output data array to start writing from.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[])">
             Encode the input data producing a URL safe base 64 encoded byte array.
            
             @return a byte array containing the URL safe base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[])">
             Decode the URL safe base 64 encoded input data - white space will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[],System.IO.Stream)">
             decode the URL safe base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String)">
             decode the URL safe base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String,System.IO.Stream)">
             Decode the URL safe base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Zlib.ZDeflaterOutputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Zlib.ZInflaterInputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateHolder">
            <remarks>
            The Holder object.
            <pre>
            Holder ::= SEQUENCE {
            	baseCertificateID   [0] IssuerSerial OPTIONAL,
            		-- the issuer and serial number of
            		-- the holder's Public Key Certificate
            	entityName          [1] GeneralNames OPTIONAL,
            		-- the name of the claimant or role
            	objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
            		-- used to directly authenticate the holder,
            		-- for example, an executable
            }
            </pre>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.#ctor(System.Int32,System.String,System.String,System.Byte[])">
             Constructs a holder for v2 attribute certificates with a hash value for
             some type of object.
             <p>
             <code>digestedObjectType</code> can be one of the following:
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
             <p>This cannot be used if a v1 attribute certificate is used.</p>
            
             @param digestedObjectType The digest object type.
             @param digestAlgorithm The algorithm identifier for the hash.
             @param otherObjectTypeID The object type ID if
                        <code>digestedObjectType</code> is
                        <code>otherObjectDigest</code>.
             @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetObjectDigest">
             Returns the hash if an object digest info is used.
            
             @return The hash or <code>null</code> if no object digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetEntityNames">
             Return any principal objects inside the attribute certificate holder entity names field.
            
             @return an array of IPrincipal objects (usually X509Name), null if no entity names field is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetIssuer">
             Return the principals associated with the issuer attached to this holder
            
             @return an array of principals, null if no BaseCertificateID is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestedObjectType">
             Returns the digest object type if an object digest info is used.
             <p>
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
            
             @return The digest object type or -1 if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestAlgorithm">
             Returns the other object type ID if an object digest info is used.
            
             @return The other object type ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.OtherObjectTypeID">
             Returns the digest algorithm ID if an object digest info is used.
            
             @return The digest algorithm ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.SerialNumber">
             Return the serial number associated with the issuer attached to this holder.
            
             @return the certificate serial number, null if no BaseCertificateID is set.
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateIssuer">
            Carrying class for an attribute certificate issuer.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.#ctor(Org.BouncyCastle.Asn1.X509.AttCertIssuer)">
             Set the issuer directly with the ASN.1 structure.
            
             @param issuer The issuer
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.GetPrincipals">
            <summary>Return any principal objects inside the attribute certificate issuer object.</summary>
            <returns>An array of IPrincipal objects (usually X509Principal).</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure">
            <remarks>A high level authority key identifier.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.X509.X509Certificate)">
             Create an AuthorityKeyIdentifier using the passed in certificate's public
             key, issuer and serial number.
            
             @param certificate the certificate providing the information.
             @throws CertificateParsingException if there is a problem processing the certificate
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Create an AuthorityKeyIdentifier using just the hash of the
             public key.
            
             @param pubKey the key to generate the hash from.
             @throws InvalidKeyException if there is a problem using the key.
        </member>
        <member name="T:Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure">
            A high level subject key identifier.
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="T:Org.BouncyCastle.X509.IX509AttributeCertificate">
            <remarks>Interface for an X.509 Attribute Certificate.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetAttributes">
            <summary>Return the attributes contained in the attribute block in the certificate.</summary>
            <returns>An array of attributes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetAttributes(System.String)">
            <summary>Return the attributes with the same type as the passed in oid.</summary>
            <param name="oid">The object identifier we wish to match.</param>
            <returns>An array of matched attributes, null if there is no match.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetEncoded">
            <summary>Return an ASN.1 encoded byte array representing the attribute certificate.</summary>
            <returns>An ASN.1 encoded byte array.</returns>
            <exception cref="T:System.IO.IOException">If the certificate cannot be encoded.</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Version">
            <summary>The version number for the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.SerialNumber">
            <summary>The serial number for the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.NotBefore">
            <summary>The UTC DateTime before which the certificate is not valid.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.NotAfter">
            <summary>The UTC DateTime after which the certificate is not valid.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Holder">
            <summary>The holder of the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Issuer">
            <summary>The issuer details for the certificate.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.PrincipalUtilities">
            <remarks>
            A utility class that will extract X509Principal objects from X.509 certificates.
            <p>
            Use this in preference to trying to recreate a principal from a string, not all
            DNs are what they should be, so it's best to leave them encoded where they
            can be.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the issuer of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetSubjectX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the subject of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Crl)">
            <summary>Return the issuer of the given CRL as an X509Principal.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector">
             This class is an <code>Selector</code> like implementation to select
             attribute certificates from a given set of criteria.
            
             @see org.bouncycastle.x509.X509AttributeCertificate
             @see org.bouncycastle.x509.X509Store
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Match(System.Object)">
            <summary>
            Decides if the given attribute certificate should be selected.
            </summary>
            <param name="obj">The attribute certificate to be checked.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name The name as a GeneralName (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(System.Byte[])">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the name in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetNames(System.Collections.IEnumerable)">
            Adds a collection with target names criteria. If <code>null</code> is
            given any will do.
            <p>
            The collection consists of either GeneralName objects or byte[] arrays representing
            DER encoded GeneralName structures.
            </p>
            
            @param names A collection of target names.
            @throws IOException if a parsing error occurs.
            @see #AddTargetName(byte[])
            @see #AddTargetName(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetNames">
            Gets the target names. The collection consists of <code>List</code>s
            made up of an <code>Integer</code> in the first entry and a DER encoded
            byte array or a <code>String</code> in the second entry.
            <p>The returned collection is immutable.</p>
            
            @return The collection of target names
            @see #setTargetNames(Collection)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param group The group as GeneralName form (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(System.Byte[])">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the group in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetGroups(System.Collections.IEnumerable)">
             Adds a collection with target groups criteria. If <code>null</code> is
             given any will do.
             <p>
             The collection consists of <code>GeneralName</code> objects or <code>byte[]</code>
             representing DER encoded GeneralNames.
             </p>
            
             @param names A collection of target groups.
             @throws IOException if a parsing error occurs.
             @see #AddTargetGroup(byte[])
             @see #AddTargetGroup(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetGroups">
             Gets the target groups. The collection consists of <code>List</code>s
             made up of an <code>Integer</code> in the first entry and a DER encoded
             byte array or a <code>String</code> in the second entry.
             <p>The returned collection is immutable.</p>
            
             @return The collection of target groups.
             @see #setTargetGroups(Collection)
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCert">
            <summary>The attribute certificate which must be matched.</summary>
            <remarks>If <c>null</c> is given, any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCertificateValid">
            <summary>The criteria for validity</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Holder">
            <summary>The holder.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Issuer">
            <summary>The issuer.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SerialNumber">
            <summary>The serial number.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector">
            <remarks>
            This class is an <code>IX509Selector</code> implementation to select
            certificate pairs, which are e.g. used for cross certificates. The set of
            criteria is given from two <code>X509CertStoreSelector</code> objects,
            each of which, if present, must match the respective component of a pair.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.Match(System.Object)">
            <summary>
            Decides if the given certificate pair should be selected. If
            <c>obj</c> is not a <code>X509CertificatePair</code>, this method
            returns <code>false</code>.
            </summary>
            <param name="obj">The <code>X509CertificatePair</code> to be tested.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.CertPair">
            <summary>The certificate pair which is used for testing on equality.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ForwardSelector">
            <summary>The certificate selector for the forward part.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ReverseSelector">
            <summary>The certificate selector for the reverse part.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CollectionStore">
            A simple collection backed store.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStore.#ctor(System.Collections.ICollection)">
             Basic constructor.
            
             @param collection - initial contents for the store, this is copied.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStore.GetMatches(Org.BouncyCastle.X509.Store.IX509Selector)">
             Return the matches in the collection for the passed in selector.
            
             @param selector the selector to match against.
             @return a possibly empty collection of matching objects.
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters">
            <remarks>This class contains a collection for collection based <code>X509Store</code>s.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.#ctor(System.Collections.ICollection)">
            <summary>
            Constructor.
            <p>
            The collection is copied.
            </p>
            </summary>
            <param name="collection">The collection containing X.509 object types.</param>
            <exception cref="T:System.ArgumentNullException">If collection is null.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.GetCollection">
            <summary>Returns a copy of the <code>ICollection</code>.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.ToString">
            <summary>Returns a formatted string describing the parameters.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.Issuers">
            <summary>
            An <code>ICollection</code> of <code>X509Name</code> objects
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.AttrCertChecking">
             The attribute certificate being checked. This is not a criterion.
             Rather, it is optional information that may help a {@link X509Store} find
             CRLs that would be relevant when checking revocation for the specified
             attribute certificate. If <code>null</code> is specified, then no such
             optional information is provided.
            
             @param attrCert the <code>IX509AttributeCertificate</code> being checked (or
                         <code>null</code>)
             @see #getAttrCertificateChecking()
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.CompleteCrlEnabled">
             If <code>true</code> only complete CRLs are returned. Defaults to
             <code>false</code>.
            
             @return <code>true</code> if only complete CRLs are returned.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.DeltaCrlIndicatorEnabled">
             Returns if this selector must match CRLs with the delta CRL indicator
             extension set. Defaults to <code>false</code>.
            
             @return Returns <code>true</code> if only CRLs with the delta CRL
                     indicator extension are selected.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPoint">
             The issuing distribution point.
             <p>
             The issuing distribution point extension is a CRL extension which
             identifies the scope and the distribution point of a CRL. The scope
             contains among others information about revocation reasons contained in
             the CRL. Delta CRLs and complete CRLs must have matching issuing
             distribution points.</p>
             <p>
             The byte array is cloned to protect against subsequent modifications.</p>
             <p>
             You must also enable or disable this criteria with
             {@link #setIssuingDistributionPointEnabled(bool)}.</p>
            
             @param issuingDistributionPoint The issuing distribution point to set.
                                             This is the DER encoded OCTET STRING extension value.
             @see #getIssuingDistributionPoint()
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPointEnabled">
             Whether the issuing distribution point criteria should be applied.
             Defaults to <code>false</code>.
             <p>
             You may also set the issuing distribution point criteria if not a missing
             issuing distribution point should be assumed.</p>
            
             @return Returns if the issuing distribution point check is enabled.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.MaxBaseCrlNumber">
             The maximum base CRL number. Defaults to <code>null</code>.
            
             @return Returns the maximum base CRL number.
             @see #setMaxBaseCRLNumber(BigInteger)
        </member>
        <member name="T:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory">
            <summary>
            A factory to produce Public Key Info Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a Subject Public Key Info object for a given public key.
            </summary>
            <param name="key">One of ElGammalPublicKeyParameters, DSAPublicKeyParameter, DHPublicKeyParameters, RsaKeyParameters or ECPublicKeyParameters</param>
            <returns>A subject public key info object.</returns>
            <exception cref="T:System.Exception">Throw exception if object provided is not one of the above.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Attribute">
            Class for carrying the values in an X.509 Attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param at an object representing an attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create an X.509 Attribute with the type given by the passed in oid and
             the value represented by an ASN.1 Set containing value.
            
             @param oid type of the attribute
             @param value value object to go into the atribute's value set.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Create an X.59 Attribute with the type given by the passed in oid and the
             value represented by an ASN.1 Set containing the objects in value.
            
             @param oid type of the attribute
             @param value vector of values to go in the attribute's value set.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return a Der encoded version of this certificate.
            </summary>
            <returns>A byte array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CertificatePair">
            <remarks>
            This class contains a cross certificate pair. Cross certificates pairs may
            contain two cross signed certificates from two CAs. A certificate from the
            other CA to this CA is contained in the forward certificate, the certificate
            from this CA to the other CA is contained in the reverse certificate.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificatePair.#ctor(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate)">
            <summary>Constructor</summary>
            <param name="forward">Certificate from the other CA to this CA.</param>
            <param name="reverse">Certificate from this CA to the other CA.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificatePair.#ctor(Org.BouncyCastle.Asn1.X509.CertificatePair)">
            <summary>Constructor from a ASN.1 CertificatePair structure.</summary>
            <param name="pair">The <c>CertificatePair</c> ASN.1 object.</param>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509CertificatePair.Forward">
            <summary>Returns the certificate from the other CA to this CA.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509CertificatePair.Reverse">
            <summary>Returns the certificate from this CA to the other CA.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CertificateParser">
            class for dealing with X509 certificates.
            <p>
            At the moment this will deal with "-----BEGIN CERTIFICATE-----" to "-----END CERTIFICATE-----"
            base 64 encoded certs, as well as the BER binaries of certificates and some classes of PKCS#7
            objects.</p>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertPairParser.ReadCertPair(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertPairParser.ReadCertPairs(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.IsRevoked(Org.BouncyCastle.X509.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlEntry.#ctor(Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Org.BouncyCastle.Asn1.X509.X509Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.IO.Stream)">
            Generates a certificate revocation list (CRL) object and initializes
            it with the data read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.IO.Stream)">
             Returns a (possibly empty) collection view of the CRLs read from
             the given input stream inStream.
            
             The inStream may contain a sequence of DER-encoded CRLs, or
             a PKCS#7 CRL set.  This is a PKCS#7 SignedData object, with the
             only significant field being crls.  In particular the signature
             and the contents are ignored.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509KeyUsage">
             A holding class for constructing an X509 Key Usage extension.
            
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509KeyUsage.keyEncipherment | X509KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V1CertificateGenerator">
            <summary>
            Class to Generate X509V1 Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Reset">
            <summary>
            Reset the generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the issuer distinguished name.
            The issuer is the entity whose private key is used to sign the certificate.
            </summary>
            <param name="issuer">The issuers DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the subject distinguished name.
            The subject describes the entity associated with the public key.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm that will be used to sign this certificate.
            This can be either a name or an OID, names are treated as case insensitive.
            </summary>
            <param name="signatureAlgorithm">string representation of the algorithm name</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate a new X509Certificate.
            </summary>
            <param name="privateKey">The private key of the issuer used to sign this certificate.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a new X509Certificate specifying a SecureRandom instance that you would like to use.
            </summary>
            <param name="privateKey">The private key of the issuer used to sign this certificate.</param>
            <param name="random">The Secure Random you want to use.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V1CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2AttributeCertificate">
            <summary>An implementation of a version 2 X.509 Attribute Certificate.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator">
            <remarks>Class to produce an X.509 Version 2 AttributeCertificate.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetHolder(Org.BouncyCastle.X509.AttributeCertificateHolder)">
            <summary>Set the Holder of this Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetIssuer(Org.BouncyCastle.X509.AttributeCertificateIssuer)">
            <summary>Set the issuer.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>Set the serial number for the certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm. This can be either a name or an OID, names
            are treated as case insensitive.
            </summary>
            <param name="signatureAlgorithm">The algorithm name.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddAttribute(Org.BouncyCastle.X509.X509Attribute)">
            <summary>Add an attribute.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>Add a given extension field for the standard extensions tag.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add a given extension field for the standard extensions tag.
            The value parameter becomes the contents of the octet string associated
            with the extension.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an X509 certificate, based on the current issuer and subject.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate an X509 certificate, based on the current issuer and subject,
            using the supplied source of randomness, if required.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2CrlGenerator">
            class to produce an X.509 Version 2 CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Reset">
            reset the generator
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            Set the issuer distinguished name - the issuer is the entity whose private key is used to sign the
            certificate.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32)">
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32,System.DateTime)">
             Add a CRL entry with an Invalidity Date extension as well as a CrlReason extension.
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a CRL entry with extensions.
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrl(Org.BouncyCastle.X509.X509Crl)">
             Add the CRLEntry objects contained in a previous CRL.
            
             @param other the X509Crl to source the other entries from.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.SetSignatureAlgorithm(System.String)">
             Set the signature algorithm. This can be either a name or an oid, names
             are treated as case insensitive.
            
             @param signatureAlgorithm string representation of the algorithm name.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>Generate an X509 CRL, based on the current issuer and subject.</summary>
            <param name="privateKey">The key used for signing.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Generate an X509 CRL, based on the current issuer and subject.</summary>
            <param name="privateKey">The key used for signing.</param>
            <param name="random">A user-defined source of randomness.</param>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V2CrlGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V3CertificateGenerator">
            <summary>
            A class to Generate Version 3 X509Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Reset">
            <summary>
            Reset the Generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can Get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the distinguished name of the issuer.
            The issuer is the entity which is signing the certificate.
            </summary>
            <param name="issuer">The issuer's DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the DN of the entity that this certificate is about.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm that will be used to sign this certificate.
            </summary>
            <param name="signatureAlgorithm"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectUniqueID(System.Boolean[])">
            <summary>
            Set the subject unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerUniqueID(System.Boolean[])">
            <summary>
            Set the issuer unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3).
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add an extension using a string with a dotted decimal OID.
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(System.String,System.Boolean,Org.BouncyCastle.X509.X509Certificate)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3),
            copying the extension value from another certificate.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.X509.X509Certificate)">
            add a given extension field for the standard extensions tag (tag 3)
            copying the extension value from another certificate.
            @throws CertificateParsingException if the extension cannot be extracted.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an X509Certificate.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate an X509Certificate using your own SecureRandom.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <param name="random">You Secure Random instance.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V3CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTree.Add(System.IComparable,System.Object)">
            <summary>
             Add
             args: ByVal key As IComparable, ByVal data As Object
             key is object that implements IComparable interface
             performance tip: change to use use int type (such as the hashcode)
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTree.RestoreAfterInsert(System.util.collections.OrderedTreeNode)">
            <summary>
             RestoreAfterInsert
             Additions to red-black trees usually destroy the red-black 
             properties. Examine the tree and restore. Rotations are normally 
             required to restore it
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTree.RotateLeft(System.util.collections.OrderedTreeNode)">
            <summary>
             RotateLeft
             Rebalance the tree by rotating the nodes to the left
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTree.RotateRight(System.util.collections.OrderedTreeNode)">
            <summary>
             RotateRight
             Rebalance the tree by rotating the nodes to the right
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetData(System.IComparable)" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetMinKey" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetMaxKey" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetMinValue" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetMaxValue" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.GetEnumerator" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.Elements" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.IsEmpty" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.Remove(System.IComparable)" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.Delete(System.util.collections.OrderedTreeNode)" -->
        <member name="M:System.util.collections.OrderedTree.RestoreAfterDelete(System.util.collections.OrderedTreeNode)">
            <summary>
             RestoreAfterDelete
             Deletions from red-black trees may destroy the red-black 
             properties. Examine the tree and restore. Rotations are normally 
             required to restore it
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.RemoveMin" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.RemoveMax" -->
        <!-- Badly formed XML comment ignored for member "M:System.util.collections.OrderedTree.Clear" -->
        <!-- Badly formed XML comment ignored for member "P:System.util.collections.OrderedTree.Keys" -->
        <!-- Badly formed XML comment ignored for member "P:System.util.collections.OrderedTree.Values" -->
        <member name="M:System.util.collections.OrderedTreeEnumerator.#ctor(System.util.collections.OrderedTreeNode,System.Boolean,System.Boolean,System.util.collections.OrderedTreeNode)">
            <summary>
             Determine order, walk the tree and push the nodes onto the stack
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTreeEnumerator.HasMoreElements">
            <summary>
             HasMoreElements
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTreeEnumerator.NextElement">
            <summary>
             NextElement
            </summary>
        </member>
        <member name="M:System.util.collections.OrderedTreeEnumerator.MoveNext">
            <summary>
             MoveNext
             For .NET compatibility
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeEnumerator.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeEnumerator.Value">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeNode.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeNode.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeNode.Color">
            <summary>
            Color
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeNode.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="P:System.util.collections.OrderedTreeNode.Right">
            <summary>
             Right
            </summary>
        </member>
        <member name="T:System.util.ListIterator`1">
            <summary>
            Summary description for ListIterator.
            </summary>
        </member>
        <member name="T:System.util.Util">
            <summary>
            Summary description for Util.
            </summary>
        </member>
        <member name="T:System.util.zlib.ZDeflaterOutputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="T:System.util.zlib.ZInflaterInputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="F:iTextSharp.awt.geom.AffineTransform.TYPE_UNKNOWN">
            The <code>TYPE_UNKNOWN</code> is an initial type value
        </member>
        <member name="F:iTextSharp.awt.geom.AffineTransform.ZERO">
            The min value equivalent to zero. If absolute value less then ZERO it considered as zero.  
        </member>
        <member name="F:iTextSharp.awt.geom.AffineTransform.m00">
            The values of transformation matrix
        </member>
        <member name="F:iTextSharp.awt.geom.AffineTransform.type">
            The transformation <code>type</code> 
        </member>
        <member name="M:iTextSharp.awt.geom.AffineTransform.Multiply(iTextSharp.awt.geom.AffineTransform,iTextSharp.awt.geom.AffineTransform)">
            Multiply matrix of two AffineTransform objects 
            @param t1 - the AffineTransform object is a multiplicand
            @param t2 - the AffineTransform object is a multiplier
            @return an AffineTransform object that is a result of t1 multiplied by matrix t2. 
        </member>
        <member name="M:iTextSharp.testutils.ITextTest.GetOutPdf">
            Gets the name of the resultant PDF file.
            This name will be passed to <code>makePdf</code>, <code>assertPdf</code> and <code>comparePdf</code> methods.
            @return
        </member>
        <member name="M:iTextSharp.testutils.ITextTest.GetCmpPdf">
            Gets the name of the compare PDF file.
            This name will be passed to <code>comparePdf</code> method.
            @return
        </member>
        <member name="T:iTextSharp.text.api.IWriterOperation">
             @author itextpdf.com
            
        </member>
        <member name="M:iTextSharp.text.api.IWriterOperation.Write(iTextSharp.text.pdf.PdfWriter,iTextSharp.text.Document)">
            Receive a writer and the document to do certain operations on them.
            @param writer the PdfWriter
            @param doc the document
            @throws DocumentException
        </member>
        <member name="T:iTextSharp.text.exceptions.InvalidImageException">
            RuntimeException to indicate that the provided Image is invalid/corrupted.
            Should only be thrown/not caught when ignoring invalid images.
            @since 5.4.2
        </member>
        <member name="T:iTextSharp.text.html.HtmlUtilities">
            A class that contains some utilities to parse HTML attributes and content.
            @since 5.0.6 (some of these methods used to be in the Markup class)
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.HtmlUtilities.DEFAULT_FONT_SIZE">
            a default value for font-size 
            @since 2.1.3
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.ParseLength(System.String)">
            Parses a length.
            
            @param str
                       a length in the form of an optional + or -, followed by a
                       number and a unit.
            @return a float
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.ParseLength(System.String,System.Single)">
            New method contributed by: Lubos Strapko
            
            @since 2.1.3
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.DecodeColor(System.String)">
            Converts a <CODE>BaseColor</CODE> into a HTML representation of this <CODE>
            BaseColor</CODE>.
            
            @param s
                       the <CODE>BaseColor</CODE> that has to be converted.
            @return the HTML representation of this <COLOR>BaseColor </COLOR>
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.ParseAttributes(System.String)">
            This method parses a String with attributes and returns a Properties
            object.
            
            @param str
                       a String of this form: 'key1="value1"; key2="value2";...
                       keyN="valueN" '
            @return a Properties object
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.RemoveComment(System.String,System.String,System.String)">
            Removes the comments sections of a String.
            
            @param str
                       the original String
            @param startComment
                       the String that marks the start of a Comment section
            @param endComment
                       the String that marks the end of a Comment section.
            @return the String stripped of its comment section
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.EliminateWhiteSpace(System.String)">
            Helper class that reduces the white space in a String
            @param content content containing whitespace
            @return the content without all unnecessary whitespace
        </member>
        <member name="F:iTextSharp.text.html.HtmlUtilities.FONTSIZES">
            A series of predefined font sizes.
            @since 5.0.6 (renamed)
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.GetIndexedFontSize(System.String,System.String)">
            Picks a font size from a series of predefined font sizes.
            @param value     the new value of a font, expressed as an index
            @param previous  the previous value of the font size
            @return  a new font size.
        </member>
        <member name="M:iTextSharp.text.html.HtmlUtilities.AlignmentValue(System.String)">
            Translates a String value to an alignment value.
            (written by Norman Richards, integrated into iText by Bruno)
            @param   alignment a String (one of the ALIGN_ constants of this class)
            @return  an alignment value (one of the ALIGN_ constants of the Element interface) 
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.CellWrapper">
            We use a CellWrapper because we need some extra info
            that isn't available in PdfPCell.
            @author  psoares
            @since 5.0.6 (renamed)
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.CellWrapper.cell">
            The cell that is wrapped in this stub. 
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.CellWrapper.width">
            The width of the cell.
            @since iText 5.0.6
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.CellWrapper.percentage">
            Indicates if the width is a percentage.
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.CellWrapper.#ctor(System.String,iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates a new instance of IncCell.
            @param	tag		the cell that is wrapped in this object.
            @param	chain	properties such as width
            @since	5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.CellWrapper.CreatePdfPCell(System.String,iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates a PdfPCell element based on a tag and its properties.
            @param	tag		a cell tag
            @param	chain	the hierarchy chain
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.CellWrapper.IsContent">
            @see com.lowagie.text.Element#isContent()
            @since   iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.CellWrapper.IsNestable">
            @see com.lowagie.text.Element#isNestable()
            @since   iText 2.0.8
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.ElementFactory">
            Factory that produces iText Element objects,
            based on tags and their properties.
            @author blowagie
            @author psoares
            @since 5.0.6 (renamed)
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.ElementFactory.provider">
            The font provider that will be used to fetch fonts.
            @since   iText 5.0   This used to be a FontFactoryImp
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.#ctor">
            Creates a new instance of FactoryProperties.
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.GetFont(iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates a Font object based on a chain of properties.
            @param   chain   chain of properties
            @return  an iText Font object
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.CreateChunk(System.String,iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates an iText Chunk
            @param content the content of the Chunk
            @param chain the hierarchy chain
            @return a Chunk
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.CreateParagraph(iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates an iText Paragraph object using the properties
            of the different tags and properties in the hierarchy chain.
            @param   chain   the hierarchy chain
            @return  a Paragraph without any content
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.CreateListItem(iTextSharp.text.html.simpleparser.ChainedProperties)">
            Creates an iText Paragraph object using the properties
            of the different tags and properties in the hierarchy chain.
            @param   chain   the hierarchy chain
            @return  a ListItem without any content
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.UpdateElement(iTextSharp.text.Paragraph,iTextSharp.text.html.simpleparser.ChainedProperties)">
            Method that does the actual Element creating for
            the createParagraph and createListItem method.
            @param paragraph
            @param chain
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.SetParagraphLeading(iTextSharp.text.Paragraph,System.String)">
            Sets the leading of a Paragraph object.
            @param   paragraph   the Paragraph for which we set the leading
            @param   leading     the String value of the leading
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.GetHyphenation(iTextSharp.text.html.simpleparser.ChainedProperties)">
            Gets a HyphenationEvent based on the hyphenation entry in
            the hierarchy chain.
            @param   chain   the hierarchy chain
            @return  a HyphenationEvent
            @since   2.1.2
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ElementFactory.CreateLineSeparator(System.Collections.Generic.IDictionary{System.String,System.String},System.Single)">
            Creates a LineSeparator.
            @since 5.0.6
        </member>
        <member name="P:iTextSharp.text.html.simpleparser.ElementFactory.FontProvider">
            Setter for the font provider
            @param provider
            @since   5.0.6 renamed from setFontImp
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.HTMLTagProcessors">
            This class maps tags such as div and span to their corresponding
            TagProcessor classes.
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.#ctor">
            Creates a Map containing supported tags.
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLTagProcessors.EM_STRONG_STRIKE_SUP_SUP">
            Object that processes the following tags:
            i, em, b, strong, s, strike, u, sup, sub
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLTagProcessors.A">
            Object that processes the a tag.
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.HTMLTagProcessors.BR">
            Object that processes the br tag.
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.IHTMLTagProcessor">
            Interface that needs to be implemented by every tag that is supported by HTMLWorker.
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.IHTMLTagProcessor.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            Implement this class to tell the HTMLWorker what to do
            when an open tag is encountered.
            @param worker    the HTMLWorker
            @param tag       the tag that was encountered
            @param attrs     the current attributes of the tag
            @throws DocumentException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.IHTMLTagProcessor.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            Implement this class to tell the HTMLWorker what to do
            when an close tag is encountered.
            @param worker    the HTMLWorker
            @param tag       the tag that was encountered
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_EM_STRONG_STRIKE_SUP_SUP.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_EM_STRONG_STRIKE_SUP_SUP.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_EM_STRONG_STRIKE_SUP_SUP.MapTag(System.String)">
            Maps em to i, strong to b, and strike to s.
            This is a convention: the style parser expects i, b and s.
            @param tag the original tag
            @return the mapped tag
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_A.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_A.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_BR.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_BR.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_UL_OL.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_UL_OL.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_SPAN.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_SPAN.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_H.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_H.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_LI.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_LI.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_PRE.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_PRE.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_DIV.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_DIV.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TABLE.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @throws DocumentException
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TABLE.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TR.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @throws DocumentException
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TR.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TD.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @throws DocumentException
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_TD.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_IMG.StartElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#startElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.HTMLTagProcessors.HTMLTagProcessor_IMG.EndElement(iTextSharp.text.html.simpleparser.HTMLWorker,System.String)">
            @see com.itextpdf.text.html.simpleparser.HTMLTagProcessors#endElement(com.itextpdf.text.html.simpleparser.HTMLWorker, java.lang.String)
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.IImageProcessor">
            Implement this interface to process images and
            to indicate if the image needs to be added or
            skipped.
            @since 5.0.6 (renamed)
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.IImageProcessor.Process(iTextSharp.text.Image,System.Collections.Generic.IDictionary{System.String,System.String},iTextSharp.text.html.simpleparser.ChainedProperties,iTextSharp.text.IDocListener)">
            Allows you to (pre)process the image before (or instead of)
            adding it to the DocListener with HTMLWorker.
            @param img   the Image object
            @param attrs attributes of the image
            @param chain hierarchy of attributes
            @param doc   the DocListener to which the Image needs to be added
            @return  false if you still want HTMLWorker to add the Image
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.ILinkProcessor">
            Allows you to do additional processing on a Paragraph that contains a link.
            @author  psoares
            @since 5.0.6 (renamed)
            @deprecated since 5.5.2
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.ILinkProcessor.Process(iTextSharp.text.Paragraph,iTextSharp.text.html.simpleparser.ChainedProperties)">
            Does additional processing on a link paragraph
            @param current   the Paragraph that has the link
            @param attrs     the attributes
            @return  false if the Paragraph no longer needs processing
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.ImageStore">
            @since 5.0.6
            @deprecated since 5.5.2
        </member>
        <member name="T:iTextSharp.text.html.simpleparser.TableWrapper">
            We use a TableWrapper because PdfPTable is rather complex
            to put on the HTMLWorker stack.
            @author  psoares
            @since 5.0.6 (renamed)
            @deprecated since 5.5.2
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.TableWrapper.styles">
            The styles that need to be applied to the table
            @since 5.0.6 renamed from props
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.TableWrapper.rows">
            Nested list containing the PdfPCell elements that are part of this table.
        </member>
        <member name="F:iTextSharp.text.html.simpleparser.TableWrapper.colWidths">
            Array containing the widths of the columns.
            @since iText 5.0.6
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.TableWrapper.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            Creates a new instance of IncTable.
            @param   attrs   a Map containing attributes
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.TableWrapper.AddRow(System.Collections.Generic.IList{iTextSharp.text.pdf.PdfPCell})">
            Adds a new row to the table.
            @param row a list of PdfPCell elements
        </member>
        <member name="M:iTextSharp.text.html.simpleparser.TableWrapper.CreateTable">
            Creates a new PdfPTable based on the info assembled
            in the table stub.
            @return  a PdfPTable
        </member>
        <member name="P:iTextSharp.text.html.simpleparser.TableWrapper.ColWidths">
            Setter for the column widths
            @since iText 5.0.6
        </member>
        <member name="T:iTextSharp.text.io.ArrayRandomAccessSource">
            A RandomAccessSource that is based on an underlying byte array 
            @since 5.3.5
        </member>
        <member name="T:iTextSharp.text.io.IRandomAccessSource">
            Represents an abstract source that bytes can be read from.  This class forms the foundation for all byte input in iText. 
            Implementations do not keep track of a current 'position', but rather provide absolute get methods.  Tracking position
            should be handled in classes that use RandomAccessSource internally (via composition).
            @since 5.3.5
        </member>
        <member name="M:iTextSharp.text.io.IRandomAccessSource.Get(System.Int64)">
            Gets a byte at the specified position
            @param position
            @return the byte, or -1 if EOF is reached
        </member>
        <member name="M:iTextSharp.text.io.IRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            Gets an array at the specified position.  If the number of bytes requested cannot be read, the bytes that can be
            read will be placed in bytes and the number actually read will be returned.
            @param position the position in the RandomAccessSource to read from
            @param bytes output buffer
            @param off offset into the output buffer where results will be placed
            @param len the number of bytes to read
            @return the number of bytes actually read, or -1 if the file is at EOF
        </member>
        <member name="M:iTextSharp.text.io.IRandomAccessSource.Close">
            Closes this source.  The underlying data structure or source (if any) will also be closed
            @throws IOException
        </member>
        <member name="P:iTextSharp.text.io.IRandomAccessSource.Length">
            @return the length of this source
        </member>
        <member name="T:iTextSharp.text.io.GetBufferedRandomAccessSource">
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.io.GetBufferedRandomAccessSource.source">
            The source
        </member>
        <member name="M:iTextSharp.text.io.GetBufferedRandomAccessSource.#ctor(iTextSharp.text.io.IRandomAccessSource)">
            Constructs a new OffsetRandomAccessSource
            @param source the source
        </member>
        <member name="M:iTextSharp.text.io.GetBufferedRandomAccessSource.Get(System.Int64)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.GetBufferedRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.GetBufferedRandomAccessSource.Close">
            {@inheritDoc}
        </member>
        <member name="P:iTextSharp.text.io.GetBufferedRandomAccessSource.Length">
            {@inheritDoc}
        </member>
        <member name="T:iTextSharp.text.io.GroupedRandomAccessSource">
            A RandomAccessSource that is based on a set of underlying sources, treating the sources as if they were a contiguous block of data.
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.sources">
            The underlying sources (along with some meta data to quickly determine where each source begins and ends)
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.currentSourceEntry">
            Cached value to make multiple reads from the same underlying source more efficient
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.size">
            Cached size of the underlying channel
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.#ctor(System.Collections.Generic.ICollection{iTextSharp.text.io.IRandomAccessSource})">
            Constructs a new {@link GroupedRandomAccessSource} based on the specified set of sources
            @param sources the sources used to build this group
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.GetStartingSourceIndex(System.Int64)">
            For a given offset, return the index of the source that contains the specified offset.
            This is an optimization feature to help optimize the access of the correct source without having to iterate
            through every single source each time.  It is safe to always return 0, in which case the full set of sources will be searched.
            Subclasses should override this method if they are able to compute the source index more efficiently (for example {@link FileChannelRandomAccessSource} takes advantage of fixed size page buffers to compute the index) 
            @param offset the offset
            @return the index of the input source that contains the specified offset, or 0 if unknown
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.GetSourceEntryForOffset(System.Int64)">
            Returns the SourceEntry that contains the byte at the specified offset  
            sourceReleased is called as a notification callback so subclasses can take care of cleanup when the source is no longer the active source
            @param offset the offset of the byte to look for
            @return the SourceEntry that contains the byte at the specified offset
            @throws IOException if there is a problem with IO (usually the result of the sourceReleased() call)
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.SourceReleased(iTextSharp.text.io.IRandomAccessSource)">
            Called when a given source is no longer the active source.  This gives subclasses the abilty to release resources, if appropriate. 
            @param source the source that is no longer the active source
            @throws IOException if there are any problems
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.SourceInUse(iTextSharp.text.io.IRandomAccessSource)">
            Called when a given source is about to become the active source.  This gives subclasses the abilty to retrieve resources, if appropriate. 
            @param source the source that is about to become the active source
            @throws IOException if there are any problems
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.Get(System.Int64)">
            {@inheritDoc} 
            The source that contains the byte at position is retrieved, the correct offset into that source computed, then the value
            from that offset in the underlying source is returned.
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            {@inheritDoc} 
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.Close">
            {@inheritDoc}
            Closes all of the underlying sources
        </member>
        <member name="P:iTextSharp.text.io.GroupedRandomAccessSource.Length">
            {@inheritDoc} 
        </member>
        <member name="T:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry">
            Used to track each source, along with useful meta data 
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.source">
            The underlying source
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.firstByte">
            The first byte (in the coordinates of the GroupedRandomAccessSource) that this source contains
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.lastByte">
            The last byte (in the coordinates of the GroupedRandomAccessSource) that this source contains
        </member>
        <member name="F:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.index">
            The index of this source in the GroupedRandomAccessSource
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.#ctor(System.Int32,iTextSharp.text.io.IRandomAccessSource,System.Int64)">
            Standard constructor
            @param index the index
            @param source the source
            @param offset the offset of the source in the GroupedRandomAccessSource
        </member>
        <member name="M:iTextSharp.text.io.GroupedRandomAccessSource.SourceEntry.OffsetN(System.Int64)">
            Given an absolute offset (in the GroupedRandomAccessSource coordinates), calculate the effective offset in the underlying source
            @param absoluteOffset the offset in the parent GroupedRandomAccessSource
            @return the effective offset in the underlying source
        </member>
        <member name="T:iTextSharp.text.io.IndependentRandomAccessSource">
            A RandomAccessSource that is wraps another RandomAccessSouce but does not propagate close().  This is useful when
            passing a RandomAccessSource to a method that would normally close the source.
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.io.IndependentRandomAccessSource.source">
            The source
        </member>
        <member name="M:iTextSharp.text.io.IndependentRandomAccessSource.#ctor(iTextSharp.text.io.IRandomAccessSource)">
            Constructs a new OffsetRandomAccessSource
            @param source the source
        </member>
        <member name="M:iTextSharp.text.io.IndependentRandomAccessSource.Get(System.Int64)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.IndependentRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.IndependentRandomAccessSource.Close">
            Does nothing - the underlying source is not closed
        </member>
        <member name="P:iTextSharp.text.io.IndependentRandomAccessSource.Length">
            {@inheritDoc}
        </member>
        <member name="T:iTextSharp.text.io.RAFRandomAccessSource">
            
            A RandomAccessSource that uses a {@link RandomAccessFile} as it's source
            Note: Unlike most of the RandomAccessSource implementations, this class is not thread safe
        </member>
        <member name="F:iTextSharp.text.io.RAFRandomAccessSource.raf">
            The source
        </member>
        <member name="F:iTextSharp.text.io.RAFRandomAccessSource.length">
            The length of the underling RAF.  Note that the length is cached at construction time to avoid the possibility
            of IOExceptions when reading the length.
        </member>
        <member name="M:iTextSharp.text.io.RAFRandomAccessSource.#ctor(System.IO.FileStream)">
            Creates this object
            @param raf the source for this RandomAccessSource
            @throws IOException if the RAF can't be read
        </member>
        <member name="M:iTextSharp.text.io.RAFRandomAccessSource.Get(System.Int64)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.RAFRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.io.RAFRandomAccessSource.Close">
            Closes the underlying RandomAccessFile
        </member>
        <member name="P:iTextSharp.text.io.RAFRandomAccessSource.Length">
            {@inheritDoc}
            Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes
            after construction, that change will not be reflected in this call.
        </member>
        <member name="T:iTextSharp.text.io.RandomAccessSourceFactory">
             Factory to create {@link RandomAccessSource} objects based on various types of sources
             @since 5.3.5
            
        </member>
        <member name="F:iTextSharp.text.io.RandomAccessSourceFactory.forceRead">
            whether the full content of the source should be read into memory at construction
        </member>
        <member name="F:iTextSharp.text.io.RandomAccessSourceFactory.usePlainRandomAccess">
            Whether {@link RandomAccessFile} should be used instead of a {@link FileChannel}, where applicable
        </member>
        <member name="F:iTextSharp.text.io.RandomAccessSourceFactory.exclusivelyLockFile">
            Whether the underlying file should have a RW lock on it or just an R lock
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.#ctor">
            Creates a factory that will give preference to accessing the underling data source using memory mapped files
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.SetForceRead(System.Boolean)">
            Determines whether the full content of the source will be read into memory
            @param forceRead true if the full content will be read, false otherwise
            @return this object (this allows chaining of method calls)
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateSource(System.Byte[])">
            Creates a {@link RandomAccessSource} based on a byte array
            @param data the byte array
            @return the newly created {@link RandomAccessSource}
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateSource(System.Uri)">
            Creates a {@link RandomAccessSource} based on a URL.  The data available at the URL is read into memory and used
            as the source for the {@link RandomAccessSource}
            @param url the url to read from
            @return the newly created {@link RandomAccessSource}
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateSource(System.IO.Stream)">
            Creates a {@link RandomAccessSource} based on an {@link InputStream}.  The full content of the InputStream is read into memory and used
            as the source for the {@link RandomAccessSource}
            @param is the stream to read from
            @return the newly created {@link RandomAccessSource}
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateBestSource(System.String)">
            Creates a {@link RandomAccessSource} based on a filename string.
            If the filename describes a URL, a URL based source is created
            If the filename describes a file on disk, the contents may be read into memory (if forceRead is true), opened using memory mapped file channel (if usePlainRandomAccess is false), or opened using {@link RandomAccessFile} access (if usePlainRandomAccess is true)
            This call will automatically failover to using {@link RandomAccessFile} if the memory map operation fails
            @param filename the name of the file or resource to create the {@link RandomAccessSource} for
            @return the newly created {@link RandomAccessSource}
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateByReadingToMemory(System.String)">
            Creates a new {@link RandomAccessSource} by reading the specified file/resource into memory
            @param filename the name of the resource to read
            @return the newly created {@link RandomAccessSource}
            @throws IOException if reading the underling file or stream fails
        </member>
        <member name="M:iTextSharp.text.io.RandomAccessSourceFactory.CreateByReadingToMemory(System.IO.Stream)">
            Creates a new {@link RandomAccessSource} by reading the specified file/resource into memory
            @param filename the name of the resource to read
            @return the newly created {@link RandomAccessSource}
            @throws IOException if reading the underling file or stream fails
        </member>
        <member name="T:iTextSharp.text.io.RASInputStream">
            An input stream that uses a RandomAccessSource as it's underlying source 
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.io.RASInputStream.source">
            The source
        </member>
        <member name="F:iTextSharp.text.io.RASInputStream.position">
            The current position in the source
        </member>
        <member name="M:iTextSharp.text.io.RASInputStream.#ctor(iTextSharp.text.io.IRandomAccessSource)">
            Creates an input stream based on the source
            @param source the source
        </member>
        <member name="T:iTextSharp.text.io.StreamUtil">
             Utility class with commonly used stream operations
             @since 5.3.5
            
        </member>
        <member name="M:iTextSharp.text.io.StreamUtil.InputStreamToArray(System.IO.Stream)">
            Reads the full content of a stream and returns them in a byte array
            @param is the stream to read
            @return a byte array containing all of the bytes from the stream
            @throws IOException if there is a problem reading from the input stream
        </member>
        <member name="M:iTextSharp.text.io.StreamUtil.GetResourceStream(System.String)">
            Gets the font resources.
            @param key the name of the resource
            @return the <CODE>Stream</CODE> to get the resource or
            <CODE>null</CODE> if not found
        </member>
        <member name="T:iTextSharp.text.io.WindowRandomAccessSource">
            A RandomAccessSource that wraps another RandomAccessSouce and provides a window of it at a specific offset and over
            a specific length.  Position 0 becomes the offset position in the underlying source.
            @since 5.3.5
        </member>
        <member name="F:iTextSharp.text.io.WindowRandomAccessSource.source">
            The source
        </member>
        <member name="F:iTextSharp.text.io.WindowRandomAccessSource.offset">
            The amount to offset the source by
        </member>
        <member name="F:iTextSharp.text.io.WindowRandomAccessSource.length">
            The length
        </member>
        <member name="M:iTextSharp.text.io.WindowRandomAccessSource.#ctor(iTextSharp.text.io.IRandomAccessSource,System.Int64)">
            Constructs a new OffsetRandomAccessSource that extends to the end of the underlying source
            @param source the source
            @param offset the amount of the offset to use
        </member>
        <member name="M:iTextSharp.text.io.WindowRandomAccessSource.#ctor(iTextSharp.text.io.IRandomAccessSource,System.Int64,System.Int64)">
            Constructs a new OffsetRandomAccessSource with an explicit length
            @param source the source
            @param offset the amount of the offset to use
            @param length the number of bytes to be included in this RAS
        </member>
        <member name="M:iTextSharp.text.io.WindowRandomAccessSource.Get(System.Int64)">
            {@inheritDoc}
            Note that the position will be adjusted to read from the corrected location in the underlying source
        </member>
        <member name="M:iTextSharp.text.io.WindowRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            {@inheritDoc}
            Note that the position will be adjusted to read from the corrected location in the underlying source
        </member>
        <member name="M:iTextSharp.text.io.WindowRandomAccessSource.Close">
            {@inheritDoc}
        </member>
        <member name="P:iTextSharp.text.io.WindowRandomAccessSource.Length">
            {@inheritDoc}
            Note that the length will be adjusted to read from the corrected location in the underlying source
        </member>
        <!-- Badly formed XML comment ignored for member "P:com.itextpdf.text.pdf.ListLabel.TagLabelContent" -->
        <member name="T:iTextSharp.text.log.CounterFactory">
            Factory that creates a counter for every reader or writer class.
            You can implement your own counter and declare it like this:
            <code>CounterFactory.getInstance().setCounter(new SysoCounter());</code>
            SysoCounter is just an example of a Counter implementation.
            It writes info about files being read and written to the System.out.
            
            This functionality can be used to create metrics in a SaaS context.
        </member>
        <member name="F:iTextSharp.text.log.CounterFactory.myself">
            The singleton instance. 
        </member>
        <member name="F:iTextSharp.text.log.CounterFactory.counter">
            The current counter implementation. 
        </member>
        <member name="M:iTextSharp.text.log.CounterFactory.#ctor">
            The empty constructor. 
        </member>
        <member name="M:iTextSharp.text.log.CounterFactory.getInstance">
            Returns the singleton instance of the factory. 
        </member>
        <member name="M:iTextSharp.text.log.CounterFactory.GetCounter(System.Type)">
            Returns a counter factory. 
        </member>
        <member name="M:iTextSharp.text.log.CounterFactory.GetCounter">
            Getter for the counter.
        </member>
        <member name="M:iTextSharp.text.log.CounterFactory.SetCounter(iTextSharp.text.log.ICounter)">
            Setter for the counter.
        </member>
        <member name="T:iTextSharp.text.log.DefaultCounter">
            Implementation of the Counter interface that doesn't do anything.
        </member>
        <member name="T:iTextSharp.text.log.ICounter">
            Interface that can be implemented if you want to count the number of documents
            that are being processed by iText.
            
            Implementers may use this method to record actual system usage for licensing purposes
            (e.g. count the number of documents or the volumne in bytes in the context of a SaaS license).
        </member>
        <member name="M:iTextSharp.text.log.ICounter.GetCounter(System.Type)">
            Gets a Counter instance for a specific class. 
        </member>
        <member name="M:iTextSharp.text.log.ICounter.Read(System.Int64)">
            This method gets triggered if a file is read.
            @param l	the length of the file that was written
        </member>
        <member name="M:iTextSharp.text.log.ICounter.Written(System.Int64)">
            This method gets triggered if a file is written.
            @param l	the length of the file that was written 
        </member>
        <member name="M:iTextSharp.text.log.DefaultCounter.GetCounter(System.Type)">
            @param klass
            @return this Counter implementation
            @see com.itextpdf.text.log.Counter#getCounter(java.lang.Class)
        </member>
        <member name="M:iTextSharp.text.log.DefaultCounter.Read(System.Int64)">
            @see com.itextpdf.text.log.Counter#read(long)
        </member>
        <member name="M:iTextSharp.text.log.DefaultCounter.Written(System.Int64)">
            @see com.itextpdf.text.log.Counter#written(long)
        </member>
        <member name="T:iTextSharp.text.log.ILogger">
             Logger interface
             {@link LoggerFactory#setLogger(Logger)}.
            
             @author redlab_b
            
        </member>
        <member name="M:iTextSharp.text.log.ILogger.GetLogger(System.Type)">
            @param klass
            @return the logger for the given klass
        </member>
        <member name="M:iTextSharp.text.log.ILogger.IsLogging(iTextSharp.text.log.Level)">
            @param level
            @return true if there should be logged for the given level
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Warn(System.String)">
            Log a warning message.
            @param message
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Trace(System.String)">
            Log a trace message.
            @param message
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Debug(System.String)">
            Log a debug message.
            @param message
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Info(System.String)">
            Log an info message.
            @param message
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Error(System.String)">
            Log an error message.
            @param message
        </member>
        <member name="M:iTextSharp.text.log.ILogger.Error(System.String,System.Exception)">
            Log an error message and exception.
            @param message
            @param e
        </member>
        <member name="T:iTextSharp.text.log.Level">
             The different log levels.
             @author redlab_b
            
        </member>
        <member name="T:iTextSharp.text.log.LoggerFactory">
             LoggerFactory can be used to set a logger. The logger should be created by
             implementing {@link Logger}. In the implementation users can choose how they
             log received messages. Added for developers. For some cases it can be handy
             to receive logging statements while developing applications with iText
            
             @author redlab_b
            
        </member>
        <member name="M:iTextSharp.text.log.LoggerFactory.GetLogger(System.Type)">
            Returns the logger set in this LoggerFactory. Defaults to {@link NoOpLogger}
            @param klass
            @return the logger.
        </member>
        <member name="M:iTextSharp.text.log.LoggerFactory.GetLogger(System.String)">
            Returns the logger set in this LoggerFactory. Defaults to {@link NoOpLogger}
            @param name
            @return the logger.
        </member>
        <member name="M:iTextSharp.text.log.LoggerFactory.GetInstance">
            Returns the LoggerFactory
            @return singleton instance of this LoggerFactory
        </member>
        <member name="M:iTextSharp.text.log.LoggerFactory.SetLogger(iTextSharp.text.log.ILogger)">
             Set the global logger to process logging statements with.
            
             @param logger the logger
        </member>
        <member name="M:iTextSharp.text.log.LoggerFactory.Logger">
             Get the logger.
            
             @return the logger
        </member>
        <member name="T:iTextSharp.text.log.NoOpCounter">
            Implementation of the Counter interface that doesn't do anything.
        </member>
        <member name="M:iTextSharp.text.log.NoOpCounter.GetCounter(System.Type)">
            @param klass The Class asking for the Counter
            @return the Counter instance
            @see com.itextpdf.text.log.Counter#getCounter(java.lang.Class)
        </member>
        <member name="M:iTextSharp.text.log.NoOpCounter.Read(System.Int64)">
            @see com.itextpdf.text.log.Counter#read(long)
        </member>
        <member name="M:iTextSharp.text.log.NoOpCounter.Written(System.Int64)">
            @see com.itextpdf.text.log.Counter#written(long)
        </member>
        <member name="T:iTextSharp.text.log.NoOpLogger">
             The no-operation logger, it does nothing with the received logging
             statements. And returns false by default for {@link NoOpLogger#isLogging(Level)}
            
             @author redlab_b
            
        </member>
        <member name="F:iTextSharp.text.log.SysoCounter.name">
            The name of the class for which the Counter was created
            (or iText if no name is available)
        </member>
        <member name="M:iTextSharp.text.log.SysoCounter.#ctor">
            Empty SysoCounter constructor.
        </member>
        <member name="M:iTextSharp.text.log.SysoCounter.#ctor(System.Type)">
            Constructs a SysoCounter for a specific class.
            @param klass
        </member>
        <member name="M:iTextSharp.text.log.SysoCounter.GetCounter(System.Type)">
            @see com.itextpdf.text.log.Counter#getCounter(java.lang.Class)
        </member>
        <member name="M:iTextSharp.text.log.SysoCounter.Read(System.Int64)">
            @see com.itextpdf.text.log.Counter#read(long)
        </member>
        <member name="M:iTextSharp.text.log.SysoCounter.Written(System.Int64)">
            @see com.itextpdf.text.log.Counter#written(long)
        </member>
        <member name="T:iTextSharp.text.log.SysoLogger">
             A Simple System.out logger.
             @author redlab_be
            
        </member>
        <member name="M:iTextSharp.text.log.SysoLogger.#ctor">
            Defaults packageReduce to 1.
        </member>
        <member name="M:iTextSharp.text.log.SysoLogger.#ctor(System.Int32)">
             Amount of characters each package name should be reduced with.
             @param packageReduce
            
        </member>
        <member name="M:iTextSharp.text.log.SysoLogger.#ctor(System.String,System.Int32)">
            @param klass
            @param shorten
        </member>
        <member name="M:iTextSharp.text.log.SysoLogger.Shorten(System.String)">
            @param name2
            @return
        </member>
        <member name="T:iTextSharp.text.pdf.codec.LZWCompressor">
             Modified from original LZWCompressor to change interface to passing a
             buffer of data to be compressed.
            
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.codeSize_">
            base underlying code size of data being compressed 8 for TIFF, 1 to 8 for GIF *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.clearCode_">
            reserved clear code based on code size *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.endOfInfo_">
            reserved end of data code based on code size *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.numBits_">
            current number bits output for each code *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.limit_">
            limit at which current number of bits code size has to be increased *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.prefix_">
            the prefix code which represents the predecessor string to current input point *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.bf_">
            output destination for bit codes *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.lzss_">
            general purpose LZW string table *
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWCompressor.tiffFudge_">
            modify the limits of the code values in LZW encoding due to TIFF bug / feature *
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWCompressor.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
             @param outp destination for compressed data
             @param codeSize the initial code size for the LZW compressor
             @param TIFF flag indicating that TIFF lzw fudge needs to be applied
             @exception IOException if underlying output stream error
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWCompressor.Compress(System.Byte[],System.Int32,System.Int32)">
             @param buf data to be compressed to output stream
             @exception IOException if underlying output stream error
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWCompressor.Flush">
             Indicate to compressor that no more data to go so write outp
             any remaining buffered data.
            
             @exception IOException if underlying output stream error
            
        </member>
        <member name="T:iTextSharp.text.pdf.codec.LZWStringTable">
             General purpose LZW String Table.
             Extracted from GIFEncoder by Adam Doppelt
             Comments added by Robin Luiten
             <code>expandCode</code> added by Robin Luiten
             The strLen_ table to give quick access to the lenght of an expanded
             code for use by the <code>expandCode</code> method added by Robin.
            
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWStringTable.RES_CODES">
            codesize + Reserved Codes 
        </member>
        <member name="F:iTextSharp.text.pdf.codec.LZWStringTable.strLen_">
             each entry corresponds to a code and contains the length of data
             that the code expands to when decoded.
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWStringTable.#ctor">
             Constructor allocate memory for string store data
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWStringTable.AddCharString(System.Int16,System.Byte)">
             @param index value of -1 indicates no predecessor [used in initialisation]
             @param b the byte [character] to add to the string store which follows
             the predecessor string specified the index.
             @return 0xFFFF if no space in table left for addition of predecesor
             index and byte b. Else return the code allocated for combination index + b.
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWStringTable.FindCharString(System.Int16,System.Byte)">
             @param index index to prefix string
             @param b the character that follws the index prefix
             @return b if param index is HASH_FREE. Else return the code
             for this prefix and byte successor
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWStringTable.ClearTable(System.Int32)">
             @param codesize the size of code to be preallocated for the
             string store.
            
        </member>
        <member name="M:iTextSharp.text.pdf.codec.LZWStringTable.ExpandCode(System.Byte[],System.Int32,System.Int16,System.Int32)">
             If expanded data doesnt fit into array only what will fit is written
             to buf and the return value indicates how much of the expanded code has
             been written to the buf. The next call to ExpandCode() should be with 
             the same code and have the skip parameter set the negated value of the 
             previous return. Succesive negative return values should be negated and
             added together for next skip parameter value with same code.
            
             @param buf buffer to place expanded data into
             @param offset offset to place expanded data
             @param code the code to expand to the byte array it represents.
             PRECONDITION This code must allready be in the LZSS
             @param skipHead is the number of bytes at the start of the expanded code to 
             be skipped before data is written to buf. It is possible that skipHead is
             equal to codeLen.
             @return the length of data expanded into buf. If the expanded code is longer
             than space left in buf then the value returned is a negative number which when
             negated is equal to the number of bytes that were used of the code being expanded.
             This negative value also indicates the buffer is full.
            
        </member>
        <member name="M:iTextSharp.testutils.CompareTool.SetCompareByContentErrorsLimit(System.Int32)">
            Sets the maximum errors count which will be returned as the result of the comparison.
            @param compareByContentMaxErrorCount the errors count.
            @return Returns this.
        </member>
        <member name="M:iTextSharp.testutils.CompareTool.SetFloatAbsoluteError(System.Single)">
            Sets the absolute error parameter which will be used in floating point numbers comparison.
            @param error the epsilon new value.
            @return Returns this.
        </member>
        <member name="M:iTextSharp.testutils.CompareTool.SetFloatRelativeError(System.Single)">
            Sets the relative error parameter which will be used in floating point numbers comparison.
            @param error the epsilon new value.
            @return Returns this.
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.AbstractCMap">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CidLocationFromByte">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.ICidLocation">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CidResource">
            
             @author psoares
        </member>
        <member name="M:iTextSharp.text.pdf.fonts.cmaps.CMapByteCid.DecodeSingle(iTextSharp.text.pdf.fonts.cmaps.CMapSequence)">
            
            @param seq
            @return the cid code or -1 for end
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CMapCache">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CMapCidUni">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CMapParserEx">
            
             @author psoares
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode">
             This class represents a CMap file.
            
             @author Ben Litchfield (ben@benlitchfield.com)
             @since   2.1.4
        </member>
        <member name="M:iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode.#ctor">
            Creates a new instance of CMap.
        </member>
        <member name="M:iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode.HasOneByteMappings">
             This will tell if this cmap has any one byte mappings.
            
             @return true If there are any one byte mappings, false otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode.HasTwoByteMappings">
             This will tell if this cmap has any two byte mappings.
            
             @return true If there are any two byte mappings, false otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.fonts.cmaps.CMapToUnicode.Lookup(System.Byte[],System.Int32,System.Int32)">
             This will perform a lookup into the map.
            
             @param code The code used to lookup.
             @param offset The offset into the byte array.
             @param length The length of the data we are getting.
            
             @return The string that matches the lookup.
        </member>
        <member name="T:iTextSharp.text.pdf.fonts.cmaps.CMapUniCid">
            
             @author psoares
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_COLOR">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_CMYK">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_RGB">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_FONT">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_IMAGE">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_GSTATE">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_LAYER">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_TRAILER">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_STREAM">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_FILESPEC">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_OBJECT">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_CANVAS">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_ANNOTATION">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_ACTION">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_FORM">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_STRUCTELEM">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_INLINE_IMAGE">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_GRAY">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_OUTPUTINTENT">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="F:iTextSharp.text.pdf.intern.PdfIsoKeys.PDFISOKEY_FORM_XOBJ">
            A key for an aspect that can be checked for PDF ISO Conformance. 
        </member>
        <member name="T:iTextSharp.text.pdf.ArabicLigaturizer">
             Shape arabic characters. This code was inspired by an LGPL'ed C library:
             Pango ( see http://www.pango.com/ ). Note that the code of this is the
             original work of Paulo Soares. Hence it is perfectly justifiable to distribute
             it under the MPL.
            
             @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_EN2AN">
            Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_AN2EN">
            Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_EN2AN_INIT_LR">
            Digit shaping option:
            Replace European digits (U+0030...U+0039) by Arabic-Indic digits
            if the most recent strongly directional character
            is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
            The initial state at the start of the text is assumed to be not an Arabic,
            letter, so European digits at the start of the text will not change.
            Compare to DIGITS_ALEN2AN_INIT_AL.
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_EN2AN_INIT_AL">
            Digit shaping option:
            Replace European digits (U+0030...U+0039) by Arabic-Indic digits
            if the most recent strongly directional character
            is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
            The initial state at the start of the text is assumed to be an Arabic,
            letter, so European digits at the start of the text will change.
            Compare to DIGITS_ALEN2AN_INT_LR.
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_RESERVED">
            Not a valid option value. 
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGITS_MASK">
            Bit mask for digit shaping options.
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGIT_TYPE_AN">
            Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGIT_TYPE_AN_EXTENDED">
            Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
        </member>
        <member name="F:iTextSharp.text.pdf.ArabicLigaturizer.DIGIT_TYPE_MASK">
            Bit mask for digit type options.
        </member>
        <member name="M:iTextSharp.text.pdf.ArabicLigaturizer.IsRTL">
            Arabic is written from right to left.
            @return true
            @see com.itextpdf.text.pdf.languages.LanguageProcessor#isRTL()
        </member>
        <member name="T:com.itextpdf.text.pdf.languages.DevanagariLigaturizer">
             Implementation of the IndicLigaturizer for Devanagari.
            
             Warning: this is an incomplete and experimental implementation of Devanagari. This implementation should not be used in production.
        </member>
        <member name="T:iTextSharp.text.pdf.languages.IndicLigaturizer">
            Superclass for processors that can convert a String of bytes in an Indic
            language to a String in the same language of which the bytes are reordered
            for rendering using a font that contains the necessary glyphs.
        </member>
        <member name="T:iTextSharp.text.pdf.languages.ILanguageProcessor">
            Interface that needs to be implemented by classes that process bytes
            representing text in specific languages. Processing involves changing
            order to Right to Left and/or applying ligatures.
        </member>
        <member name="M:iTextSharp.text.pdf.languages.ILanguageProcessor.Process(System.String)">
            Processes a String
            @param s	the original String
            @return the processed String
        </member>
        <member name="M:iTextSharp.text.pdf.languages.ILanguageProcessor.IsRTL">
            Indicates if the rundirection is right-to-left.
            @return true if text needs to be rendered from right to left.
        </member>
        <member name="F:iTextSharp.text.pdf.languages.IndicLigaturizer.langTable">
            The table mapping specific character indexes to the characters in a
            specific language.
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.Process(System.String)">
            Reorders the bytes in a String making Indic ligatures
            
            @param s
                       the original String
            @return the ligaturized String
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.IsRTL">
            Indic languages are written from right to left.
            
            @return false
            @see com.itextpdf.text.pdf.languages.LanguageProcessor#isRTL()
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.IsSwaraLetter(System.Char)">
            Checks if a character is vowel letter.
            
            @param ch
                       the character that needs to be checked
            @return true if the characters is a vowel letter
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.IsSwaraMatra(System.Char)">
            Checks if a character is vowel sign.
            
            @param ch
                       the character that needs to be checked
            @return true if the characters is a vowel sign
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.IsVyanjana(System.Char)">
            Checks if a character is consonant letter.
            
            @param ch
                       the character that needs to be checked
            @return true if the chracter is a consonant letter
        </member>
        <member name="M:iTextSharp.text.pdf.languages.IndicLigaturizer.Swap(System.Text.StringBuilder,System.Int32,System.Int32)">
            Swaps two characters in a StringBuilder object
            
            @param s
                       the StringBuilder
            @param i
                       the index of one character
            @param j
                       the index of the other character
        </member>
        <member name="M:com.itextpdf.text.pdf.languages.DevanagariLigaturizer.#ctor">
            Constructor for the IndicLigaturizer for Devanagari.
        </member>
        <member name="T:iTextSharp.text.pdf.languages.GujaratiLigaturizer">
            Implementation of the IndicLigaturizer for Gujarati.
        </member>
        <member name="M:iTextSharp.text.pdf.languages.GujaratiLigaturizer.#ctor">
            Constructor for the IndicLigaturizer for Gujarati.
        </member>
        <member name="M:iTextSharp.text.pdf.languages.HebrewProcessor.IsRTL">
            Hebrew is written from right to left.
            @return true
            @see com.itextpdf.text.pdf.languages.LanguageProcessor#isRTL()
        </member>
        <member name="T:iTextSharp.text.pdf.LongHashtable">
            A Hashtable that uses ints as the keys.
        </member>
        <member name="F:iTextSharp.text.pdf.LongHashtable.table">
            The hash table data.
        </member>
        <member name="F:iTextSharp.text.pdf.LongHashtable.count">
            The total number of entries in the hash table.
        </member>
        <member name="F:iTextSharp.text.pdf.LongHashtable.threshold">
            Rehashes the table when count exceeds this threshold.
        </member>
        <member name="F:iTextSharp.text.pdf.LongHashtable.loadFactor">
            The load factor for the hashtable.
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.#ctor(System.Int32,System.Single)">
            Constructs a new, empty hashtable with the specified initial
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.#ctor(System.Int32)">
            Constructs a new, empty hashtable with the specified initial
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.#ctor">
            Constructs a new, empty hashtable. A default capacity and load factor
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.IsEmpty">
            Returns true if the hashtable contains no elements.
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.Contains(System.Int64)">
            Returns true if the specified object is an element of the hashtable.
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.ContainsKey(System.Int64)">
            Returns true if the collection contains an element for the key.
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.Rehash">
            Rehashes the content of the table into a bigger table.
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.Remove(System.Int64)">
            Removes the element corresponding to the key. Does nothing if the
        </member>
        <member name="M:iTextSharp.text.pdf.LongHashtable.Clear">
            Clears the hash table so that it has no more elements in it.
        </member>
        <member name="P:iTextSharp.text.pdf.LongHashtable.Size">
            Returns the number of elements contained in the hashtable.
        </member>
        <member name="P:iTextSharp.text.pdf.LongHashtable.Item(System.Int64)">
            Gets the object associated with the specified key in the
        </member>
        <member name="T:iTextSharp.text.pdf.crypto.AESCipher">
            Creates an AES Cipher with CBC and padding PKCS5/7.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.crypto.AESCipher.#ctor(System.Boolean,System.Byte[],System.Byte[])">
            Creates a new instance of AESCipher 
        </member>
        <member name="T:iTextSharp.text.pdf.parser.BezierCurve">
             Represents a Bezier curve.
            
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.IShape">
            Represents segment from a PDF path.
            
            @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IShape.GetBasePoints">
             Treat base points as the points which are enough to construct a shape.
             E.g. for a bezier curve they are control points, for a line segment - the start and the end points
             of the segment.
            
             @return Ordered list consisting of shape's base points.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.BezierCurve.CurveCollinearityEpsilon">
            If the distance between a point and a line is less than
            this constant, then we consider the point lies on the line.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.BezierCurve.DistanceToleranceSquare">
            In the case when neither the line ((x1, y1), (x4, y4)) passes
            through both (x2, y2) and (x3, y3) nor (x1, y1) = (x4, y4) we
            use the square of the sum of the distances mentioned below in 
            compare to this field as the criterion of good approximation.
                1. The distance between the line and (x2, y2)
                2. The distance between the line and (x3, y3)
        </member>
        <member name="F:iTextSharp.text.pdf.parser.BezierCurve.DistanceToleranceManhattan">
            The Manhattan distance is used in the case when either the line 
            ((x1, y1), (x4, y4)) passes through both (x2, y2) and (x3, y3) 
            or (x1, y1) = (x4, y4). The essential observation is that when 
            the curve is a uniform speed straight line from end to end, the 
            control points are evenly spaced from beginning to end. Our measure 
            of how far we deviate from that ideal uses distance of the middle 
            controls: point 2 should be halfway between points 1 and 3; point 3 
            should be halfway between points 2 and 4.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.BezierCurve.#ctor(System.Collections.Generic.IList{iTextSharp.awt.geom.Point2D})">
            Constructs new bezier curve.
            @param controlPoints Curve's control points.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.BezierCurve.GetBasePoints">
            {@inheritDoc}
        </member>
        <member name="M:iTextSharp.text.pdf.parser.BezierCurve.GetPiecewiseLinearApproximation">
            You can adjust precision of the approximation by varying the following 
            parameters: {@link #curveCollinearityEpsilon}, {@link #distanceToleranceSquare}, 
            {@link #distanceToleranceManhattan}
            
            @return {@link java.util.List} containing points of piecewise linear approximation
                    for this bezier curve.
            @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.parser.IExtRenderListener">
             Simply extends the {@link com.itextpdf.text.pdf.parser.RenderListener} interface to provide
             additional methods.
            
             {@inheritDoc}
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IExtRenderListener.ModifyPath(iTextSharp.text.pdf.parser.PathConstructionRenderInfo)">
             Called when the current path is being modified. E.g. new segment is being added,
             new subpath is being started etc.
            
             @param renderInfo Contains information about the path segment being added to the current path.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IExtRenderListener.RenderPath(iTextSharp.text.pdf.parser.PathPaintingRenderInfo)">
             Called when the current path should be rendered.
            
             @param renderInfo Contains information about the current path which should be rendered.
             @return The path which can be used as a new clipping path.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.IExtRenderListener.ClipPath(System.Int32)">
             Called when the current path should be set as a new clipping path.
            
             @param rule Either {@link PathPaintingRenderInfo#EVEN_ODD_RULE} or {@link PathPaintingRenderInfo#NONZERO_WINDING_RULE}
        </member>
        <member name="T:iTextSharp.text.pdf.parser.InlineImageInfo">
            Represents an inline image from a PDF
            @since 5.1.4
        </member>
        <member name="P:iTextSharp.text.pdf.parser.InlineImageInfo.ImageDictionary">
            @return the image dictionary associated with this inline image
        </member>
        <member name="P:iTextSharp.text.pdf.parser.InlineImageInfo.Samples">
            @return the raw samples associated with this inline image
        </member>
        <member name="T:iTextSharp.text.pdf.parser.InlineImageUtils">
            Utility methods to help with processing of inline images
            @since 5.0.4
        </member>
        <member name="F:iTextSharp.text.pdf.parser.InlineImageUtils.inlineImageEntryAbbreviationMap">
            Map between key abbreviations allowed in dictionary of inline images and their
            equivalent image dictionary keys
        </member>
        <member name="F:iTextSharp.text.pdf.parser.InlineImageUtils.inlineImageColorSpaceAbbreviationMap">
            Map between value abbreviations allowed in dictionary of inline images for COLORSPACE
        </member>
        <member name="F:iTextSharp.text.pdf.parser.InlineImageUtils.inlineImageFilterAbbreviationMap">
            Map between value abbreviations allowed in dictionary of inline images for FILTER
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.ParseInlineImage(iTextSharp.text.pdf.PdfContentParser,iTextSharp.text.pdf.PdfDictionary)">
            Parses an inline image from the provided content parser.  The parser must be positioned immediately following the BI operator in the content stream.
            The parser will be left with current position immediately following the EI operator that terminates the inline image
            @param ps the content parser to use for reading the image. 
            @return the parsed image
            @throws IOException if anything goes wring with the parsing
            @throws InlineImageParseException if parsing of the inline image failed due to issues specific to inline image processing
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.ParseInlineImageDictionary(iTextSharp.text.pdf.PdfContentParser)">
            Parses the next inline image dictionary from the parser.  The parser must be positioned immediately following the EI operator.
            The parser will be left with position immediately following the whitespace character that follows the ID operator that ends the inline image dictionary.
            @param ps the parser to extract the embedded image information from
            @return the dictionary for the inline image, with any abbreviations converted to regular image dictionary keys and values
            @throws IOException if the parse fails
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.GetAlternateValue(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfObject)">
            Transforms value abbreviations into their corresponding real value 
            @param key the key that the value is for
            @param value the value that might be an abbreviation
            @return if value is an allowed abbreviation for the key, the expanded value for that abbreviation.  Otherwise, value is returned without modification 
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.GetComponentsPerPixel(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfDictionary)">
            @param colorSpaceName the name of the color space. If null, a bi-tonal (black and white) color space is assumed.
            @return the components per pixel for the specified color space
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.ComputeBytesPerRow(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary)">
            Computes the number of unfiltered bytes that each row of the image will contain.
            If the number of bytes results in a partial terminating byte, this number is rounded up
            per the PDF specification
            @param imageDictionary the dictionary of the inline image
            @return the number of bytes per row of the image
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.ParseUnfilteredSamples(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfContentParser)">
            Parses the samples of the image from the underlying content parser, ignoring all filters.
            The parser must be positioned immediately after the ID operator that ends the inline image's dictionary.
            The parser will be left positioned immediately following the EI operator.
            This is primarily useful if no filters have been applied. 
            @param imageDictionary the dictionary of the inline image
            @param ps the content parser
            @return the samples of the image
            @throws IOException if anything bad happens during parsing
        </member>
        <member name="M:iTextSharp.text.pdf.parser.InlineImageUtils.ParseInlineImageSamples(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.PdfContentParser)">
            Parses the samples of the image from the underlying content parser, accounting for filters
            The parser must be positioned immediately after the ID operator that ends the inline image's dictionary.
            The parser will be left positioned immediately following the EI operator.
            <b>Note:</b>This implementation does not actually apply the filters at this time
            @param imageDictionary the dictionary of the inline image
            @param ps the content parser
            @return the samples of the image
            @throws IOException if anything bad happens during parsing
        </member>
        <member name="T:iTextSharp.text.pdf.parser.InlineImageUtils.InlineImageParseException">
            Simple class in case users need to differentiate an exception from processing
            inline images vs other exceptions 
            @since 5.0.4
        </member>
        <member name="T:iTextSharp.text.pdf.parser.Line">
             Represents a line.
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Line.#ctor">
            Constructs a new zero-length line starting at zero.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Line.#ctor(System.Single,System.Single,System.Single,System.Single)">
            Constructs a new line based on the given coordinates.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Line.#ctor(iTextSharp.awt.geom.Point2D,iTextSharp.awt.geom.Point2D)">
            Constructs a new line based on the given coordinates.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.LineDashPattern">
             Represents the line dash pattern. The line dash pattern shall control the pattern
             of dashes and gaps used to stroke paths. It shall be specified by a dash array and
             a dash phase.
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineDashPattern.#ctor(iTextSharp.text.pdf.PdfArray,System.Single)">
            Creates new {@link LineDashPattern} object.
            @param dashArray The dash array. See {@link #getDashArray()}
            @param dashPhase The dash phase. See {@link #getDashPhase()}
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineDashPattern.Next">
            Calculates and returns the next element which is either gap or dash.
            @return The next dash array's element.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineDashPattern.IsSolid">
            Checks whether the dashed pattern is solid or not. It's solid when the
            size of a dash array is even and sum of all the units off in the array
            is 0.<br/>
            For example: [3 0 4 0 5 0 6 0] (sum is 0), [3 0 4 0 5 1] (sum is 1).
        </member>
        <member name="M:iTextSharp.text.pdf.parser.LineDashPattern.Reset">
            Resets the dash array so that the {@link #next()} method will start
            from the beginning of the dash array.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LineDashPattern.DashArray">
             Getter and setter for the dash array.
            
             The dash array’s elements is number that specify the lengths of
             alternating dashes and gaps; the numbers are nonnegative. The
             elements are expressed in user space units.
            
             @return The dash array.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.LineDashPattern.DashPhase">
             Getter and setter for the dash phase.
            
             The dash phase shall specify the distance into the dash pattern at which
             to start the dash. The elements are expressed in user space units.
            
             @return The dash phase.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.MultiFilteredRenderListener.AttachRenderListener``1(``0,iTextSharp.text.pdf.parser.RenderFilter[])">
            Attaches a {@link RenderListener} for the corresponding filter set.
            @param delegate RenderListener instance to be attached.
            @param filterSet filter set to be attached. The delegate will be invoked if all the filters pass.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.Path">
             Paths define shapes, trajectories, and regions of all sorts. They shall be used
             to draw lines, define the shapes of filled areas, and specify boundaries for clipping
             other graphics. A path shall be composed of straight and curved line segments, which
             may connect to one another or may be disconnected.
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.AddSubpath(iTextSharp.text.pdf.parser.Subpath)">
             Adds the subpath to this path.
            
             @param subpath The subpath to be added to this path.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.AddSubpaths(System.Collections.Generic.IList{iTextSharp.text.pdf.parser.Subpath})">
             Adds the subpaths to this path.
            
             @param subpaths {@link java.util.List} of subpaths to be added to this path.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.MoveTo(System.Single,System.Single)">
            Begins a new subpath by moving the current point to coordinates <CODE>(x, y)</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.LineTo(System.Single,System.Single)">
            Appends a straight line segment from the current point to the point <CODE>(x, y)</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.CurveTo(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE>.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.CurveTo(System.Single,System.Single,System.Single,System.Single)">
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE> with the note that the current
            point represents two control points.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.CurveFromTo(System.Single,System.Single,System.Single,System.Single)">
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE> with the note that the (x3, y3)
            point represents two control points.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.Rectangle(System.Single,System.Single,System.Single,System.Single)">
            Appends a rectangle to the current path as a complete subpath.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.CloseSubpath">
            Closes the current subpath.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.CloseAllSubpaths">
            Closes all subpathes contained in this path.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.ReplaceCloseWithLine">
            Adds additional line to each closed subpath and makes the subpath unclosed. 
            The line connects the last and the first points of the subpaths.
            
            @returns Indices of modified subpaths.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Path.IsEmpty">
            Path is empty if it contains no subpaths.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.Path.Subpaths">
            @return A {@link java.util.List} of subpaths forming this path.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.Path.CurrentPoint">
             The current point is the trailing endpoint of the segment most recently added to the current path.
            
             @return The current point.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PathConstructionRenderInfo">
             Contains information relating to construction the current path.
            
             @since 5.5.6
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.MOVETO">
            See {@link com.itextpdf.text.pdf.parser.Path#moveTo(float, float)}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.LINETO">
            See {@link com.itextpdf.text.pdf.parser.Path#lineTo(float, float)}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.CURVE_123">
            See {@link com.itextpdf.text.pdf.parser.Path#curveTo(float, float, float, float, float, float)}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.CURVE_23">
            See {@link com.itextpdf.text.pdf.parser.Path#curveTo(float, float, float, float)}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.CURVE_13">
            See {@link com.itextpdf.text.pdf.parser.Path#curveFromTo(float, float, float, float)}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.CLOSE">
            See {@link com.itextpdf.text.pdf.parser.Path#closeSubpath()}
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.RECT">
            See {@link com.itextpdf.text.pdf.parser.Path#rectangle(float, float, float, float)}
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.#ctor(System.Int32,System.Collections.Generic.IList{System.Single},iTextSharp.text.pdf.parser.Matrix)">
            @param operation   Indicates which path-construction operation should be performed.
            @param segmentData Contains data of a new segment being added to the current path.
                               E.g. x, y, w, h for rectangle; x, y for line etc.
            @param ctm         Current transformation matrix.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.#ctor(System.Int32,iTextSharp.text.pdf.parser.Matrix)">
            See {@link #PathConstructionRenderInfo(int, java.util.List, Matrix)}
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.Operation">
            @return construction operation should be performed on the current path.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.SegmentData">
            @return {@link java.util.List} containing data of a new segment (E.g. x, y, w, h for rectangle;
                    x, y for line etc.) if the specified operation relates to adding the segment to the
                    current path, <CODE>null</CODE> otherwise.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathConstructionRenderInfo.Ctm">
            @return Current transformation matrix.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.PathPaintingRenderInfo">
             Contains information relating to painting current path.
            
             @since 5.5.6
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.NONZERO_WINDING_RULE">
             The nonzero winding number rule determines whether a given point is inside a path by
             conceptually drawing a ray from that point to infinity in any direction and then examining
             the places where a segment of the path crosses the ray. Starting with a count of 0, the rule
             adds 1 each time a path segment crosses the ray from left to right and subtracts 1 each time a
             segment crosses from right to left. After counting all the crossings, if the result is 0, the
             point is outside the path; otherwise, it is inside.
            
             For more details see PDF spec.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.EVEN_ODD_RULE">
             The even-odd rule determines whether a point is inside a path by drawing a ray from that point in
             any direction and simply counting the number of path segments that cross the ray, regardless of
             direction. If this number is odd, the point is inside; if even, the point is outside.
            
             For more details see PDF spec.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.NO_OP">
            End the path object without filling or stroking it. This operator shall be a path-painting no-op,
            used primarily for the side effect of changing the current clipping path
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.STROKE">
            Value specifying stroke operation to perform on the current path.
        </member>
        <member name="F:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.FILL">
            Value specifying fill operation to perform on the current path. When the fill operation
            is performed it should use either nonzero winding or even-odd rule.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.#ctor(System.Int32,System.Int32,iTextSharp.text.pdf.parser.GraphicsState)">
            @param operation One of the possible combinations of {@link #STROKE} and {@link #FILL} values or {@link #NO_OP}
            @param rule      Either {@link #NONZERO_WINDING_RULE} or {@link #EVEN_ODD_RULE}.
            @param gs        The graphics state.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.#ctor(System.Int32,iTextSharp.text.pdf.parser.GraphicsState)">
             If the operation is {@link #NO_OP} then the rule is ignored,
             otherwise {@link #NONZERO_WINDING_RULE} is used by default.
            
             See {@link #PathPaintingRenderInfo(int, int, GraphicsState)}
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.Operation">
            @return <CODE>int</CODE> value which is either {@link #NO_OP} or one of possible
            combinations of {@link #STROKE} and {@link #FILL}
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.Rule">
            @return Either {@link #NONZERO_WINDING_RULE} or {@link #EVEN_ODD_RULE}.
        </member>
        <member name="P:iTextSharp.text.pdf.parser.PathPaintingRenderInfo.Ctm">
            @return Current transformation matrix.
        </member>
        <member name="T:iTextSharp.text.pdf.parser.Subpath">
             As subpath is a part of a path comprising a sequence of connected segments.
            
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.#ctor(iTextSharp.text.pdf.parser.Subpath)">
            Copy constuctor.
            @param subpath
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.#ctor(iTextSharp.awt.geom.Point2D)">
            Constructs a new subpath starting at the given point.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.#ctor(System.Single,System.Single)">
            Constructs a new subpath starting at the given point.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.SetStartPoint(iTextSharp.awt.geom.Point2D)">
            Sets the start point of the subpath.
            @param startPoint
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.SetStartPoint(System.Single,System.Single)">
            Sets the start point of the subpath.
            @param x
            @param y
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.GetStartPoint">
            @return The point this subpath starts at.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.GetLastPoint">
            @return The last point of the subpath.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.AddSegment(iTextSharp.text.pdf.parser.IShape)">
            Adds a segment to the subpath.
            Note: each new segment shall start at the end of the previous segment.
            @param segment new segment.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.GetSegments">
            @return {@link java.util.List} comprising all the segments
                    the subpath made on.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.IsEmpty">
            Checks whether subpath is empty or not.
            @return true if the subpath is empty, false otherwise.
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.IsSinglePointOpen">
            @return <CODE>true</CODE> if this subpath contains only one point and it is not closed,
                    <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.IsDegenerate">
             Returns a <CODE>bool</CODE> indicating whether the subpath is degenerate or not.
             A degenerate subpath is the subpath consisting of a single-point closed path or of
             two or more points at the same coordinates.
            
             @return <CODE>bool</CODE> value indicating whether the path is degenerate or not.
             @since 5.5.6
        </member>
        <member name="M:iTextSharp.text.pdf.parser.Subpath.GetPiecewiseLinearApproximation">
            @return {@link java.util.List} containing points of piecewise linear approximation
                    for this subpath.
            @since 5.5.6
        </member>
        <member name="P:iTextSharp.text.pdf.parser.Subpath.Closed">
             Returns or sets a <CODE>bool</CODE> value indicating whether the subpath must be closed or not.
             Ignore this value if the subpath is a rectangle because in this case it is already closed
             (of course if you paint the path using <CODE>re</CODE> operator)
            
             @return <CODE>bool</CODE> value indicating whether the path must be closed or not.
             @since 5.5.6
        </member>
        <member name="T:iTextSharp.text.pdf.PdfConcatenate">
            Wrapper class for PdfCopy and PdfSmartCopy.
            Allows you to concatenate existing PDF documents with much less code.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfConcatenate.document">
            The Document object for PdfCopy. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfConcatenate.copy">
            The actual PdfWriter 
        </member>
        <member name="M:iTextSharp.text.pdf.PdfConcatenate.#ctor(System.IO.Stream)">
            Creates an instance of the concatenation class.
            @param os    the Stream for the PDF document
        </member>
        <member name="M:iTextSharp.text.pdf.PdfConcatenate.#ctor(System.IO.Stream,System.Boolean)">
            Creates an instance of the concatenation class.
            @param os    the Stream for the PDF document
            @param smart do we want PdfCopy to detect redundant content?
        </member>
        <member name="M:iTextSharp.text.pdf.PdfConcatenate.AddPages(iTextSharp.text.pdf.PdfReader)">
            Adds the pages from an existing PDF document.
            @param reader    the reader for the existing PDF document
            @return          the number of pages that were added
            @throws DocumentException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.PdfConcatenate.Open">
            Opens the document (if it isn't open already).
            Opening the document is done implicitly.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfConcatenate.Close">
            We've finished writing the concatenated document.
        </member>
        <member name="P:iTextSharp.text.pdf.PdfConcatenate.Writer">
            Gets the PdfCopy instance so that you can add bookmarks or change preferences before you close PdfConcatenate.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDiv.spacingBefore">
            The spacing before the table.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDiv.spacingAfter">
            The spacing after the table.
        </member>
        <member name="F:iTextSharp.text.pdf.PdfDiv.keepTogether">
            Defines if the div should be kept on one page if possible
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.getActualHeight">
            IMPROTANT NOTE: be careful with this method because it would return correct result
            only in case if {@link PdfDiv#layout(PdfContentByte, boolean, boolean, float, float, float, float)}
            was already called.
            @return the actual height the div would require to layout it's content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.getActualWidth">
            IMPROTANT NOTE: be careful with this method because it would return correct result
            only in case if {@link PdfDiv#layout(PdfContentByte, boolean, boolean, float, float, float, float)}
            was already called.
            @return the actual width the div would require to layout it's content
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.SetBackgroundImage(iTextSharp.text.Image,System.Single,System.Single)">
            Image will be scaled to fit in the div occupied area.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.IsContent">
            @see com.itextpdf.text.Element#isContent()
            @since	iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.IsNestable">
            @see com.itextpdf.text.Element#isNestable()
            @since	iText 2.0.8
        </member>
        <member name="M:iTextSharp.text.pdf.PdfDiv.Process(iTextSharp.text.IElementListener)">
             Processes the element by adding it (or the different parts) to an
             <CODE>ElementListener</CODE>.
            
             @param	listener	an <CODE>ElementListener</CODE>
             @return	<CODE>true</CODE> if the element was processed successfully
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDiv.Chunks">
             Gets all the chunks in this element.
            
             @return	an <CODE>ArrayList</CODE>
        </member>
        <member name="P:iTextSharp.text.pdf.PdfDiv.Type">
             Gets the type of the text element.
            
             @return	a type
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPHeaderCell.NONE">
            this is a possible style. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPHeaderCell.ROW">
            this is a possible style. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPHeaderCell.COLUMN">
            this is a possible style. 
        </member>
        <member name="F:iTextSharp.text.pdf.PdfPHeaderCell.BOTH">
            this is a possible style. 
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSigLockDictionary">
            A signature field lock dictionary.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSigLockDictionary.#ctor">
            Creates a signature lock valid for all fields in the document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSigLockDictionary.#ctor(iTextSharp.text.pdf.PdfSigLockDictionary.LockPermissions)">
            Creates a signature lock for all fields in the document,
            setting specific permissions.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSigLockDictionary.#ctor(iTextSharp.text.pdf.PdfSigLockDictionary.LockAction,System.String[])">
            Creates a signature lock for specific fields in the document.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfSigLockDictionary.#ctor(iTextSharp.text.pdf.PdfSigLockDictionary.LockAction,iTextSharp.text.pdf.PdfSigLockDictionary.LockPermissions,System.String[])">
            Creates a signature lock for specific fields in the document.
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSigLockDictionary.LockAction">
            Enumerates the different actions of a signature lock.
            Indicates the set of fields that should be locked:
            all the fields in the document,
            all the fields specified in the /Fields array
            all the fields except those specified in the /Fields array
        </member>
        <member name="T:iTextSharp.text.pdf.PdfSigLockDictionary.LockPermissions">
            Enumerates the different levels of permissions.
        </member>
        <member name="M:iTextSharp.text.pdf.PdfStructTreeController.AttachStructTreeRootKids(iTextSharp.text.pdf.PdfObject)">
            Add kid to structureTreeRoot from structTreeRoot
        </member>
        <member name="T:iTextSharp.text.pdf.security.CertificateInfo">
            Class containing static methods that allow you to get information from
            an X509 Certificate: the issuer and the subject.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.GetIssuerFields(Org.BouncyCastle.X509.X509Certificate)">
            Get the issuer fields from an X509 Certificate
            @param cert an X509Certificate
            @return an X509Name
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.GetIssuer(System.Byte[])">
            Get the "issuer" from the TBSCertificate bytes that are passed in
            @param enc a TBSCertificate in a byte array
            @return a DERObject
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.GetSubjectFields(Org.BouncyCastle.X509.X509Certificate)">
            Get the subject fields from an X509 Certificate
            @param cert an X509Certificate
            @return an X509Name
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.GetSubject(System.Byte[])">
            Get the "subject" from the TBSCertificate bytes that are passed in
            @param enc A TBSCertificate in a byte array
            @return a DERObject
        </member>
        <member name="T:iTextSharp.text.pdf.security.CertificateInfo.X509Name">
            a class that holds an X509 name
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.T">
            Title
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.SN">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.SURNAME">
            Naming attribute of type X520name 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.GIVENNAME">
            Naming attribute of type X520name 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.INITIALS">
            Naming attribute of type X520name 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.GENERATION">
            Naming attribute of type X520name 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.UNIQUE_IDENTIFIER">
            Naming attribute of type X520name 
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.EmailAddress" -->
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.DC">
            object identifier 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.UID">
            LDAP User id. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.DefaultSymbols">
            A Hashtable with default symbols 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateInfo.X509Name.values">
            A Hashtable with values 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructs an X509 name
            @param seq an Asn1 Sequence
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.X509Name.#ctor(System.String)">
            Constructs an X509 name
            @param dirName a directory name
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.X509Name.GetFieldArray(System.String)">
            gets a field array from the values Hashmap
            @param name
            @return an ArrayList
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.X509Name.GetFields">
            getter for values
            @return a Hashtable with the fields of the X509 name
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateInfo.X509Name.ToString">
            @see java.lang.Object#toString()
        </member>
        <member name="T:iTextSharp.text.pdf.security.CertificateInfo.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:iTextSharp.text.pdf.security.CertificateUtil">
            This class contains a series of static methods that
            allow you to retrieve information from a Certificate.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateUtil.GetCRLURL(Org.BouncyCastle.X509.X509Certificate)">
            Gets the URL of the Certificate Revocation List for a Certificate
            @param certificate   the Certificate
            @return  the String where you can check if the certificate was revoked
            @throws CertificateParsingException
            @throws IOException 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateUtil.GetOCSPURL(Org.BouncyCastle.X509.X509Certificate)">
            Retrieves the OCSP URL from the given certificate.
            @param certificate the certificate
            @return the URL or null
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateUtil.GetTSAURL(Org.BouncyCastle.X509.X509Certificate)">
            Gets the URL of the TSA if it's available on the certificate
            @param certificate   a certificate
            @return  a TSA URL
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateUtil.GetExtensionValue(Org.BouncyCastle.X509.X509Certificate,System.String)">
            @param certificate   the certificate from which we need the ExtensionValue
            @param oid the Object Identifier value for the extension.
            @return  the extension value as an ASN1Primitive object
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateUtil.GetStringFromGeneralName(Org.BouncyCastle.Asn1.Asn1Object)">
            Gets a String from an ASN1Primitive
            @param names the ASN1Primitive
            @return  a human-readable String
            @throws IOException
        </member>
        <member name="T:iTextSharp.text.pdf.security.CertificateVerification">
            This class consists of some methods that allow you to verify certificates.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerification.VerifyCertificate(Org.BouncyCastle.X509.X509Certificate,System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Crl},System.DateTime)">
            Verifies a single certificate.
            @param cert the certificate to verify
            @param crls the certificate revocation list or <CODE>null</CODE>
            @param calendar the date or <CODE>null</CODE> for the current date
            @return a <CODE>String</CODE> with the error description or <CODE>null</CODE>
            if no error
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerification.VerifyCertificates(System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Crl},System.DateTime)">
            Verifies a certificate chain against a KeyStore.
            @param certs the certificate chain
            @param keystore the <CODE>KeyStore</CODE>
            @param crls the certificate revocation list or <CODE>null</CODE>
            @param calendar the date or <CODE>null</CODE> for the current date
            @return <CODE>null</CODE> if the certificate chain could be validated or a
            <CODE>Object[]{cert,error}</CODE> where <CODE>cert</CODE> is the
            failed certificate and <CODE>error</CODE> is the error message
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerification.VerifyCertificates(System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.DateTime)">
            Verifies a certificate chain against a KeyStore.
            @param certs the certificate chain
            @param keystore the <CODE>KeyStore</CODE>
            @param calendar the date or <CODE>null</CODE> for the current date
            @return <CODE>null</CODE> if the certificate chain could be validated or a
            <CODE>Object[]{cert,error}</CODE> where <CODE>cert</CODE> is the
            failed certificate and <CODE>error</CODE> is the error message
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerification.VerifyOcspCertificates(Org.BouncyCastle.Ocsp.BasicOcspResp,System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate})">
            Verifies an OCSP response against a KeyStore.
            @param ocsp the OCSP response
            @param keystore the <CODE>KeyStore</CODE>
            @param provider the provider or <CODE>null</CODE> to use the BouncyCastle provider
            @return <CODE>true</CODE> is a certificate was found
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerification.VerifyTimestampCertificates(Org.BouncyCastle.Tsp.TimeStampToken,System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate})">
            Verifies a time stamp against a KeyStore.
            @param ts the time stamp
            @param keystore the <CODE>KeyStore</CODE>
            @param provider the provider or <CODE>null</CODE> to use the BouncyCastle provider
            @return <CODE>true</CODE> is a certificate was found
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateVerifier.verifier">
            The previous CertificateVerifier in the chain of verifiers. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CertificateVerifier.onlineCheckingAllowed">
            Indicates if going online to verify a certificate is allowed. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerifier.#ctor(iTextSharp.text.pdf.security.CertificateVerifier)">
            Creates the CertificateVerifier in a chain of verifiers.
            @param verifier	the previous verifier in the chain
        </member>
        <member name="M:iTextSharp.text.pdf.security.CertificateVerifier.Verify(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Checks the validity of the certificate, and calls the next
            verifier in the chain, if any.
            @param signCert	the certificate that needs to be checked
            @param issuerCert	its issuer
            @param signDate		the date the certificate needs to be valid
            @return a list of <code>VerificationOK</code> objects.
            The list will be empty if the certificate couldn't be verified.
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="P:iTextSharp.text.pdf.security.CertificateVerifier.OnlineCheckingAllowed">
            Decide whether or not online checking is allowed.
            @param onlineCheckingAllowed
        </member>
        <member name="T:iTextSharp.text.pdf.security.CrlClientOffline">
            An implementation of the CrlClient that handles offline
            Certificate Revocation Lists.
            @author Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.security.ICrlClient">
            Interface that needs to be implemented if you want to embed
            Certificate Revocation Lists into your PDF.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.security.ICrlClient.GetEncoded(Org.BouncyCastle.X509.X509Certificate,System.String)">
            Gets a collection of byte array each representing a crl.
            @param	checkCert	the certificate from which a CRL URL can be obtained
            @param	url		a CRL url if you don't want to obtain it from the certificate
            @return	a collection of byte array each representing a crl. It may return null or an empty collection
        </member>
        <member name="F:iTextSharp.text.pdf.security.CrlClientOffline.crls">
            The CRL as a byte array. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOffline.#ctor(System.Byte[])">
            Creates an instance of a CrlClient in case you
            have a local cache of the Certificate Revocation List.
            @param crlEncoded    the CRL bytes
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOffline.GetEncoded(Org.BouncyCastle.X509.X509Certificate,System.String)">
            Returns the CRL bytes (the parameters are ignored).
            @see com.itextpdf.text.pdf.security.CrlClient#getEncoded(java.security.cert.X509Certificate, java.lang.String)
        </member>
        <member name="T:iTextSharp.text.pdf.security.CrlClientOnline">
            An implementation of the CrlClient that fetches the CRL bytes
            from an URL.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.security.CrlClientOnline.LOGGER">
            The Logger instance. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CrlClientOnline.urls">
            The URLs of the CRLs. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOnline.#ctor">
            Creates a CrlClientOnline instance that will try to find
            a single CRL by walking through the certificate chain.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOnline.#ctor(System.String[])">
            Creates a CrlClientOnline instance using one or more URLs.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOnline.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate})">
            Creates a CrlClientOnline instance using a certificate chain.
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOnline.AddUrl(System.String)">
            Adds an URL to the list of CRL URLs
            @param url	an URL in the form of a String
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlClientOnline.GetEncoded(Org.BouncyCastle.X509.X509Certificate,System.String)">
            Fetches the CRL bytes from an URL.
            If no url is passed as parameter, the url will be obtained from the certificate.
            If you want to load a CRL from a local file, subclass this method and pass an
            URL with the path to the local file to this method. An other option is to use
            the CrlClientOffline class.
            @see com.itextpdf.text.pdf.security.CrlClient#getEncoded(java.security.cert.X509Certificate, java.lang.String)
        </member>
        <member name="F:iTextSharp.text.pdf.security.RootStoreVerifier.LOGGER">
            The Logger instance 
        </member>
        <member name="F:iTextSharp.text.pdf.security.RootStoreVerifier.certificates">
            A key store against which certificates can be verified. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.RootStoreVerifier.#ctor(iTextSharp.text.pdf.security.CertificateVerifier)">
            Creates a RootStoreVerifier in a chain of verifiers.
            
            @param verifier
                       the next verifier in the chain
        </member>
        <member name="M:iTextSharp.text.pdf.security.RootStoreVerifier.Verify(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies a single certificate against a key store (if present).
            
            @param signCert
                       the certificate to verify
            @param issuerCert
                       the issuer certificate
            @param signDate
                       the date the certificate needs to be valid
            @return a list of <code>VerificationOK</code> objects.
            The list will be empty if the certificate couldn't be verified.
        </member>
        <member name="P:iTextSharp.text.pdf.security.RootStoreVerifier.Certificates">
            Sets the Key Store against which a certificate can be checked.
            
            @param keyStore
                       a root store
        </member>
        <member name="F:iTextSharp.text.pdf.security.CrlVerifier.LOGGER">
            The Logger instance 
        </member>
        <member name="F:iTextSharp.text.pdf.security.CrlVerifier.crls">
            The list of CRLs to check for revocation date. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlVerifier.#ctor(iTextSharp.text.pdf.security.CertificateVerifier,System.Collections.Generic.List{Org.BouncyCastle.X509.X509Crl})">
            Creates a CRLVerifier instance.
            @param verifier	the next verifier in the chain
            @param crls a list of CRLs
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlVerifier.Verify(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies if a a valid CRL is found for the certificate.
            If this method returns false, it doesn't mean the certificate isn't valid.
            It means we couldn't verify it against any CRL that was available.
            @param signCert	the certificate that needs to be checked
            @param issuerCert	its issuer
            @return a list of <code>VerificationOK</code> objects.
            The list will be empty if the certificate couldn't be verified.
            @see com.itextpdf.text.pdf.security.RootStoreVerifier#verify(java.security.cert.X509Certificate, java.security.cert.X509Certificate, java.util.Date)
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlVerifier.Verify(Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies a certificate against a single CRL.
            @param crl	the Certificate Revocation List
            @param signCert	a certificate that needs to be verified
            @param issuerCert	its issuer
            @param signDate		the sign date
            @return true if the verification succeeded
            @throws GeneralSecurityException
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlVerifier.GetCrl(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate)">
            Fetches a CRL for a specific certificate online (without further checking).
            @param signCert	the certificate
            @param issuerCert	its issuer
            @return	an X509CRL object
        </member>
        <member name="M:iTextSharp.text.pdf.security.CrlVerifier.IsSignatureValid(Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.X509.X509Certificate)">
            Checks if a CRL verifies against the issuer certificate or a trusted anchor.
            @param crl	the CRL
            @param crlIssuer	the trusted anchor
            @return	true if the CRL can be trusted
        </member>
        <member name="T:iTextSharp.text.pdf.security.DigestAlgorithms">
            Class that contains a map with the different message digest algorithms.
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.SHA1">
            Algorithm available for signatures since PDF 1.3 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.SHA256">
            Algorithm available for signatures since PDF 1.6 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.SHA384">
            Algorithm available for signatures since PDF 1.7 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.SHA512">
            Algorithm available for signatures since PDF 1.7 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.RIPEMD160">
            Algorithm available for signatures since PDF 1.7 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.digestNames">
            Maps the digest IDs with the human-readable name of the digest algorithm. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.DigestAlgorithms.allowedDigests">
            Maps the name of a digest algorithm with its ID. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.DigestAlgorithms.GetMessageDigest(System.String)">
            Creates a MessageDigest object that can be used to create a hash.
            @param hashAlgorithm the algorithm you want to use to create a hash
            @param provider  the provider you want to use to create the hash
            @return  a MessageDigest object
            @throws NoSuchAlgorithmException 
            @throws NoSuchProviderException 
            @throws GeneralSecurityException
        </member>
        <member name="M:iTextSharp.text.pdf.security.DigestAlgorithms.Digest(System.IO.Stream,System.String)">
            Creates a hash using a specific digest algorithm and a provider. 
            @param data  the message of which you want to create a hash
            @param hashAlgorithm the algorithm used to create the hash
            @param provider  the provider used to create the hash
            @return  the hash
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.DigestAlgorithms.GetDigest(System.String)">
            Gets the digest name for a certain id
            @param oid   an id (for instance "1.2.840.113549.2.5")
            @return  a digest name (for instance "MD5")
        </member>
        <member name="M:iTextSharp.text.pdf.security.DigestAlgorithms.GetAllowedDigests(System.String)">
            Returns the id of a digest algorithms that is allowed in PDF,
            or null if it isn't allowed. 
            @param name  the name of the digest algorithm
            @return  an oid
        </member>
        <member name="T:iTextSharp.text.pdf.security.EncryptionAlgorithms">
            Class that contains a map with the different encryption algorithms.
        </member>
        <member name="F:iTextSharp.text.pdf.security.EncryptionAlgorithms.algorithmNames">
            Maps IDs of encryption algorithms with its human-readable name. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.EncryptionAlgorithms.GetAlgorithm(System.String)">
            Gets the algorithm name for a certain id.
            @param oid    an id (for instance "1.2.840.113549.1.1.1")
            @return   an algorithm name (for instance "RSA")
            @since    2.1.6
        </member>
        <member name="T:com.itextpdf.text.pdf.security.ExternalBlankSignatureContainer">
            Produces a blank (or empty) signature. Useful for deferred signing with
            MakeSignature.signExternalContainer().
            @author Paulo Soares
        </member>
        <member name="T:iTextSharp.text.pdf.security.IExternalSignatureContainer">
            Interface to sign a document. The signing is fully done externally, including the container composition.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.security.IExternalSignatureContainer.Sign(System.IO.Stream)">
            Produces the container with the signature.
            @param data the data to sign
            @return a container with the signature and other objects, like CRL and OCSP. The container will generally be a PKCS7 one.
            @throws GeneralSecurityException 
        </member>
        <member name="M:iTextSharp.text.pdf.security.IExternalSignatureContainer.ModifySigningDictionary(iTextSharp.text.pdf.PdfDictionary)">
            Modifies the signature dictionary to suit the container. At least the keys PdfName.FILTER and 
            PdfName.SUBFILTER will have to be set.
            @param signDic the signature dictionary
        </member>
        <member name="T:iTextSharp.text.pdf.security.IExternalSignature">
            Interface that needs to be implemented to do the actual signing.
            For instance: you'll have to implement this interface if you want
            to sign a PDF using a smart card.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.security.IExternalSignature.GetHashAlgorithm">
            Returns the hash algorithm.
            @return  the hash algorithm (e.g. "SHA-1", "SHA-256,...")
        </member>
        <member name="M:iTextSharp.text.pdf.security.IExternalSignature.GetEncryptionAlgorithm">
            Returns the encryption algorithm used for signing.
            @return the encryption algorithm ("RSA" or "DSA")
        </member>
        <member name="M:iTextSharp.text.pdf.security.IExternalSignature.Sign(System.Byte[])">
            Signs it using the encryption algorithm in combination with
            the digest algorithm.
            @param message   the message you want to be hashed and signed
            @return  a signed message digest
            @throws GeneralSecurityException
        </member>
        <member name="T:iTextSharp.text.pdf.security.IOcspClient">
            Interface for the OCSP Client.
            @since 2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.security.IOcspClient.GetEncoded(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.String)">
            	     * Gets an encoded byte array with OCSP validation. The method should not throw an exception.
                     * @param checkCert to certificate to check
                     * @param rootCert the parent certificate
                     * @param url the url to get the verification. It it's null it will be taken
                     * from the check cert or from other implementation specific source
            	     * @return	a byte array with the validation or null if the validation could not be obtained
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.text.pdf.security.ITSAClient" -->
        <member name="M:iTextSharp.text.pdf.security.ITSAClient.GetTokenSizeEstimate">
            Get the time stamp token size estimate.
            Implementation must return value large enough to accomodate the entire token
            returned by getTimeStampToken() _prior_ to actual getTimeStampToken() call.
            @return   an estimate of the token size
        </member>
        <member name="M:iTextSharp.text.pdf.security.ITSAClient.GetMessageDigest">
            Gets the MessageDigest to digest the data imprint
            @return the digest algorithm name
        </member>
        <member name="M:iTextSharp.text.pdf.security.ITSAClient.GetTimeStampToken(System.Byte[])">
            Get RFC 3161 timeStampToken.
            Method may return null indicating that timestamp should be skipped.
            @param imprint byte[] - data imprint to be time-stamped
            @return byte[] - encoded, TSA signed data of the timeStampToken
            @throws Exception - TSA request failed
        </member>
        <member name="T:iTextSharp.text.pdf.security.IXmlLocator">
            Helps to locate xml stream
        </member>
        <member name="T:iTextSharp.text.pdf.security.IXpathConstructor">
            Constructor for XPath2 expression
        </member>
        <member name="M:iTextSharp.text.pdf.security.IXpathConstructor.GetXpathExpression">
            Get XPath2 expression
        </member>
        <member name="M:iTextSharp.text.pdf.security.IXpathConstructor.GetNamespaceManager">
            Get XmlNamespaceManager to resolve namespace conflicts
        </member>
        <member name="T:iTextSharp.text.pdf.security.LtvTimestamp">
            PAdES-LTV Timestamp
            @author Pulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvTimestamp.Timestamp(iTextSharp.text.pdf.PdfSignatureAppearance,iTextSharp.text.pdf.security.ITSAClient,System.String)">
            Signs a document with a PAdES-LTV Timestamp. The document is closed at the end.
            @param sap the signature appearance
            @param tsa the timestamp generator
            @param signatureName the signature name or null to have a name generated
            automatically
            @throws Exception
        </member>
        <member name="T:iTextSharp.text.pdf.security.LtvVerification">
            Add verification according to PAdES-LTV (part 4)
            @author psoares
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerification.#ctor(iTextSharp.text.pdf.PdfStamper)">
            The verification constructor. This class should only be created with
            PdfStamper.getLtvVerification() otherwise the information will not be
            added to the Pdf.
            @param stp the PdfStamper to apply the validation to
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerification.AddVerification(System.String,iTextSharp.text.pdf.security.IOcspClient,iTextSharp.text.pdf.security.ICrlClient,iTextSharp.text.pdf.security.LtvVerification.CertificateOption,iTextSharp.text.pdf.security.LtvVerification.Level,iTextSharp.text.pdf.security.LtvVerification.CertificateInclusion)">
            Add verification for a particular signature
            @param signatureName the signature to validate (it may be a timestamp)
            @param ocsp the interface to get the OCSP
            @param crl the interface to get the CRL
            @param certOption
            @param level the validation options to include
            @param certInclude
            @return true if a validation was generated, false otherwise
            @throws Exception
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerification.GetParent(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate[])">
            Returns the issuing certificate for a child certificate.
            @param cert  the certificate for which we search the parent
            @param certs an array with certificates that contains the parent
            @return  the partent certificate
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerification.AddVerification(System.String,System.Collections.Generic.ICollection{System.Byte[]},System.Collections.Generic.ICollection{System.Byte[]},System.Collections.Generic.ICollection{System.Byte[]})">
             Alternative addVerification.
             I assume that inputs are deduplicated.
            
             @throws IOException
             @throws GeneralSecurityException
            
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerification.Merge">
            Merges the validation with any validation already in the document or creates
            a new one.
            @throws IOException 
        </member>
        <member name="T:iTextSharp.text.pdf.security.LtvVerification.Level">
            What type of verification to include 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.Level.OCSP">
            Include only OCSP
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.Level.CRL">
            Include only CRL
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.Level.OCSP_CRL">
            Include both OCSP and CRL
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.Level.OCSP_OPTIONAL_CRL">
            Include CRL only if OCSP can't be read
        </member>
        <member name="T:iTextSharp.text.pdf.security.LtvVerification.CertificateOption">
            Options for how many certificates to include
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.CertificateOption.SIGNING_CERTIFICATE">
            Include verification just for the signing certificate
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.CertificateOption.WHOLE_CHAIN">
            Include verification for the whole chain of certificates
        </member>
        <member name="T:iTextSharp.text.pdf.security.LtvVerification.CertificateInclusion">
            Certificate inclusion in the DSS and VRI dictionaries in the CERT and CERTS
            keys
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.CertificateInclusion.YES">
            Include certificates in the DSS and VRI dictionaries
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerification.CertificateInclusion.NO">
            Do not include certificates in the DSS and VRI dictionaries
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.LOGGER">
            The Logger instance 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.option">
            Do we need to check all certificate, or only the signing certificate? 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.verifyRootCertificate">
            Verify root. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.reader">
            A reader object for the revision that is being verified. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.fields">
            The fields in the revision that is being verified. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.signDate">
            The date the revision was signed, or <code>null</code> for the highest revision. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.signatureName">
            The signature that covers the revision. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.pkcs7">
            The PdfPKCS7 object for the signature. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.latestRevision">
            Indicates if we're working with the latest revision. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.LtvVerifier.dss">
            The document security store for the revision that is being verified 
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.#ctor(iTextSharp.text.pdf.PdfReader)">
            Creates a VerificationData object for a PdfReader
            @param reader	a reader for the document we want to verify.
            @throws GeneralSecurityException 
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.CoversWholeDocument">
            Checks if the signature covers the whole document
            and throws an exception if the document was altered
            @return a PdfPKCS7 object
            @throws GeneralSecurityException
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.Verify(System.Collections.Generic.List{iTextSharp.text.pdf.security.VerificationOK})">
            Verifies all the document-level timestamps and all the signatures in the document.
            @throws IOException
            @throws GeneralSecurityException
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.VerifySignature">
            Verifies a document level timestamp.
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.VerifyChain(Org.BouncyCastle.X509.X509Certificate[])">
            Checks the certificates in a certificate chain:
            are they valid on a specific date, and
            do they chain up correctly?
            @param chain
            @throws GeneralSecurityException
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.Verify(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies certificates against a list of CRLs and OCSP responses.
            @param signingCert
            @param issuerCert
            @return a list of <code>VerificationOK</code> objects.
            The list will be empty if the certificate couldn't be verified.
            @throws GeneralSecurityException
            @throws IOException
            @see com.itextpdf.text.pdf.security.RootStoreVerifier#verify(java.security.cert.X509Certificate, java.security.cert.X509Certificate)
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.SwitchToPreviousRevision">
            Switches to the previous revision.
            @throws IOException
            @throws GeneralSecurityException 
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.GetCRLsFromDSS">
            Gets a list of X509CRL objects from a Document Security Store.
            @return	a list of CRLs
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.LtvVerifier.GetOCSPResponsesFromDSS">
            Gets OCSP responses from the Document Security Store.
            @return	a list of BasicOCSPResp objects
            @throws IOException
            @throws GeneralSecurityException
        </member>
        <member name="P:iTextSharp.text.pdf.security.LtvVerifier.Verifier">
            Sets an extra verifier.
            @param verifier the verifier to set
        </member>
        <member name="P:iTextSharp.text.pdf.security.LtvVerifier.CertificateOption">
            Sets the certificate option.
            @param	option	Either CertificateOption.SIGNING_CERTIFICATE (default) or CertificateOption.WHOLE_CHAIN
        </member>
        <member name="P:iTextSharp.text.pdf.security.LtvVerifier.VerifyRootCertificate">
            Set the verifyRootCertificate to false if you can't verify the root certificate.
        </member>
        <member name="T:iTextSharp.text.pdf.security.MakeSignature">
            Class that signs your PDF.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.security.MakeSignature.LOGGER">
            The Logger instance. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeSignature.SignDetached(iTextSharp.text.pdf.PdfSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.Collections.Generic.ICollection{iTextSharp.text.pdf.security.ICrlClient},iTextSharp.text.pdf.security.IOcspClient,iTextSharp.text.pdf.security.ITSAClient,System.Int32,iTextSharp.text.pdf.security.CryptoStandard)">
            Signs the document using the detached mode, CMS or CAdES equivalent.
            @param sap the PdfSignatureAppearance
            @param externalSignature the interface providing the actual signing
            @param chain the certificate chain
            @param crlList the CRL list
            @param ocspClient the OCSP client
            @param tsaClient the Timestamp client
            @param provider the provider or null
            @param estimatedSize the reserved size for the signature. It will be estimated if 0
            @param cades true to sign CAdES equivalent PAdES-BES, false to sign CMS
            @throws DocumentException 
            @throws IOException 
            @throws GeneralSecurityException 
            @throws NoSuchAlgorithmException 
            @throws Exception 
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeSignature.ProcessCrl(Org.BouncyCastle.X509.X509Certificate,System.Collections.Generic.ICollection{iTextSharp.text.pdf.security.ICrlClient})">
            Processes a CRL list.
            @param cert	a Certificate if one of the CrlList implementations needs to retrieve the CRL URL from it.
            @param crlList	a list of CrlClient implementations
            @return	a collection of CRL bytes that can be embedded in a PDF.
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeSignature.SignExternalContainer(iTextSharp.text.pdf.PdfSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignatureContainer,System.Int32)">
            Sign the document using an external container, usually a PKCS7. The signature is fully composed
            externally, iText will just put the container inside the document.
            @param sap the PdfSignatureAppearance
            @param externalSignatureContainer the interface providing the actual signing
            @param estimatedSize the reserved size for the signature
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException 
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeSignature.SignDeferred(iTextSharp.text.pdf.PdfReader,System.String,System.IO.Stream,iTextSharp.text.pdf.security.IExternalSignatureContainer)">
            Signs a PDF where space was already reserved.
            @param reader the original PDF
            @param fieldName the field to sign. It must be the last field
            @param outs the output PDF
            @param externalSignatureContainer the signature container doing the actual signing. Only the 
            method ExternalSignatureContainer.sign is used
            @throws DocumentException
            @throws IOException
            @throws GeneralSecurityException 
        </member>
        <member name="T:iTextSharp.text.pdf.security.MakeXmlSignature">
            Class that signs your XML.
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXmlDSig(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,System.Security.Cryptography.Xml.KeyInfoClause)">
            Signs the xml using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param keyInfo KeyInfo for verification
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXades(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,Org.BouncyCastle.X509.X509Certificate[],System.Boolean)">
            Signs the xml with XAdES BES using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param chain the certificate chain
            @param includeSignaturePolicy if true SignaturePolicyIdentifier will be included (XAdES-EPES)
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXadesBes(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,Org.BouncyCastle.X509.X509Certificate[])">
            Signs the xml with XAdES BES using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param chain the certificate chain
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXadesEpes(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,Org.BouncyCastle.X509.X509Certificate[])">
            Signs the xml with XAdES BES using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param chain the certificate chain
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXmlDSig(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,Org.BouncyCastle.X509.X509Certificate[])">
            Signs the xml using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param chain the certificate chain
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="M:iTextSharp.text.pdf.security.MakeXmlSignature.SignXmlDSig(iTextSharp.text.pdf.XmlSignatureAppearance,iTextSharp.text.pdf.security.IExternalSignature,System.Security.Cryptography.AsymmetricAlgorithm)">
            Signs the xml using the enveloped mode, with optional xpath transform (see XmlSignatureAppearance).
            @param sap the XmlSignatureAppearance
            @param externalSignature  the interface providing the actual signing
            @param publicKey PublicKey for verification
            @throws GeneralSecurityException
            @throws IOException
            @throws DocumentException
        </member>
        <member name="T:iTextSharp.text.pdf.security.OcspClientBouncyCastle">
            OcspClient implementation using BouncyCastle.
            @author Paulo Soares
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspClientBouncyCastle.#ctor">
            Create default implemention of {@code OcspClient}.
            Note, if you use this constructor, OCSP response will not be verified.
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspClientBouncyCastle.#ctor(iTextSharp.text.pdf.security.OcspVerifier)">
            Create {@code OcspClient}
            @param verifier will be used for response verification. {@see OCSPVerifier}.
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspClientBouncyCastle.GetBasicOCSPResp(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.String)">
            Gets OCSP response. If {@see OCSPVerifier} was set, the response will be checked.
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspClientBouncyCastle.GetEncoded(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.String)">
             Gets an encoded byte array with OCSP validation. The method should not throw an exception.
            
             @param checkCert to certificate to check
             @param rootCert  the parent certificate
             @param url       to get the verification. It it's null it will be taken
                              from the check cert or from other implementation specific source
             @return a byte array with the validation or null if the validation could not be obtained
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspClientBouncyCastle.GenerateOCSPRequest(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Math.BigInteger)">
            Generates an OCSP request using BouncyCastle.
            @param issuerCert	certificate of the issues
            @param serialNumber	serial number
            @return	an OCSP request
            @throws OCSPException
            @throws IOException
        </member>
        <member name="F:iTextSharp.text.pdf.security.OcspVerifier.LOGGER">
            The Logger instance 
        </member>
        <member name="F:iTextSharp.text.pdf.security.OcspVerifier.ocsps">
            The list of OCSP responses. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.#ctor(iTextSharp.text.pdf.security.CertificateVerifier,System.Collections.Generic.List{Org.BouncyCastle.Ocsp.BasicOcspResp})">
            Creates an OCSPVerifier instance.
            @param verifier	the next verifier in the chain
            @param ocsps a list of OCSP responses
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.Verify(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies if a a valid OCSP response is found for the certificate.
            If this method returns false, it doesn't mean the certificate isn't valid.
            It means we couldn't verify it against any OCSP response that was available.
            @param signCert	the certificate that needs to be checked
            @param issuerCert	its issuer
            @return a list of <code>VerificationOK</code> objects.
            The list will be empty if the certificate couldn't be verified.
            @see com.itextpdf.text.pdf.security.RootStoreVerifier#verify(java.security.cert.X509Certificate, java.security.cert.X509Certificate, java.util.Date)
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.Verify(Org.BouncyCastle.Ocsp.BasicOcspResp,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate,System.DateTime)">
            Verifies a certificate against a single OCSP response
            @param ocspResp	the OCSP response
            @param signCert  the certificate that needs to be checked
            @param issuerCert  the certificate of CA
            @param signDate  sign date
            @return {@code true}, in case successful check, otherwise false.
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.IsValidResponse(Org.BouncyCastle.Ocsp.BasicOcspResp,Org.BouncyCastle.X509.X509Certificate)">
            Verifies if an OCSP response is genuine
             If it doesn't verify against the issuer certificate and response's certificates, it may verify
            using a trusted anchor or cert.
            @param ocspResp	the OCSP response
            @param issuerCert	the issuer certificate
            @throws GeneralSecurityException
            @throws IOException
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.VerifyResponse(Org.BouncyCastle.Ocsp.BasicOcspResp,Org.BouncyCastle.X509.X509Certificate)">
            Verifies if the response is valid.
            If it doesn't verify against the issuer certificate and response's certificates, it may verify
            using a trusted anchor or cert.
            NOTE. Use {@code isValidResponse()} instead.
            @param ocspResp	the response object
            @param issuerCert the issuer certificate
            @return	true if the response can be trusted
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.IsSignatureValid(Org.BouncyCastle.Ocsp.BasicOcspResp,Org.BouncyCastle.X509.X509Certificate)">
            Checks if an OCSP response is genuine
            @param ocspResp	the OCSP response
            @param responderCert	the responder certificate
            @return	true if the OCSP response verifies against the responder certificate
        </member>
        <member name="M:iTextSharp.text.pdf.security.OcspVerifier.GetOcspResponse(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate)">
            Gets an OCSP response online and returns it if the status is GOOD
            (without further checking).
            @param signCert	the signing certificate
            @param issuerCert	the issuer certificate
            @return an OCSP response
        </member>
        <member name="T:iTextSharp.text.pdf.security.PdfPKCS7">
            This class does all the processing related to signing
            and verifying a PKCS#7 signature.
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.#ctor(Org.BouncyCastle.Crypto.ICipherParameters,System.Collections.Generic.ICollection{Org.BouncyCastle.X509.X509Certificate},System.String,System.Boolean)">
            Assembles all the elements needed to create a signature, except for the data.
            @param privKey the private key
            @param certChain the certificate chain
            @param interfaceDigest the interface digest
            @param hashAlgorithm the hash algorithm
            @param provider the provider or <code>null</code> for the default provider
            @param hasRSAdata <CODE>true</CODE> if the sub-filter is adbe.pkcs7.sha1
            @throws InvalidKeyException on error
            @throws NoSuchProviderException on error
            @throws NoSuchAlgorithmException on error
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.#ctor(System.Byte[],System.Byte[])">
            Use this constructor if you want to verify a signature using the sub-filter adbe.x509.rsa_sha1.
            @param contentsKey the /Contents key
            @param certsKey the /Cert key
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.#ctor(System.Byte[],iTextSharp.text.pdf.PdfName)">
            Use this constructor if you want to verify a signature.
            @param contentsKey the /Contents key
            @param filterSubtype the filtersubtype
            @param provider the provider or <code>null</code> for the default provider
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.signName">
            Holds value of property signName. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.reason">
            Holds value of property reason. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.location">
            Holds value of property location. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.signDate">
            Holds value of property signDate. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.version">
            Version of the PKCS#7 object 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.signerversion">
            Version of the PKCS#7 "SignerInfo" object. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.digestAlgorithmOid">
            The ID of the digest algorithm, e.g. "2.16.840.1.101.3.4.2.1". 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.messageDigest">
            The object that will create the digest 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.digestalgos">
            The digest algorithms 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.digestAttr">
            The digest attributes 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetHashAlgorithm">
            Returns the name of the digest algorithm, e.g. "SHA256".
            @return the digest algorithm name, e.g. "SHA256"
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.digestEncryptionAlgorithmOid">
            The encryption algorithm. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetDigestAlgorithm">
            Get the algorithm used to calculate the message digest, e.g. "SHA1withRSA".
            @return the algorithm used to calculate the message digest
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.externalDigest">
            The signed digest if created outside this class 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.externalRSAdata">
            External RSA data 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.SetExternalDigest(System.Byte[],System.Byte[],System.String)">
            Sets the digest/signature to an external calculated value.
            @param digest the digest. This is the actual signature
            @param RSAdata the extra data that goes into the data tag in PKCS#7
            @param digestEncryptionAlgorithm the encryption algorithm. It may must be <CODE>null</CODE> if the <CODE>digest</CODE>
            is also <CODE>null</CODE>. If the <CODE>digest</CODE> is not <CODE>null</CODE>
            then it may be "RSA" or "DSA"
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.sig">
            Class from the Java SDK that provides the functionality of a digital signature algorithm. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.digest">
            The signed digest as calculated by this class (or extracted from an existing PDF) 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.RSAdata">
            The RSA data 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.Update(System.Byte[],System.Int32,System.Int32)">
            Update the digest with the specified bytes.
            This method is used both for signing and verifying
            @param buf the data buffer
            @param off the offset in the data buffer
            @param len the data length
            @throws SignatureException on error
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetEncodedPKCS1">
            Gets the bytes for the PKCS#1 object.
            @return a byte array
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetEncodedPKCS7">
            Gets the bytes for the PKCS7SignedData object.
            @return the bytes for the PKCS7SignedData object
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetEncodedPKCS7(System.Byte[])">
            Gets the bytes for the PKCS7SignedData object. Optionally the authenticatedAttributes
            in the signerInfo can also be set. If either of the parameters is <CODE>null</CODE>, none will be used.
            @param secondDigest the digest in the authenticatedAttributes
            @return the bytes for the PKCS7SignedData object
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetEncodedPKCS7(System.Byte[],iTextSharp.text.pdf.security.ITSAClient,System.Byte[],System.Collections.Generic.ICollection{System.Byte[]},iTextSharp.text.pdf.security.CryptoStandard)">
            Gets the bytes for the PKCS7SignedData object. Optionally the authenticatedAttributes
            in the signerInfo can also be set, OR a time-stamp-authority client
            may be provided.
            @param secondDigest the digest in the authenticatedAttributes
            @param tsaClient TSAClient - null or an optional time stamp authority client
            @return byte[] the bytes for the PKCS7SignedData object
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.BuildUnauthenticatedAttributes(System.Byte[])">
            Added by Aiken Sam, 2006-11-15, modifed by Martin Brunecky 07/12/2007
            to start with the timeStampToken (signedData 1.2.840.113549.1.7.2).
            Token is the TSA response without response status, which is usually
            handled by the (vendor supplied) TSA request/response interface).
            @param timeStampToken byte[] - time stamp token, DER encoded signedData
            @return ASN1EncodableVector
            @throws IOException
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.pdf.security.PdfPKCS7.getAuthenticatedAttributeBytes(System.Byte[],System.Byte[],System.Collections.Generic.ICollection{System.Byte[]},iTextSharp.text.pdf.security.CryptoStandard)" -->
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetAuthenticatedAttributeSet(System.Byte[],System.Byte[],System.Collections.Generic.ICollection{System.Byte[]},iTextSharp.text.pdf.security.CryptoStandard)">
            This method provides that encoding and the parameters must be
            exactly the same as in {@link #getEncodedPKCS7(byte[],Calendar)}.
            
            @param secondDigest the content digest
            @return the byte array representation of the authenticatedAttributes ready to be signed
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.sigAttr">
            Signature attributes 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.sigAttrDer">
            Signature attributes (maybe not necessary, but we use it as fallback) 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.encContDigest">
            encrypted digest 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.verified">
            Indicates if a signature has already been verified 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.verifyResult">
            The result of the verification 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.Verify">
            Verify the digest.
            @throws SignatureException on error
            @return <CODE>true</CODE> if the signature checks out, <CODE>false</CODE> otherwise
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.VerifyTimestampImprint">
            Checks if the timestamp refers to this document.
            @throws java.security.NoSuchAlgorithmException on error
            @return true if it checks false otherwise
            @since   2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.certs">
            All the X.509 certificates in no particular order. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.signCerts">
            All the X.509 certificates used for the main signature. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.signCert">
            The X.509 certificate that is used to sign the digest. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.CalcSignCertificateChain">
            Helper method that creates the collection of certificates
            used for the main signature based on the complete list
            of certificates and the sign certificate.
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.FindCRL(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Helper method that tries to construct the CRLs.
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.basicResp">
            BouncyCastle BasicOCSPResp 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.IsRevocationValid">
            Checks if OCSP revocation refers to the document signing certificate.
            @return true if it checks, false otherwise
            @since   2.1.6
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.FindOcsp(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Helper method that creates the BasicOCSPResp object.
            @param seq
            @throws IOException
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.isTsp">
            True if there's a PAdES LTV time stamp. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PdfPKCS7.timeStampToken">
            BouncyCastle TimeStampToken. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetFilterSubtype">
            Returns the filter subtype.
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfPKCS7.GetEncryptionAlgorithm">
            Returns the encryption algorithm
            @return	the name of an encryption algorithm
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.SignName">
            Getter/setter for property sigName.
            @return Value of property sigName.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.Reason">
            Getter for property reason.
            @return Value of property reason.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.Location">
            Getter for property location.
            @return Value of property location.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.SignDate">
            Getter for property signDate.
            @return Value of property signDate.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.Version">
            Get the version of the PKCS#7 object.
            @return the version of the PKCS#7 object.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.SigningInfoVersion">
            Get the version of the PKCS#7 "SignerInfo" object.
            @return the version of the PKCS#7 "SignerInfo" object.
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.DigestAlgorithmOid">
            Getter for the ID of the digest algorithm, e.g. "2.16.840.1.101.3.4.2.1"
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.DigestEncryptionAlgorithmOid">
            Getter for the digest encryption algorithm
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.Certificates">
            Get all the X.509 certificates associated with this PKCS#7 object in no particular order.
            Other certificates, from OCSP for example, will also be included.
            @return the X.509 certificates associated with this PKCS#7 object
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.SignCertificateChain">
            Get the X.509 sign certificate chain associated with this PKCS#7 object.
            Only the certificates used for the main signature will be returned, with
            the signing certificate first.
            @return the X.509 certificates associated with this PKCS#7 object
            @since   2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.SigningCertificate">
            Get the X.509 certificate actually used to sign the digest.
            @return the X.509 certificate actually used to sign the digest
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.CRLs">
            Get the X.509 certificate revocation lists associated with this PKCS#7 object
            @return the X.509 certificate revocation lists associated with this PKCS#7 object
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.Ocsp">
            Gets the OCSP basic response if there is one.
            @return the OCSP basic response or null
            @since   2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.IsTsp">
            Check if it's a PAdES-LTV time stamp.
            @return true if it's a PAdES-LTV time stamp, false otherwise
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.TimeStampToken">
            Gets the timestamp token if there is one.
            @return the timestamp token or null
            @since   2.1.6
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfPKCS7.TimeStampDate">
            Gets the timestamp date
            @return  a date
            @since   2.1.6
        </member>
        <member name="T:iTextSharp.text.pdf.security.PdfSignatureAppDictionary">
            A dictionary that stores the name of the application that signs the PDF.
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfSignatureAppDictionary.#ctor">
            Creates new PdfSignatureAppDictionary 
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfSignatureAppDictionary.SignatureCreator">
            Sets the signature created property in the Prop_Build dictionary's App
            dictionary
            
            @param name
        </member>
        <member name="T:iTextSharp.text.pdf.security.PdfSignatureBuildProperties">
            Dictionary that stores signature build properties.
            @author Kwinten Pisman
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfSignatureBuildProperties.#ctor">
            Creates new PdfSignatureBuildProperties 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PdfSignatureBuildProperties.GetPdfSignatureAppProperty">
            Gets the {@link PdfSignatureAppDictionary} from this dictionary. If it
            does not exist, it adds a new {@link PdfSignatureAppDictionary} and
            returns this instance.
            
            @return {@link PdfSignatureAppDictionary}
        </member>
        <member name="P:iTextSharp.text.pdf.security.PdfSignatureBuildProperties.SignatureCreator">
            Sets the signatureCreator property in the underlying
            {@link PdfSignatureAppDictionary} dictionary.
            
            @param name
        </member>
        <member name="T:iTextSharp.text.pdf.security.PrivateKeySignature">
            Implementation of the ExternalSignature interface that can be used
            when you have a PrivateKey object.
            @author Paulo Soares
        </member>
        <member name="F:iTextSharp.text.pdf.security.PrivateKeySignature.pk">
            The private key object. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PrivateKeySignature.hashAlgorithm">
            The hash algorithm. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.PrivateKeySignature.encryptionAlgorithm">
            The encryption algorithm (obtained from the private key) 
        </member>
        <member name="M:iTextSharp.text.pdf.security.PrivateKeySignature.#ctor(Org.BouncyCastle.Crypto.ICipherParameters,System.String)">
            Creates an ExternalSignature instance
            @param pk    a PrivateKey object
            @param hashAlgorithm the hash algorithm (e.g. "SHA-1", "SHA-256",...)
            @param provider  the security provider (e.g. "BC")
        </member>
        <member name="M:iTextSharp.text.pdf.security.PrivateKeySignature.Sign(System.Byte[])">
            Creates a message digest using the hash algorithm
            and signs it using the encryption algorithm.
            @param message   the message you want to be hashed and signed
            @return  a signed message digest
            @see com.itextpdf.text.pdf.security.ExternalSignature#sign(byte[])
        </member>
        <member name="M:iTextSharp.text.pdf.security.PrivateKeySignature.GetHashAlgorithm">
            Returns the hash algorithm.
            @return  the hash algorithm (e.g. "SHA-1", "SHA-256,...")
            @see com.itextpdf.text.pdf.security.ExternalSignature#getHashAlgorithm()
        </member>
        <member name="M:iTextSharp.text.pdf.security.PrivateKeySignature.GetEncryptionAlgorithm">
            Returns the encryption algorithm used for signing.
            @return the encryption algorithm ("RSA" or "DSA")
            @see com.itextpdf.text.pdf.security.ExternalSignature#getEncryptionAlgorithm()
        </member>
        <member name="T:iTextSharp.text.pdf.security.SecurityIDs">
            A list of IDs that are used by the security classes
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.certification">
            Is the signature a cerification signature (true) or an approval signature (false)? 
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.fillInAllowed">
            Is form filling allowed by this signature? 
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.annotationsAllowed">
            Is adding annotations allowed by this signature? 
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.fieldLocks">
            Does this signature lock specific fields? 
        </member>
        <member name="M:iTextSharp.text.pdf.security.SignaturePermissions.#ctor(iTextSharp.text.pdf.PdfDictionary,iTextSharp.text.pdf.security.SignaturePermissions)">
            Creates an object that can inform you about the type of signature
            in a signature dictionary as well as some of the permissions
            defined by the signature.
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.Certification">
            Getter to find out if the signature is a certification signature.
            @return true if the signature is a certification signature, false for an approval signature.
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.FillInAllowed">
            Getter to find out if filling out fields is allowed after signing.
            @return true if filling out fields is allowed
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.AnnotationsAllowed">
            Getter to find out if adding annotations is allowed after signing.
            @return true if adding annotations is allowed
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.FieldLocks">
            Getter for the field lock actions, and fields that are impacted by the action
            @return an Array with field names
        </member>
        <member name="T:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock">
            Class that contains a field lock action and
            an array of the fields that are involved.
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.action">
            Can be /All, /Exclude or /Include 
        </member>
        <member name="F:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.fields">
            An array of PdfString values with fieldnames 
        </member>
        <member name="M:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.#ctor(iTextSharp.text.pdf.PdfName,iTextSharp.text.pdf.PdfArray)">
            Creates a FieldLock instance 
        </member>
        <member name="M:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.ToString">
            toString method 
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.Action">
            Getter for the field lock action. 
        </member>
        <member name="P:iTextSharp.text.pdf.security.SignaturePermissions.FieldLock.Fields">
            Getter for the fields involved in the lock action. 
        </member>
        <member name="T:iTextSharp.text.pdf.security.TSAClientBouncyCastle">
            Time Stamp Authority Client interface implementation using Bouncy Castle
            org.bouncycastle.tsp package.
            <p>
            Created by Aiken Sam, 2006-11-15, refactored by Martin Brunecky, 07/15/2007
            for ease of subclassing.
            </p>
            @since	2.1.6
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.DEFAULTTOKENSIZE">
            The default value for the hash algorithm 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.DEFAULTHASHALGORITHM">
            The default value for the hash algorithm 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.LOGGER">
            The Logger instance. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.tsaURL">
            URL of the Time Stamp Authority 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.tsaUsername">
            TSA Username 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.tsaPassword">
            TSA password 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.tsaInfo">
            An interface that allows you to inspect the timestamp info. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.tokenSizeEstimate">
            Estimate of the received time stamp token 
        </member>
        <member name="F:iTextSharp.text.pdf.security.TSAClientBouncyCastle.digestAlgorithm">
            Hash algorithm 
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.#ctor(System.String)">
            Creates an instance of a TSAClient that will use BouncyCastle.
            @param url String - Time Stamp Authority URL (i.e. "http://tsatest1.digistamp.com/TSA")
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.#ctor(System.String,System.String,System.String)">
            Creates an instance of a TSAClient that will use BouncyCastle.
            @param url String - Time Stamp Authority URL (i.e. "http://tsatest1.digistamp.com/TSA")
            @param username String - user(account) name
            @param password String - password
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.#ctor(System.String,System.String,System.String,System.Int32,System.String)">
            Constructor.
            Note the token size estimate is updated by each call, as the token
            size is not likely to change (as long as we call the same TSA using
            the same imprint length).
            @param url String - Time Stamp Authority URL (i.e. "http://tsatest1.digistamp.com/TSA")
            @param username String - user(account) name
            @param password String - password
            @param tokSzEstimate int - estimated size of received time stamp token (DER encoded)
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.SetTSAInfo(iTextSharp.text.pdf.security.ITSAInfoBouncyCastle)">
            @param tsaInfo the tsaInfo to set
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.GetTokenSizeEstimate">
            Get the token size estimate.
            Returned value reflects the result of the last succesfull call, padded
            @return an estimate of the token size
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.GetMessageDigest">
            Gets the MessageDigest to digest the data imprint
            @return the digest algorithm name
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.GetTimeStampToken(System.Byte[])">
            Get RFC 3161 timeStampToken.
            Method may return null indicating that timestamp should be skipped.
            @param imprint data imprint to be time-stamped
            @return encoded, TSA signed data of the timeStampToken
        </member>
        <member name="M:iTextSharp.text.pdf.security.TSAClientBouncyCastle.GetTSAResponse(System.Byte[])">
            Get timestamp token - communications layer
            @return - byte[] - TSA response, raw bytes (RFC 3161 encoded)
        </member>
        <member name="T:iTextSharp.text.pdf.security.ITSAInfoBouncyCastle">
            Interface you can implement and pass to TSAClientBouncyCastle in case
            you want to do something with the information returned
        </member>
        <member name="M:iTextSharp.text.pdf.security.ITSAInfoBouncyCastle.InspectTimeStampTokenInfo(Org.BouncyCastle.Tsp.TimeStampTokenInfo)">
            When a timestamp is created using TSAClientBouncyCastle,
            this method is triggered passing an object that contains
            info about the timestamp and the time stamping authority.
            @param info a TimeStampTokenInfo object
        </member>
        <member name="T:iTextSharp.text.pdf.security.VerificationException">
            An exception that is thrown when something is wrong with a certificate.
        </member>
        <member name="M:iTextSharp.text.pdf.security.VerificationException.#ctor(Org.BouncyCastle.X509.X509Certificate,System.String)">
            Creates a VerificationException
        </member>
        <member name="F:iTextSharp.text.pdf.security.VerificationOK.certificate">
            The certificate that was verified successfully. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.VerificationOK.verifierClass">
            The CertificateVerifier that was used for verifying. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.VerificationOK.message">
            The reason why the certificate verified successfully. 
        </member>
        <member name="M:iTextSharp.text.pdf.security.VerificationOK.#ctor(Org.BouncyCastle.X509.X509Certificate,iTextSharp.text.pdf.security.CertificateVerifier,System.String)">
            Creates a VerificationOK object
            @param certificate	the certificate that was successfully verified
            @param verifierClass	the class that was used for verification
            @param message		the reason why the certificate could be verified
        </member>
        <member name="M:iTextSharp.text.pdf.security.VerificationOK.ToString">
            A single String explaining which certificate was verified, how and why.
            @see java.lang.Object#toString()
        </member>
        <member name="T:iTextSharp.text.pdf.security.X509Certificate2Signature">
            <summary>
            Creates a signature using a X509Certificate2. It supports smartcards without 
            exportable private keys.
            </summary>
        </member>
        <member name="F:iTextSharp.text.pdf.security.X509Certificate2Signature.certificate">
            <summary>
            The certificate with the private key
            </summary>
        </member>
        <member name="F:iTextSharp.text.pdf.security.X509Certificate2Signature.hashAlgorithm">
            The hash algorithm. 
        </member>
        <member name="F:iTextSharp.text.pdf.security.X509Certificate2Signature.encryptionAlgorithm">
            The encryption algorithm (obtained from the private key) 
        </member>
        <member name="M:iTextSharp.text.pdf.security.X509Certificate2Signature.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,System.String)">
            <summary>
            Creates a signature using a X509Certificate2. It supports smartcards without 
            exportable private keys.
            </summary>
            <param name="certificate">The certificate with the private key</param>
            <param name="hashAlgorithm">The hash algorithm for the signature. As the Windows CAPI is used
            to do the signature the only hash guaranteed to exist is SHA-1</param>
        </member>
        <member name="M:iTextSharp.text.pdf.security.X509Certificate2Signature.GetHashAlgorithm">
            Returns the hash algorithm.
            @return  the hash algorithm (e.g. "SHA-1", "SHA-256,...")
            @see com.itextpdf.text.pdf.security.ExternalSignature#getHashAlgorithm()
        </member>
        <member name="M:iTextSharp.text.pdf.security.X509Certificate2Signature.GetEncryptionAlgorithm">
            Returns the encryption algorithm used for signing.
            @return the encryption algorithm ("RSA" or "DSA")
            @see com.itextpdf.text.pdf.security.ExternalSignature#getEncryptionAlgorithm()
        </member>
        <member name="T:iTextSharp.text.pdf.XfaXmlLocator">
            Helps to locate xml stream inside PDF document with Xfa form.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaXmlLocator.GetDocument">
            Gets Document to sign
        </member>
        <member name="M:iTextSharp.text.pdf.XfaXmlLocator.SetDocument(System.Xml.XmlDocument)">
            Save document as single XML stream in AcroForm.
            @param document signed document
            @throws IOException
            @throws DocumentException
        </member>
        <member name="T:iTextSharp.text.pdf.XfaXpathConstructor">
            Constructor for xpath expression for signing XfaForm
        </member>
        <member name="M:iTextSharp.text.pdf.XfaXpathConstructor.#ctor">
            Empty constructor, no transform.
        </member>
        <member name="M:iTextSharp.text.pdf.XfaXpathConstructor.#ctor(iTextSharp.text.pdf.XfaXpathConstructor.XdpPackage)">
            Construct for Xpath expression. Depends from selected xdp package.
            @param xdpPackage
        </member>
        <member name="M:iTextSharp.text.pdf.XfaXpathConstructor.GetXpathExpression">
            Get XPath expression
        </member>
        <member name="T:iTextSharp.text.pdf.XfaXpathConstructor.XdpPackage">
            Possible xdp packages to sign
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.#ctor(iTextSharp.text.pdf.PdfStamperImp)">
            Constructs XmlSignatureAppearance object.
            @param writer the writer to which the signature will be written.
        </member>
        <member name="F:iTextSharp.text.pdf.XmlSignatureAppearance.signDate">
            Holds value of property xades:SigningTime. 
        </member>
        <member name="F:iTextSharp.text.pdf.XmlSignatureAppearance.description">
            Holds value of property xades:Description. 
        </member>
        <member name="F:iTextSharp.text.pdf.XmlSignatureAppearance.mimeType">
            Holds value of property xades:MimeType. 
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.SetCertificate(Org.BouncyCastle.X509.X509Certificate)">
            Sets the certificate used to provide the text in the appearance.
            This certificate doesn't take part in the actual signing process.
            @param signCertificate the certificate
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.GetSignDate">
            Gets the signature date.
            @return the signature date
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.SetSignDate(System.DateTime)">
            Sets the signature date.
            @param signDate the signature date
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.GetXmlLocator">
            Helps to locate xml stream
            @return XmlLocator, cannot be null.
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.GetXpathConstructor">
            Constructor for xpath expression in case signing only part of XML document.
            @return XpathConstructor, can be null
        </member>
        <member name="M:iTextSharp.text.pdf.XmlSignatureAppearance.Close">
            Close PdfStamper
            @throws IOException
            @throws DocumentException
        </member>
        <member name="T:iTextSharp.text.Version">
            This class contains version information about iText.
            DO NOT CHANGE THE VERSION INFORMATION WITHOUT PERMISSION OF THE COPYRIGHT HOLDERS OF ITEXT.
            Changing the version makes it extremely difficult to debug an application.
            Also, the nature of open source software is that you honor the copyright of the original creators of the software.
        </member>
        <member name="F:iTextSharp.text.Version.AGPL">
            String that will indicate if the AGPL version is used. 
        </member>
        <member name="F:iTextSharp.text.Version.version">
            The iText version instance. 
        </member>
        <member name="F:iTextSharp.text.Version.iText">
            This String contains the name of the product.
            iText is a registered trademark by iText Group NV.
            Please don't change this constant.
        </member>
        <member name="F:iTextSharp.text.Version.release">
            This String contains the version number of this iText release.
            For debugging purposes, we request you NOT to change this constant.
        </member>
        <member name="F:iTextSharp.text.Version.iTextVersion">
            This String contains the iText version as shown in the producer line.
            iText is a product developed by iText Group NV.
            iText Group requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
        </member>
        <member name="F:iTextSharp.text.Version.key">
            The license key.
        </member>
        <member name="M:iTextSharp.text.Version.GetInstance">
            Gets an instance of the iText version that is currently used.
            Note that iText Group requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
        </member>
        <member name="P:iTextSharp.text.Version.Product">
            	     * Gets the product name.
            	     * iText Group requests that you retain the iText producer line
            	     * in every PDF that is created or manipulated using iText.
                     * @return the product name
        </member>
        <member name="P:iTextSharp.text.Version.Release">
            	     * Gets the release number.
            	     * iText Group requests that you retain the iText producer line
            	     * in every PDF that is created or manipulated using iText.
                     * @return the release number
        </member>
        <member name="P:iTextSharp.text.Version.GetVersion">
            	     * Returns the iText version as shown in the producer line.
            	     * iText is a product developed by iText Group NV.
            	     * iText Group requests that you retain the iText producer line
            	     * in every PDF that is created or manipulated using iText.
                     * @return iText version
        </member>
        <member name="P:iTextSharp.text.Version.Key">
            Returns a license key if one was provided, or null if not.
            @return a license key.
        </member>
        <member name="P:iTextSharp.text.Version.IsAGPLVersion">
            Checks if the AGPL version is used.
            @return returns true if the AGPL version is used.
        </member>
        <member name="T:iTextSharp.text.WritableDirectElement">
             An element that is not an element, it holds {@link Element#WRITABLE_DIRECT}
             as Element type. It implements WriterOperation to do operations on the
             {@link PdfWriter} and the {@link Document} that must be done at the time of
             the writing. Much like a {@link VerticalPositionMark} but little different.
            
             @author itextpdf.com
            
        </member>
        <member name="P:iTextSharp.text.WritableDirectElement.Type">
            @return {@link Element#WRITABLE_DIRECT}
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.handler.HTMLNewLineHandler">
             This {@link NewLineHandler} returns true on the tags <code>p</code>,
             <code>blockqoute</code>and <code>br</code>
            
             @author Balder
            
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.INewLineHandler">
             A NewLineHandler determines if an encountered tag should result in a new line
             in a document.
            
             @author Balder
             @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.INewLineHandler.IsNewLineTag(System.String)">
            @param tag the tag to check if after this one a new line should be in a document
            @return true in case a new line should be added.
            @since 5.0.6
        </member>
        <member name="M:iTextSharp.text.xml.simpleparser.handler.HTMLNewLineHandler.#ctor">
             Default constructor
            
             @since 5.0.6
        </member>
        <member name="T:iTextSharp.text.xml.simpleparser.handler.NeverNewLineHandler">
             Always returns false.
             @author Balder
             @since 5.0.6
            
        </member>
        <member name="T:iTextSharp.text.xml.XmlDomWriter">
            
             @author psoares
        </member>
        <member name="F:iTextSharp.text.xml.XmlDomWriter.fOut">
            Print writer. 
        </member>
        <member name="F:iTextSharp.text.xml.XmlDomWriter.fCanonical">
            Canonical output. 
        </member>
        <member name="F:iTextSharp.text.xml.XmlDomWriter.fXML11">
            Processing XML 1.1 document. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.#ctor">
            Default constructor. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.SetCanonical(System.Boolean)">
            Sets whether output is canonical. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.SetOutput(System.IO.Stream,System.String)">
            Sets the output stream for printing. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.SetOutput(System.IO.TextWriter)">
            Sets the output writer. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.Write(System.Xml.XmlNode)">
            Writes the specified node, recursively. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.SortAttributes(System.Xml.XmlAttributeCollection)">
            Returns a sorted list of attributes. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.NormalizeAndPrint(System.String,System.Boolean)">
            Normalizes and prints the given string. 
        </member>
        <member name="M:iTextSharp.text.xml.XmlDomWriter.NormalizeAndPrint(System.Char,System.Boolean)">
            Normalizes and print the given character. 
        </member>
        <member name="T:iTextSharp.text.xml.XmlToTxt">
            This class converts XML into plain text stripping all tags.
        </member>
        <member name="F:iTextSharp.text.xml.XmlToTxt.buf">
            Buffer that stores all content that is encountered.
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.Parse(System.IO.Stream)">
            Static method that parses an XML Stream.
            @param is    the XML input that needs to be parsed
            @return  a String obtained by removing all tags from the XML
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.#ctor">
            Creates an instance of XML to TXT.
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.ToString">
            @return  the String after parsing.
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.StartElement(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#startElement(java.lang.String, java.util.Map)
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.EndElement(System.String)">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#endElement(java.lang.String)
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.StartDocument">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#startDocument()
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.EndDocument">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#endDocument()
        </member>
        <member name="M:iTextSharp.text.xml.XmlToTxt.Text(System.String)">
            @see com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler#text(java.lang.String)
        </member>
        <member name="T:iTextSharp.text.xml.XMLUtil">
             Contains utility methods for XML.
             @author Balder
             @since 5.0.6
            
        </member>
        <member name="M:iTextSharp.text.xml.XMLUtil.EscapeXML(System.String,System.Boolean)">
            Escapes a string with the appropriated XML codes.
            @param s the string to be escaped
            @param onlyASCII codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE>
            @return the escaped string
            @since 5.0.6
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.text.xml.XMLUtil.UnescapeXML(System.String)" -->
        <member name="M:iTextSharp.text.xml.XMLUtil.Unescape(System.String)">
            Unescapes 'lt', 'gt', 'apos', 'quote' and 'amp' to the
            corresponding character values.
            @param   s   a string representing a character
            @return  a character value
        </member>
        <member name="M:iTextSharp.text.xml.XMLUtil.IsValidCharacterValue(System.String)">
            Checks if a character value should be escaped/unescaped.
            @param   s   the String representation of an integer
            @return  true if it's OK to escape or unescape this value 
        </member>
        <member name="M:iTextSharp.text.xml.XMLUtil.IsValidCharacterValue(System.Int32)">
            Checks if a character value should be escaped/unescaped.
            @param   c   a character value
            @return  true if it's OK to escape or unescape this value 
        </member>
        <member name="M:iTextSharp.text.xml.XMLUtil.FindInArray(System.Char,System.Char[],System.Int32)">
            Looks for a character in a character array, starting from a certain position
            @param needle    the character you're looking for
            @param haystack  the character array
            @param start     the start position
            @return  the position where the character was found, or -1 if it wasn't found.
        </member>
        <member name="M:iTextSharp.text.xml.XMLUtil.GetEncodingName(System.Byte[])">
            Returns the IANA encoding name that is auto-detected from
            the bytes specified, with the endian-ness of that encoding where appropriate.
            (method found in org.apache.xerces.impl.XMLEntityManager, originally published
            by the Apache Software Foundation under the Apache Software License; now being
            used in iText under the MPL)
            @param b4    The first four bytes of the input.
            @return an IANA-encoding string
            @since 5.0.6
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.CONTRIBUTOR">
            External Contributors to the resource (other than the authors). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.COVERAGE">
            The extent or scope of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.CREATOR">
            The authors of the resource (listed in order of precedence, if significant). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.DATE">
            Date(s) that something interesting happened to the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.DESCRIPTION">
            A textual description of the content of the resource. Multiple values may be present for different languages. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.FORMAT">
            The file format used when saving the resource. Tools and applications should set this property to the save format of the data. It may include appropriate qualifiers. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.IDENTIFIER">
            Unique identifier of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.LANGUAGE">
            An unordered array specifying the languages used in the	resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.PUBLISHER">
            Publishers. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.RELATION">
            Relationships to other documents. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.RIGHTS">
            Informal rights statement, selected by language. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.SOURCE">
            Unique identifier of the work from which this resource was derived. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.SUBJECT">
            An unordered array of descriptive phrases or keywords that specify the topic of the content of the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.TITLE">
            The title of the document, or the name given to the resource. Typically, it will be a name by which the resource is formally known. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.DublinCoreProperties.TYPE">
            A document type; for example, novel, poem, or working paper. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.AddTitle(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds a title.
            
             @param xmpMeta
             @param title
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.SetTitle(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String)">
             Sets a title.
            
             @param xmpMeta
             @param title
             @param genericLang  The name of the generic language
             @param specificLang The name of the specific language
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.AddDescription(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds a description.
            
             @param xmpMeta
             @param desc
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.SetDescription(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String)">
             Sets a description.
            
             @param xmpMeta
             @param desc
             @param genericLang  The name of the generic language
             @param specificLang The name of the specific language
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.AddSubject(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds a subject.
            
             @param xmpMeta
             @param subject
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.SetSubject(iTextSharp.xmp.IXmpMeta,System.String[])">
             Sets a subject.
            
             @param xmpMeta
             @param subject array of subjects
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.AddAuthor(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds a single author.
            
             @param xmpMeta
             @param author
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.SetAuthor(iTextSharp.xmp.IXmpMeta,System.String[])">
             Sets an array of authors.
            
             @param xmpMeta
             @param author
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.AddPublisher(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds a single publisher.
            
             @param xmpMeta
             @param publisher
        </member>
        <member name="M:iTextSharp.text.xml.xmp.DublinCoreProperties.SetPublisher(iTextSharp.xmp.IXmpMeta,System.String[])">
             Sets an array of publishers.
            
             @param xmpMeta
             @param publisher
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfProperties.KEYWORDS">
            Keywords. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfProperties.VERSION">
            The PDF file version (for example: 1.0, 1.3, and so on). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.PdfProperties.PRODUCER">
            The Producer. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfProperties.SetKeywords(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds keywords.
            
             @param xmpMeta
             @param keywords
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfProperties.SetProducer(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the producer.
            
             @param xmpMeta
             @param producer
        </member>
        <member name="M:iTextSharp.text.xml.xmp.PdfProperties.SetVersion(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the version.
            
             @param xmpMeta
             @param version
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.ADVISORY">
            An unordered array specifying properties that were edited outside the authoring application. Each item should contain a single namespace and XPath separated by one ASCII space (U+0020). 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.BASEURL">
            The base URL for relative URLs in the document content. If this document contains Internet links, and those links are relative, they are relative to this base URL. This property provides a standard way for embedded relative URLs to be interpreted by tools. Web authoring tools should set the value based on their notion of where URLs will be interpreted. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.CREATEDATE">
            The date and time the resource was originally created. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.CREATORTOOL">
            The name of the first known tool used to create the resource. If history is present in the metadata, this value should be equivalent to that of xmpMM:History's softwareAgent property. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.IDENTIFIER">
            An unordered array of text strings that unambiguously identify the resource within a given context. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.METADATADATE">
            The date and time that any metadata for this resource was last changed. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.MODIFYDATE">
            The date and time the resource was last modified. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.NICKNAME">
            A short informal name for the resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpBasicProperties.THUMBNAILS">
            An alternative array of thumbnail images for a file, which can differ in characteristics such as size or image encoding. 
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetCreatorTool(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the creatortool.
            
             @param xmpMeta
             @param creator
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetCreateDate(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the creation date.
            
             @param xmpMeta
             @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetModDate(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the modification date.
            
             @param xmpMeta
             @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetMetaDataDate(iTextSharp.xmp.IXmpMeta,System.String)">
             Adds the meta data date.
            
             @param xmpMeta
             @param date
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetIdentifiers(iTextSharp.xmp.IXmpMeta,System.String[])">
            Sets the identifier.
            
             @param xmpMeta
             @param id
        </member>
        <member name="M:iTextSharp.text.xml.xmp.XmpBasicProperties.SetNickname(iTextSharp.xmp.IXmpMeta,System.String)">
            Adds the nickname.
            
             @param xmpMeta
             @param name
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.DERIVEDFROM">
            A reference to the original document from which this one is derived. It is a minimal reference; missing components can be assumed to be unchanged. For example, a new version might only need to specify the instance ID and version number of the previous version, or a rendition might only need to specify the instance ID and rendition class of the original. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.DOCUMENTID">
            The common identifier for all versions and renditions of a document. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.HISTORY">
            An ordered array of high-level user actions that resulted in this resource. It is intended to give human readers a general indication of the steps taken to make the changes from the previous version to this one. The list should be at an abstract level; it is not intended to be an exhaustive keystroke or other detailed history. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.MANAGEDFROM">
            A reference to the document as it was prior to becoming managed. It is set when a managed document is introduced to an asset management system that does not currently own it. It may or may not include references to different management systems. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.MANAGER">
            The name of the asset management system that manages this resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.MANAGETO">
            A URI identifying the managed resource to the asset management system; the presence of this property is the formal indication that this resource is managed. The form and content of this URI is private to the asset management system. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.MANAGEUI">
            A URI that can be used to access information about the managed resource through a web browser. It might require a custom browser plugin. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.MANAGERVARIANT">
            Specifies a particular variant of the asset management system. The format of this property is private to the specific asset management system. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.RENDITIONCLASS">
            The rendition class name for this resource.
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.RENDITIONPARAMS">
             Can be used to provide additional rendition parameters that are too complex or verbose to encode in xmpMM: RenditionClass. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.VERSIONID">
            The document version identifier for this resource. 
        </member>
        <member name="F:iTextSharp.text.xml.xmp.XmpMMProperties.VERSIONS">
            The version history associated with this resource.
        </member>
        <member name="T:iTextSharp.xmp.impl.Base64">
            <summary>
            A utility class to perform base64 encoding and decoding as specified
            in RFC-1521. See also RFC 1421.
            
            @version     $Revision: 1.4 $
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.Base64.INVALID">
            <summary>
            marker for invalid bytes </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.Base64.WHITESPACE">
            <summary>
            marker for accepted whitespace bytes </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.Base64.EQUAL">
            <summary>
            marker for an equal symbol </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.Base64.Encode(System.Byte[])">
            <summary>
            Encode the given byte[].
            </summary>
            <param name="src"> the source string. </param>
            <returns> the base64-encoded data. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Base64.Encode(System.Byte[],System.Int32)">
            <summary>
            Encode the given byte[].
            </summary>
            <param name="src"> the source string. </param>
            <param name="lineFeed"> a linefeed is added after <code>linefeed</code> characters;
                       must be dividable by four; 0 means no linefeeds </param>
            <returns> the base64-encoded data. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Base64.Encode(System.String)">
            <summary>
            Encode the given string. </summary>
            <param name="src"> the source string. </param>
            <returns> the base64-encoded string. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Base64.Decode(System.Byte[])">
            <summary>
            Decode the given byte[].
            </summary>
            <param name="src">
                       the base64-encoded data. </param>
            <returns> the decoded data. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Base64.Decode(System.String)">
            <summary>
            Decode the given string.
            </summary>
            <param name="src"> the base64-encoded string. </param>
            <returns> the decoded string. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.ByteBuffer">
            <summary>
            Byte buffer container including length of valid data.
            
            @since   11.10.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.#ctor(System.Int32)">
            <param name="initialCapacity"> the initial capacity for this buffer </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.#ctor(System.Byte[])">
            <param name="buffer"> a byte array that will be wrapped with <code>ByteBuffer</code>. </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.#ctor(System.Byte[],System.Int32)">
            <param name="buffer"> a byte array that will be wrapped with <code>ByteBuffer</code>. </param>
            <param name="length"> the length of valid bytes in the array </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.#ctor(System.IO.Stream)">
            <summary>
            Loads the stream into a buffer. 
            </summary>
            <param name="in"> an InputStream </param>
            <exception cref="T:System.IO.IOException"> If the stream cannot be read. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer"> a byte array that will be wrapped with <code>ByteBuffer</code>. </param>
            <param name="offset"> the offset of the provided buffer. </param>
            <param name="length"> the length of valid bytes in the array </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.ByteAt(System.Int32)">
            <param name="index"> the index to retrieve the byte from </param>
            <returns> Returns a byte from the buffer </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.CharAt(System.Int32)">
            <param name="index"> the index to retrieve a byte as int or char. </param>
            <returns> Returns a byte from the buffer </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.Append(System.Byte)">
            <summary>
            Appends a byte to the buffer. </summary>
            <param name="b"> a byte </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Appends a byte array or part of to the buffer.
            </summary>
            <param name="bytes"> a byte array </param>
            <param name="offset"> an offset with </param>
            <param name="len"> </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.Append(System.Byte[])">
            <summary>
            Append a byte array to the buffer </summary>
            <param name="bytes"> a byte array </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.Append(iTextSharp.xmp.impl.ByteBuffer)">
            <summary>
            Append another buffer to this buffer. </summary>
            <param name="anotherBuffer"> another <code>ByteBuffer</code> </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ByteBuffer.EnsureCapacity(System.Int32)">
            <summary>
            Ensures the requested capacity by increasing the buffer size when the
            current length is exceeded.
            </summary>
            <param name="requestedLength"> requested new buffer length </param>
        </member>
        <member name="P:iTextSharp.xmp.impl.ByteBuffer.ByteStream">
            <returns> Returns a byte stream that is limited to the valid amount of bytes. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.ByteBuffer.Length">
            <returns> Returns the length, that means the number of valid bytes, of the buffer;
            the inner byte array might be bigger than that. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.ByteBuffer.Encoding">
            <summary>
            Detects the encoding of the byte buffer, stores and returns it. 
            Only UTF-8, UTF-16LE/BE and UTF-32LE/BE are recognized.
            <em>Note:</em> UTF-32 flavors are not supported by Java, the XML-parser will complain.
            </summary>
            <returns> Returns the encoding string. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.CountOutputStream">
            <summary>
            An <code>OutputStream</code> that counts the written bytes.
            
            @since   08.11.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.CountOutputStream._outp">
            <summary>
            the decorated output stream </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.CountOutputStream._bytesWritten">
            <summary>
            the byte counter </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.CountOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor with providing the output stream to decorate. </summary>
            <param name="out"> an <code>OutputStream</code> </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.CountOutputStream.Write(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.CountOutputStream.Write(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.CountOutputStream.Write(System.Int32)" -->
        <member name="P:iTextSharp.xmp.impl.CountOutputStream.BytesWritten">
            <returns> the bytesWritten </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.FilterReader">
            <summary>
            Abstract class for reading filtered character streams.
            The abstract class <code>FilterReader</code> itself
            provides default methods that pass all requests to
            the contained stream. Subclasses of <code>FilterReader</code>
            should override some of these methods and may also provide
            additional methods and fields.
            
            @author      Mark Reinhold
            @since       JDK1.1
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.FilterReader.Read">
             Reads a single character.
            
             @exception  IOException  If an I/O error occurs
        </member>
        <member name="M:iTextSharp.xmp.impl.FilterReader.Read(System.Char[],System.Int32,System.Int32)">
             Reads characters into a portion of an array.
            
             @exception  IOException  If an I/O error occurs
        </member>
        <member name="M:iTextSharp.xmp.impl.FilterReader.Close">
            **
        </member>
        <member name="T:iTextSharp.xmp.impl.FixAsciiControlsReader">
            <summary>
            @since   22.08.2006
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.impl.PushbackReader">
            <summary>
            A character-stream reader that allows characters to be pushed back into the
            stream.
            
            @author      Mark Reinhold
            @since       JDK1.1
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.PushbackReader._buf">
            <summary>
            Pushback buffer </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.PushbackReader._pos">
            <summary>
            Current position in buffer </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.PushbackReader.#ctor(System.IO.TextReader,System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.PushbackReader.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new pushback reader with a one-character pushback buffer.
            </summary>
            <param name="in">  The reader from which characters will be read </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.EnsureOpen">
            <summary>
            Checks to make sure that the stream has not been closed. </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Read">
            <summary>
            Reads a single character.
            </summary>
            <returns>     The character read, or -1 if the end of the stream has been
                        reached
            </returns>
            <exception cref="T:System.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads characters into a portion of an array.
            </summary>
            <param name="cbuf">  Destination buffer </param>
            <param name="off">   Offset at which to start writing characters </param>
            <param name="len">   Maximum number of characters to read
            </param>
            <returns>     The number of characters read, or -1 if the end of the
                        stream has been reached
            </returns>
            <exception cref="T:System.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Unread(System.Int32)">
            <summary>
            Pushes back a single character by copying it to the front of the
            pushback buffer. After this method returns, the next character to be read
            will have the value <code>(char)c</code>.
            </summary>
            <param name="c">  The int value representing a character to be pushed back
            </param>
            <exception cref="T:System.IO.IOException">  If the pushback buffer is full,
                                     or if some other I/O error occurs </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Unread(System.Char[],System.Int32,System.Int32)">
            <summary>
            Pushes back a portion of an array of characters by copying it to the
            front of the pushback buffer.  After this method returns, the next
            character to be read will have the value <code>cbuf[off]</code>, the
            character after that will have the value <code>cbuf[off+1]</code>, and
            so forth.
            </summary>
            <param name="cbuf">  Character array </param>
            <param name="off">   Offset of first character to push back </param>
            <param name="len">   Number of characters to push back
            </param>
            <exception cref="T:System.IO.IOException">  If there is insufficient room in the pushback
                                     buffer, or if some other I/O error occurs </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Unread(System.Char[])">
            <summary>
            Pushes back an array of characters by copying it to the front of the
            pushback buffer.  After this method returns, the next character to be
            read will have the value <code>cbuf[0]</code>, the character after that
            will have the value <code>cbuf[1]</code>, and so forth.
            </summary>
            <param name="cbuf">  Character array to push back
            </param>
            <exception cref="T:System.IO.IOException">  If there is insufficient room in the pushback
                                     buffer, or if some other I/O error occurs </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.PushbackReader.Close">
            <summary>
            Closes the stream and releases any system resources associated with
            it. Once the stream has been closed, further read(),
            unread(), ready(), or skip() invocations will throw an IOException.
            Closing a previously closed stream has no effect.
            </summary>
            <exception cref="T:System.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="F:iTextSharp.xmp.impl.FixAsciiControlsReader._control">
            <summary>
            the result of the escaping sequence </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.FixAsciiControlsReader._digits">
            <summary>
            count the digits of the sequence </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.FixAsciiControlsReader._state">
            <summary>
            the state of the automaton </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.FixAsciiControlsReader.#ctor(System.IO.TextReader)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.FixAsciiControlsReader.Read(System.Char[],System.Int32,System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.FixAsciiControlsReader.ProcessChar(System.Char)">
            <summary>
            Processes numeric escaped chars to find out if they are a control character. </summary>
            <param name="ch"> a char </param>
            <returns> Returns the char directly or as replacement for the escaped sequence. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.Iso8601Converter">
            <summary>
            Converts between ISO 8601 Strings and <code>Calendar</code> with millisecond resolution.
            
            @since   16.02.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Iso8601Converter.Parse(System.String)" -->
        <member name="M:iTextSharp.xmp.impl.Iso8601Converter.Parse(System.String,iTextSharp.xmp.IXmpDateTime)">
            <param name="iso8601String"> a date string that is ISO 8601 conform. </param>
            <param name="binValue"> an existing XMPDateTime to set with the parsed date </param>
            <returns> Returns an XMPDateTime-object containing the ISO8601-date. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Is thrown when the string is non-conform. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Iso8601Converter.Render(iTextSharp.xmp.IXmpDateTime)" -->
        <member name="T:iTextSharp.xmp.impl.ParseState">
            <summary>
            @since   22.08.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.#ctor(System.String)">
            <param name="str"> initializes the parser container </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.Length">
            <returns> Returns the length of the input. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.HasNext">
            <returns> Returns whether there are more chars to come. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.Ch(System.Int32)">
            <param name="index"> index of char </param>
            <returns> Returns char at a certain index. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.Ch">
            <returns> Returns the current char or 0x0000 if there are no more chars. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.Skip">
            <summary>
            Skips the next char.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.Pos">
            <returns> Returns the current position. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseState.GatherInt(System.String,System.Int32)">
            <summary>
            Parses a integer from the source and sets the pointer after it. </summary>
            <param name="errorMsg"> Error message to put in the exception if no number can be found </param>
            <param name="maxValue"> the max value of the number to return </param>
            <returns> Returns the parsed integer. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if no integer can be found. </exception>
        </member>
        <member name="T:iTextSharp.xmp.impl.Latin1Converter">
            <summary>
            @since   12.10.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.Latin1Converter.#ctor">
            <summary>
            Private constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Latin1Converter.Convert(iTextSharp.xmp.impl.ByteBuffer)" -->
        <member name="M:iTextSharp.xmp.impl.Latin1Converter.ConvertToUtf8(System.Byte)">
            <summary>
            Converts a Cp1252 char (contains all Latin-1 chars above 0x80) into a
            UTF-8 byte sequence. The bytes 0x81, 0x8D, 0x8F, 0x90, and 0x9D are
            formally undefined by Windows 1252 and therefore replaced by a space
            (0x20).
            </summary>
            <param name="ch">
                       an Cp1252 / Latin-1 byte </param>
            <returns> Returns a byte array containing a UTF-8 byte sequence. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.ParameterAsserts">
            <summary>
            @since   11.08.2006
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.XmpConst">
            <summary>
            Common constants for the XMP Toolkit. 
            
            @since 20.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XML">
            <summary>
            The XML namespace for XML. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_RDF">
            <summary>
            The XML namespace for RDF. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_DC">
            <summary>
            The XML namespace for the Dublin Core schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_IPTCCORE">
            <summary>
            The XML namespace for the IPTC Core schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_IPTCEXT">
            <summary>
            The XML namespace for the IPTC Extension schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_DICOM">
            <summary>
            The XML namespace for the DICOM medical schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_PLUS">
            <summary>
            The XML namespace for the PLUS (Picture Licensing Universal System, http://www.useplus.org) </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_X">
            <summary>
            The XML namespace Adobe XMP Metadata. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XMP">
            <summary>
            The XML namespace for the XMP "basic" schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XMP_RIGHTS">
            <summary>
            The XML namespace for the XMP copyright schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XMP_MM">
            <summary>
            The XML namespace for the XMP digital asset management schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XMP_BJ">
            <summary>
            The XML namespace for the job management schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_XMP_NOTE">
            <summary>
            The XML namespace for the job management schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_PDF">
            <summary>
            The XML namespace for the PDF schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_PDFX">
            <summary>
            The XML namespace for the PDF schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_PHOTOSHOP">
            <summary>
            The XML namespace for the Photoshop custom schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_PSALBUM">
            <summary>
            The XML namespace for the Photoshop Album schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_EXIF">
            <summary>
            The XML namespace for Adobe's EXIF schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_EXIFX">
            <summary>
            NS for the CIPA XMP for Exif document v1.1 </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_TIFF">
            <summary>
            The XML namespace for Adobe's TIFF schema. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_BWF">
            <summary>
            BExt Schema </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_RIFFINFO">
            <summary>
            RIFF Info Schema </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_TXMP">
            <summary>
            Transform XMP </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_SWF">
            <summary>
            Adobe Flash SWF </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.NS_DC_DEPRECATED">
            <summary>
            legacy Dublin Core NS, will be converted to NS_DC </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_IDENTIFIERQUAL">
            <summary>
            The XML namespace for qualifiers of the xmp:Identifier property. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_DIMENSIONS">
            <summary>
            The XML namespace for fields of the Dimensions type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_IMAGE">
            <summary>
            The XML namespace for fields of a graphical image. Used for the Thumbnail type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_RESOURCEEVENT">
            <summary>
            The XML namespace for fields of the ResourceEvent type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_RESOURCEREF">
            <summary>
            The XML namespace for fields of the ResourceRef type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_ST_VERSION">
            <summary>
            The XML namespace for fields of the Version type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TYPE_ST_JOB">
            <summary>
            The XML namespace for fields of the JobRef type. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TRUESTR">
            <summary>
            The canonical true string value for Booleans in serialized XMP. Code that converts from the
            string to a bool should be case insensitive, and even allow "1".
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.FALSESTR">
            <summary>
            The canonical false string value for Booleans in serialized XMP. Code that converts from the
            string to a bool should be case insensitive, and even allow "0".
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.ARRAY_LAST_ITEM">
            <summary>
            Index that has the meaning to be always the last item in an array. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.ARRAY_ITEM_NAME">
            <summary>
            Node name of an array item. </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.X_DEFAULT">
            <summary>
            The x-default string for localized properties </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.XML_LANG">
            <summary>
            xml:lang qualfifier </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.RDF_TYPE">
            <summary>
            rdf:type qualfifier </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.XMP_PI">
            <summary>
            Processing Instruction (PI) for xmp packet </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TAG_XMPMETA">
            <summary>
            XMP meta tag version new </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpConst.TAG_XAPMETA">
            <summary>
            XMP meta tag version old </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.#ctor">
            <summary>
            private constructor
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertArrayName(System.String)">
            <summary>
            Asserts that an array name is set. </summary>
            <param name="arrayName"> an array name </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Array name is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertPropName(System.String)">
            <summary>
            Asserts that a property name is set. </summary>
            <param name="propName"> a property name or path </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Property name is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertSchemaNs(System.String)">
            <summary>
            Asserts that a schema namespace is set. </summary>
            <param name="schemaNs"> a schema namespace </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Schema is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertPrefix(System.String)">
            <summary>
            Asserts that a prefix is set. </summary>
            <param name="prefix"> a prefix </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Prefix is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertSpecificLang(System.String)">
            <summary>
            Asserts that a specific language is set. </summary>
            <param name="specificLang"> a specific lang </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Specific language is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertStructName(System.String)">
            <summary>
            Asserts that a struct name is set. </summary>
            <param name="structName"> a struct name </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Struct name is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertNotNull(System.Object)">
            <summary>
            Asserts that any string parameter is set. </summary>
            <param name="param"> any string parameter </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the parameter is null or has length 0. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParameterAsserts.AssertImplementation(iTextSharp.xmp.IXmpMeta)">
            <summary>
            Asserts that the xmp object is of this implemention
            (<seealso cref="T:iTextSharp.xmp.impl.XmpMetaImpl"/>). </summary>
            <param name="xmp"> the XMP object </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> A wrong implentaion is used. </exception>
        </member>
        <member name="T:iTextSharp.xmp.impl.ParseRdf">
            <summary>
            Parser for "normal" XML serialisation of RDF.  
            
            @since   14.07.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_RDF">
            <summary>
            Start of coreSyntaxTerms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_DATATYPE">
            <summary>
            End of coreSyntaxTerms </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_DESCRIPTION">
            <summary>
            Start of additions for syntax Terms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_LI">
            <summary>
            End of of additions for syntaxTerms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_ABOUT_EACH">
            <summary>
            Start of oldTerms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_BAG_ID">
            <summary>
            End of oldTerms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.RDFTERM_FIRST_SYNTAX">
            <summary>
            ! Yes, the syntax terms include the core terms. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.ParseRdf.DEFAULT_PREFIX">
            <summary>
            this prefix is used for default namespaces </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.Parse(System.Xml.XmlNode)">
            <summary>
            The main parsing method. The XML tree is walked through from the root node and and XMP tree
            is created. This is a raw parse, the normalisation of the XMP tree happens outside.
            </summary>
            <param name="xmlRoot"> the XML root node </param>
            <returns> Returns an XMP metadata object (not normalized) </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Occurs if the parsing fails for any reason. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfRdf(iTextSharp.xmp.impl.XmpMetaImpl,System.Xml.XmlNode)">
            <summary>
            Each of these parsing methods is responsible for recognizing an RDF
            syntax production and adding the appropriate structure to the XMP tree.
            They simply return for success, failures will throw an exception.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="rdfRdfNode"> the top-level xml node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.ParseRdf.RdfNodeElementList(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode)" -->
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfNodeElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.5 nodeElementURIs
            		anyURI - ( coreSyntaxTerms | rdf:li | oldTerms )
            
            7.2.11 nodeElement
            		start-element ( URI == nodeElementURIs,
            		attributes == set ( ( idAttr | nodeIdAttr | aboutAttr )?, propertyAttr* ) )
            		propertyEltList
            		end-element()
            
            A node element URI is rdf:Description or anything else that is not an RDF
            term.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfNodeElementAttrs(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            
            <summary>
            7.2.7 propertyAttributeURIs
            		anyURI - ( coreSyntaxTerms | rdf:Description | rdf:li | oldTerms )
            
            7.2.11 nodeElement
            start-element ( URI == nodeElementURIs,
            					attributes == set ( ( idAttr | nodeIdAttr | aboutAttr )?, propertyAttr* ) )
            					propertyEltList
            					end-element()
            
            Process the attribute list for an RDF node element. A property attribute URI is 
            anything other than an RDF term. The rdf:ID and rdf:nodeID attributes are simply ignored, 
            as are rdf:about attributes on inner nodes.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfPropertyElementList(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.13 propertyEltList
            ws* ( propertyElt ws* )*
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlParent"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfPropertyElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.14 propertyElt
            
            	resourcePropertyElt | literalPropertyElt | parseTypeLiteralPropertyElt |
            	parseTypeResourcePropertyElt | parseTypeCollectionPropertyElt | 
            	parseTypeOtherPropertyElt | emptyPropertyElt
            
            7.2.15 resourcePropertyElt
            	start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            	ws* nodeElement ws*
            	end-element()
            
            7.2.16 literalPropertyElt
            	start-element (
            		URI == propertyElementURIs, attributes == set ( idAttr?, datatypeAttr?) )
            	text()
            	end-element()
            
            7.2.17 parseTypeLiteralPropertyElt
            	start-element (
            		URI == propertyElementURIs, attributes == set ( idAttr?, parseLiteral ) )
            	literal
            	end-element()
            
            7.2.18 parseTypeResourcePropertyElt
            	start-element (
            		 URI == propertyElementURIs, attributes == set ( idAttr?, parseResource ) )
            	propertyEltList
            	end-element()
            
            7.2.19 parseTypeCollectionPropertyElt
            	start-element (
            		URI == propertyElementURIs, attributes == set ( idAttr?, parseCollection ) )
            	nodeElementList
            	end-element()
            
            7.2.20 parseTypeOtherPropertyElt
            	start-element ( URI == propertyElementURIs, attributes == set ( idAttr?, parseOther ) )
            	propertyEltList
            	end-element()
            
            7.2.21 emptyPropertyElt
            	start-element ( URI == propertyElementURIs,
            		attributes == set ( idAttr?, ( resourceAttr | nodeIdAttr )?, propertyAttr* ) )
            	end-element()
            
            The various property element forms are not distinguished by the XML element name, 
            but by their attributes for the most part. The exceptions are resourcePropertyElt and 
            literalPropertyElt. They are distinguished by their XML element content.
            
            NOTE: The RDF syntax does not explicitly include the xml:lang attribute although it can 
            appear in many of these. We have to allow for it in the attibute counts below.	 
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfResourcePropertyElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.15 resourcePropertyElt
            	start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            	ws* nodeElement ws*
            	end-element()
            
            This handles structs using an rdf:Description node, 
            arrays using rdf:Bag/Seq/Alt, and typedNodes. It also catches and cleans up qualified 
            properties written with rdf:Description and rdf:value.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfLiteralPropertyElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.16 literalPropertyElt
            	start-element ( URI == propertyElementURIs, 
            			attributes == set ( idAttr?, datatypeAttr?) )
            	text()
            	end-element()
            
            Add a leaf node with the text value and qualifiers for the attributes. </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfParseTypeLiteralPropertyElement">
            <summary>
            7.2.17 parseTypeLiteralPropertyElt
            	start-element ( URI == propertyElementURIs,
            		attributes == set ( idAttr?, parseLiteral ) )
            	literal
            	end-element()
            </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfParseTypeResourcePropertyElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.18 parseTypeResourcePropertyElt
            	start-element ( URI == propertyElementURIs, 
            		attributes == set ( idAttr?, parseResource ) )
            	propertyEltList
            	end-element()
            
            Add a new struct node with a qualifier for the possible rdf:ID attribute. 
            Then process the XML child nodes to get the struct fields.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfParseTypeCollectionPropertyElement">
            <summary>
            7.2.19 parseTypeCollectionPropertyElt
            	start-element ( URI == propertyElementURIs, 
            		attributes == set ( idAttr?, parseCollection ) )
            	nodeElementList
            	end-element()
            </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.RdfParseTypeOtherPropertyElement">
            <summary>
            7.2.20 parseTypeOtherPropertyElt
            	start-element ( URI == propertyElementURIs, attributes == set ( idAttr?, parseOther ) )
            	propertyEltList
            	end-element()
            </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.ParseRdf.RdfEmptyPropertyElement(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.ParseRdf.AddChildNode(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Adds a child node.
            </summary>
            <param name="xmp"> the xmp metadata object that is generated </param>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="xmlNode"> the currently processed XML node </param>
            <param name="value"> Node value </param>
            <param name="isTopLevel"> Flag if the node is a top-level node </param>
            <returns> Returns the newly created child node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.AddQualifierNode(iTextSharp.xmp.impl.XmpNode,System.String,System.String)">
            <summary>
            Adds a qualifier node.
            </summary>
            <param name="xmpParent"> the parent xmp node </param>
            <param name="name"> the name of the qualifier which has to be 
            		QName including the <b>default prefix</b> </param>
            <param name="value"> the value of the qualifier </param>
            <returns> Returns the newly created child node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.FixupQualifiedNode(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            The parent is an RDF pseudo-struct containing an rdf:value field. Fix the
            XMP data model. The rdf:value node must be the first child, the other
            children are qualifiers. The form, value, and children of the rdf:value
            node are the real ones. The rdf:value node's qualifiers must be added to
            the others.
            </summary>
            <param name="xmpParent"> the parent xmp node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thown on parsing errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.IsWhitespaceNode(System.Xml.XmlNode)">
            <summary>
            Checks if the node is a white space. </summary>
            <param name="node"> an XML-node </param>
            <returns> Returns whether the node is a whitespace node, 
            		i.e. a text node that contains only whitespaces. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.ParseRdf.IsPropertyElementName(System.Int32)">
            <summary>
            7.2.6 propertyElementURIs
            		anyURI - ( coreSyntaxTerms | rdf:Description | oldTerms )
            </summary>
            <param name="term"> the term id </param>
            <returns> Return true if the term is a property element name. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.ParseRdf.IsOldTerm(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.ParseRdf.IsCoreSyntaxTerm(System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)">
            <summary>
            Determines the ID for a certain RDF Term.
            Arranged to hopefully minimize the parse time for large XMP.
            </summary>
            <param name="node"> an XML node </param>
            <returns> Returns the term ID. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.QName">
            <summary>
            @since   09.11.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.QName._localName">
            <summary>
            XML localname </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.QName._prefix">
            <summary>
            XML namespace prefix </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.QName.#ctor(System.String)">
            <summary>
            Splits a qname into prefix and localname. </summary>
            <param name="qname"> a QName </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.QName.#ctor(System.String,System.String)">
            <summary>
            Constructor that initializes the fields </summary>
            <param name="prefix"> the prefix </param>
            <param name="localName"> the name </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.QName.HasPrefix">
            <returns> Returns whether the QName has a prefix. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.QName.LocalName">
            <returns> the localName </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.QName.Prefix">
            <returns> the prefix </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.Utils">
            <summary>
            Utility functions for the XMPToolkit implementation.
            
            @since 06.06.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.Utils.UUID_SEGMENT_COUNT">
            <summary>
            segments of a UUID </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.Utils.UUID_LENGTH">
            <summary>
            length of a UUID </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.Utils._xmlNameStartChars" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.Utils._xmlNameChars" -->
        <member name="M:iTextSharp.xmp.impl.Utils.#cctor">
            <summary>
            init char tables </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.#ctor">
            <summary>
            Private constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Utils.NormalizeLangValue(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Utils.SplitNameAndValue(System.String)" -->
        <member name="M:iTextSharp.xmp.impl.Utils.IsInternalProperty(System.String,System.String)">
            
            <param name="schema">
                       a schema namespace </param>
            <param name="prop">
                       an XMP Property </param>
            <returns> Returns true if the property is defined as &quot;Internal
                    Property&quot;, see XMP Specification. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.CheckUuidFormat(System.String)">
            <summary>
            Check some requirements for an UUID:
            <ul>
            <li>Length of the UUID is 32</li>
            <li>The Delimiter count is 4 and all the 4 delimiter are on their right
            position (8,13,18,23)</li>
            </ul>
            
            </summary>
            <param name="uuid"> uuid to test </param>
            <returns> true - this is a well formed UUID, false - UUID has not the expected format </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Utils.IsXmlName(System.String)" -->
        <member name="M:iTextSharp.xmp.impl.Utils.IsXmlNameNs(System.String)">
            <summary>
            Checks if the value is a legal "unqualified" XML name, as
            defined in the XML Namespaces proposed recommendation.
            These are XML names, except that they must not contain a colon. </summary>
            <param name="name"> the value to check </param>
            <returns> Returns true if the name is a valid "unqualified" XML name. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.IsControlChar(System.Char)">
            <param name="c">  a char </param>
            <returns> Returns true if the char is an ASCII control char. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.Utils.EscapeXml(System.String,System.Boolean,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.Utils.RemoveControlChars(System.String)">
            <summary>
            Replaces the ASCII control chars with a space.
            </summary>
            <param name="value">
                       a node value </param>
            <returns> Returns the cleaned up value </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.IsNameStartChar(System.Char)">
            <summary>
            Simple check if a character is a valid XML start name char.
            All characters according to the XML Spec 1.1 are accepted:
            http://www.w3.org/TR/xml11/#NT-NameStartChar
            </summary>
            <param name="ch"> a character </param>
            <returns> Returns true if the character is a valid first char of an XML name. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.IsNameChar(System.Char)">
            <summary>
            Simple check if a character is a valid XML name char
            (every char except the first one), according to the XML Spec 1.1:
            http://www.w3.org/TR/xml11/#NT-NameChar
            </summary>
            <param name="ch"> a character </param>
            <returns> Returns true if the character is a valid char of an XML name. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.Utils.InitCharTables">
            <summary>
            Initializes the char tables for the chars 0x00-0xFF for later use,
            according to the XML 1.1 specification
            http://www.w3.org/TR/xml11
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpDateTimeImpl">
            <summary>
            The implementation of <code>XMPDateTime</code>. Internally a <code>calendar</code> is used
            plus an additional nano seconds field, because <code>Calendar</code> supports only milli
            seconds. The <code>nanoSeconds</code> convers only the resolution beyond a milli second.
            
            @since 16.02.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.xmp.IXmpDateTime" -->
        <member name="M:iTextSharp.xmp.IXmpDateTime.HasDate">
            <summary>
            This flag is set either by parsing or by setting year, month or day. </summary>
            <returns> Returns true if the XMPDateTime object has a date portion. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpDateTime.HasTime">
            <summary>
            This flag is set either by parsing or by setting hours, minutes, seconds or milliseconds. </summary>
            <returns> Returns true if the XMPDateTime object has a time portion. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpDateTime.HasTimeZone">
            <summary>
            This flag is set either by parsing or by setting hours, minutes, seconds or milliseconds. </summary>
            <returns> Returns true if the XMPDateTime object has a defined timezone. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Year">
            <returns> Returns the year, can be negative. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Month">
            <returns> Returns The month in the range 1..12. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Day">
            <returns> Returns the day of the month in the range 1..31. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Hour">
            <returns> Returns hour - The hour in the range 0..23. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Minute">
            <returns> Returns the minute in the range 0..59. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.Second">
            <returns> Returns the second in the range 0..59. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.NanoSecond">
            <returns> Returns milli-, micro- and nano seconds.
            		   Nanoseconds within a second, often left as zero? </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpDateTime.TimeZone">
            <returns> Returns the time zone. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.IXmpDateTime.Calendar" -->
        <member name="P:iTextSharp.xmp.IXmpDateTime.Iso8601String">
            <returns> Returns the ISO 8601 string representation of the date and time. </returns>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpDateTimeImpl._nanoSeconds">
            <summary>
            The nano seconds take micro and nano seconds, while the milli seconds are in the calendar.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpDateTimeImpl._timeZone">
            <summary>
            Use NO time zone as default </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpDateTimeImpl.#ctor">
            <summary>
            Creates an <code>XMPDateTime</code>-instance with the current time in the default time
            zone.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpDateTimeImpl.#ctor(iTextSharp.xmp.XmpCalendar)">
            <summary>
            Creates an <code>XMPDateTime</code>-instance from a calendar.
            </summary>
            <param name="calendar"> a <code>Calendar</code> </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpDateTimeImpl.#ctor(System.DateTime,System.TimeZone)">
            <summary>
            Creates an <code>XMPDateTime</code>-instance from 
            a <code>Date</code> and a <code>TimeZone</code>.
            </summary>
            <param name="date"> a date describing an absolute point in time </param>
            <param name="timeZone"> a TimeZone how to interpret the date </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpDateTimeImpl.#ctor(System.String)">
            <summary>
            Creates an <code>XMPDateTime</code>-instance from an ISO 8601 string.
            </summary>
            <param name="strValue"> an ISO 8601 string </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the string is a non-conform ISO 8601 string, an exception is thrown </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpDateTimeImpl.CompareTo(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpDateTimeImpl.HasDate" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpDateTimeImpl.HasTime" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpDateTimeImpl.HasTimeZone" -->
        <member name="M:iTextSharp.xmp.impl.XmpDateTimeImpl.ToString">
            <returns> Returns the ISO string representation. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Year" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Month" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Day" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Hour" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Minute" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Second" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.NanoSecond" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.TimeZone" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Calendar" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpDateTimeImpl.Iso8601String" -->
        <member name="T:iTextSharp.xmp.impl.XmpIteratorImpl">
            <summary>
            The <code>XMPIterator</code> implementation.
            Iterates the XMP Tree according to a set of options.
            During the iteration the XMPMeta-object must not be changed.
            Calls to <code>skipSubtree()</code> / <code>skipSiblings()</code> will affect the iteration.
             
            @since   29.06.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.xmp.IXmpIterator" -->
        <member name="M:iTextSharp.xmp.IXmpIterator.SkipSubtree">
            <summary>
            Skip the subtree below the current node when <code>next()</code> is
            called.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.IXmpIterator.SkipSiblings">
            <summary>
            Skip the subtree below and remaining siblings of the current node when
            <code>next()</code> is called.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl._nodeIterator">
            <summary>
            the node iterator doing the work </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl._options">
            <summary>
            stores the iterator options </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl._baseNs">
            <summary>
            the base namespace of the property path, will be changed during the iteration </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl._skipSiblings">
            <summary>
            flag to indicate that skipSiblings() has been called. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.skipSubtree">
            <summary>
            flag to indicate that skipSiblings() has been called. </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.#ctor(iTextSharp.xmp.impl.XmpMetaImpl,System.String,System.String,iTextSharp.xmp.options.IteratorOptions)">
            <summary>
            Constructor with optionsl initial values. If <code>propName</code> is provided, 
            <code>schemaNs</code> has also be provided. </summary>
            <param name="xmp"> the iterated metadata object. </param>
            <param name="schemaNs"> the iteration is reduced to this schema (optional) </param>
            <param name="propPath"> the iteration is redurce to this property within the <code>schemaNs</code> </param>
            <param name="options"> advanced iteration options, see <seealso cref="T:iTextSharp.xmp.options.IteratorOptions"/> </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the node defined by the paramters is not existing.  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpIteratorImpl.SkipSubtree" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpIteratorImpl.SkipSiblings" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpIteratorImpl.MoveNext" -->
        <member name="P:iTextSharp.xmp.impl.XmpIteratorImpl.Options">
            <returns> Exposes the options for inner class. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpIteratorImpl.BaseNs">
            <returns> Exposes the options for inner class. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpIteratorImpl.Current" -->
        <member name="T:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator">
            <summary>
            The <code>XMPIterator</code> implementation.
            It first returns the node itself, then recursivly the children and qualifier of the node.
            
            @since   29.06.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ITERATE_NODE">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ITERATE_CHILDREN">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ITERATE_QUALIFIER">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._path">
            <summary>
            the recursively accumulated path </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._visitedNode">
            <summary>
            the currently visited node </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._childrenIterator">
            <summary>
            the iterator that goes through the children and qualifier list </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._index">
            <summary>
            index of node with parent, only interesting for arrays </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._returnProperty">
            <summary>
            the cached <code>PropertyInfo</code> to return </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._state">
            <summary>
            the state of the iteration </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator._subIterator">
            <summary>
            the iterator for each child </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.#ctor(iTextSharp.xmp.impl.XmpIteratorImpl,iTextSharp.xmp.impl.XmpNode,System.String,System.Int32)">
            <summary>
            Constructor for the node iterator. </summary>
            <param name="visitedNode"> the currently visited node </param>
            <param name="parentPath"> the accumulated path of the node </param>
            <param name="index"> the index within the parent node (only for arrays) </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.MoveNext" -->
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ReportNode">
            <summary>
            Sets the returnProperty as next item or recurses into <code>hasNext()</code>. </summary>
            <returns> Returns if there is a next item to return.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.IterateChildren(System.Collections.IEnumerator)">
            <summary>
            Handles the iteration of the children or qualfier </summary>
            <param name="iterator"> an iterator </param>
            <returns> Returns if there are more elements available. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.AccumulatePath(iTextSharp.xmp.impl.XmpNode,System.String,System.Int32)">
            <param name="currNode"> the node that will be added to the path. </param>
            <param name="parentPath"> the path up to this node. </param>
            <param name="currentIndex"> the current array index if an arrey is traversed </param>
            <returns> Returns the updated path. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.CreatePropertyInfo(iTextSharp.xmp.impl.XmpNode,System.String,System.String)">
            <summary>
            Creates a property info object from an <code>XMPNode</code>. </summary>
            <param name="node"> an <code>XMPNode</code> </param>
            <param name="baseNs"> the base namespace to report </param>
            <param name="path"> the full property path </param>
            <returns> Returns a <code>XMPProperty</code>-object that serves representation of the node. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ChildrenIterator">
            <returns> the childrenIterator </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIterator.ReturnProperty">
            <returns> Returns the returnProperty. </returns>
        </member>
        <member name="T:iTextSharp.xmp.properties.IXmpPropertyInfo">
            <summary>
            This interface is used to return a property together with its path and namespace.
            It is returned when properties are iterated with the <code>XMPIterator</code>.
            
            @since   06.07.2006
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.properties.IXmpProperty">
            <summary>
            This interface is used to return a text property together with its and options.
            
            @since   23.01.2006
            </summary>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpProperty.Value">
            <returns> Returns the value of the property. </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpProperty.Options">
            <returns> Returns the options of the property. </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpProperty.Language">
            <summary>
            Only set by <seealso cref="M:iTextSharp.xmp.IXmpMeta.GetLocalizedText(System.String,System.String,System.String,System.String)"/>. </summary>
            <returns> Returns the language of the alt-text item. </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpPropertyInfo.Namespace">
            <returns> Returns the namespace of the property </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpPropertyInfo.Path">
            <returns> Returns the path of the property, but only if returned by the iterator. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIteratorChildren">
            <summary>
            This iterator is derived from the default <code>NodeIterator</code>,
            and is only used for the option <seealso cref="F:iTextSharp.xmp.options.IteratorOptions.JUST_CHILDREN"/>.
            
            @since 02.10.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIteratorChildren.#ctor(iTextSharp.xmp.impl.XmpIteratorImpl,iTextSharp.xmp.impl.XmpNode,System.String)">
            <summary>
            Constructor </summary>
            <param name="parentNode"> the node which children shall be iterated. </param>
            <param name="parentPath"> the full path of the former node without the leaf node. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpIteratorImpl.NodeIteratorChildren.MoveNext" -->
        <member name="T:iTextSharp.xmp.impl.XmpMetaImpl">
            <summary>
            Implementation for <seealso cref="T:iTextSharp.xmp.IXmpMeta"/>.
            
            @since 17.02.2006
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.IXmpMeta">
            <summary>
            This class represents the set of XMP metadata as a DOM representation. It has methods to read and
            modify all kinds of properties, create an iterator over all properties and Serialize the metadata
            to a String, byte-array or <code>OutputStream</code>.
            
            @since 20.01.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.GetProperty(System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.GetArrayItem(System.String,System.String,System.Int32)">
            <summary>
            Provides access to items within an array. The index is passed as an integer, you need not
            worry about the path string syntax for array items, convert a loop index to a string, etc.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in GetProperty. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <param name="itemIndex"> The index of the desired item. Arrays in XMP are indexed from 1. The
                   constant <seealso cref="F:iTextSharp.xmp.XmpConst.ARRAY_LAST_ITEM"/> always refers to the last existing array
                   item. </param>
            <returns> Returns a <code>XMPProperty</code> containing the value and the options or
                    <code>null</code> if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.CountArrayItems(System.String,System.String)">
            <summary>
            Returns the number of items in the array.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in GetProperty. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <returns> Returns the number of items in the array. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.GetStructField(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.GetQualifier(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetProperty(System.String,System.String,System.Object,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetProperty(System.String,System.String,System.Object)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetArrayItem(System.String,System.String,System.Int32,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Replaces an item within an array. The index is passed as an integer, you need not worry about
            the path string syntax for array items, convert a loop index to a string, etc. The array
            passed must already exist. In normal usage the selected array item is modified. A new item is
            automatically appended if the index is the array size plus 1.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in GetProperty. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in GetProperty. </param>
            <param name="itemIndex"> The index of the desired item. Arrays in XMP are indexed from 1. To address
                   the last existing item, use <seealso cref="M:iTextSharp.xmp.IXmpMeta.CountArrayItems(System.String,System.String)"/> to find
                   out the length of the array. </param>
            <param name="itemValue"> the new value of the array item. Has the same usage as propValue in
                   <code>SetProperty()</code>. </param>
            <param name="options"> the set options for the item. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetArrayItem(System.String,System.String,System.Int32,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Inserts an item into an array previous to the given index. The index is passed as an integer,
            you need not worry about the path string syntax for array items, convert a loop index to a
            string, etc. The array passed must already exist. In normal usage the selected array item is
            modified. A new item is automatically appended if the index is the array size plus 1.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in GetProperty. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in GetProperty. </param>
            <param name="itemIndex"> The index to insert the new item. Arrays in XMP are indexed from 1. Use
            		  <code>XmpConst.ARRAY_LAST_ITEM</code> to append items. </param>
            <param name="itemValue"> the new value of the array item. Has the same usage as
                   propValue in <code>SetProperty()</code>. </param>
            <param name="options"> the set options that decide about the kind of the node. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.AppendArrayItem(System.String,System.String,iTextSharp.xmp.options.PropertyOptions,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.AppendArrayItem(System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetStructField(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Provides access to fields within a nested structure. The namespace for the field is passed as
            a URI, you need not worry about the path string syntax. The names of fields should be XML
            qualified names, that is within an XML namespace. The path syntax for a qualified name uses
            the namespace prefix, which is unreliable because the prefix is never guaranteed. The URI is
            the formal name, the prefix is just a local shorthand in a given sequence of XML text.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in GetProperty. </param>
            <param name="structName"> The name of the struct. May be a general path expression, must not be null
                   or the empty string. Has the same namespace prefix usage as propName in GetProperty. </param>
            <param name="fieldNs"> The namespace URI for the field. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="fieldName"> The name of the field. Must be a single XML name, must not be null or the
                   empty string. Has the same namespace prefix usage as the structName parameter. </param>
            <param name="fieldValue"> the value of thefield, if the field has a value. 
                   Has the same usage as propValue in GetProperty. </param>
            <param name="options"> Option flags describing the field. See the earlier description. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetStructField(System.String,System.String,System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Provides access to a qualifier attached to a property. The namespace for the qualifier is
            passed as a URI, you need not worry about the path string syntax. In many regards qualifiers
            are like struct fields. See the introductory discussion of qualified properties for more
            information. The names of qualifiers should be XML qualified names, that is within an XML
            namespace. The path syntax for a qualified name uses the namespace prefix, which is
            unreliable because the prefix is never guaranteed. The URI is the formal name, the prefix is
            just a local shorthand in a given sequence of XML text. The property the qualifier
            will be attached has to exist.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in GetProperty. </param>
            <param name="propName"> The name of the property to which the qualifier is attached. Has the same
                   usage as in GetProperty. </param>
            <param name="qualNs"> The namespace URI for the qualifier. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="qualName"> The name of the qualifier. Must be a single XML name, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as the
                   propName parameter. </param>
            <param name="qualValue"> A pointer to the <code>null</code> terminated UTF-8 string that is the
                   value of the qualifier, if the qualifier has a value. Has the same usage as propValue
                   in GetProperty. </param>
            <param name="options"> Option flags describing the qualifier. See the earlier description. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.DeleteProperty(System.String,System.String)">
            <summary>
            Deletes the given XMP subtree rooted at the given property. It is not an error if the
            property does not exist.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property. Has the same usage as in GetProperty. </param>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DeleteArrayItem(System.String,System.String,System.Int32)">
            <summary>
            Deletes the given XMP subtree rooted at the given array item. It is not an error if the array
            item does not exist.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in GetProperty. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <param name="itemIndex"> The index of the desired item. Arrays in XMP are indexed from 1. The
                   constant <code>XmpConst.ARRAY_LAST_ITEM</code> always refers to the last
                   existing array item. </param>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DeleteStructField(System.String,System.String,System.String,System.String)">
            <summary>
            Deletes the given XMP subtree rooted at the given struct field. It is not an error if the
            field does not exist.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="structName"> The name of the struct. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in GetProperty. </param>
            <param name="fieldNs"> The namespace URI for the field. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="fieldName"> The name of the field. Must be a single XML name, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as the
                   structName parameter. </param>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DeleteQualifier(System.String,System.String,System.String,System.String)">
            <summary>
            Deletes the given XMP subtree rooted at the given qualifier. It is not an error if the
            qualifier does not exist.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property to which the qualifier is attached. Has the same
                   usage as in GetProperty. </param>
            <param name="qualNs"> The namespace URI for the qualifier. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="qualName"> The name of the qualifier. Must be a single XML name, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as the
                   propName parameter. </param>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DoesPropertyExist(System.String,System.String)">
            <summary>
            Returns whether the property exists.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property. 
            		  Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns true if the property exists. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DoesArrayItemExist(System.String,System.String,System.Int32)">
            <summary>
            Tells if the array item exists.
            </summary>
            <param name="schemaNs"> The namespace URI for the array. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <param name="itemIndex"> The index of the desired item. Arrays in XMP are indexed from 1. The
                   constant <code>XmpConst.ARRAY_LAST_ITEM</code> always refers to the last
                   existing array item. </param>
            <returns> Returns <code>true</code> if the array exists, <code>false</code> otherwise. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DoesStructFieldExist(System.String,System.String,System.String,System.String)">
            <summary>
            DoesStructFieldExist tells if the struct field exists.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="structName"> The name of the struct. May be a general path expression, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <param name="fieldNs"> The namespace URI for the field. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="fieldName"> The name of the field. Must be a single XML name, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as the
                   structName parameter. </param>
            <returns> Returns true if the field exists. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DoesQualifierExist(System.String,System.String,System.String,System.String)">
            <summary>
            DoesQualifierExist tells if the qualifier exists.
            </summary>
            <param name="schemaNs"> The namespace URI for the struct. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property to which the qualifier is attached. Has the same
                   usage as in <code>GetProperty()</code>. </param>
            <param name="qualNs"> The namespace URI for the qualifier. Has the same URI and prefix usage as the
                   schemaNs parameter. </param>
            <param name="qualName"> The name of the qualifier. Must be a single XML name, must not be
                   <code>null</code> or the empty string. Has the same namespace prefix usage as the
                   propName parameter. </param>
            <returns> Returns true if the qualifier exists. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.GetLocalizedText(System.String,System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Modifies the value of a selected item in an alt-text array. Creates an appropriate array item
            if necessary, and handles special cases for the x-default item. If the selected item is from
            a match with the specific language, the value of that item is modified. If the existing value
            of that item matches the existing value of the x-default item, the x-default item is also
            modified. If the array only has 1 existing item (which is not x-default), an x-default item
            is added with the given value. If the selected item is from a match with the generic language
            and there are no other generic matches, the value of that item is modified. If the existing
            value of that item matches the existing value of the x-default item, the x-default item is
            also modified. If the array only has 1 existing item (which is not x-default), an x-default
            item is added with the given value. If the selected item is from a partial match with the
            generic language and there are other partial matches, a new item is created for the specific
            language. The x-default item is not modified. If the selected item is from the last 2 rules
            then a new item is created for the specific language. If the array only had an x-default
            item, the x-default item is also modified. If the array was empty, items are created for the
            specific language and x-default.
            
            <em>Note:</em> In a future version of this API a method 
            		using Java <code>java.lang.Locale</code> will be added.
            
            </summary>
            <param name="schemaNs"> The namespace URI for the alt-text array. Has the same usage as in
                   <code>GetProperty()</code>. </param>
            <param name="altTextName"> The name of the alt-text array. May be a general path expression, must not
                   be <code>null</code> or the empty string. Has the same namespace prefix usage as
                   propName in <code>GetProperty()</code>. </param>
            <param name="genericLang"> The name of the generic language as an RFC 3066 primary subtag. May be
                   <code>null</code> or the empty string if no generic language is wanted. </param>
            <param name="specificLang"> The name of the specific language as an RFC 3066 tag. Must not be
                   <code>null</code> or the empty string. </param>
            <param name="itemValue"> A pointer to the <code>null</code> terminated UTF-8 string that is the new
                   value for the appropriate array item. </param>
            <param name="options"> Option flags, none are defined at present. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyBoolean(System.String,System.String)">
            <summary>
            These are very similar to <code>GetProperty()</code> and <code>SetProperty()</code> above, 
            but the value is returned or provided in a literal form instead of as a UTF-8 string. 
            The path composition functions in <code>XMPPathFactory</code> may be used to compose an path 
            expression for fields in nested structures, items in arrays, or qualifiers.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>Boolean</code> value or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyInteger(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns an <code>Integer</code> value or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyLong(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>Long</code> value or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyDouble(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>Double</code> value or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyDate(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>XMPDateTime</code>-object or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyCalendar(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a Java <code>Calendar</code>-object or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyBase64(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>byte[]</code>-array contained the decoded base64 value 
            		   or <code>null</code> if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.GetPropertyString(System.String,System.String)">
            <summary>
            Convenience method to retrieve the literal value of a property.
            <em>Note:</em> There is no <code>SetPropertyString()</code>, 
            because <code>SetProperty()</code> sets a string value.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>GetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <returns> Returns a <code>String</code> value or <code>null</code> 
            		   if the property does not exist. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur, 
            		   especially conversion errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyBoolean(System.String,System.String,System.Boolean,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property to a literal <code>boolean</code> value.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the literal property value as <code>boolean</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyBoolean(System.String,System.String,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyInteger(System.String,System.String,System.Int32,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property to a literal <code>int</code> value.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the literal property value as <code>int</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyInteger(System.String,System.String,System.Int32)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyLong(System.String,System.String,System.Int64,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property to a literal <code>long</code> value.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the literal property value as <code>long</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyLong(System.String,System.String,System.Int64)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyDouble(System.String,System.String,System.Double,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property to a literal <code>double</code> value.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the literal property value as <code>double</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyDouble(System.String,System.String,System.Double)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyDate(System.String,System.String,iTextSharp.xmp.IXmpDateTime,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property with an XMPDateTime-object, 
            which is serialized to an ISO8601 date.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the property value as <code>XMPDateTime</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyDate(System.String,System.String,iTextSharp.xmp.IXmpDateTime)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyCalendar(System.String,System.String,System.DateTime,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property with a Java Calendar-object, 
            which is serialized to an ISO8601 date.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the property value as Java <code>Calendar</code>. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyCalendar(System.String,System.String,System.DateTime)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.SetPropertyBase64(System.String,System.String,System.SByte[],iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Convenience method to set a property from a binary <code>byte[]</code>-array, 
            which is serialized as base64-string.
            </summary>
            <param name="schemaNs"> The namespace URI for the property. Has the same usage as in
                    <code>SetProperty()</code>. </param>
            <param name="propName"> The name of the property.
            		   Has the same usage as in <code>GetProperty()</code>. </param>
            <param name="propValue"> the literal property value as byte array. </param>
            <param name="options"> options of the property to set (optional). </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.SetPropertyBase64(System.String,System.String,System.SByte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.Iterator" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.Iterator(iTextSharp.xmp.options.IteratorOptions)" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.Iterator(System.String,System.String,iTextSharp.xmp.options.IteratorOptions)">
            <summary>
            Construct an iterator for the properties within an XMP object. According to the parameters it iterates the entire data tree,
            properties within a specific schema, or a subtree rooted at a specific node.
            </summary>
            <param name="schemaNs"> Optional schema namespace URI to restrict the iteration. Omitted (visit all
                   schema) by passing <code>null</code> or empty String. </param>
            <param name="propName"> Optional property name to restrict the iteration. May be an arbitrary path
                   expression. Omitted (visit all properties) by passing <code>null</code> or empty
                   String. If no schema URI is given, it is ignored. </param>
            <param name="options"> Option flags to control the iteration. See <seealso cref="T:iTextSharp.xmp.options.IteratorOptions"/> for
                   details. </param>
            <returns> Returns an <code>XMPIterator</code> for this <code>XMPMeta</code>-object
                    considering the given options. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpMeta.Sort" -->
        <member name="M:iTextSharp.xmp.IXmpMeta.Normalize(iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Perform the normalization as a separate parsing step.
            Normally it is done during parsing, unless the parsing option
            <seealso cref="F:iTextSharp.xmp.options.ParseOptions.OMIT_NORMALIZATION"/> is set to <code>true</code>.
            <em>Note:</em> It does no harm to call this method to an already normalized xmp object. 
            It was a PDF/A requirement to get hand on the unnormalized <code>XMPMeta</code> object.
            </summary>
            <param name="options"> optional parsing options. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Wraps all errors and exceptions that may occur. </exception>
        </member>
        <member name="M:iTextSharp.xmp.IXmpMeta.DumpObject">
            <summary>
            Renders this node and the tree unter this node in a human readable form. </summary>
            <returns> Returns a multiline string containing the dump. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpMeta.ObjectName">
            <summary>
            This correlates to the about-attribute,
            returns the empty String if no name is set.
            </summary>
            <returns> Returns the name of the XMP object. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpMeta.PacketHeader">
            <returns> Returns the unparsed content of the &lt;?xpacket&gt; processing instruction.
            		This contains normally the attribute-like elements 'begin="&lt;BOM&gt;"
            	id="W5M0MpCehiHzreSzNTczkc9d"' and possibly the deprecated elements 'bytes="1234"' or
            		'encoding="XXX"'. If the parsed packet has not been wrapped into an xpacket,
            		<code>null</code> is returned.    </returns>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpMetaImpl.VALUE_STRING">
            <summary>
            Property values are Strings by default </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpMetaImpl._tree">
            <summary>
            root of the metadata tree </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpMetaImpl._packetHeader">
            <summary>
            the xpacket processing instructions content </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaImpl.#ctor">
            <summary>
            Constructor for an empty metadata object.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaImpl.#ctor(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Constructor for a cloned metadata tree.
            </summary>
            <param name="tree">
                       an prefilled metadata tree which fulfills all
                       <code>XMPNode</code> contracts. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.AppendArrayItem(System.String,System.String,iTextSharp.xmp.options.PropertyOptions,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.AppendArrayItem(System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.CountArrayItems(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DeleteArrayItem(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DeleteProperty(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DeleteQualifier(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DeleteStructField(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DoesPropertyExist(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DoesArrayItemExist(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DoesStructFieldExist(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DoesQualifierExist(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetArrayItem(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetLocalizedText(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetLocalizedText(System.String,System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetProperty(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyBoolean(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyBoolean(System.String,System.String,System.Boolean,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyBoolean(System.String,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyInteger(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyInteger(System.String,System.String,System.Int32,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyInteger(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyLong(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyLong(System.String,System.String,System.Int64,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyLong(System.String,System.String,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyDouble(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyDouble(System.String,System.String,System.Double,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyDouble(System.String,System.String,System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyDate(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyDate(System.String,System.String,iTextSharp.xmp.IXmpDateTime,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyDate(System.String,System.String,iTextSharp.xmp.IXmpDateTime)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyCalendar(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyCalendar(System.String,System.String,System.DateTime,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyCalendar(System.String,System.String,System.DateTime)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyBase64(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyString(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyBase64(System.String,System.String,System.SByte[],iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetPropertyBase64(System.String,System.String,System.SByte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetQualifier(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetStructField(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Iterator" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Iterator(iTextSharp.xmp.options.IteratorOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Iterator(System.String,System.String,iTextSharp.xmp.options.IteratorOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetArrayItem(System.String,System.String,System.Int32,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetArrayItem(System.String,System.String,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.InsertArrayItem(System.String,System.String,System.Int32,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.InsertArrayItem(System.String,System.String,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetProperty(System.String,System.String,System.Object,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetProperty(System.String,System.String,System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetQualifier(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetQualifier(System.String,System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetStructField(System.String,System.String,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.SetStructField(System.String,System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Clone" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.DumpObject" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Sort" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.Normalize(iTextSharp.xmp.options.ParseOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetProperty(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaImpl.GetPropertyObject(System.String,System.String,System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.XmpMetaImpl.DoSetArrayItem(iTextSharp.xmp.impl.XmpNode,System.Int32,System.String,iTextSharp.xmp.options.PropertyOptions,System.Boolean)">
            <summary>
            Locate or create the item node and set the value. Note the index
            parameter is one-based! The index can be in the range [1..size + 1] or
            "last()", normalize it and check the insert flags. The order of the
            normalization checks is important. If the array is empty we end up with
            an index and location to set item size + 1.
            </summary>
            <param name="arrayNode"> an array node </param>
            <param name="itemIndex"> the index where to insert the item </param>
            <param name="itemValue"> the item value </param>
            <param name="itemOptions"> the options for the new item </param>
            <param name="insert"> insert oder overwrite at index position? </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaImpl.SetNode(iTextSharp.xmp.impl.XmpNode,System.Object,iTextSharp.xmp.options.PropertyOptions,System.Boolean)">
            <summary>
            The internals for SetProperty() and related calls, used after the node is
            found or created.
            </summary>
            <param name="node">
                       the newly created node </param>
            <param name="value">
                       the node value, can be <code>null</code> </param>
            <param name="newOptions">
                       options for the new node, must not be <code>null</code>. </param>
            <param name="deleteExisting"> flag if the existing value is to be overwritten </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thrown if options and value do not correspond </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaImpl.evaluateNodeValue(System.Int32,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Evaluates a raw node value to the given value type, apply special
            conversions for defined types in XMP.
            </summary>
            <param name="valueType">
                       an int indicating the value type </param>
            <param name="propNode">
                       the node containing the value </param>
            <returns> Returns a literal value for the node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpMetaImpl.Root">
            <returns> Returns the root node of the XMP tree. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpMetaImpl.ObjectName" -->
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.impl.XmpMetaImpl.PacketHeader" -->
        <member name="T:iTextSharp.xmp.impl.XmpMetaParser">
            <summary>
            This class replaces the <code>ExpatAdapter.cpp</code> and does the
            XML-parsing and fixes the prefix. After the parsing several normalisations
            are applied to the XMPTree.
            
            @since 01.02.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaParser.#ctor">
            <summary>
            Hidden constructor, initialises the SAX parser handler.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaParser.Parse(System.Object,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Parses the input source into an XMP metadata object, including
            de-aliasing and normalisation.
            </summary>
            <param name="input"> the input can be an <code>InputStream</code>, a <code>String</code> or 
            			a byte buffer containing the XMP packet. </param>
            <param name="options"> the parse options </param>
            <returns> Returns the resulting XMP metadata object </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if parsing or normalisation fails. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaParser.ParseXml(System.Object,iTextSharp.xmp.options.ParseOptions)" -->
        <member name="M:iTextSharp.xmp.impl.XmpMetaParser.ParseXmlFromInputStream(System.IO.Stream,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Parses XML from an <seealso cref="T:System.IO.Stream"/>,
            fixing the encoding (Latin-1 to UTF-8) and illegal control character optionally.
            </summary>
            <param name="stream"> an <code>InputStream</code> </param>
            <param name="options"> the parsing options </param>
            <returns> Returns an XML DOM-Document. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown when the parsing fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaParser.ParseXmlFromBytebuffer(iTextSharp.xmp.impl.ByteBuffer,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Parses XML from a byte buffer, 
            fixing the encoding (Latin-1 to UTF-8) and illegal control character optionally.
            </summary>
            <param name="buffer"> a byte buffer containing the XMP packet </param>
            <param name="options"> the parsing options </param>
            <returns> Returns an XML DOM-Document. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown when the parsing fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpMetaParser.ParseXmlFromString(System.String,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Parses XML from a <seealso cref="T:System.String"/>, 
            fixing the illegal control character optionally.
            </summary>
            <param name="input"> a <code>String</code> containing the XMP packet </param>
            <param name="options"> the parsing options </param>
            <returns> Returns an XML DOM-Document. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown when the parsing fails. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpMetaParser.FindRootNode(System.Xml.XmlNode,System.Boolean,System.Object[])" -->
        <member name="T:iTextSharp.xmp.impl.XmpNode">
            <summary>
            A node in the internally XMP tree, which can be a schema node, a property node, an array node,
            an array item, a struct node or a qualifier node (without '?').
            
            Possible improvements:
            
            1. The kind Node of node might be better represented by a class-hierarchy of different nodes.
            2. The array type should be an enum
            3. isImplicitNode should be removed completely and replaced by return values of fi.
            4. hasLanguage, hasType should be automatically maintained by XMPNode
            
            @since 21.02.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._alias">
            <summary>
            flag if the node is an alias </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._children">
            <summary>
            list of child nodes, lazy initialized </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._hasAliases">
            <summary>
            flag if the node has aliases </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._hasValueChild">
            <summary>
            flag if the node has an "rdf:value" child node. </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._implicit">
            <summary>
            flag if the node is implicitly created </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._name">
            <summary>
            name of the node, contains different information depending of the node kind </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._options">
            <summary>
            options describing the kind of the node </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._parent">
            <summary>
            link to the parent node </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._qualifier">
            <summary>
            list of qualifier of the node, lazy initialized </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNode._value">
            <summary>
            value of the node, contains different information depending of the node kind </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.#ctor(System.String,System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Creates an <code>XMPNode</code> with initial values.
            </summary>
            <param name="name"> the name of the node </param>
            <param name="value"> the value of the node </param>
            <param name="options"> the options of the node </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.#ctor(System.String,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Constructor for the node without value.
            </summary>
            <param name="name"> the name of the node </param>
            <param name="options"> the options of the node </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNode.Clone" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNode.CompareTo(System.Object)" -->
        <member name="M:iTextSharp.xmp.impl.XmpNode.Clear">
            <summary>
            Resets the node.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.GetChild(System.Int32)">
            <param name="index"> an index [1..size] </param>
            <returns> Returns the child with the requested index. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.AddChild(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Adds a node as child to this node. </summary>
            <param name="node"> an XMPNode </param>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.AddChild(System.Int32,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Adds a node as child to this node. </summary>
            <param name="index"> the index of the node <em>before</em> which the new one is inserted.
            <em>Note:</em> The node children are indexed from [1..size]! 
            An index of size + 1 appends a node. </param>
            <param name="node"> an XMPNode </param>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.ReplaceChild(System.Int32,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Replaces a node with another one. </summary>
            <param name="index"> the index of the node that will be replaced.
            <em>Note:</em> The node children are indexed from [1..size]! </param>
            <param name="node"> the replacement XMPNode </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.RemoveChild(System.Int32)">
            <summary>
            Removes a child at the requested index. </summary>
            <param name="itemIndex"> the index to remove [1..size]  </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.RemoveChild(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Removes a child node.
            If its a schema node and doesn't have any children anymore, its deleted.
            </summary>
            <param name="node"> the child node to delete. </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.CleanupChildren">
            <summary>
            Removes the children list if this node has no children anymore;
            checks if the provided node is a schema node and doesn't have any children anymore, 
            its deleted.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.RemoveChildren">
            <summary>
            Removes all children from the node. 
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.FindChildByName(System.String)">
            <param name="expr"> child node name to look for </param>
            <returns> Returns an <code>XMPNode</code> if node has been found, <code>null</code> otherwise.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.GetQualifier(System.Int32)">
            <param name="index"> an index [1..size] </param>
            <returns> Returns the qualifier with the requested index. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.AddQualifier(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Appends a qualifier to the qualifier list and sets respective options. </summary>
            <param name="qualNode"> a qualifier node. </param>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.RemoveQualifier(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Removes one qualifier node and fixes the options. </summary>
            <param name="qualNode"> qualifier to remove </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.RemoveQualifiers">
            <summary>
            Removes all qualifiers from the node and sets the options appropriate. 
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.FindQualifierByName(System.String)">
            <param name="expr"> qualifier node name to look for </param>
            <returns> Returns a qualifier <code>XMPNode</code> if node has been found, 
            <code>null</code> otherwise.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.HasChildren">
            <returns> Returns whether the node has children. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.IterateChildren">
            <returns> Returns an iterator for the children.
            <em>Note:</em> take care to use it.remove(), as the flag are not adjusted in that case. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.HasQualifier">
            <returns> Returns whether the node has qualifier attached. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.IterateQualifier">
            <returns> Returns an iterator for the qualifier.
            <em>Note:</em> take care to use it.remove(), as the flag are not adjusted in that case. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.CloneSubtree(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Performs a <b>deep clone</b> of the complete subtree (children and
            qualifier )into and add it to the destination node.
            </summary>
            <param name="destination"> the node to add the cloned subtree </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.DumpNode(System.Boolean)">
            <summary>
            Renders this node and the tree unter this node in a human readable form. </summary>
            <param name="recursive"> Flag is qualifier and child nodes shall be rendered too </param>
            <returns> Returns a multiline string containing the dump. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNode.Sort" -->
        <member name="M:iTextSharp.xmp.impl.XmpNode.DumpNode(System.Text.StringBuilder,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Dumps this node and its qualifier and children recursively.
            <em>Note:</em> It creats empty options on every node.
            </summary>
            <param name="result"> the buffer to append the dump. </param>
            <param name="recursive"> Flag is qualifier and child nodes shall be rendered too </param>
            <param name="indent"> the current indent level. </param>
            <param name="index"> the index within the parent node (important for arrays)  </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.find(System.Collections.IList,System.String)">
            <summary>
            Internal find. </summary>
            <param name="list"> the list to search in </param>
            <param name="expr"> the search expression </param>
            <returns> Returns the found node or <code>nulls</code>. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.AssertChildNotExisting(System.String)">
            <summary>
            Checks that a node name is not existing on the same level, except for array items. </summary>
            <param name="childName"> the node name to check </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if a node with the same name is existing. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNode.AssertQualifierNotExisting(System.String)">
            <summary>
            Checks that a qualifier name is not existing on the same level. </summary>
            <param name="qualifierName"> the new qualifier name </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if a node with the same name is existing. </exception>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Parent">
            <returns> Returns the parent node. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.ChildrenLength">
            <returns> Returns the number of children without neccessarily creating a list. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.QualifierLength">
            <returns> Returns the number of qualifier without neccessarily creating a list. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Name">
            <returns> Returns the name. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Value">
            <returns> Returns the value. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Options">
            <returns> Returns the options. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Implicit">
            <returns> Returns the implicit flag </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.HasAliases">
            <returns> Returns if the node contains aliases (applies only to schema nodes) </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Alias">
            <returns> Returns if the node contains aliases (applies only to schema nodes) </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.HasValueChild">
            <returns> the hasValueChild </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.LanguageNode">
            <returns> Returns whether this node is a language qualifier.  </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.TypeNode">
            <returns> Returns whether this node is a type qualifier.  </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Children">
            <summary>
            <em>Note:</em> This method should always be called when accessing 'children' to be sure
            that its initialized. </summary>
            <returns> Returns list of children that is lazy initialized. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.UnmodifiableChildren">
            <returns> Returns a read-only copy of child nodes list. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.XmpNode.Qualifier">
            <returns> Returns list of qualifier that is lazy initialized. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpNodeUtils">
            <summary>
            Utilities for <code>XMPNode</code>.
            
            @since   Aug 28, 2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.#ctor">
            <summary>
            Private Constructor
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindSchemaNode(iTextSharp.xmp.impl.XmpNode,System.String,System.Boolean)">
            <summary>
            Find or create a schema node if <code>createNodes</code> is false and
            </summary>
            <param name="tree"> the root of the xmp tree. </param>
            <param name="namespaceUri"> a namespace </param>
            <param name="createNodes"> a flag indicating if the node shall be created if not found.
            		  <em>Note:</em> The namespace must be registered prior to this call.
            </param>
            <returns> Returns the schema node if found, <code>null</code> otherwise.
            		   Note: If <code>createNodes</code> is <code>true</code>, it is <b>always</b>
            		   returned a valid node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> An exception is only thrown if an error occurred, not if a
                    		node was not found. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindSchemaNode(iTextSharp.xmp.impl.XmpNode,System.String,System.String,System.Boolean)">
            <summary>
            Find or create a schema node if <code>createNodes</code> is true.
            </summary>
            <param name="tree"> the root of the xmp tree. </param>
            <param name="namespaceUri"> a namespace </param>
            <param name="suggestedPrefix"> If a prefix is suggested, the namespace is allowed to be registered. </param>
            <param name="createNodes"> a flag indicating if the node shall be created if not found.
            		  <em>Note:</em> The namespace must be registered prior to this call.
            </param>
            <returns> Returns the schema node if found, <code>null</code> otherwise.
            		   Note: If <code>createNodes</code> is <code>true</code>, it is <b>always</b>
            		   returned a valid node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> An exception is only thrown if an error occurred, not if a
                    		node was not found. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindChildNode(iTextSharp.xmp.impl.XmpNode,System.String,System.Boolean)">
            <summary>
            Find or create a child node under a given parent node. If the parent node is no 
            Returns the found or created child node.
            </summary>
            <param name="parent">
                       the parent node </param>
            <param name="childName">
                       the node name to find </param>
            <param name="createNodes">
                       flag, if new nodes shall be created. </param>
            <returns> Returns the found or created node or <code>null</code>. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindNode(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.xpath.XmpPath,System.Boolean,iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Follow an expanded path expression to find or create a node.
            </summary>
            <param name="xmpTree"> the node to begin the search. </param>
            <param name="xpath"> the complete xpath </param>
            <param name="createNodes"> flag if nodes shall be created 
            			(when called by <code>setProperty()</code>) </param>
            <param name="leafOptions"> the options for the created leaf nodes (only when
            		<code>createNodes == true</code>). </param>
            <returns> Returns the node if found or created or <code>null</code>. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> An exception is only thrown if an error occurred, 
            			not if a node was not found. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.DeleteNode(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Deletes the the given node and its children from its parent.
            Takes care about adjusting the flags. </summary>
            <param name="node"> the top-most node to delete. </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.SetNodeValue(iTextSharp.xmp.impl.XmpNode,System.Object)">
            <summary>
            This is setting the value of a leaf node.
            </summary>
            <param name="node"> an XMPNode </param>
            <param name="value"> a value </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.VerifySetOptions(iTextSharp.xmp.options.PropertyOptions,System.Object)">
            <summary>
            Verifies the PropertyOptions for consistancy and updates them as needed. 
            If options are <code>null</code> they are created with default values.
            </summary>
            <param name="options"> the <code>PropertyOptions</code> </param>
            <param name="itemValue"> the node value to set </param>
            <returns> Returns the updated options. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the options are not consistant.  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.SerializeNodeValue(System.Object)">
            <summary>
            Converts the node value to String, apply special conversions for defined
            types in XMP.
            </summary>
            <param name="value">
                       the node value to set </param>
            <returns> Returns the String representation of the node value. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNodeUtils.FollowXPathStep(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.xpath.XmpPathSegment,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindQualifierNode(iTextSharp.xmp.impl.XmpNode,System.String,System.Boolean)">
            <summary>
            Find or create a qualifier node under a given parent node. Returns a pointer to the 
            qualifier node, and optionally an iterator for the node's position in 
            the parent's vector of qualifiers. The iterator is unchanged if no qualifier node (null) 
            is returned.
            <em>Note:</em> On entry, the qualName parameter must not have the leading '?' from the 
            XmpPath step.
            </summary>
            <param name="parent"> the parent XMPNode </param>
            <param name="qualName"> the qualifier name </param>
            <param name="createNodes"> flag if nodes shall be created </param>
            <returns> Returns the qualifier node if found or created, <code>null</code> otherwise. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.FindIndexedItem(iTextSharp.xmp.impl.XmpNode,System.String,System.Boolean)">
            <param name="arrayNode"> an array node </param>
            <param name="segment"> the segment containing the array index </param>
            <param name="createNodes"> flag if new nodes are allowed to be created. </param>
            <returns> Returns the index or index = -1 if not found </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Throws Exceptions </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.LookupFieldSelector(iTextSharp.xmp.impl.XmpNode,System.String,System.String)">
            <summary>
            Searches for a field selector in a node:
            [fieldName="value] - an element in an array of structs, chosen by a field value.
            No implicit nodes are created by field selectors. 
            </summary>
            <param name="arrayNode"> </param>
            <param name="fieldName"> </param>
            <param name="fieldValue"> </param>
            <returns> Returns the index of the field if found, otherwise -1. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.LookupQualSelector(iTextSharp.xmp.impl.XmpNode,System.String,System.String,System.UInt32)">
            <summary>
            Searches for a qualifier selector in a node:
            [?qualName="value"] - an element in an array, chosen by a qualifier value.
            No implicit nodes are created for qualifier selectors, 
            except for an alias to an x-default item.
            </summary>
            <param name="arrayNode"> an array node </param>
            <param name="qualName"> the qualifier name </param>
            <param name="qualValue"> the qualifier value </param>
            <param name="aliasForm"> in case the qual selector results from an alias,
            		  an x-default node is created if there has not been one. </param>
            <returns> Returns the index of th </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.NormalizeLangArray(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Make sure the x-default item is first. Touch up &quot;single value&quot;
            arrays that have a default plus one real language. This case should have
            the same value for both items. Older Adobe apps were hardwired to only
            use the &quot;x-default&quot; item, so we copy that value to the other
            item.
            </summary>
            <param name="arrayNode">
                       an alt text array node </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.DetectAltText(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            See if an array is an alt-text array. If so, make sure the x-default item
            is first.
            </summary>
            <param name="arrayNode">
                       the array node to check if its an alt-text array </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.AppendLangItem(iTextSharp.xmp.impl.XmpNode,System.String,System.String)">
            <summary>
            Appends a language item to an alt text array.
            </summary>
            <param name="arrayNode"> the language array </param>
            <param name="itemLang"> the language of the item </param>
            <param name="itemValue"> the content of the item </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if a duplicate property is added </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNodeUtils.ChooseLocalizedText(iTextSharp.xmp.impl.XmpNode,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.impl.XmpNodeUtils.LookupLanguageItem(iTextSharp.xmp.impl.XmpNode,System.String)">
            <summary>
            Looks for the appropriate language item in a text alternative array.item
            </summary>
            <param name="arrayNode">
                       an array node </param>
            <param name="language">
                       the requested language </param>
            <returns> Returns the index if the language has been found, -1 otherwise. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpNormalizer">
            <summary>
            @since   Aug 18, 2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpNormalizer._dcArrayForms">
            <summary>
            caches the correct dc-property array forms </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.#cctor">
            <summary>
            init char tables </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.#ctor">
            <summary>
            Hidden constructor
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.Process(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Normalizes a raw parsed XMPMeta-Object </summary>
            <param name="xmp"> the raw metadata object </param>
            <param name="options"> the parsing options </param>
            <returns> Returns the normalized metadata object </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Collects all severe processing errors.  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.TweakOldXmp(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Tweak old XMP: Move an instance ID from rdf:about to the
            <em>xmpMM:InstanceID</em> property. An old instance ID usually looks
            like "uuid:bac965c4-9d87-11d9-9a30-000d936b79c4", plus InDesign
            3.0 wrote them like "bac965c4-9d87-11d9-9a30-000d936b79c4". If
            the name looks like a UUID simply move it to <em>xmpMM:InstanceID</em>,
            don't worry about any existing <em>xmpMM:InstanceID</em>. Both will
            only be present when a newer file with the <em>xmpMM:InstanceID</em>
            property is updated by an old app that uses <em>rdf:about</em>.
            </summary>
            <param name="tree"> the root of the metadata tree </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if tweaking fails.  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.TouchUpDataModel(iTextSharp.xmp.impl.XmpMetaImpl)">
            <summary>
            Visit all schemas to do general fixes and handle special cases.
            </summary>
            <param name="xmp"> the metadata object implementation </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the normalisation fails. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpNormalizer.NormalizeDcArrays(iTextSharp.xmp.impl.XmpNode)" -->
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.RepairAltText(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Make sure that the array is well-formed AltText. Each item must be simple
            and have an "xml:lang" qualifier. If repairs are needed, keep simple
            non-empty items by adding the "xml:lang" with value "x-repair". </summary>
            <param name="arrayNode"> the property node of the array to repair. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards unexpected exceptions. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.MoveExplicitAliases(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.options.ParseOptions)">
            <summary>
            Visit all of the top level nodes looking for aliases. If there is
            no base, transplant the alias subtree. If there is a base and strict
            aliasing is on, make sure the alias and base subtrees match.
            </summary>
            <param name="tree"> the root of the metadata tree </param>
            <param name="options"> th parsing options </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards XMP errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.TransplantArrayItemAlias(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Moves an alias node of array form to another schema into an array </summary>
            <param name="childNode"> the node to be moved </param>
            <param name="baseArray"> the base array for the array item </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards XMP errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.FixGpsTimeStamp(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Fixes the GPS Timestamp in EXIF. </summary>
            <param name="exifSchema"> the EXIF schema node </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the date conversion fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.DeleteEmptySchemas(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Remove all empty schemas from the metadata tree that were generated during the rdf parsing. </summary>
            <param name="tree"> the root of the metadata tree </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.CompareAliasedSubtrees(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.XmpNode,System.Boolean)">
            <summary>
            The outermost call is special. The names almost certainly differ. The
            qualifiers (and hence options) will differ for an alias to the x-default
            item of a langAlt array.
            </summary>
            <param name="aliasNode"> the alias node </param>
            <param name="baseNode"> the base node of the alias </param>
            <param name="outerCall"> marks the outer call of the recursion </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards XMP errors  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.MigrateAudioCopyright(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            The initial support for WAV files mapped a legacy ID3 audio copyright
            into a new xmpDM:copyright property. This is special case code to migrate
            that into dc:rights['x-default']. The rules:
            
            <pre>
            1. If there is no dc:rights array, or an empty array -
               Create one with dc:rights['x-default'] set from double linefeed and xmpDM:copyright.
            
            2. If there is a dc:rights array but it has no x-default item -
               Create an x-default item as a copy of the first item then apply rule #3.
            
            3. If there is a dc:rights array with an x-default item, 
               Look for a double linefeed in the value.
                A. If no double linefeed, compare the x-default value to the xmpDM:copyright value.
                    A1. If they match then leave the x-default value alone.
                    A2. Otherwise, append a double linefeed and 
                        the xmpDM:copyright value to the x-default value.
                B. If there is a double linefeed, compare the trailing text to the xmpDM:copyright value.
                    B1. If they match then leave the x-default value alone.
                    B2. Otherwise, replace the trailing x-default text with the xmpDM:copyright value.
            
            4. In all cases, delete the xmpDM:copyright property.
            </pre>
            </summary>
            <param name="xmp"> the metadata object </param>
            <param name="dmCopyright"> the "dm:copyright"-property </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpNormalizer.InitDcArrays">
            <summary>
            Initializes the map that contains the known arrays, that are fixed by 
            <seealso cref="M:iTextSharp.xmp.impl.XmpNormalizer.NormalizeDcArrays(iTextSharp.xmp.impl.XmpNode)"/>. 
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpSchemaRegistryImpl">
            <summary>
            The schema registry handles the namespaces, aliases and global options for the XMP Toolkit. There
            is only one single instance used by the toolkit.
            
            @since 27.01.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.xmp.IXmpSchemaRegistry" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpSchemaRegistry.RegisterNamespace(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpSchemaRegistry.GetNamespacePrefix(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpSchemaRegistry.GetNamespaceUri(System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.GetNamespaces">
            <returns> Returns the registered prefix/namespace-pairs as map, where the keys are the
                    namespaces and the values are the prefixes. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.GetPrefixes">
            <returns> Returns the registered namespace/prefix-pairs as map, where the keys are the
                    prefixes and the values are the namespaces. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.IXmpSchemaRegistry.DeleteNamespace(System.String)" -->
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.ResolveAlias(System.String,System.String)">
            <summary>
            Determines if a name is an alias, and what it is aliased to.
            </summary>
            <param name="aliasNs">
                       The namespace URI of the alias. Must not be <code>null</code> or the empty
                       string. </param>
            <param name="aliasProp">
                       The name of the alias. May be an arbitrary path expression
                       path, must not be <code>null</code> or the empty string. </param>
            <returns> Returns the <code>XMPAliasInfo</code> for the given alias namespace and property or
            		<code>null</code> if there is no such alias. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.FindAliases(System.String)">
            <summary>
            Collects all aliases that are contained in the provided namespace.
            If nothing is found, an empty array is returned. 
            </summary>
            <param name="aliasNs"> a schema namespace URI </param>
            <returns> Returns all alias infos from aliases that are contained in the provided namespace.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.FindAlias(System.String)">
            <summary>
            Searches for registered aliases.
            </summary>
            <param name="qname">
                       an XML conform qname </param>
            <returns> Returns if an alias definition for the given qname to another
                    schema and property is registered. </returns>
        </member>
        <member name="M:iTextSharp.xmp.IXmpSchemaRegistry.GetAliases">
            <returns> Returns the registered aliases as map, where the key is the "qname" (prefix and name)
            and the value an <code>XMPAliasInfo</code>-object. </returns>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSchemaRegistryImpl._aliasMap">
            <summary>
            a map of all registered aliases. 
             The map is a relationship from a qname to an <code>XMPAliasInfo</code>-object. 
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSchemaRegistryImpl._namespaceToPrefixMap">
            <summary>
            a map from a namespace URI to its registered prefix </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSchemaRegistryImpl._prefixToNamespaceMap">
            <summary>
            a map from a prefix to the associated namespace URI </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSchemaRegistryImpl._regex">
            <summary>
            The pattern that must not be contained in simple properties </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.#ctor">
            <summary>
            Performs the initialisation of the registry with the default namespaces, aliases and global
            options.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.RegisterNamespace(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.DeleteNamespace(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.GetNamespacePrefix(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.GetNamespaceUri(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.ResolveAlias(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.FindAlias(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.FindAliases(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.GetNamespaces" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.GetPrefixes" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.GetAliases" -->
        <member name="M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.RegisterStandardNamespaces">
            <summary>
            Register the standard namespaces of schemas and types that are included in the XMP
            Specification and some other Adobe private namespaces.
            Note: This method is not lock because only called by the constructor.
            </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards processing exceptions </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.RegisterAlias(System.String,System.String,System.String,System.String,iTextSharp.xmp.options.AliasOptions)" -->
        <member name="M:iTextSharp.xmp.impl.XmpSchemaRegistryImpl.RegisterStandardAliases">
            <summary>
            Register the standard aliases.
            Note: This method is not lock because only called by the constructor.
            </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the registrations of at least one alias fails. </exception>
        </member>
        <member name="T:iTextSharp.xmp.properties.IXmpAliasInfo">
            <summary>
            This interface is used to return info about an alias.
            
            @since   27.01.2006
            </summary>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpAliasInfo.Namespace">
            <returns> Returns Returns the namespace URI for the base property. </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpAliasInfo.Prefix">
            <returns> Returns the default prefix for the given base property.  </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpAliasInfo.PropName">
            <returns> Returns the path of the base property. </returns>
        </member>
        <member name="P:iTextSharp.xmp.properties.IXmpAliasInfo.AliasForm">
            <returns> Returns the kind of the alias. This can be a direct alias
                    (ARRAY), a simple property to an ordered array
                    (ARRAY_ORDERED), to an alternate array
                    (ARRAY_ALTERNATE) or to an alternate text array
                    (ARRAY_ALT_TEXT). </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.ReadOnlyDictionary.ReadOnly(System.Collections.IDictionary)" -->
        <member name="T:iTextSharp.xmp.impl.XmpSerializerHelper">
            <summary>
            Serializes the <code>XMPMeta</code>-object to an <code>OutputStream</code> according to the
            <code>SerializeOptions</code>. 
            
            @since   11.07.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerHelper.Serialize(iTextSharp.xmp.impl.XmpMetaImpl,System.IO.Stream,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Static method to Serialize the metadata object. For each serialisation, a new XMPSerializer
            instance is created, either XMPSerializerRDF or XMPSerializerPlain so thats its possible to 
            serialialize the same XMPMeta objects in two threads.
            </summary>
            <param name="xmp"> a metadata implementation object </param>
            <param name="out"> the output stream to Serialize to </param>
            <param name="options"> serialization options, can be <code>null</code> for default. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerHelper.SerializeToString(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into a string.
            <em>Note:</em> Encoding is forced to UTF-16 when serializing to a
            string to ensure the correctness of "exact packet size".
            </summary>
            <param name="xmp"> a metadata implementation object </param>
            <param name="options"> Options to control the serialization (see
                       <seealso cref="T:iTextSharp.xmp.options.SerializeOptions"/>). </param>
            <returns> Returns a string containing the serialized RDF. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerHelper.SerializeToBuffer(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into a byte buffer.
            </summary>
            <param name="xmp"> a metadata implementation object </param>
            <param name="options"> Options to control the serialization (see <seealso cref="T:iTextSharp.xmp.options.SerializeOptions"/>). </param>
            <returns> Returns a byte buffer containing the serialized RDF. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpSerializerRdf">
            <summary>
            Serializes the <code>XMPMeta</code>-object using the standard RDF serialization format. 
            The output is written to an <code>OutputStream</code> 
            according to the <code>SerializeOptions</code>. 
            
            @since   11.07.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf.DEFAULT_PAD">
            <summary>
            default padding </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf.PACKET_TRAILER">
            <summary>
            The w/r is missing inbetween </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf.RDF_ATTR_QUALIFIER">
            <summary>
            a set of all rdf attribute qualifier </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._options">
            <summary>
            the stored serialization options </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._outputStream">
            <summary>
            the output stream to Serialize to </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._padding">
            <summary>
            the padding in the XMP Packet, or the length of the complete packet in
             case of option <em>exactPacketLength</em>. 
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._unicodeSize">
            <summary>
            the size of one unicode char, for UTF-8 set to 1 
             (Note: only valid for ASCII chars lower than 0x80),
             set to 2 in case of UTF-16 
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._writer">
            <summary>
            this writer is used to do the actual serialization </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.XmpSerializerRdf._xmp">
            <summary>
            the metadata object to be serialized. </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.Serialize(iTextSharp.xmp.IXmpMeta,System.IO.Stream,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            The actual serialization.
            </summary>
            <param name="xmp"> the metadata object to be serialized </param>
            <param name="out"> outputStream the output stream to Serialize to </param>
            <param name="options"> the serialization options
            </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If case of wrong options or any other serialization error. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.AddPadding(System.Int32)">
            <summary>
            Calculates the padding according to the options and write it to the stream. </summary>
            <param name="tailLength"> the length of the tail string </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> thrown if packet size is to small to fit the padding </exception>
            <exception cref="T:System.IO.IOException"> forwards writer errors </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.CheckOptionsConsistence">
            <summary>
            Checks if the supplied options are consistent. </summary>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if options are conflicting </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeAsRdf">
            <summary>
            Writes the (optional) packet header and the outer rdf-tags. </summary>
            <returns> Returns the packet end processing instraction to be written after the padding. </returns>
            <exception cref="T:System.IO.IOException"> Forwarded writer exceptions. </exception>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCanonicalRdfSchemas(System.Int32)">
            <summary>
            Serializes the metadata in pretty-printed manner. </summary>
            <param name="level"> indent level </param>
            <exception cref="T:System.IO.IOException"> Forwarded writer exceptions </exception>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.WriteTreeName">
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfSchemas(System.Int32)">
            <summary>
            Serializes the metadata in compact manner. </summary>
            <param name="level"> indent level to start with </param>
            <exception cref="T:System.IO.IOException"> Forwarded writer exceptions </exception>
            <exception cref="T:iTextSharp.xmp.XmpException">  </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfAttrProps(iTextSharp.xmp.impl.XmpNode,System.Int32)">
            <summary>
            Write each of the parent's simple unqualified properties as an attribute. Returns true if all
            of the properties are written as attributes.
            </summary>
            <param name="parentNode"> the parent property node </param>
            <param name="indent"> the current indent level </param>
            <returns> Returns true if all properties can be rendered as RDF attribute. </returns>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfElementProps(iTextSharp.xmp.impl.XmpNode,System.Int32)">
            <summary>
            Recursively handles the "value" for a node that must be written as an RDF
            property element. It does not matter if it is a top level property, a
            field of a struct, or an item of an array. The indent is that for the
            property element. The patterns bwlow ignore attribute qualifiers such as
            xml:lang, they don't affect the output form.
            
            <blockquote>
            
            <pre>
             	&lt;ns:UnqualifiedStructProperty-1
             		... The fields as attributes, if all are simple and unqualified
             	/&gt;
             
             	&lt;ns:UnqualifiedStructProperty-2 rdf:parseType="Resource"&gt;
             		... The fields as elements, if none are simple and unqualified
             	&lt;/ns:UnqualifiedStructProperty-2&gt;
             
             	&lt;ns:UnqualifiedStructProperty-3&gt;
             		&lt;rdf:Description
             			... The simple and unqualified fields as attributes
             		&gt;
             			... The compound or qualified fields as elements
             		&lt;/rdf:Description&gt;
             	&lt;/ns:UnqualifiedStructProperty-3&gt;
             
             	&lt;ns:UnqualifiedArrayProperty&gt;
             		&lt;rdf:Bag&gt; or Seq or Alt
             			... Array items as rdf:li elements, same forms as top level properties
             		&lt;/rdf:Bag&gt;
             	&lt;/ns:UnqualifiedArrayProperty&gt;
             
             	&lt;ns:QualifiedProperty rdf:parseType="Resource"&gt;
             		&lt;rdf:value&gt; ... Property "value" 
             			following the unqualified forms ... &lt;/rdf:value&gt;
             		... Qualifiers looking like named struct fields
             	&lt;/ns:QualifiedProperty&gt;
            </pre>
            
            </blockquote>
            
            *** Consider numbered array items, but has compatibility problems. ***
            Consider qualified form with rdf:Description and attributes.
            </summary>
            <param name="parentNode"> the parent node </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards writer exceptions </exception>
            <exception cref="T:iTextSharp.xmp.XmpException"> If qualifier and element fields are mixed. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfSimpleProp(iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Serializes a simple property.
            </summary>
            <param name="node"> an XMPNode </param>
            <returns> Returns an array containing the flags emitEndTag and indentEndTag. </returns>
            <exception cref="T:System.IO.IOException"> Forwards the writer exceptions. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfArrayProp(iTextSharp.xmp.impl.XmpNode,System.Int32)">
            <summary>
            Serializes an array property.
            </summary>
            <param name="node"> an XMPNode </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards the writer exceptions. </exception>
            <exception cref="T:iTextSharp.xmp.XmpException"> If qualifier and element fields are mixed. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfStructProp(iTextSharp.xmp.impl.XmpNode,System.Int32,System.Boolean)">
            <summary>
            Serializes a struct property.
            </summary>
            <param name="node"> an XMPNode </param>
            <param name="indent"> the current indent level </param>
            <param name="hasRdfResourceQual"> Flag if the element has resource qualifier </param>
            <returns> Returns true if an end flag shall be emitted. </returns>
            <exception cref="T:System.IO.IOException"> Forwards the writer exceptions. </exception>
            <exception cref="T:iTextSharp.xmp.XmpException"> If qualifier and element fields are mixed. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCompactRdfGeneralQualifier(System.Int32,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Serializes the general qualifier. </summary>
            <param name="node"> the root node of the subtree </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards all writer exceptions. </exception>
            <exception cref="T:iTextSharp.xmp.XmpException"> If qualifier and element fields are mixed. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCanonicalRdfSchema(iTextSharp.xmp.impl.XmpNode,System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.DeclareUsedNamespaces(iTextSharp.xmp.impl.XmpNode,Org.BouncyCastle.Utilities.Collections.ISet,System.Int32)">
            <summary>
            Writes all used namespaces of the subtree in node to the output. 
            The subtree is recursivly traversed. </summary>
            <param name="node"> the root node of the subtree </param>
            <param name="usedPrefixes"> a set containing currently used prefixes </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards all writer exceptions. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.DeclareNamespace(System.String,System.String,Org.BouncyCastle.Utilities.Collections.ISet,System.Int32)">
            <summary>
            Writes one namespace declaration to the output. </summary>
            <param name="prefix"> a namespace prefix (without colon) or a complete qname (when namespace == null) </param>
            <param name="namespace"> the a namespace </param>
            <param name="usedPrefixes"> a set containing currently used prefixes </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards all writer exceptions. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.StartOuterRdfDescription(iTextSharp.xmp.impl.XmpNode,System.Int32)">
            <summary>
            Start the outer rdf:Description element, including all needed xmlns attributes.
            Leave the element open so that the compact form can add property attributes.
            </summary>
            <exception cref="T:System.IO.IOException"> If the writing to   </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSerializerRdf.EndOuterRdfDescription(System.Int32)" -->
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.SerializeCanonicalRdfProperty(iTextSharp.xmp.impl.XmpNode,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Recursively handles the "value" for a node. It does not matter if it is a
            top level property, a field of a struct, or an item of an array. The
            indent is that for the property element. An xml:lang qualifier is written
            as an attribute of the property start tag, not by itself forcing the
            qualified property form. The patterns below mostly ignore attribute
            qualifiers like xml:lang. Except for the one struct case, attribute
            qualifiers don't affect the output form.
            
            <blockquote>
            
            <pre>
            	&lt;ns:UnqualifiedSimpleProperty&gt;value&lt;/ns:UnqualifiedSimpleProperty&gt;
            
            	&lt;ns:UnqualifiedStructProperty&gt; (If no rdf:resource qualifier)
            		&lt;rdf:Description&gt;
            			... Fields, same forms as top level properties
            		&lt;/rdf:Description&gt;
            	&lt;/ns:UnqualifiedStructProperty&gt;
            
            	&lt;ns:ResourceStructProperty rdf:resource="URI"
            		... Fields as attributes
            	&gt;
            
            	&lt;ns:UnqualifiedArrayProperty&gt;
            		&lt;rdf:Bag&gt; or Seq or Alt
            			... Array items as rdf:li elements, same forms as top level properties
            		&lt;/rdf:Bag&gt;
            	&lt;/ns:UnqualifiedArrayProperty&gt;
            
            	&lt;ns:QualifiedProperty&gt;
            		&lt;rdf:Description&gt;
            			&lt;rdf:value&gt; ... Property "value" following the unqualified 
            				forms ... &lt;/rdf:value&gt;
            			... Qualifiers looking like named struct fields
            		&lt;/rdf:Description&gt;
            	&lt;/ns:QualifiedProperty&gt;
            </pre>
            
            </blockquote>
            </summary>
            <param name="node"> the property node </param>
            <param name="emitAsRdfValue"> property shall be rendered as attribute rather than tag </param>
            <param name="useCanonicalRdf"> use canonical form with inner description tag or 
            		  the compact form with rdf:ParseType="resource" attribute. </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> Forwards all writer exceptions. </exception>
            <exception cref="T:iTextSharp.xmp.XmpException"> If "rdf:resource" and general qualifiers are mixed. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.EmitRdfArrayTag(iTextSharp.xmp.impl.XmpNode,System.Boolean,System.Int32)">
            <summary>
            Writes the array start and end tags.
            </summary>
            <param name="arrayNode"> an array node </param>
            <param name="isStartTag"> flag if its the start or end tag </param>
            <param name="indent"> the current indent level </param>
            <exception cref="T:System.IO.IOException"> forwards writer exceptions </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.AppendNodeValue(System.String,System.Boolean)">
            <summary>
            Serializes the node value in XML encoding. Its used for tag bodies and
            attributes. <em>Note:</em> The attribute is always limited by quotes,
            thats why <code>&amp;apos;</code> is never serialized. <em>Note:</em>
            Control chars are written unescaped, but if the user uses others than tab, LF
            and CR the resulting XML will become invalid.
            </summary>
            <param name="value"> the value of the node </param>
            <param name="forAttribute"> flag if value is an attribute value </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpSerializerRdf.canBeRDFAttrProp(iTextSharp.xmp.impl.XmpNode)" -->
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.WriteIndent(System.Int32)">
            <summary>
            Writes indents and automatically includes the baseindend from the options. </summary>
            <param name="times"> number of indents to write </param>
            <exception cref="T:System.IO.IOException"> forwards exception </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.Write(System.Char)">
            <summary>
            Writes a char to the output. </summary>
            <param name="c"> a char </param>
            <exception cref="T:System.IO.IOException"> forwards writer exceptions </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.Write(System.String)">
            <summary>
            Writes a String to the output. </summary>
            <param name="str"> a String </param>
            <exception cref="T:System.IO.IOException"> forwards writer exceptions </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.WriteChars(System.Int32,System.Char)">
            <summary>
            Writes an amount of chars, mostly spaces </summary>
            <param name="number"> number of chars </param>
            <param name="c"> a char </param>
            <exception cref="T:System.IO.IOException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpSerializerRdf.WriteNewline">
            <summary>
            Writes a newline according to the options. </summary>
            <exception cref="T:System.IO.IOException"> Forwards exception </exception>
        </member>
        <member name="T:iTextSharp.xmp.impl.XmpUtilsImpl">
            <summary>
            @since 11.08.2006
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.XmpUtilsImpl.SPACES" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.XmpUtilsImpl.COMMAS" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.XmpUtilsImpl.SEMICOLA" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.XmpUtilsImpl.CONTROLS" -->
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.impl.XmpUtilsImpl.QUOTES" -->
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.#ctor">
            <summary>
            Private constructor, as
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpUtilsImpl.CatenateArrayItems(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String,System.String,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.SeparateArrayItems(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions,System.Boolean)">
            <summary>
            see {@link XMPUtils#separateArrayItems(XMPMeta, String, String, String, 
            PropertyOptions, boolean)}
            </summary>
            <param name="xmp">
                       The XMP object containing the array to be updated. </param>
            <param name="schemaNs">
                       The schema namespace URI for the array. Must not be null or
                       the empty string. </param>
            <param name="arrayName">
                       The name of the array. May be a general path expression, must
                       not be null or the empty string. Each item in the array must
                       be a simple string value. </param>
            <param name="catedStr">
                       The string to be separated into the array items. </param>
            <param name="arrayOptions">
                       Option flags to control the separation. </param>
            <param name="preserveCommas">
                       Flag if commas shall be preserved
            </param>
            <exception cref="T:iTextSharp.xmp.XmpException">
                        Forwards the Exceptions from the metadata processing </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.SeparateFindCreateArray(System.String,System.String,iTextSharp.xmp.options.PropertyOptions,iTextSharp.xmp.impl.XmpMetaImpl)">
            <summary>
            Utility to find or create the array used by <code>separateArrayItems()</code>. </summary>
            <param name="schemaNs"> a the namespace fo the array </param>
            <param name="arrayName"> the name of the array </param>
            <param name="arrayOptions"> the options for the array if newly created </param>
            <param name="xmp"> the xmp object </param>
            <returns> Returns the array node. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards exceptions </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpUtilsImpl.RemoveProperties(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpUtilsImpl.AppendProperties(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.IXmpMeta,System.Boolean,System.Boolean,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.RemoveSchemaChildren(iTextSharp.xmp.impl.XmpNode,System.Boolean)">
            <summary>
            Remove all schema children according to the flag
            <code>doAllProperties</code>. Empty schemas are automatically remove
            by <code>XMPNode</code>
            </summary>
            <param name="schemaNode">
                       a schema node </param>
            <param name="doAllProperties">
                       flag if all properties or only externals shall be removed. </param>
            <returns> Returns true if the schema is empty after the operation. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.XmpUtilsImpl.AppendSubtree(iTextSharp.xmp.impl.XmpMetaImpl,iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.XmpNode,System.Boolean,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.ItemValuesMatch(iTextSharp.xmp.impl.XmpNode,iTextSharp.xmp.impl.XmpNode)">
            <summary>
            Compares two nodes including its children and qualifier. </summary>
            <param name="leftNode"> an <code>XMPNode</code> </param>
            <param name="rightNode"> an <code>XMPNode</code> </param>
            <returns> Returns true if the nodes are equal, false otherwise. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards exceptions to the calling method. </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.CheckSeparator(System.String)">
            <summary>
            Make sure the separator is OK. It must be one semicolon surrounded by
            zero or more spaces. Any of the recognized semicolons or spaces are
            allowed.
            </summary>
            <param name="separator"> </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.CheckQuotes(System.String,System.Char)">
            <summary>
            Make sure the open and close quotes are a legitimate pair and return the
            correct closing quote or an exception.
            </summary>
            <param name="quotes">
                       opened and closing quote in a string </param>
            <param name="openQuote">
                       the open quote </param>
            <returns> Returns a corresponding closing quote. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> </exception>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.ClassifyCharacter(System.Char)">
            <summary>
            Classifies the character into normal chars, spaces, semicola, quotes,
            control chars.
            </summary>
            <param name="ch">
                       a char </param>
            <returns> Return the character kind. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.GetClosingQuote(System.Char)">
            <param name="openQuote">
                       the open quote char </param>
            <returns> Returns the matching closing quote for an open quote. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.ApplyQuotes(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Add quotes to the item.
            </summary>
            <param name="item">
                       the array item </param>
            <param name="openQuote">
                       the open quote character </param>
            <param name="closeQuote">
                       the closing quote character </param>
            <param name="allowCommas">
                       flag if commas are allowed </param>
            <returns> Returns the value in quotes. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.IsSurroundingQuote(System.Char,System.Char,System.Char)">
            <param name="ch"> a character </param>
            <param name="openQuote"> the opening quote char </param>
            <param name="closeQuote"> the closing quote char </param>
            <returns> Return it the character is a surrounding quote. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.XmpUtilsImpl.IsClosingingQuote(System.Char,System.Char,System.Char)">
            <param name="ch"> a character </param>
            <param name="openQuote"> the opening quote char </param>
            <param name="closeQuote"> the closing quote char </param>
            <returns> Returns true if the character is a closing quote. </returns>
        </member>
        <member name="T:iTextSharp.xmp.impl.xpath.XmpPath">
            <summary>
            Representates an XMP XmpPath with segment accessor methods.
            
            @since   28.02.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPath.STRUCT_FIELD_STEP">
            <summary>
            Marks a struct field step , also for top level nodes (schema "fields"). </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPath.QUALIFIER_STEP">
            <summary>
            Marks a qualifier step. 
             Note: Order is significant to separate struct/qual from array kinds! 
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPath.ARRAY_INDEX_STEP">
            <summary>
            Marks an array index step </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPath._segments">
            <summary>
            stores the segments of an XmpPath </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPath.Add(iTextSharp.xmp.impl.xpath.XmpPathSegment)">
            <summary>
            Append a path segment
            </summary>
            <param name="segment"> the segment to add </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPath.GetSegment(System.Int32)">
            <param name="index"> the index of the segment to return </param>
            <returns> Returns a path segment. </returns>
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPath.Size">
            <returns> Returns the size of the xmp path.  </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.xpath.XmpPath.ToString" -->
        <member name="T:iTextSharp.xmp.impl.xpath.XmpPathParser">
             Parser for XMP XPaths.
            
             @since   01.03.2006
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.#ctor">
            Private constructor
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.xpath.XmpPathParser.ExpandXPath(System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.SkipPathDelimiter(System.String,iTextSharp.xmp.impl.xpath.PathPosition)">
            @param path
            @param pos
            @throws XmpException
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.ParseStructSegment(iTextSharp.xmp.impl.xpath.PathPosition)">
            Parses a struct segment
            @param pos the current position in the path
            @return Retusn the segment or an errror
            @throws XmpException If the sement is empty
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.ParseIndexSegment(iTextSharp.xmp.impl.xpath.PathPosition)">
            Parses an array index segment.
            
            @param pos the xmp path 
            @return Returns the segment or an error
            @throws XmpException thrown on xmp path errors
            
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.ParseRootNode(System.String,iTextSharp.xmp.impl.xpath.PathPosition,iTextSharp.xmp.impl.xpath.XmpPath)">
            Parses the root node of an XMP Path, checks if namespace and prefix fit together
            and resolve the property to the base property if it is an alias. 
            @param schemaNs the root namespace
            @param pos the parsing position helper
            @param expandedXPath  the path to contribute to
            @throws XmpException If the path is not valid.
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.VerifyQualName(System.String)">
            Verifies whether the qualifier name is not XML conformant or the
            namespace prefix has not been registered.
            
            @param qualName
                       a qualifier name
            @throws XmpException
                        If the name is not conformant
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathParser.VerifySimpleXmlName(System.String)">
            Verify if an XML name is conformant.
            
            @param name
                       an XML name
            @throws XmpException
                        When the name is not XML conformant
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.xpath.XmpPathParser.VerifyXPathRoot(System.String,System.String)" -->
        <member name="T:iTextSharp.xmp.impl.xpath.PathPosition">
            This objects contains all needed char positions to parse.
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.PathPosition.NameEnd">
            the complete path 
            the end of a segment name 
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.PathPosition.StepBegin">
            the begin of a step 
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.PathPosition.StepEnd">
            the end of a step 
        </member>
        <member name="T:iTextSharp.xmp.impl.xpath.XmpPathSegment">
            <summary>
            A segment of a parsed <code>XmpPath</code>.
             
            @since   23.06.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPathSegment._alias">
            <summary>
            flag if segment is an alias </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPathSegment._aliasForm">
            <summary>
            alias form if applicable </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPathSegment._kind">
            <summary>
            kind of the path segment </summary>
        </member>
        <member name="F:iTextSharp.xmp.impl.xpath.XmpPathSegment._name">
            <summary>
            name of the path segment </summary>
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathSegment.#ctor(System.String)">
            <summary>
            Constructor with initial values.
            </summary>
            <param name="name"> the name of the segment </param>
        </member>
        <member name="M:iTextSharp.xmp.impl.xpath.XmpPathSegment.#ctor(System.String,System.UInt32)">
            <summary>
            Constructor with initial values.
            </summary>
            <param name="name"> the name of the segment </param>
            <param name="kind"> the kind of the segment </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.impl.xpath.XmpPathSegment.ToString" -->
        <member name="P:iTextSharp.xmp.impl.xpath.XmpPathSegment.Kind">
            <returns> Returns the kind. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.xpath.XmpPathSegment.Name">
            <returns> Returns the name. </returns>
        </member>
        <member name="P:iTextSharp.xmp.impl.xpath.XmpPathSegment.Alias">
            <param name="alias"> the flag to set </param>
        </member>
        <member name="P:iTextSharp.xmp.impl.xpath.XmpPathSegment.AliasForm">
            <returns> Returns the aliasForm if this segment has been created by an alias. </returns>
        </member>
        <member name="T:iTextSharp.xmp.options.AliasOptions">
            <summary>
            Options for XMPSchemaRegistryImpl#registerAlias.
            
            @since 20.02.2006
            </summary>
        </member>
        <member name="T:iTextSharp.xmp.options.XmpOptions">
            <summary>
            The base class for a collection of 32 flag bits. Individual flags are defined as enum value bit
            masks. Inheriting classes add convenience accessor methods.
            
            @since 24.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.XmpOptions._optionNames">
            <summary>
            a map containing the bit names </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.XmpOptions._options">
            <summary>
            the internal int containing all options </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.#ctor">
            <summary>
            The default constructor.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.#ctor(System.UInt32)">
            <summary>
            Constructor with the options bit mask. 
            </summary>
            <param name="options"> the options bit mask </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the options are not correct </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.Clear">
            <summary>
            Resets the options.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.IsExactly(System.UInt32)">
            <param name="optionBits"> an option bitmask </param>
            <returns> Returns true, if this object is equal to the given options.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.ContainsAllOptions(System.UInt32)">
            <param name="optionBits"> an option bitmask </param>
            <returns> Returns true, if this object contains all given options.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.ContainsOneOf(System.UInt32)">
            <param name="optionBits"> an option bitmask </param>
            <returns> Returns true, if this object contain at least one of the given options.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.GetOption(System.UInt32)">
            <param name="optionBit"> the binary bit or bits that are requested </param>
            <returns> Returns if <emp>all</emp> of the requested bits are set or not. </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.SetOption(System.UInt32,System.Boolean)">
            <param name="optionBits"> the binary bit or bits that shall be set to the given value </param>
            <param name="value"> the boolean value to set </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.XmpOptions.Equals(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.XmpOptions.GetHashCode" -->
        <member name="M:iTextSharp.xmp.options.XmpOptions.ToString">
            <returns> Returns the options as hex bitmask.  </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.DefineOptionName(System.UInt32)">
            <summary>
            To be implemeted by inheritants. </summary>
            <param name="option"> a single, valid option bit. </param>
            <returns> Returns a human readable name for an option bit. </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.AssertConsistency(System.UInt32)">
            <summary>
            The inheriting option class can do additional checks on the options.
            <em>Note:</em> For performance reasons this method is only called 
            when setting bitmasks directly.
            When get- and set-methods are used, this method must be called manually,
            normally only when the Options-object has been created from a client
            (it has to be made public therefore).
            </summary>
            <param name="options"> the bitmask to check. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the options are not consistent. </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.AssertOptionsValid(System.UInt32)">
            <summary>
            Checks options before they are set.
            First it is checked if only defined options are used,
            second the additional <seealso cref="M:iTextSharp.xmp.options.XmpOptions.AssertConsistency(System.UInt32)"/>-method is called.
            </summary>
            <param name="options"> the options to check </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the options are invalid. </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.GetOptionName(System.UInt32)">
            <summary>
            Looks up or asks the inherited class for the name of an option bit.
            Its save that there is only one valid option handed into the method. </summary>
            <param name="option"> a single option bit </param>
            <returns> Returns the option name or undefined. </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.XmpOptions.ProcureOptionNames">
            <returns> Returns the optionNames map and creates it if required. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.XmpOptions.Options">
            <summary>
            Is friendly to access it during the tests. </summary>
            <returns> Returns the options. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.XmpOptions.OptionsString">
            <summary>
            Creates a human readable string from the set options. <em>Note:</em> This method is quite
            expensive and should only be used within tests or as </summary>
            <returns> Returns a String listing all options that are set to <code>true</code> by their name,
            like &quot;option1 | option4&quot;. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.XmpOptions.ValidOptions">
            <summary>
            To be implemeted by inheritants. </summary>
            <returns> Returns a bit mask where all valid option bits are set. </returns>
        </member>
        <member name="F:iTextSharp.xmp.options.AliasOptions.PROP_DIRECT">
            <summary>
            This is a direct mapping. The actual data type does not matter. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.AliasOptions.PROP_ARRAY">
            <summary>
            The actual is an unordered array, the alias is to the first element of the array. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.AliasOptions.PROP_ARRAY_ORDERED">
            <summary>
            The actual is an ordered array, the alias is to the first element of the array. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.AliasOptions.PROP_ARRAY_ALTERNATE">
            <summary>
            The actual is an alternate array, the alias is to the first element of the array. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.AliasOptions.PROP_ARRAY_ALT_TEXT">
            <summary>
            The actual is an alternate text array, the alias is to the 'x-default' element of the array.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.AliasOptions.#ctor" -->
        <member name="M:iTextSharp.xmp.options.AliasOptions.#ctor(System.UInt32)">
            <param name="options"> the options to init with </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If options are not consistant </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.AliasOptions.ToPropertyOptions">
            <returns> returns a <seealso cref="T:iTextSharp.xmp.options.PropertyOptions"/>s object </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the options are not consistant.  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.AliasOptions.DefineOptionName(System.UInt32)" -->
        <member name="P:iTextSharp.xmp.options.AliasOptions.Simple">
            <returns> Returns if the alias is of the simple form. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.AliasOptions.Array">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.AliasOptions.ArrayOrdered">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.AliasOptions.ArrayAlternate">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.AliasOptions.ArrayAltText">
            <returns> Returns the option. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.options.AliasOptions.ValidOptions" -->
        <member name="T:iTextSharp.xmp.options.IteratorOptions">
            <summary>
            Options for <code>XMPIterator</code> construction.
            
            @since 24.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.IteratorOptions.JUST_CHILDREN">
            <summary>
            Just do the immediate children of the root, default is subtree. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.IteratorOptions.JUST_LEAFNODES">
            <summary>
            Just do the leaf nodes, default is all nodes in the subtree.
             Bugfix #2658965: If this option is set the Iterator returns the namespace 
             of the leaf instead of the namespace of the base property. 
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.IteratorOptions.JUST_LEAFNAME">
            <summary>
            Return just the leaf part of the path, default is the full path. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.IteratorOptions.OMIT_QUALIFIERS">
            <summary>
            Omit all qualifiers. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.IteratorOptions.DefineOptionName(System.UInt32)" -->
        <member name="P:iTextSharp.xmp.options.IteratorOptions.JustChildren">
            <returns> Returns whether the option is set. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.IteratorOptions.JustLeafname">
            <returns> Returns whether the option is set. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.IteratorOptions.JustLeafnodes">
            <returns> Returns whether the option is set. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.IteratorOptions.OmitQualifiers">
            <returns> Returns whether the option is set. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.options.IteratorOptions.ValidOptions" -->
        <member name="T:iTextSharp.xmp.options.ParseOptions">
            <summary>
            Options for <seealso cref="M:iTextSharp.xmp.XmpMetaFactory.Parse(System.IO.Stream,iTextSharp.xmp.options.ParseOptions)"/>.
            
            @since 24.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.ParseOptions.REQUIRE_XMP_META">
            <summary>
            Require a surrounding &quot;x:xmpmeta&quot; element in the xml-document. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.ParseOptions.STRICT_ALIASING">
            <summary>
            Do not reconcile alias differences, throw an exception instead. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.ParseOptions.FIX_CONTROL_CHARS">
            <summary>
            Convert ASCII control characters 0x01 - 0x1F (except tab, cr, and lf) to spaces. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.ParseOptions.ACCEPT_LATIN_1">
            <summary>
            If the input is not unicode, try to parse it as ISO-8859-1. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.ParseOptions.OMIT_NORMALIZATION">
            <summary>
            Do not carry run the XMPNormalizer on a packet, leave it as it is. </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.ParseOptions.#ctor">
            <summary>
            Sets the options to the default values.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.ParseOptions.DefineOptionName(System.UInt32)" -->
        <member name="P:iTextSharp.xmp.options.ParseOptions.RequireXmpMeta">
            <returns> Returns the requireXMPMeta. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.ParseOptions.StrictAliasing">
            <returns> Returns the strictAliasing. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.ParseOptions.FixControlChars">
            <returns> Returns the strictAliasing. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.ParseOptions.AcceptLatin1">
            <returns> Returns the strictAliasing. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.ParseOptions.OmitNormalization">
            <returns> Returns the option "omit normalization". </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.options.ParseOptions.ValidOptions" -->
        <member name="T:iTextSharp.xmp.options.PropertyOptions">
            <summary>
            The property flags are used when properties are fetched from the <code>XMPMeta</code>-object
            and provide more detailed information about the property.
            
            @since   03.07.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.PropertyOptions.DELETE_EXISTING">
            <summary>
            may be used in the future </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.PropertyOptions.SEPARATE_NODE">
            <summary>
            Updated by iText. Indicates if the property should be writted as a separate node
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.PropertyOptions.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.PropertyOptions.#ctor(System.UInt32)">
            <summary>
            Intialization constructor
            </summary>
            <param name="options"> the initialization options </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If the options are not valid  </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.PropertyOptions.EqualArrayTypes(iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Compares two options set for array compatibility.
            </summary>
            <param name="options"> other options </param>
            <returns> Returns true if the array options of the sets are equal. </returns>
        </member>
        <member name="M:iTextSharp.xmp.options.PropertyOptions.MergeWith(iTextSharp.xmp.options.PropertyOptions)">
            <summary>
            Merges the set options of a another options object with this.
            If the other options set is null, this objects stays the same. </summary>
            <param name="options"> other options </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> If illegal options are provided  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.PropertyOptions.DefineOptionName(System.UInt32)" -->
        <member name="M:iTextSharp.xmp.options.PropertyOptions.AssertConsistency(System.UInt32)">
            <summary>
            Checks that a node not a struct and array at the same time;
            and URI cannot be a struct.
            </summary>
            <param name="options"> the bitmask to check. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the options are not consistent. </exception>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.Uri">
            <returns> Return whether the property value is a URI. It is serialized to RDF using the
                    <tt>rdf:resource</tt> attribute. Not mandatory for URIs, but considered RDF-savvy. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.HasQualifiers">
            <returns> Return whether the property has qualifiers. These could be an <tt>xml:lang</tt>
                    attribute, an <tt>rdf:type</tt> property, or a general qualifier. See the
                    introductory discussion of qualified properties for more information. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.Qualifier">
            <returns> Return whether this property is a qualifier for some other property. Note that if the
                    qualifier itself has a structured value, this flag is only set for the top node of
                    the qualifier's subtree. Qualifiers may have arbitrary structure, and may even have
                    qualifiers. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.HasLanguage">
            <returns> Return whether this property has an <tt>xml:lang</tt> qualifier. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.HasType">
            <returns> Return whether this property has an <tt>rdf:type</tt> qualifier. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.Struct">
            <returns> Return whether this property contains nested fields. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.Array">
            <returns> Return whether this property is an array. By itself this indicates a general
                    unordered array. It is serialized using an <tt>rdf:Bag</tt> container. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.ArrayOrdered">
            <returns> Return whether this property is an ordered array. Appears in conjunction with
                    getPropValueIsArray(). It is serialized using an <tt>rdf:Seq</tt> container. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.ArrayAlternate">
            <returns> Return whether this property is an alternative array. Appears in conjunction with
                    getPropValueIsArray(). It is serialized using an <tt>rdf:Alt</tt> container. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.ArrayAltText">
            <returns> Return whether this property is an alt-text array. Appears in conjunction with
                    getPropArrayIsAlternate(). It is serialized using an <tt>rdf:Alt</tt> container.
                    Each array element is a simple property with an <tt>xml:lang</tt> attribute. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.SchemaNode">
            <param name="value"> the value to set </param>
            <returns> Returns this to enable cascaded options. </returns>
            <returns> Returns whether the SCHEMA_NODE option is set. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.CompositeProperty">
            <returns> Returns whether the property is of composite type - an array or a struct. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.Simple">
            <returns> Returns whether the property is of composite type - an array or a struct. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.PropertyOptions.OnlyArrayOptions">
            <returns> Returns true if only array options are set. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.options.PropertyOptions.ValidOptions" -->
        <member name="T:iTextSharp.xmp.options.SerializeOptions">
            <summary>
            Options for <seealso cref="M:iTextSharp.xmp.XmpMetaFactory.SerializeToBuffer(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.options.SerializeOptions)"/>.
            
            @since 24.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.OMIT_PACKET_WRAPPER">
            <summary>
            Omit the XML packet wrapper. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.READONLY_PACKET">
            <summary>
            Mark packet as read-only. Default is a writeable packet. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.USE_COMPACT_FORMAT">
            <summary>
            Use a compact form of RDF.
            The compact form is the default serialization format (this flag is technically ignored).
            To Serialize to the canonical form, set the flag USE_CANONICAL_FORMAT.
            If both flags &quot;compact&quot; and &quot;canonical&quot; are set, canonical is used.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.USE_CANONICAL_FORMAT">
            <summary>
            Use the canonical form of RDF if set. By default the compact form is used </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.INCLUDE_THUMBNAIL_PAD">
            <summary>
            Include a padding allowance for a thumbnail image. If no <tt>xmp:Thumbnails</tt> property
            is present, the typical space for a JPEG thumbnail is used.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.EXACT_PACKET_LENGTH">
            <summary>
            The padding parameter provides the overall packet length. The actual amount of padding is
            computed. An exception is thrown if the packet exceeds this length with no padding.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iTextSharp.xmp.options.SerializeOptions.OMIT_XMPMETA_ELEMENT" -->
        <member name="F:iTextSharp.xmp.options.SerializeOptions.SORT">
            <summary>
            Sort the struct properties and qualifier before serializing </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.LITTLEENDIAN_BIT">
            <summary>
            Bit indicating little endian encoding, unset is big endian </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.UTF16_BIT">
            <summary>
            Bit indication UTF16 encoding. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.ENCODE_UTF8">
            <summary>
            UTF8 encoding; this is the default </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.ENCODE_UTF16BE">
            <summary>
            UTF16BE encoding </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions.ENCODE_UTF16LE">
            <summary>
            UTF16LE encoding </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions._baseIndent">
            <summary>
            The number of levels of indentation to be used for the outermost XML element in the
            serialized RDF. This is convenient when embedding the RDF in other text, defaults to 0.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions._indent">
            <summary>
            The string to be used for each level of indentation in the serialized
            RDF. If empty it defaults to two ASCII spaces, U+0020.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions._newline">
            <summary>
            The string to be used as a line terminator. If empty it defaults to; linefeed, U+000A, the
            standard XML newline.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions._omitVersionAttribute">
            <summary>
            Omits the Toolkit version attribute, not published, only used for Unit tests. </summary>
        </member>
        <member name="F:iTextSharp.xmp.options.SerializeOptions._padding">
            <summary>
            The amount of padding to be added if a writeable XML packet is created. If zero is passed
            (the default) an appropriate amount of padding is computed.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.SerializeOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.options.SerializeOptions.#ctor(System.UInt32)">
            <summary>
            Constructor using inital options </summary>
            <param name="options"> the inital options </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if options are not consistant. </exception>
        </member>
        <member name="M:iTextSharp.xmp.options.SerializeOptions.Clone">
            
            <returns> Returns clone of this SerializeOptions-object with the same options set. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.options.SerializeOptions.DefineOptionName(System.UInt32)" -->
        <member name="P:iTextSharp.xmp.options.SerializeOptions.OmitPacketWrapper">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.OmitXmpMetaElement">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.ReadOnlyPacket">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.UseCompactFormat">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.UseCanonicalFormat">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.IncludeThumbnailPad">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.ExactPacketLength">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.Sort">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.EncodeUtf16Be">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.EncodeUtf16Le">
            <returns> Returns the option. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.BaseIndent">
            <returns> Returns the baseIndent. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.Indent">
            <returns> Returns the indent. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.Newline">
            <returns> Returns the newline. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.Padding">
            <returns> Returns the padding. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.OmitVersionAttribute">
            <returns> Returns whether the Toolkit version attribute shall be omitted.
            <em>Note:</em> This options can only be set by unit tests. </returns>
        </member>
        <member name="P:iTextSharp.xmp.options.SerializeOptions.Encoding">
            <returns> Returns the encoding as Java encoding String.  </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:iTextSharp.xmp.options.SerializeOptions.ValidOptions" -->
        <member name="T:iTextSharp.xmp.XmpMetaFactory">
            <summary>
            Creates <code>XMPMeta</code>-instances from an <code>InputStream</code>
            
            @since 30.01.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpMetaFactory._schema">
            <summary>
            The singleton instance of the <code>XMPSchemaRegistry</code>.
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpMetaFactory._versionInfo">
            <summary>
            cache for version info
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.Create">
            <returns> Returns an empty <code>XMPMeta</code>-object. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.Parse(System.IO.Stream)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.Parse(System.IO.Stream,iTextSharp.xmp.options.ParseOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.ParseFromString(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.ParseFromString(System.String,iTextSharp.xmp.options.ParseOptions)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.ParseFromBuffer(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpMetaFactory.ParseFromBuffer(System.Byte[],iTextSharp.xmp.options.ParseOptions)" -->
        <member name="M:iTextSharp.xmp.XmpMetaFactory.Serialize(iTextSharp.xmp.IXmpMeta,System.IO.Stream)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into an <code>OutputStream</code>
            with default options.
            </summary>
            <param name="xmp"> a metadata object </param>
            <param name="out"> an <code>OutputStream</code> to write the serialized RDF to. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.Serialize(iTextSharp.xmp.IXmpMeta,System.IO.Stream,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into an <code>OutputStream</code>.
            </summary>
            <param name="xmp">     a metadata object </param>
            <param name="options"> Options to control the serialization (see <seealso cref="T:iTextSharp.xmp.options.SerializeOptions"/>). </param>
            <param name="out">     an <code>OutputStream</code> to write the serialized RDF to. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.SerializeToBuffer(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into a byte buffer.
            </summary>
            <param name="xmp">     a metadata object </param>
            <param name="options"> Options to control the serialization (see <seealso cref="T:iTextSharp.xmp.options.SerializeOptions"/>). </param>
            <returns> Returns a byte buffer containing the serialized RDF. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.SerializeToString(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.options.SerializeOptions)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into a string. <em>Note:</em> Encoding
            is ignored when serializing to a string.
            </summary>
            <param name="xmp">     a metadata object </param>
            <param name="options"> Options to control the serialization (see <seealso cref="T:iTextSharp.xmp.options.SerializeOptions"/>). </param>
            <returns> Returns a string containing the serialized RDF. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> on serializsation errors. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.AssertImplementation(iTextSharp.xmp.IXmpMeta)">
            <param name="xmp"> Asserts that xmp is compatible to <code>XMPMetaImpl</code>.s </param>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.Reset">
            <summary>
            Resets the _schema registry to its original state (creates a new one).
            Be careful this might break all existing XMPMeta-objects and should be used
            only for testing purpurses.
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpMetaFactory.GetVersionInfo">
            <summary>
            Obtain version information. The XMPVersionInfo singleton is created the first time
            its requested.
            </summary>
            <returns> Returns the version information. </returns>
        </member>
        <member name="P:iTextSharp.xmp.XmpMetaFactory.SchemaRegistry">
            <returns> Returns the singleton instance of the <code>XMPSchemaRegistry</code>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.xmp.IXmpVersionInfo" -->
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Major">
            <returns> Returns the primary release number, the "1" in version "1.2.3". </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Minor">
            <returns> Returns the secondary release number, the "2" in version "1.2.3". </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Micro">
            <returns> Returns the tertiary release number, the "3" in version "1.2.3". </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Build">
            <returns> Returns a rolling build number, monotonically increasing in a release. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Debug">
            <returns> Returns true if this is a debug build. </returns>
        </member>
        <member name="P:iTextSharp.xmp.IXmpVersionInfo.Message">
            <returns> Returns a comprehensive version information string. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iTextSharp.xmp.XmpPathFactory" -->
        <member name="M:iTextSharp.xmp.XmpPathFactory.ComposeArrayItemPath(System.String,System.Int32)">
            <summary>
            Compose the path expression for an item in an array.
            </summary>
            <param name="arrayName"> The name of the array. May be a general path expression, must not be
                   <code>null</code> or the empty string. </param>
            <param name="itemIndex"> The index of the desired item. Arrays in XMP are indexed from 1.
            		  0 and below means last array item and renders as <code>[last()]</code>.	
            </param>
            <returns> Returns the composed path basing on fullPath. This will be of the form
                    <tt>ns:arrayName[i]</tt>, where "ns" is the prefix for schemaNs and
                    "i" is the decimal representation of itemIndex. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Throws exeption if index zero is used. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.ComposeStructFieldPath(System.String,System.String)">
            <summary>
            Compose the path expression for a field in a struct. The result can be added to the
            path of 
            
            </summary>
            <param name="fieldNs"> The namespace URI for the field. Must not be <code>null</code> or the empty
                   string. </param>
            <param name="fieldName"> The name of the field. Must be a simple XML name, must not be
                   <code>null</code> or the empty string. </param>
            <returns> Returns the composed path. This will be of the form
                    <tt>ns:structName/fNS:fieldName</tt>, where "ns" is the prefix for
                    schemaNs and "fNS" is the prefix for fieldNs. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the path to create is not valid. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.ComposeQualifierPath(System.String,System.String)">
            <summary>
            Compose the path expression for a qualifier.
            </summary>
            <param name="qualNs"> The namespace URI for the qualifier. May be <code>null</code> or the empty
                   string if the qualifier is in the XML empty namespace. </param>
            <param name="qualName"> The name of the qualifier. Must be a simple XML name, must not be
                   <code>null</code> or the empty string. </param>
            <returns> Returns the composed path. This will be of the form
                    <tt>ns:propName/?qNS:qualName</tt>, where "ns" is the prefix for
                    schemaNs and "qNS" is the prefix for qualNs. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the path to create is not valid. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.ComposeLangSelector(System.String,System.String)">
            <summary>
            Compose the path expression to select an alternate item by language. The
            path syntax allows two forms of &quot;content addressing&quot; that may
            be used to select an item in an array of alternatives. The form used in
            ComposeLangSelector lets you select an item in an alt-text array based on
            the value of its <tt>xml:lang</tt> qualifier. The other form of content
            addressing is shown in ComposeFieldSelector. \note ComposeLangSelector
            does not supplant SetLocalizedText or GetLocalizedText. They should
            generally be used, as they provide extra logic to choose the appropriate
            language and maintain consistency with the 'x-default' value.
            ComposeLangSelector gives you an path expression that is explicitly and
            only for the language given in the langName parameter.
            </summary>
            <param name="arrayName">
                       The name of the array. May be a general path expression, must
                       not be <code>null</code> or the empty string. </param>
            <param name="langName">
                       The RFC 3066 code for the desired language. </param>
            <returns> Returns the composed path. This will be of the form
                    <tt>ns:arrayName[@xml:lang='langName']</tt>, where
                    &quot;ns&quot; is the prefix for schemaNs. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpPathFactory.ComposeFieldSelector(System.String,System.String,System.String,System.String)" -->
        <member name="M:iTextSharp.xmp.XmpPathFactory.AssertQualNs(System.String)">
            <summary>
            ParameterAsserts that a qualifier namespace is set. </summary>
            <param name="qualNs"> a qualifier namespace </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Qualifier schema is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.AssertQualName(System.String)">
            <summary>
            ParameterAsserts that a qualifier name is set. </summary>
            <param name="qualName"> a qualifier name or path </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Qualifier name is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.AssertFieldNs(System.String)">
            <summary>
            ParameterAsserts that a struct field namespace is set. </summary>
            <param name="fieldNs"> a struct field namespace </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Struct field schema is null or empty </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpPathFactory.AssertFieldName(System.String)">
            <summary>
            ParameterAsserts that a struct field name is set. </summary>
            <param name="fieldName"> a struct field name or path </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Struct field name is null or empty </exception>
        </member>
        <member name="T:iTextSharp.xmp.XmpDateTimeFactory">
            <summary>
            A factory to create <code>XMPDateTime</code>-instances from a <code>Calendar</code> or an
            ISO 8601 string or for the current time.
            
            @since 16.02.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.CreateFromCalendar(iTextSharp.xmp.XmpCalendar)">
            <summary>
            Creates an <code>XMPDateTime</code> from a <code>Calendar</code>-object.
            </summary>
            <param name="calendar"> a <code>Calendar</code>-object. </param>
            <returns> An <code>XMPDateTime</code>-object. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.Create">
            <summary>
            Creates an empty <code>XMPDateTime</code>-object. </summary>
            <returns> Returns an <code>XMPDateTime</code>-object. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpDateTimeFactory.Create(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpDateTimeFactory.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.CreateFromIso8601(System.String)">
            <summary>
            Creates an <code>XMPDateTime</code> from an ISO 8601 string.
            </summary>
            <param name="strValue"> The ISO 8601 string representation of the date/time. </param>
            <returns> An <code>XMPDateTime</code>-object. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> When the ISO 8601 string is non-conform </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.SetLocalTimeZone(iTextSharp.xmp.IXmpDateTime)">
            <summary>
            Sets the local time zone without touching any other Any existing time zone value is replaced,
            the other date/time fields are not adjusted in any way.
            </summary>
            <param name="dateTime"> the <code>XMPDateTime</code> variable containing the value to be modified. </param>
            <returns> Returns an updated <code>XMPDateTime</code>-object. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.ConvertToUtcTime(iTextSharp.xmp.IXmpDateTime)">
            <summary>
            Make sure a time is UTC. If the time zone is not UTC, the time is
            adjusted and the time zone set to be UTC.
            </summary>
            <param name="dateTime">
                       the <code>XMPDateTime</code> variable containing the time to
                       be modified. </param>
            <returns> Returns an updated <code>XMPDateTime</code>-object. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpDateTimeFactory.ConvertToLocalTime(iTextSharp.xmp.IXmpDateTime)">
            <summary>
            Make sure a time is local. If the time zone is not the local zone, the time is adjusted and
            the time zone set to be local.
            </summary>
            <param name="dateTime"> the <code>XMPDateTime</code> variable containing the time to be modified. </param>
            <returns> Returns an updated <code>XMPDateTime</code>-object. </returns>
        </member>
        <member name="P:iTextSharp.xmp.XmpDateTimeFactory.CurrentDateTime">
            <summary>
            Obtain the current date and time.
            </summary>
            <returns> Returns The returned time is UTC, properly adjusted for the local time zone. The
                    resolution of the time is not guaranteed to be finer than seconds. </returns>
        </member>
        <member name="T:iTextSharp.xmp.XmpError">
            <summary>
            @since   21.09.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpError.BADSTREAM">
            <summary>
            <em>Note:</em> This is an error code introduced by Java. </summary>
        </member>
        <member name="T:iTextSharp.xmp.XmpException">
            <summary>
            This exception wraps all errors that occur in the XMP Toolkit.
            
            @since   16.02.2006
            </summary>
        </member>
        <member name="F:iTextSharp.xmp.XmpException._errorCode">
            <summary>
            the errorCode of the XMP toolkit </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpException.#ctor(System.String,System.Int32)">
            <summary>
            Constructs an exception with a message and an error code. </summary>
            <param name="message"> the message </param>
            <param name="errorCode"> the error code </param>
        </member>
        <member name="M:iTextSharp.xmp.XmpException.#ctor(System.String,System.Int32,System.Exception)">
            <summary>
            Constructs an exception with a message, an error code and a <code>Throwable</code> </summary>
            <param name="message"> the error message. </param>
            <param name="errorCode"> the error code </param>
            <param name="t"> the exception source </param>
        </member>
        <member name="P:iTextSharp.xmp.XmpException.ErrorCode">
            <returns> Returns the errorCode. </returns>
        </member>
        <member name="T:iTextSharp.xmp.XmpUtils">
            <summary>
            Utility methods for XMP. I included only those that are different from the
            Java default conversion utilities.
            
            @since 21.02.2006
            </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.#ctor">
            <summary>
            Private constructor </summary>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.CatenateArrayItems(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Create a single edit string from an array of strings.
            </summary>
            <param name="xmp">
                       The XMP object containing the array to be catenated. </param>
            <param name="schemaNs">
                       The schema namespace URI for the array. Must not be null or
                       the empty string. </param>
            <param name="arrayName">
                       The name of the array. May be a general path expression, must
                       not be null or the empty string. Each item in the array must
                       be a simple string value. </param>
            <param name="separator">
                       The string to be used to separate the items in the catenated
                       string. Defaults to "; ", ASCII semicolon and space
                       (U+003B, U+0020). </param>
            <param name="quotes">
                       The characters to be used as quotes around array items that
                       contain a separator. Defaults to '"' </param>
            <param name="allowCommas">
                       Option flag to control the catenation. </param>
            <returns> Returns the string containing the catenated array items. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards the Exceptions from the metadata processing </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.SeparateArrayItems(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.String,iTextSharp.xmp.options.PropertyOptions,System.Boolean)">
            <summary>
            Separate a single edit string into an array of strings.
            </summary>
            <param name="xmp">
                       The XMP object containing the array to be updated. </param>
            <param name="schemaNs">
                       The schema namespace URI for the array. Must not be null or
                       the empty string. </param>
            <param name="arrayName">
                       The name of the array. May be a general path expression, must
                       not be null or the empty string. Each item in the array must
                       be a simple string value. </param>
            <param name="catedStr">
                       The string to be separated into the array items. </param>
            <param name="arrayOptions"> Option flags to control the separation. </param>
            <param name="preserveCommas"> Flag if commas shall be preserved </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards the Exceptions from the metadata processing  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpUtils.RemoveProperties(iTextSharp.xmp.IXmpMeta,System.String,System.String,System.Boolean,System.Boolean)" -->
        <member name="M:iTextSharp.xmp.XmpUtils.AppendProperties(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.IXmpMeta,System.Boolean,System.Boolean)">
            <summary>
            Alias without the new option <code>deleteEmptyValues</code>. </summary>
            <param name="source"> The source XMP object. </param>
            <param name="dest"> The destination XMP object. </param>
            <param name="doAllProperties"> Do internal properties in addition to external properties. </param>
            <param name="replaceOldValues"> Replace the values of existing properties. </param>
            <exception cref="T:iTextSharp.xmp.XmpException"> Forwards the Exceptions from the metadata processing  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpUtils.AppendProperties(iTextSharp.xmp.IXmpMeta,iTextSharp.xmp.IXmpMeta,System.Boolean,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iTextSharp.xmp.XmpUtils.ConvertToBoolean(System.String)" -->
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertFromBoolean(System.Boolean)">
            <summary>
            Convert from boolean to string.
            </summary>
            <param name="value">
                       a boolean value </param>
            <returns> The XMP string representation of the boolean. The values used are
                    given by the constnts <seealso cref="F:iTextSharp.xmp.XmpConst.TRUESTR"/> and
                    <seealso cref="F:iTextSharp.xmp.XmpConst.FALSESTR"/>. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertToInteger(System.String)">
            <summary>
            Converts a string value to an <code>int</code>.
            </summary>
            <param name="rawValue">
                       the string value </param>
            <returns> Returns an int. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">
                        If the <code>rawValue</code> is <code>null</code> or empty or the
                        conversion fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertFromInteger(System.Int32)">
            <summary>
            Convert from int to string.
            </summary>
            <param name="value">
                       an int value </param>
            <returns> The string representation of the int. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertToLong(System.String)">
            <summary>
            Converts a string value to a <code>long</code>.
            </summary>
            <param name="rawValue">
                       the string value </param>
            <returns> Returns a long. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">
                        If the <code>rawValue</code> is <code>null</code> or empty or the
                        conversion fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertFromLong(System.Int64)">
            <summary>
            Convert from long to string.
            </summary>
            <param name="value">
                       a long value </param>
            <returns> The string representation of the long. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertToDouble(System.String)">
            <summary>
            Converts a string value to a <code>double</code>.
            </summary>
            <param name="rawValue">
                       the string value </param>
            <returns> Returns a double. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">
                        If the <code>rawValue</code> is <code>null</code> or empty or the
                        conversion fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertFromDouble(System.Double)">
            <summary>
            Convert from long to string.
            </summary>
            <param name="value">
                       a long value </param>
            <returns> The string representation of the long. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertToDate(System.String)">
            <summary>
            Converts a string value to an <code>XMPDateTime</code>.
            </summary>
            <param name="rawValue">
                       the string value </param>
            <returns> Returns an <code>XMPDateTime</code>-object. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException">
                        If the <code>rawValue</code> is <code>null</code> or empty or the
                        conversion fails. </exception>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.ConvertFromDate(iTextSharp.xmp.IXmpDateTime)">
            <summary>
            Convert from <code>XMPDateTime</code> to string.
            </summary>
            <param name="value">
                       an <code>XMPDateTime</code> </param>
            <returns> The string representation of the long. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.EncodeBase64(System.Byte[])">
            <summary>
            Convert from a byte array to a base64 encoded string.
            </summary>
            <param name="buffer">
                       the byte array to be converted </param>
            <returns> Returns the base64 string. </returns>
        </member>
        <member name="M:iTextSharp.xmp.XmpUtils.DecodeBase64(System.String)">
            <summary>
            Decode from Base64 encoded string to raw data.
            </summary>
            <param name="base64String">
                       a base64 encoded string </param>
            <returns> Returns a byte array containg the decoded string. </returns>
            <exception cref="T:iTextSharp.xmp.XmpException"> Thrown if the given string is not property base64 encoded </exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent.ToAsn1Object">
            <pre>
            CAKeyUpdAnnContent ::= SEQUENCE {
                                        oldWithNew   CmpCertificate, -- old pub signed with new priv
                                        newWithOld   CmpCertificate, -- new pub signed with old priv
                                        newWithNew   CmpCertificate  -- new pub signed with new priv
             }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertConfirmContent.ToAsn1Object">
            <pre>
            CertConfirmContent ::= SEQUENCE OF CertStatus
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair.ToAsn1Object">
            <pre>
            CertifiedKeyPair ::= SEQUENCE {
                                             certOrEncCert       CertOrEncCert,
                                             privateKey      [0] EncryptedValue      OPTIONAL,
                                             -- see [CRMF] for comment on encoding
                                             publicationInfo [1] PKIPublicationInfo  OPTIONAL
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertOrEncCert.ToAsn1Object">
            <pre>
            CertOrEncCert ::= CHOICE {
                                 certificate     [0] CMPCertificate,
                                 encryptedCert   [1] EncryptedValue
                      }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertRepMessage.ToAsn1Object">
            <pre>
            CertRepMessage ::= SEQUENCE {
                                     caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                        OPTIONAL,
                                     response         SEQUENCE OF CertResponse
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertResponse.ToAsn1Object">
            <pre>
            CertResponse ::= SEQUENCE {
                                       certReqId           INTEGER,
                                       -- to match this response with corresponding request (a value
                                       -- of -1 is to be used if certReqId is not specified in the
                                       -- corresponding request)
                                       status              PKIStatusInfo,
                                       certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
                                       rspInfo             OCTET STRING        OPTIONAL
                                       -- analogous to the id-regInfo-utf8Pairs string defined
                                       -- for regInfo in CertReqMsg [CRMF]
                        }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertStatus.ToAsn1Object">
            <pre>
            CertStatus ::= SEQUENCE {
                              certHash    OCTET STRING,
                              -- the hash of the certificate, using the same hash algorithm
                              -- as is used to create and verify the certificate signature
                              certReqId   INTEGER,
                              -- to match this confirmation with the corresponding req/rep
                              statusInfo  PKIStatusInfo OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.Challenge.ToAsn1Object">
             <pre>
             Challenge ::= SEQUENCE {
                             owf                 AlgorithmIdentifier  OPTIONAL,
            
                             -- MUST be present in the first Challenge; MAY be omitted in
                             -- any subsequent Challenge in POPODecKeyChallContent (if
                             -- omitted, then the owf used in the immediately preceding
                             -- Challenge is to be used).
            
                             witness             OCTET STRING,
                             -- the result of applying the one-way function (owf) to a
                             -- randomly-generated INTEGER, A.  [Note that a different
                             -- INTEGER MUST be used for each Challenge.]
                             challenge           OCTET STRING
                             -- the encryption (under the public key for which the cert.
                             -- request is being made) of Rand, where Rand is specified as
                             --   Rand ::= SEQUENCE {
                             --      int      INTEGER,
                             --       - the randomly-generated INTEGER A (above)
                             --      sender   GeneralName
                             --       - the sender's name (as included in PKIHeader)
                             --   }
                  }
             </pre>
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.#ctor(Org.BouncyCastle.Asn1.X509.AttributeCertificate)">
            Note: the addition of attribute certificates is a BC extension.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.ToAsn1Object">
             <pre>
             CMPCertificate ::= CHOICE {
                        x509v3PKCert        Certificate
                        x509v2AttrCert      [1] AttributeCertificate
              }
             </pre>
             Note: the addition of attribute certificates is a BC extension.
            
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CrlAnnContent.ToAsn1Object">
            <pre>
            CrlAnnContent ::= SEQUENCE OF CertificateList
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent.ToAsn1Object">
            <pre>
            ErrorMsgContent ::= SEQUENCE {
                                   pKIStatusInfo          PKIStatusInfo,
                                   errorCode              INTEGER           OPTIONAL,
                                   -- implementation-specific error codes
                                   errorDetails           PKIFreeText       OPTIONAL
                                   -- implementation-specific error details
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenMsgContent.ToAsn1Object">
            <pre>
            GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenRepContent.ToAsn1Object">
            <pre>
            GenRepContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue">
             Example InfoTypeAndValue contents include, but are not limited
             to, the following (un-comment in this ASN.1 module and use as
             appropriate for a given environment):
             <pre>
               id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
                  CAProtEncCertValue      ::= CMPCertificate
               id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
                 SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
               id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
                 EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
               id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
                  PreferredSymmAlgValue   ::= AlgorithmIdentifier
               id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
                  CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
               id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
                  CurrentCRLValue         ::= CertificateList
               id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
                  UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
               id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
                  KeyPairParamReqValue    ::= OBJECT IDENTIFIER
               id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
                  KeyPairParamRepValue    ::= AlgorithmIdentifer
               id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
                  RevPassphraseValue      ::= EncryptedValue
               id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
                  ImplicitConfirmValue    ::= NULL
               id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
                  ConfirmWaitTimeValue    ::= GeneralizedTime
               id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
                  OrigPKIMessageValue     ::= PKIMessages
               id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
                  SuppLangTagsValue       ::= SEQUENCE OF UTF8String
            
             where
            
               id-pkix OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3)
                  dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
             and
                  id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue.ToAsn1Object">
            <pre>
            InfoTypeAndValue ::= SEQUENCE {
                                    infoType               OBJECT IDENTIFIER,
                                    infoValue              ANY DEFINED BY infoType  OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent.ToAsn1Object">
            <pre>
            KeyRecRepContent ::= SEQUENCE {
                                    status                  PKIStatusInfo,
                                    newSigCert          [0] CMPCertificate OPTIONAL,
                                    caCerts             [1] SEQUENCE SIZE (1..MAX) OF
                                                                      CMPCertificate OPTIONAL,
                                    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
                                                                      CertifiedKeyPair OPTIONAL
                         }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.OobCertHash.ToAsn1Object">
            <pre>
            OobCertHash ::= SEQUENCE {
                                 hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
                                 certId      [1] CertId                  OPTIONAL,
                                 hashVal         BIT STRING
                                 -- hashVal is calculated over the Der encoding of the
                                 -- self-signed certificate with the identifier certID.
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PbmParameter.ToAsn1Object">
            <pre>
             PbmParameter ::= SEQUENCE {
                                   salt                OCTET STRING,
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this string to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   owf                 AlgorithmIdentifier,
                                   -- AlgId for a One-Way Function (SHA-1 recommended)
                                   iterationCount      INTEGER,
                                   -- number of times the OWF is applied
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this integer to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   mac                 AlgorithmIdentifier
                                   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
               }   -- or HMAC [RFC2104, RFC2202])
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            Creates a new PkiBody.
            @param type one of the TYPE_* constants
            @param content message content
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.ToAsn1Object">
            <pre>
            PkiBody ::= CHOICE {       -- message-specific body elements
                   ir       [0]  CertReqMessages,        --Initialization Request
                   ip       [1]  CertRepMessage,         --Initialization Response
                   cr       [2]  CertReqMessages,        --Certification Request
                   cp       [3]  CertRepMessage,         --Certification Response
                   p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
                   popdecc  [5]  POPODecKeyChallContent, --pop Challenge
                   popdecr  [6]  POPODecKeyRespContent,  --pop Response
                   kur      [7]  CertReqMessages,        --Key Update Request
                   kup      [8]  CertRepMessage,         --Key Update Response
                   krr      [9]  CertReqMessages,        --Key Recovery Request
                   krp      [10] KeyRecRepContent,       --Key Recovery Response
                   rr       [11] RevReqContent,          --Revocation Request
                   rp       [12] RevRepContent,          --Revocation Response
                   ccr      [13] CertReqMessages,        --Cross-Cert. Request
                   ccp      [14] CertRepMessage,         --Cross-Cert. Response
                   ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
                   cann     [16] CertAnnContent,         --Certificate Ann.
                   rann     [17] RevAnnContent,          --Revocation Ann.
                   crlann   [18] CRLAnnContent,          --CRL Announcement
                   pkiconf  [19] PKIConfirmContent,      --Confirmation
                   nested   [20] NestedMessageContent,   --Nested Message
                   genm     [21] GenMsgContent,          --General Message
                   genp     [22] GenRepContent,          --General Response
                   error    [23] ErrorMsgContent,        --Error Message
                   certConf [24] CertConfirmContent,     --Certificate confirm
                   pollReq  [25] PollReqContent,         --Polling request
                   pollRep  [26] PollRepContent          --Polling response
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent.ToAsn1Object">
            <pre>
            PkiConfirmContent ::= NULL
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cmp.PkiHeader.NULL_NAME">
            Value for a "null" recipient or sender.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeader.ToAsn1Object">
            <pre>
             PkiHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder.Build">
            <pre>
             PKIHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.PkiHeader,Org.BouncyCastle.Asn1.Cmp.PkiBody,Org.BouncyCastle.Asn1.DerBitString,Org.BouncyCastle.Asn1.Cmp.CmpCertificate[])">
             Creates a new PkiMessage.
            
             @param header message header
             @param body message body
             @param protection message protection (may be null)
             @param extraCerts extra certificates (may be null)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.ToAsn1Object">
            <pre>
            PkiMessage ::= SEQUENCE {
                             header           PKIHeader,
                             body             PKIBody,
                             protection   [0] PKIProtection OPTIONAL,
                             extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessages.ToAsn1Object">
            <pre>
            PkiMessages ::= SEQUENCE SIZE (1..MAX) OF PkiMessage
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollRepContent.ToAsn1Object">
            <pre>
            PollRepContent ::= SEQUENCE OF SEQUENCE {
                    certReqId              INTEGER,
                    checkAfter             INTEGER,  -- time in seconds
                    reason                 PKIFreeText OPTIONAL
                }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollReqContent.ToAsn1Object">
            <pre>
            PollReqContent ::= SEQUENCE OF SEQUENCE {
                                   certReqId              INTEGER
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent.ToAsn1Object">
            <pre>
            PopoDecKeyChallContent ::= SEQUENCE OF Challenge
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent.ToAsn1Object">
            <pre>
            PopoDecKeyRespContent ::= SEQUENCE OF INTEGER
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ProtectedPart.ToAsn1Object">
            <pre>
            ProtectedPart ::= SEQUENCE {
                               header    PKIHeader,
                               body      PKIBody
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevAnnContent.ToAsn1Object">
            <pre>
            RevAnnContent ::= SEQUENCE {
                  status              PKIStatus,
                  certId              CertId,
                  willBeRevokedAt     GeneralizedTime,
                  badSinceDate        GeneralizedTime,
                  crlDetails          Extensions  OPTIONAL
                   -- extra CRL details (e.g., crl number, reason, location, etc.)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevDetails.ToAsn1Object">
            <pre>
            RevDetails ::= SEQUENCE {
                             certDetails         CertTemplate,
                              -- allows requester to specify as much as they can about
                              -- the cert. for which revocation is requested
                              -- (e.g., for cases in which serialNumber is not available)
                              crlEntryDetails     Extensions       OPTIONAL
                              -- requested crlEntryExtensions
                        }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevRepContent.ToAsn1Object">
            <pre>
            RevRepContent ::= SEQUENCE {
                   status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
                   -- in same order as was sent in RevReqContent
                   revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
                   -- IDs for which revocation was requested
                   -- (same order as status)
                   crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL
                   -- the resulting CRLs (there may be more than one)
              }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevReqContent.ToAsn1Object">
            <pre>
            RevReqContent ::= SEQUENCE OF RevDetails
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attributes.ToAsn1Object">
            <pre>
            Attributes ::=
              SET SIZE(1..MAX) OF Attribute -- according to RFC 5652
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.MetaData.ToAsn1Object">
            <pre>
            MetaData ::= SEQUENCE {
              hashProtected        BOOLEAN,
              fileName             UTF8String OPTIONAL,
              mediaType            IA5String OPTIONAL,
              otherMetaData        Attributes OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRevocationInfoFormat object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(System.Object)">
             return a OtherRevocationInfoFormat object from the given object.
            
             @param obj the object we want converted.
             @exception IllegalArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            OtherRevocationInfoFormat ::= SEQUENCE {
                 otherRevInfoFormat OBJECT IDENTIFIER,
                 otherRevInfo ANY DEFINED BY otherRevInfoFormat }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ScvpReqRes.ToAsn1Object">
            <pre>
               ScvpReqRes ::= SEQUENCE {
               request  [0] EXPLICIT ContentInfo OPTIONAL,
               response     ContentInfo }
            </pre>
            @return  the ASN.1 primitive representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl.ToAsn1Object">
            <pre>
            TimeStampAndCRL ::= SEQUENCE {
                timeStamp   TimeStampToken,          -- according to RFC 3161
                crl         CertificateList OPTIONAL -- according to RFC 5280
             }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampedData.ToAsn1Object">
            <pre>
            TimeStampedData ::= SEQUENCE {
              version              INTEGER { v1(1) },
              dataUri              IA5String OPTIONAL,
              metaData             MetaData OPTIONAL,
              content              OCTET STRING OPTIONAL,
              temporalEvidence     Evidence
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence.ToAsn1Object">
            <pre>
            TimeStampTokenEvidence ::=
               SEQUENCE SIZE(1..MAX) OF TimeStampAndCrl
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue.ToAsn1Object">
            <pre>
            AttributeTypeAndValue ::= SEQUENCE {
                      type         OBJECT IDENTIFIER,
                      value        ANY DEFINED BY type }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertId.ToAsn1Object">
            <pre>
            CertId ::= SEQUENCE {
                            issuer           GeneralName,
                            serialNumber     INTEGER }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMessages.ToAsn1Object">
            <pre>
            CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.#ctor(Org.BouncyCastle.Asn1.Crmf.CertRequest,Org.BouncyCastle.Asn1.Crmf.ProofOfPossession,Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue[])">
            Creates a new CertReqMsg.
            @param certReq CertRequest
            @param popo may be null
            @param regInfo may be null
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.ToAsn1Object">
            <pre>
            CertReqMsg ::= SEQUENCE {
                               certReq   CertRequest,
                               pop       ProofOfPossession  OPTIONAL,
                               -- content depends upon key type
                               regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertRequest.ToAsn1Object">
            <pre>
            CertRequest ::= SEQUENCE {
                                 certReqId     INTEGER,          -- ID for matching request and reply
                                 certTemplate  CertTemplate,  -- Selected fields of cert to be issued
                                 controls      Controls OPTIONAL }   -- Attributes affecting issuance
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplate.ToAsn1Object">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetVersion(System.Int32)">
            Sets the X.509 version. Note: for X509v3, use 2 here. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetIssuerUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the issuer unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetSubjectUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the subject unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.Build">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.Controls.ToAsn1Object">
            <pre>
            Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncKeyWithID.ToAsn1Object">
            <pre>
            EncKeyWithID ::= SEQUENCE {
                 privateKey           PrivateKeyInfo,
                 identifier CHOICE {
                    string               UTF8String,
                    generalName          GeneralName
                } OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedKey.ToAsn1Object">
            <pre>
               EncryptedKey ::= CHOICE {
                   encryptedValue        EncryptedValue, -- deprecated
                   envelopedData     [0] EnvelopedData }
                   -- The encrypted private key MUST be placed in the envelopedData
                   -- encryptedContentInfo encryptedContent OCTET STRING.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedValue.ToAsn1Object">
            <pre>
            EncryptedValue ::= SEQUENCE {
                                intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
                                -- the intended algorithm for which the value will be used
                                symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
                                -- the symmetric algorithm used to encrypt the value
                                encSymmKey    [2] BIT STRING           OPTIONAL,
                                -- the (encrypted) symmetric key used to encrypt the value
                                keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
                                -- algorithm used to encrypt the symmetric key
                                valueHint     [4] OCTET STRING         OPTIONAL,
                                -- a brief description or identifier of the encValue content
                                -- (may be meaningful only to the sending entity, and used only
                                -- if EncryptedValue might be re-examined by the sending entity
                                -- in the future)
                                encValue       BIT STRING }
                                -- the encrypted value itself
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.OptionalValidity.ToAsn1Object">
            <pre>
            OptionalValidity ::= SEQUENCE {
                                   notBefore  [0] Time OPTIONAL,
                                   notAfter   [1] Time OPTIONAL } --at least one MUST be present
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions.ToAsn1Object">
            <pre>
             PkiArchiveOptions ::= CHOICE {
                 encryptedPrivKey     [0] EncryptedKey,
                 -- the actual value of the private key
                 keyGenParameters     [1] KeyGenParameters,
                 -- parameters which allow the private key to be re-generated
                 archiveRemGenPrivKey [2] BOOLEAN }
                 -- set to TRUE if sender wishes receiver to archive the private
                 -- key of a key pair that the receiver generates in response to
                 -- this request; set to FALSE if no archival is desired.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.ToAsn1Object">
            <pre>
            PkiPublicationInfo ::= SEQUENCE {
                             action     INTEGER {
                                            dontPublish (0),
                                            pleasePublish (1) },
                             pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
            -- pubInfos MUST NOT be present if action is "dontPublish"
            -- (if action is "pleasePublish" and pubInfos is omitted,
            -- "dontCare" is assumed)
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Crmf.PKMacValue">
            Password-based MAC value for use with POPOSigningKeyInput.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.Cmp.PbmParameter,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param params parameters for password-based MAC
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param aid CMPObjectIdentifiers.passwordBasedMAC, with PBMParameter
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.ToAsn1Object">
            <pre>
            PKMACValue ::= SEQUENCE {
                 algId  AlgorithmIdentifier,
                 -- algorithm value shall be PasswordBasedMac 1.2.840.113533.7.66.13
                 -- parameter value is PBMParameter
                 value  BIT STRING }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoPrivKey.ToAsn1Object">
            <pre>
            PopoPrivKey ::= CHOICE {
                   thisMessage       [0] BIT STRING,         -- Deprecated
                    -- possession is proven in this message (which contains the private
                    -- key itself (encrypted for the CA))
                   subsequentMessage [1] SubsequentMessage,
                    -- possession will be proven in a subsequent message
                   dhMAC             [2] BIT STRING,         -- Deprecated
                   agreeMAC          [3] PKMACValue,
                   encryptedKey      [4] EnvelopedData }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new Proof of Possession object for a signing key.
            @param poposkIn the PopoSigningKeyInput structure, or null if the
                CertTemplate includes both subject and publicKey values.
            @param aid the AlgorithmIdentifier used to sign the proof of possession.
            @param signature a signature over the DER-encoded value of poposkIn,
                or the DER-encoded value of certReq if poposkIn is null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.ToAsn1Object">
            <pre>
            PopoSigningKey ::= SEQUENCE {
                                 poposkInput           [0] PopoSigningKeyInput OPTIONAL,
                                 algorithmIdentifier   AlgorithmIdentifier,
                                 signature             BIT STRING }
             -- The signature (using "algorithmIdentifier") is on the
             -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
             -- certReq CertTemplate contains the subject and publicKey values,
             -- then poposkInput MUST be omitted and the signature MUST be
             -- computed on the DER-encoded value of CertReqMsg certReq.  If
             -- the CertReqMsg certReq CertTemplate does not contain the public
             -- key and subject values, then poposkInput MUST be present and
             -- MUST be signed.  This strategy ensures that the public key is
             -- not present in both the poposkInput and CertReqMsg certReq
             -- CertTemplate fields.
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput with sender name as authInfo. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.Crmf.PKMacValue,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput using password-based MAC. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.ToAsn1Object">
            <pre>
            PopoSigningKeyInput ::= SEQUENCE {
                   authInfo             CHOICE {
                                            sender              [0] GeneralName,
                                            -- used only if an authenticated identity has been
                                            -- established for the sender (e.g., a DN from a
                                            -- previously-issued and currently-valid certificate
                                            publicKeyMac        PKMacValue },
                                            -- used if no authenticated GeneralName currently exists for
                                            -- the sender; publicKeyMac contains a password-based MAC
                                            -- on the DER-encoded value of publicKey
                   publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.Sender">
            Returns the sender field, or null if authInfo is publicKeyMac 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.PublicKeyMac">
            Returns the publicKeyMac field, or null if authInfo is sender 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor">
            Creates a ProofOfPossession with type raVerified. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKey)">
            Creates a ProofOfPossession for a signing key. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(System.Int32,Org.BouncyCastle.Asn1.Crmf.PopoPrivKey)">
            Creates a ProofOfPossession for key encipherment or agreement.
            @param type one of TYPE_KEY_ENCIPHERMENT or TYPE_KEY_AGREEMENT
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.ToAsn1Object">
            <pre>
            ProofOfPossession ::= CHOICE {
                                      raVerified        [0] NULL,
                                      -- used if the RA has already verified that the requester is in
                                      -- possession of the private key
                                      signature         [1] PopoSigningKey,
                                      keyEncipherment   [2] PopoPrivKey,
                                      keyAgreement      [3] PopoPrivKey }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.SinglePubInfo.ToAsn1Object">
            <pre>
            SinglePubInfo ::= SEQUENCE {
                   pubMethod    INTEGER {
                      dontCare    (0),
                      x500        (1),
                      web         (2),
                      ldap        (3) },
                  pubLocation  GeneralName OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.CscaMasterList">
             The CscaMasterList object. This object can be wrapped in a
             CMSSignedData to be published in LDAP.
            
             <pre>
             CscaMasterList ::= SEQUENCE {
               version                CscaMasterListVersion,
               certList               SET OF Certificate }
               
             CscaMasterListVersion :: INTEGER {v0(0)}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Icao.LdsVersionInfo.ToAsn1Object">
            <pre>
            LDSVersionInfo ::= SEQUENCE {
               ldsVersion PRINTABLE STRING
               unicodeVersion PRINTABLE STRING
             }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.#ctor(Org.BouncyCastle.Asn1.X509.PolicyInformation)">
            Construct a CertificatePolicies object containing one PolicyInformation.
            
            @param name the name to be contained.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            CertificatePolicies ::= SEQUENCE SIZE {1..MAX} OF PolicyInformation
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationKey">
            <summary>
            Represents revocation key OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationReason">
            <summary>
            Represents revocation reason OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator">
            Default authenticated attributes generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor(Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.CreateStandardAttributeTable(System.Collections.IDictionary)">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in IDictionary of attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.GetAttributes(System.Collections.IDictionary)">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.GetCertificates">
             Return the certificates stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CertificateHolder objects.
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.GetCrls">
             Return the CRLs stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CRLHolder objects.
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.ToAsn1Structure">
             Return the underlying ASN.1 object defining this SignerInformation object.
            
             @return a OriginatorInfo.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha3Digest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.SipHash">
            <summary>
            Implementation of SipHash as specified in "SipHash: a fast short-input PRF", by Jean-Philippe
            Aumasson and Daniel J. Bernstein (https://131002.net/siphash/siphash.pdf).
            </summary>
            <remarks>
            "SipHash is a family of PRFs SipHash-c-d where the integer parameters c and d are the number of
            compression rounds and the number of finalization rounds. A compression round is identical to a
            finalization round and this round function is called SipRound. Given a 128-bit key k and a
            (possibly empty) byte string m, SipHash-c-d returns a 64-bit value..."
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor">
            <summary>SipHash-2-4</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor(System.Int32,System.Int32)">
            <summary>SipHash-c-d</summary>
            <param name="c">the number of compression rounds</param>
            <param name="d">the number of finalization rounds</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OcbBlockCipher">
            An implementation of the "work in progress" Internet-Draft <a
            href="http://tools.ietf.org/html/draft-irtf-cfrg-ocb-03">The OCB Authenticated-Encryption
            Algorithm</a>, licensed per:
            
            <blockquote><p><a href="http://www.cs.ucdavis.edu/~rogaway/ocb/license1.pdf">License for
            Open-Source Software Implementations of OCB</a> (Jan 9, 2013) - 'License 1'<br/>
            Under this license, you are authorized to make, use, and distribute open-source software
            implementations of OCB. This license terminates for you if you sue someone over their open-source
            software implementation of OCB claiming that you have a patent covering their implementation.
            </p><p>
            This is a non-binding summary of a legal document (the link above). The parameters of the license
            are specified in the license document and that document is controlling.</p></blockquote>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             Construct without a usage index, this will do a random construction of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             Construct for a specific usage index - this has the effect of using verifiable canonical generation of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
             @param usageIndex a valid usage index.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertDescription">
            <summary>
            RFC 2246 7.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertLevel">
            <summary>
            RFC 2246 7.2
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.CertificateAuthorities">
            <returns>A <see cref="T:System.Collections.IList"/> of X509Name</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CipherSuite">
            <summary>
            RFC 2246 A.5
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ClientCertificateType">
            <summary>
            RFC 2246 7.4.4
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod">
            <summary>
            RFC 2246 6.1
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ContentType">
            <summary>
            RFC 2246 6.2.1
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsClientContext,Org.BouncyCastle.Crypto.Tls.EncryptionAlgorithm,Org.BouncyCastle.Crypto.Tls.DigestAlgorithm)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateRC4Cipher(Org.BouncyCastle.Crypto.Tls.TlsClientContext,System.Int32,Org.BouncyCastle.Crypto.Tls.DigestAlgorithm)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateAesCipher(Org.BouncyCastle.Crypto.Tls.TlsClientContext,System.Int32,Org.BouncyCastle.Crypto.Tls.DigestAlgorithm)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateDesEdeCipher(Org.BouncyCastle.Crypto.Tls.TlsClientContext,System.Int32,Org.BouncyCastle.Crypto.Tls.DigestAlgorithm)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateDigest(Org.BouncyCastle.Crypto.Tls.DigestAlgorithm)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECCurveType">
            <summary>
            RFC 4492 5.4
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_prime">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a prime field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_char2">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a characteristic-2 field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.named_curve">
            Indicates that a named curve is used. This option SHOULD be used when applicable.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECPointFormat">
            <summary>
            RFC 4492 5.1.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ExtensionType">
            <summary>
            RFC 4366 2.3
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.HandshakeType">
            <summary>
            RFC 2246 7.4
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.LegacyTlsAuthentication">
            <summary>
            A temporary class to wrap old CertificateVerifyer stuff for new TlsAuthentication.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.NotifyServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <summary>
            Called by the protocol handler to report the server certificate.
            </summary>
            <remarks>
            This method is responsible for certificate verification and validation
            </remarks>
            <param name="serverCertificate">The server <see cref="T:Org.BouncyCastle.Crypto.Tls.Certificate"/> received</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.GetClientCredentials(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <summary>
            Return client credentials in response to server's certificate request
            </summary>
            <param name="certificateRequest">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateRequest"/> containing server certificate request details
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCredentials"/> to be used for client authentication
            (or <c>null</c> for no client authentication)
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.LegacyTlsClient">
            <summary>
            A temporary class to use LegacyTlsAuthentication 
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.NamedCurve">
            <summary>
            RFC 4492 5.1.1
            The named curves defined here are those specified in SEC 2 [13]. Note that many of
            these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00
            through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the
            client supports arbitrary prime and characteristic-2 curves, respectively (the curve
            parameters must be encoded explicitly in ECParameters).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Ssl3Mac">
            HMAC implementation based on original internet draft for HMAC (RFC 2104)
            
            The difference is that padding is concatentated versus XORed with the key
            
            H(K + opad, H(K + ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            Base constructor for one of the standard digest algorithms that the byteLength of
            the algorithm is know for. Behaviour is undefined for digests other than MD5 or SHA1.
            
            @param digest the digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDheKeyExchange">
            ECDHE key exchange (see RFC 4492)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDHKeyExchange">
            ECDH key exchange (see RFC 4492)
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.MiscPemGenerator">
            PEM generator for the original set of PEM objects used in Open SSL.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Constructor for an unencrypted private key PEM object.
            
             @param key private key to be encoded.
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.String)">
             Constructor for an encrypted private key PEM object.
            
             @param key       private key to be encoded
             @param algorithm encryption algorithm to use
             @param provider  provider to use
             @throws NoSuchAlgorithmException if algorithm/mode cannot be found
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCrlUtilities.FindCrls(Org.BouncyCastle.X509.Store.X509CrlStoreSelector,System.Collections.IList)">
            <summary>
            crl checking
            Return a Collection of all CRLs found in the X509Store's that are
            matching the crlSelect criteriums.
            </summary>
            <param name="crlSelect">a {@link X509CRLStoreSelector} object that will be used
            to select the CRLs</param>
            <param name="crlStores">a List containing only {@link org.bouncycastle.x509.X509Store
            X509Store} objects. These are used to search for CRLs</param>
            <returns>a Collection of all found {@link X509CRL X509CRL} objects. May be
            empty but never <code>null</code>.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            <param name="obj">
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </param>
            <returns>
            A <see cref="T:System.Object"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:System.util.collections.ReadOnlyDictionary`2">
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="dictionaryToWrap"/>.
            </summary>
            <param name="dictionaryToWrap">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:System.util.collections.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:System.util.collections.ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
    </members>
</doc>
